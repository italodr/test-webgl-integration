(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var __toCommonJS = /* @__PURE__ */ ((cache) => {
    return (module, temp) => {
      return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

  // node_modules/@jocabola/gfx/lib/utils/glInfo.js
  var init_glInfo = __esm({
    "node_modules/@jocabola/gfx/lib/utils/glInfo.js"() {
    }
  });

  // node_modules/three/build/three.module.js
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  }
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  }
  function inverseLerp(x, y, value) {
    if (x !== y) {
      return (value - x) / (y - x);
    } else {
      return 0;
    }
  }
  function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  }
  function damp(x, y, lambda, dt) {
    return lerp(x, y, 1 - Math.exp(-lambda * dt));
  }
  function pingpong(x, length = 1) {
    return length - Math.abs(euclideanModulo(x, length * 2) - length);
  }
  function smoothstep(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  }
  function smootherstep(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  }
  function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  }
  function randFloat(low, high) {
    return low + Math.random() * (high - low);
  }
  function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  }
  function seededRandom(s) {
    if (s !== void 0)
      _seed = s % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  }
  function degToRad(degrees) {
    return degrees * DEG2RAD;
  }
  function radToDeg(radians) {
    return radians * RAD2DEG;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  function setQuaternionFromProperEuler(q, a, b, c, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch (order) {
      case "XYX":
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;
      case "YZY":
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;
      case "ZXZ":
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;
      case "XZX":
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;
      case "YXY":
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;
      case "ZYZ":
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
  function arrayNeedsUint32(array) {
    for (let i2 = array.length - 1; i2 >= 0; --i2) {
      if (array[i2] > 65535)
        return true;
    }
    return false;
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  function hue2rgb(p2, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p2 + (q - p2) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p2 + (q - p2) * 6 * (2 / 3 - t);
    return p2;
  }
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.prototype.slice.call(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
      _testAxis.fromArray(axes, i2);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA$1.fromBufferAttribute(position, a);
    _vB$1.fromBufferAttribute(position, b);
    _vC$1.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
        const influence = morphInfluences[i2];
        const morphAttribute = morphPosition[i2];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, a);
        _tempB.fromBufferAttribute(morphAttribute, b);
        _tempC.fromBufferAttribute(morphAttribute, c);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
          _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
          _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
        }
      }
      _vA$1.add(_morphA);
      _vB$1.add(_morphB);
      _vC$1.add(_morphC);
    }
    if (object.isSkinnedMesh) {
      object.boneTransform(a, _vA$1);
      object.boneTransform(b, _vB$1);
      object.boneTransform(c, _vC$1);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a);
        _uvB$1.fromBufferAttribute(uv, b);
        _uvC$1.fromBufferAttribute(uv, c);
        intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv2) {
        _uvA$1.fromBufferAttribute(uv2, a);
        _uvB$1.fromBufferAttribute(uv2, b);
        _uvC$1.fromBufferAttribute(uv2, c);
        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      const face = {
        a,
        b,
        c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p2 in src[u]) {
        const property = src[u][p2];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p2] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p2] = property.slice();
        } else {
          dst[u][p2] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u = 0; u < uniforms.length; u++) {
      const tmp3 = cloneUniforms(uniforms[u]);
      for (const p2 in tmp3) {
        merged[p2] = tmp3[p2];
      }
    }
    return merged;
  }
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type = 5126;
      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Float64Array) {
        console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type = 5131;
          } else {
            console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type = 5123;
        }
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      } else if (array instanceof Uint8ClampedArray) {
        type = 5121;
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
        } else {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        }
        updateRange.count = -1;
      }
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update
    };
  }
  function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = alpha === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render6(renderList, scene) {
      let forceClear = false;
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        background = cubemaps.get(background);
      }
      const xr = renderer.xr;
      const session = xr.getSession && xr.getSession();
      if (session && session.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      if (renderer.autoClear || forceClear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha2) {
      state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha2 = 1) {
        clearColor.set(color);
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha2) {
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      render: render6
    };
  }
  function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state = getBindingState(geometry, program, material);
        if (currentState !== state) {
          currentState = state;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(geometry, index);
        if (updateBuffers)
          saveCache(geometry, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (object.isInstancedMesh === true) {
        updateBuffers = true;
      }
      if (index !== null) {
        attributes.update(index, 34963);
      }
      if (updateBuffers) {
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(34963, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
        newAttributes[i2] = 0;
        enabledAttributes[i2] = 0;
        attributeDivisors[i2] = 0;
      }
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(geometry, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      for (const key in geometryAttributes) {
        const cachedAttribute = cachedAttributes[key];
        const geometryAttribute = geometryAttributes[key];
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(geometry, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      for (const key in attributes2) {
        const attribute = attributes2[key];
        const data = {};
        data.attribute = attribute;
        if (attribute.data) {
          data.data = attribute.data;
        }
        cache[key] = data;
        attributesNum++;
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
        newAttributes[i2] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
        if (enabledAttributes[i2] !== newAttributes[i2]) {
          gl.disableVertexAttribArray(i2);
          enabledAttributes[i2] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
      if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
        gl.vertexAttribIPointer(index, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data && data.isInstancedInterleavedBuffer) {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttribute(programAttribute.location + i2);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i2) * bytesPerElement);
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttribute(programAttribute.location + i2);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render6(start, count) {
      gl.drawArrays(mode, start, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start, count, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render6;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      drawBuffers,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
      const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
      resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i2 = 0; i2 !== lGlobal; ++i2) {
          dstArray[i2] = globalState[i2];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
            plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer) {
    let cubemaps = /* @__PURE__ */ new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer, texture);
              cubemaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function _createPlanes() {
    const _lodPlanes2 = [];
    const _sizeLods2 = [];
    const _sigmas2 = [];
    let lod = LOD_MAX;
    for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
      const sizeLod = Math.pow(2, lod);
      _sizeLods2.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i2 > LOD_MAX - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
      } else if (i2 === 0) {
        sigma = 0;
      }
      _sigmas2.push(sigma);
      const texelSize = 1 / (sizeLod - 1);
      const min = -texelSize / 2;
      const max = 1 + texelSize / 2;
      const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x = face % 3 * 2 / 3 - 1;
        const y = face > 2 ? 0 : -1;
        const coordinates = [
          x,
          y,
          0,
          x + 2 / 3,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      _lodPlanes2.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
  }
  function _createRenderTarget(params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x, y, width, height) {
    target.viewport.set(x, y, width, height);
    target.scissor.set(x, y, width, height);
  }
  function _getBlurShader(maxSamples) {
    const weights = new Float32Array(maxSamples);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new RawShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: { "n": maxSamples },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectShader() {
    const texelSize = new Vector2(1, 1);
    const shaderMaterial = new RawShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "texelSize": { value: texelSize }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = texture2D ( envMap, uv ).rgb;
				uv.x += texelSize.x;
				vec3 tr = texture2D ( envMap, uv ).rgb;
				uv.y += texelSize.y;
				vec3 br = texture2D ( envMap, uv ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = texture2D ( envMap, uv ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getCubemapShader() {
    const shaderMaterial = new RawShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "flipEnvMap": { value: -1 }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = /* @__PURE__ */ new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
            texture.needsPMREMUpdate = false;
            let renderTarget = cubeUVmaps.get(texture);
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer);
            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
            cubeUVmaps.set(texture, renderTarget);
            return renderTarget.texture;
          } else {
            if (cubeUVmaps.has(texture)) {
              return cubeUVmaps.get(texture).texture;
            } else {
              const image = texture.image;
              if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer);
                const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                cubeUVmaps.set(texture, renderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image) {
      let count = 0;
      const length = 6;
      for (let i2 = 0; i2 < length; i2++) {
        if (image[i2] !== void 0)
          count++;
      }
      return count === length;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = /* @__PURE__ */ new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension(name) !== null;
      },
      init: function(capabilities) {
        if (capabilities.isWebGL2) {
          getExtension("EXT_color_buffer_float");
        } else {
          getExtension("WEBGL_depth_texture");
          getExtension("OES_texture_float");
          getExtension("OES_texture_half_float");
          getExtension("OES_texture_half_float_linear");
          getExtension("OES_standard_derivatives");
          getExtension("OES_element_index_uint");
          getExtension("OES_vertex_array_object");
          getExtension("ANGLE_instanced_arrays");
        }
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
        getExtension("WEBGL_multisampled_render_to_texture");
      },
      get: function(name) {
        const extension = getExtension(name);
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = /* @__PURE__ */ new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i2 = 0, l = array.length; i2 < l; i2++) {
          attributes.update(array[i2], 34962);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
          const a = array[i2 + 0];
          const b = array[i2 + 1];
          const c = array[i2 + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i2 = 0, l = array.length / 3 - 1; i2 < l; i2 += 3) {
          const a = i2 + 0;
          const b = i2 + 1;
          const c = i2 + 2;
          indices.push(a, b, b, c, c, a);
        }
      }
      const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render6(start, count) {
      gl.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render6;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render6 = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render6.calls++;
      switch (mode) {
        case 4:
          render6.triangles += instanceCount * (count / 3);
          break;
        case 1:
          render6.lines += instanceCount * (count / 2);
          break;
        case 3:
          render6.lines += instanceCount * (count - 1);
          break;
        case 2:
          render6.lines += instanceCount * count;
          break;
        case 0:
          render6.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render6.frame++;
      render6.calls = 0;
      render6.triangles = 0;
      render6.points = 0;
      render6.lines = 0;
    }
    return {
      memory,
      render: render6,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function numericalSort(a, b) {
    return a[0] - b[0];
  }
  function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function denormalize(morph, attribute) {
    let denominator = 1;
    const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
    if (array instanceof Int8Array)
      denominator = 127;
    else if (array instanceof Int16Array)
      denominator = 32767;
    else if (array instanceof Int32Array)
      denominator = 2147483647;
    else
      console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
    morph.divideScalar(denominator);
  }
  function WebGLMorphtargets(gl, capabilities, textures) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const morphTextures = /* @__PURE__ */ new WeakMap();
    const morph = new Vector3();
    const workInfluences = [];
    for (let i2 = 0; i2 < 8; i2++) {
      workInfluences[i2] = [i2, 0];
    }
    function update(object, geometry, material, program) {
      const objectInfluences = object.morphTargetInfluences;
      if (capabilities.isWebGL2 === true) {
        const numberOfMorphTargets = geometry.morphAttributes.position.length;
        let entry = morphTextures.get(geometry);
        if (entry === void 0 || entry.count !== numberOfMorphTargets) {
          let disposeTexture = function() {
            texture.dispose();
            morphTextures.delete(geometry);
            geometry.removeEventListener("dispose", disposeTexture);
          };
          if (entry !== void 0)
            entry.texture.dispose();
          const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
          const morphTargets = geometry.morphAttributes.position;
          const morphNormals = geometry.morphAttributes.normal || [];
          const numberOfVertices = geometry.attributes.position.count;
          const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
          let width = numberOfVertices * numberOfVertexData;
          let height = 1;
          if (width > capabilities.maxTextureSize) {
            height = Math.ceil(width / capabilities.maxTextureSize);
            width = capabilities.maxTextureSize;
          }
          const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
          const texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);
          texture.format = RGBAFormat;
          texture.type = FloatType;
          texture.needsUpdate = true;
          const vertexDataStride = numberOfVertexData * 4;
          for (let i2 = 0; i2 < numberOfMorphTargets; i2++) {
            const morphTarget = morphTargets[i2];
            const morphNormal = morphNormals[i2];
            const offset = width * height * 4 * i2;
            for (let j = 0; j < morphTarget.count; j++) {
              morph.fromBufferAttribute(morphTarget, j);
              if (morphTarget.normalized === true)
                denormalize(morph, morphTarget);
              const stride = j * vertexDataStride;
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
              if (hasMorphNormals === true) {
                morph.fromBufferAttribute(morphNormal, j);
                if (morphNormal.normalized === true)
                  denormalize(morph, morphNormal);
                buffer[offset + stride + 4] = morph.x;
                buffer[offset + stride + 5] = morph.y;
                buffer[offset + stride + 6] = morph.z;
                buffer[offset + stride + 7] = 0;
              }
            }
          }
          entry = {
            count: numberOfMorphTargets,
            texture,
            size: new Vector2(width, height)
          };
          morphTextures.set(geometry, entry);
          geometry.addEventListener("dispose", disposeTexture);
        }
        let morphInfluencesSum = 0;
        for (let i2 = 0; i2 < objectInfluences.length; i2++) {
          morphInfluencesSum += objectInfluences[i2];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
        program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
        program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
      } else {
        const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === void 0 || influences.length !== length) {
          influences = [];
          for (let i2 = 0; i2 < length; i2++) {
            influences[i2] = [i2, 0];
          }
          influencesList[geometry.id] = influences;
        }
        for (let i2 = 0; i2 < length; i2++) {
          const influence = influences[i2];
          influence[0] = i2;
          influence[1] = objectInfluences[i2];
        }
        influences.sort(absNumericalSort);
        for (let i2 = 0; i2 < 8; i2++) {
          if (i2 < length && influences[i2][1]) {
            workInfluences[i2][0] = influences[i2][0];
            workInfluences[i2][1] = influences[i2][1];
          } else {
            workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i2][1] = 0;
          }
        }
        workInfluences.sort(numericalSort);
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const influence = workInfluences[i2];
          const index = influence[0];
          const value = influence[1];
          if (index !== Number.MAX_SAFE_INTEGER && value) {
            if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
              geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
            }
            if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
              geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
            }
            morphInfluences[i2] = value;
            morphInfluencesSum += value;
          } else {
            if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
              geometry.deleteAttribute("morphTarget" + i2);
            }
            if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
              geometry.deleteAttribute("morphNormal" + i2);
            }
            morphInfluences[i2] = 0;
          }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
      }
    }
    return {
      update
    };
  }
  function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = /* @__PURE__ */ new WeakMap();
    function update(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        attributes.update(object.instanceMatrix, 34962);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, 34962);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = /* @__PURE__ */ new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
        offset += blockSize;
        array[i2].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i2 = 0, l = a.length; i2 < l; i2++) {
      if (a[i2] !== b[i2])
        return false;
    }
    return true;
  }
  function copyArray(a, b) {
    for (let i2 = 0, l = b.length; i2 < l; i2++) {
      a[i2] = b[i2];
    }
  }
  function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (let i2 = 0; i2 !== n; ++i2) {
      r[i2] = textures.allocateTextureUnit();
    }
    return r;
  }
  function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }
  function setValueV2ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
  }
  function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
  }
  function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }
  function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }
  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }
  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }
  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }
  function setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
  }
  function setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
  }
  function setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
  }
  function setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
  }
  function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i2 = 0; i2 !== n; ++i2) {
      textures.safeSetTexture2D(v[i2] || emptyTexture, units[i2]);
    }
  }
  function setValueT3DArray(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i2 = 0; i2 !== n; ++i2) {
      textures.setTexture3D(v[i2] || emptyTexture3d, units[i2]);
    }
  }
  function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i2 = 0; i2 !== n; ++i2) {
      textures.safeSetTextureCube(v[i2] || emptyCubeTexture, units[i2]);
    }
  }
  function setValueT2DArrayArray(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i2 = 0; i2 !== n; ++i2) {
      textures.setTexture2DArray(v[i2] || emptyTexture2dArray, units[i2]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3DArray;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArrayArray;
    }
  }
  function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
  function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
  function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, 35718);
    for (let i2 = 0; i2 < n; ++i2) {
      const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  function addLineNumbers(string) {
    const lines = string.split("\n");
    for (let i2 = 0; i2 < lines.length; i2++) {
      lines[i2] = i2 + 1 + ": " + lines[i2];
    }
    return lines.join("\n");
  }
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
        return ["Linear", "( value )"];
    }
  }
  function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === "")
      return "";
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl.getShaderSource(shader));
  }
  function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for (let i2 = 0; i2 < n; i2++) {
      const info = gl.getActiveAttrib(program, i2);
      const name = info.name;
      let locationSize = 1;
      if (info.type === 35674)
        locationSize = 2;
      if (info.type === 35675)
        locationSize = 3;
      if (info.type === 35676)
        locationSize = 4;
      attributes[name] = {
        type: info.type,
        location: gl.getAttribLocation(program, name),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
  }
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
  }
  function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return loopReplacer(match, start, end, snippet);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define MAX_BONES " + parameters.maxBones,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.transparent ? "" : "#define OPAQUE",
        ShaderChunk["encodings_pars_fragment"],
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
        parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new Layers();
    const _customShaders = new WebGLShaderCache();
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function getMaxBones(object) {
      const skeleton = object.skeleton;
      const bones = skeleton.bones;
      if (floatVertexTextures) {
        return 1024;
      } else {
        const nVertexUniforms = maxVertexUniforms;
        const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        const maxBones = Math.min(nVertexMatrices, bones.length);
        if (maxBones < bones.length) {
          console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
          return 0;
        }
        return maxBones;
      }
    }
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const shaderID = shaderIDs[material.type];
      const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      let vertexShader, fragmentShader;
      let customVertexShaderID, customFragmentShaderID;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
        _customShaders.update(material);
        customVertexShaderID = _customShaders.getVertexShaderID(material);
        customFragmentShaderID = _customShaders.getFragmentShaderID(material);
      }
      const currentRenderTarget = renderer.getRenderTarget();
      const useAlphaTest = material.alphaTest > 0;
      const useClearcoat = material.clearcoat > 0;
      const parameters = {
        isWebGL2,
        shaderID,
        shaderName: material.type,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        customVertexShaderID,
        customFragmentShaderID,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: object.isInstancedMesh === true,
        instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
        supportsVertexTextures: vertexTextures,
        outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
        map: !!material.map,
        matcap: !!material.matcap,
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
        lightMap: !!material.lightMap,
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
        clearcoat: useClearcoat,
        clearcoatMap: useClearcoat && !!material.clearcoatMap,
        clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
        clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        specularIntensityMap: !!material.specularIntensityMap,
        specularColorMap: !!material.specularColorMap,
        transparent: material.transparent,
        alphaMap: !!material.alphaMap,
        alphaTest: useAlphaTest,
        gradientMap: !!material.gradientMap,
        sheen: material.sheen > 0,
        sheenColorMap: !!material.sheenColorMap,
        sheenRoughnessMap: !!material.sheenRoughnessMap,
        transmission: material.transmission > 0,
        transmissionMap: !!material.transmissionMap,
        thicknessMap: !!material.thicknessMap,
        combine: material.combine,
        vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog,
        fogExp2: fog && fog.isFogExp2,
        flatShading: !!material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer,
        skinning: object.isSkinnedMesh === true && maxBones > 0,
        maxBones,
        useVertexTexture: floatVertexTextures,
        morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
        morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
        morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.fragDepth,
        extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.customVertexShaderID);
        array.push(parameters.customFragmentShaderID);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        getProgramCacheKeyParameters(array, parameters);
        getProgramCacheKeyBooleans(array, parameters);
        array.push(renderer.outputEncoding);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
      array.push(parameters.precision);
      array.push(parameters.outputEncoding);
      array.push(parameters.envMapMode);
      array.push(parameters.combine);
      array.push(parameters.vertexUvs);
      array.push(parameters.fogExp2);
      array.push(parameters.sizeAttenuation);
      array.push(parameters.maxBones);
      array.push(parameters.morphTargetsCount);
      array.push(parameters.numDirLights);
      array.push(parameters.numPointLights);
      array.push(parameters.numSpotLights);
      array.push(parameters.numHemiLights);
      array.push(parameters.numRectAreaLights);
      array.push(parameters.numDirLightShadows);
      array.push(parameters.numPointLightShadows);
      array.push(parameters.numSpotLightShadows);
      array.push(parameters.shadowMapType);
      array.push(parameters.toneMapping);
      array.push(parameters.numClippingPlanes);
      array.push(parameters.numClipIntersection);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
      _programLayers.disableAll();
      if (parameters.isWebGL2)
        _programLayers.enable(0);
      if (parameters.supportsVertexTextures)
        _programLayers.enable(1);
      if (parameters.instancing)
        _programLayers.enable(2);
      if (parameters.instancingColor)
        _programLayers.enable(3);
      if (parameters.map)
        _programLayers.enable(4);
      if (parameters.matcap)
        _programLayers.enable(5);
      if (parameters.envMap)
        _programLayers.enable(6);
      if (parameters.envMapCubeUV)
        _programLayers.enable(7);
      if (parameters.lightMap)
        _programLayers.enable(8);
      if (parameters.aoMap)
        _programLayers.enable(9);
      if (parameters.emissiveMap)
        _programLayers.enable(10);
      if (parameters.bumpMap)
        _programLayers.enable(11);
      if (parameters.normalMap)
        _programLayers.enable(12);
      if (parameters.objectSpaceNormalMap)
        _programLayers.enable(13);
      if (parameters.tangentSpaceNormalMap)
        _programLayers.enable(14);
      if (parameters.clearcoat)
        _programLayers.enable(15);
      if (parameters.clearcoatMap)
        _programLayers.enable(16);
      if (parameters.clearcoatRoughnessMap)
        _programLayers.enable(17);
      if (parameters.clearcoatNormalMap)
        _programLayers.enable(18);
      if (parameters.displacementMap)
        _programLayers.enable(19);
      if (parameters.specularMap)
        _programLayers.enable(20);
      if (parameters.roughnessMap)
        _programLayers.enable(21);
      if (parameters.metalnessMap)
        _programLayers.enable(22);
      if (parameters.gradientMap)
        _programLayers.enable(23);
      if (parameters.alphaMap)
        _programLayers.enable(24);
      if (parameters.alphaTest)
        _programLayers.enable(25);
      if (parameters.vertexColors)
        _programLayers.enable(26);
      if (parameters.vertexAlphas)
        _programLayers.enable(27);
      if (parameters.vertexUvs)
        _programLayers.enable(28);
      if (parameters.vertexTangents)
        _programLayers.enable(29);
      if (parameters.uvsVertexOnly)
        _programLayers.enable(30);
      if (parameters.fog)
        _programLayers.enable(31);
      array.push(_programLayers.mask);
      _programLayers.disableAll();
      if (parameters.useFog)
        _programLayers.enable(0);
      if (parameters.flatShading)
        _programLayers.enable(1);
      if (parameters.logarithmicDepthBuffer)
        _programLayers.enable(2);
      if (parameters.skinning)
        _programLayers.enable(3);
      if (parameters.useVertexTexture)
        _programLayers.enable(4);
      if (parameters.morphTargets)
        _programLayers.enable(5);
      if (parameters.morphNormals)
        _programLayers.enable(6);
      if (parameters.premultipliedAlpha)
        _programLayers.enable(7);
      if (parameters.shadowMapEnabled)
        _programLayers.enable(8);
      if (parameters.physicallyCorrectLights)
        _programLayers.enable(9);
      if (parameters.doubleSided)
        _programLayers.enable(10);
      if (parameters.flipSided)
        _programLayers.enable(11);
      if (parameters.depthPacking)
        _programLayers.enable(12);
      if (parameters.dithering)
        _programLayers.enable(13);
      if (parameters.specularIntensityMap)
        _programLayers.enable(14);
      if (parameters.specularColorMap)
        _programLayers.enable(15);
      if (parameters.transmission)
        _programLayers.enable(16);
      if (parameters.transmissionMap)
        _programLayers.enable(17);
      if (parameters.thicknessMap)
        _programLayers.enable(18);
      if (parameters.sheen)
        _programLayers.enable(19);
      if (parameters.sheenColorMap)
        _programLayers.enable(20);
      if (parameters.sheenRoughnessMap)
        _programLayers.enable(21);
      if (parameters.decodeVideoTexture)
        _programLayers.enable(22);
      if (parameters.transparent)
        _programLayers.enable(23);
      array.push(_programLayers.mask);
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
        const preexistingProgram = programs[p2];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i2 = programs.indexOf(program);
        programs[i2] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    function releaseShaderCache(material) {
      _customShaders.remove(material);
    }
    function dispose() {
      _customShaders.dispose();
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      releaseShaderCache,
      programs,
      dispose
    };
  }
  function WebGLProperties() {
    let properties = /* @__PURE__ */ new WeakMap();
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      remove,
      update,
      dispose
    };
  }
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init10() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
      let renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1)
        transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
        const renderItem = renderItems[i2];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init: init10,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists() {
    let lists = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth) {
      let list;
      if (lists.has(scene) === false) {
        list = new WebGLRenderList();
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= lists.get(scene).length) {
          list = new WebGLRenderList();
          lists.get(scene).push(list);
        } else {
          list = lists.get(scene)[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    for (let i2 = 0; i2 < 9; i2++)
      state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, physicallyCorrectLights) {
      let r = 0, g = 0, b = 0;
      for (let i2 = 0; i2 < 9; i2++)
        state.probe[i2].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      lights.sort(shadowCastingLightsFirst);
      const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
      for (let i2 = 0, l = lights.length; i2 < l; i2++) {
        const light = lights[i2];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r += color.r * intensity * scaleFactor;
          g += color.g * intensity * scaleFactor;
          b += color.b * intensity * scaleFactor;
        } else if (light.isLightProbe) {
          for (let j = 0; j < 9; j++) {
            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
            numSpotShadows++;
          }
          state.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state.ambient[0] = r;
      state.ambient[1] = g;
      state.ambient[2] = b;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotShadowMatrix.length = numSpotShadows;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        state.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i2 = 0, l = lights.length; i2 < l; i2++) {
        const light = lights[i2];
        if (light.isDirectionalLight) {
          const uniforms = state.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.direction.normalize();
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init10() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(physicallyCorrectLights) {
      lights.setup(lightsArray, physicallyCorrectLights);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init: init10,
      state,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth = 0) {
      let renderState;
      if (renderStates.has(scene) === false) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStates.get(scene).length) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStates.get(scene).push(renderState);
        } else {
          renderState = renderStates.get(scene)[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (let i2 = 0, il = lights.length; i2 < il; i2++) {
        const light = lights[i2];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
          const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.camera.updateProjectionMatrix();
        }
        if (shadow.map === null) {
          const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
          _state.viewport(_viewport);
          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }
        if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
        shadow.needsUpdate = false;
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
      const geometry = _objects.update(fullScreenMesh);
      if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
        shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialVertical.needsUpdate = true;
        shadowMaterialHorizontal.needsUpdate = true;
      }
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
      let result = null;
      const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      }
      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k = 0, kl = groups.length; k < kl; k++) {
              const group = groups[k];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        renderObject(children[i2], camera, shadowCamera, light, type);
      }
    }
  }
  function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }
          color.set(r, g, b, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;
                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;
                case LessDepth:
                  gl.depthFunc(513);
                  break;
                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;
                case EqualDepth:
                  gl.depthFunc(514);
                  break;
                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;
                case GreaterDepth:
                  gl.depthFunc(516);
                  break;
                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;
                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);
      for (let i2 = 0; i2 < count; i2++) {
        gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (isWebGL2) {
          if (target === 36009) {
            currentBoundFramebuffers[36160] = framebuffer;
          }
          if (target === 36160) {
            currentBoundFramebuffers[36009] = framebuffer;
          }
        }
        return true;
      }
      return false;
    }
    function drawBuffers(renderTarget, framebuffer) {
      let drawBuffers2 = defaultDrawbuffers;
      let needsUpdate = false;
      if (renderTarget) {
        drawBuffers2 = currentDrawbuffers.get(framebuffer);
        if (drawBuffers2 === void 0) {
          drawBuffers2 = [];
          currentDrawbuffers.set(framebuffer, drawBuffers2);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures = renderTarget.texture;
          if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
            for (let i2 = 0, il = textures.length; i2 < il; i2++) {
              drawBuffers2[i2] = 36064 + i2;
            }
            drawBuffers2.length = textures.length;
            needsUpdate = true;
          }
        } else {
          if (drawBuffers2[0] !== 36064) {
            drawBuffers2[0] = 36064;
            needsUpdate = true;
          }
        }
      } else {
        if (drawBuffers2[0] !== 1029) {
          drawBuffers2[0] = 1029;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          gl.drawBuffers(drawBuffers2);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
        }
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: 32774,
      [SubtractEquation]: 32778,
      [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: 0,
      [OneFactor]: 1,
      [SrcColorFactor]: 768,
      [SrcAlphaFactor]: 770,
      [SrcAlphaSaturateFactor]: 776,
      [DstColorFactor]: 774,
      [DstAlphaFactor]: 772,
      [OneMinusSrcColorFactor]: 769,
      [OneMinusSrcAlphaFactor]: 771,
      [OneMinusDstColorFactor]: 775,
      [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width);
        currentLineWidth = width;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }
      let boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage2D() {
      try {
        gl.texSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage3D() {
      try {
        gl.texSubImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage2D() {
      try {
        gl.compressedTexSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage2D() {
      try {
        gl.texStorage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage3D() {
      try {
        gl.texStorage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function reset() {
      gl.disable(3042);
      gl.disable(2884);
      gl.disable(2929);
      gl.disable(32823);
      gl.disable(3089);
      gl.disable(2960);
      gl.disable(32926);
      gl.blendEquation(32774);
      gl.blendFunc(1, 0);
      gl.blendFuncSeparate(1, 0, 1, 0);
      gl.colorMask(true, true, true, true);
      gl.clearColor(0, 0, 0, 0);
      gl.depthMask(true);
      gl.depthFunc(513);
      gl.clearDepth(1);
      gl.stencilMask(4294967295);
      gl.stencilFunc(519, 0, 4294967295);
      gl.stencilOp(7680, 7680, 7680);
      gl.clearStencil(0);
      gl.cullFace(1029);
      gl.frontFace(2305);
      gl.polygonOffset(0, 0);
      gl.activeTexture(33984);
      gl.bindFramebuffer(36160, null);
      if (isWebGL2 === true) {
        gl.bindFramebuffer(36009, null);
        gl.bindFramebuffer(36008, null);
      }
      gl.useProgram(null);
      gl.lineWidth(1);
      gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentBoundFramebuffers = {};
      currentDrawbuffers = /* @__PURE__ */ new WeakMap();
      defaultDrawbuffers = [];
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
      currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      drawBuffers,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      texImage2D,
      texImage3D,
      texStorage2D,
      texStorage3D,
      texSubImage2D,
      texSubImage3D,
      compressedTexSubImage2D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const hasMultisampledRenderToTexture = extensions.has("WEBGL_multisampled_render_to_texture");
    const MultisampledRenderToTextureExtension = hasMultisampledRenderToTexture ? extensions.get("WEBGL_multisampled_render_to_texture") : void 0;
    const _videoTextures = /* @__PURE__ */ new WeakMap();
    let _canvas2;
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width, height) {
      return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }
      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor2 = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
          const width = floor2(scale * image.width);
          const height = floor2(scale * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width, height);
          const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo$1(image) {
      return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target) {
      _gl.generateMipmap(target);
    }
    function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 33319) {
        if (glType === 5126)
          internalFormat = 33328;
        if (glType === 5131)
          internalFormat = 33327;
        if (glType === 5121)
          internalFormat = 33323;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
        if (glType === 32819)
          internalFormat = 32854;
        if (glType === 32820)
          internalFormat = 32855;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function getMipLevels(texture, image, supportsMips) {
      if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        return Math.log2(Math.max(image.width, image.height)) + 1;
      } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
        return texture.mipmaps.length;
      } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
        return image.mipmaps.length;
      } else {
        return 1;
      }
    }
    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
      info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      _gl.deleteTexture(textureProperties.__webglTexture);
      properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      if (!renderTarget)
        return;
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
        info.memory.textures--;
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i2 = 0; i2 < 6; i2++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        for (let i2 = 0, il = texture.length; i2 < il; i2++) {
          const attachmentProperties = properties.get(texture[i2]);
          if (attachmentProperties.__webglTexture) {
            _gl.deleteTexture(attachmentProperties.__webglTexture);
            info.memory.textures--;
          }
          properties.remove(texture[i2]);
        }
      }
      properties.remove(texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === void 0) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
      [RepeatWrapping]: 10497,
      [ClampToEdgeWrapping]: 33071,
      [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
      [NearestFilter]: 9728,
      [NearestMipmapNearestFilter]: 9984,
      [NearestMipmapLinearFilter]: 9986,
      [LinearFilter]: 9729,
      [LinearMipmapNearestFilter]: 9985,
      [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
      }
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = 3553;
      if (texture.isDataTexture2DArray)
        textureType = 35866;
      if (texture.isDataTexture3D)
        textureType = 32879;
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(textureType, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, 0, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          if (texture.format !== RGBAFormat) {
            if (glFormat !== null) {
              if (useTexStorage) {
                state.compressedTexSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
              } else {
                state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              }
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
      } else if (texture.isDataTexture2DArray) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isDataTexture3D) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
        cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(34069 + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i2].image;
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
              } else {
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
      const glFormat = utils.convert(texture.format, texture.encoding);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const renderTargetProperties = properties.get(renderTarget);
      if (!renderTargetProperties.__hasExternalTextures) {
        if (textureTarget === 32879 || textureTarget === 35866) {
          state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
      }
      state.bindFramebuffer(36160, framebuffer);
      if (renderTarget.useRenderToTexture) {
        MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
      } else {
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
      }
      state.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = 33189;
        if (isMultisample || renderTarget.useRenderToTexture) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          if (renderTarget.useRenderToTexture) {
            MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && renderTarget.useRenderbuffer) {
          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else if (renderTarget.useRenderToTexture) {
          MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
        const glFormat = utils.convert(texture.format, texture.encoding);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && renderTarget.useRenderbuffer) {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (renderTarget.useRenderToTexture) {
          MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      const samples = getRenderTargetSamples(renderTarget);
      if (renderTarget.depthTexture.format === DepthFormat) {
        if (renderTarget.useRenderToTexture) {
          MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        }
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        if (renderTarget.useRenderToTexture) {
          MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        }
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i2 = 0; i2 < 6; i2++) {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
            renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
          }
        } else {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state.bindFramebuffer(36160, null);
    }
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      if (colorTexture !== void 0) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
      }
      if (depthTexture !== void 0) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      if (renderTarget.isWebGLMultipleRenderTargets !== true) {
        if (textureProperties.__webglTexture === void 0) {
          textureProperties.__webglTexture = _gl.createTexture();
        }
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultipleRenderTargets) {
          if (capabilities.drawBuffers) {
            const textures = renderTarget.texture;
            for (let i2 = 0, il = textures.length; i2 < il; i2++) {
              const attachmentProperties = properties.get(textures[i2]);
              if (attachmentProperties.__webglTexture === void 0) {
                attachmentProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
              }
            }
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          }
        } else if (renderTarget.useRenderbuffer) {
          if (isWebGL2) {
            renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
            renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
            const glFormat = utils.convert(texture.format, texture.encoding);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
            _gl.bindRenderbuffer(36161, null);
            if (renderTarget.depthBuffer) {
              renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
            }
            state.bindFramebuffer(36160, null);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      if (isCube) {
        state.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, texture, supportsMips);
        for (let i2 = 0; i2 < 6; i2++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067);
        }
        state.unbindTexture();
      } else if (isMultipleRenderTargets) {
        const textures = renderTarget.texture;
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          const attachment = textures[i2];
          const attachmentProperties = properties.get(attachment);
          state.bindTexture(3553, attachmentProperties.__webglTexture);
          setTextureParameters(3553, attachment, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
          if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
            generateMipmap(3553);
          }
        }
        state.unbindTexture();
      } else {
        let glTextureType = 3553;
        if (isRenderTarget3D) {
          if (isWebGL2) {
            const isTexture3D = texture.isDataTexture3D;
            glTextureType = isTexture3D ? 32879 : 35866;
          } else {
            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
          }
        }
        state.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(glTextureType);
        }
        state.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const texture = textures[i2];
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
          const webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(target, webglTexture);
          generateMipmap(target);
          state.unbindTexture();
        }
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.useRenderbuffer) {
        if (isWebGL2) {
          const width = renderTarget.width;
          const height = renderTarget.height;
          let mask = 16384;
          const invalidationArray = [36064];
          const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
          if (renderTarget.depthBuffer) {
            invalidationArray.push(depthStyle);
          }
          if (!renderTarget.ignoreDepthForMultisampleCopy) {
            if (renderTarget.depthBuffer)
              mask |= 256;
            if (renderTarget.stencilBuffer)
              mask |= 1024;
          }
          const renderTargetProperties = properties.get(renderTarget);
          state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
          state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
          if (renderTarget.ignoreDepthForMultisampleCopy) {
            _gl.invalidateFramebuffer(36008, [depthStyle]);
            _gl.invalidateFramebuffer(36009, [depthStyle]);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
          _gl.invalidateFramebuffer(36008, invalidationArray);
          state.bindFramebuffer(36008, null);
          state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return isWebGL2 && (renderTarget.useRenderbuffer || renderTarget.useRenderToTexture) ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    function verifyColorSpace(texture, image) {
      const encoding = texture.encoding;
      const format = texture.format;
      const type = texture.type;
      if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
        return image;
      if (encoding !== LinearEncoding) {
        if (encoding === sRGBEncoding) {
          if (isWebGL2 === false) {
            if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
              texture.format = _SRGBAFormat;
              texture.minFilter = LinearFilter;
              texture.generateMipmaps = false;
            } else {
              image = ImageUtils.sRGBToLinear(image);
            }
          } else {
            if (format !== RGBAFormat || type !== UnsignedByteType) {
              console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
            }
          }
        } else {
          console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
        }
      }
      return image;
    }
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (warnedTexture2D === false) {
          console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warnedTexture2D = true;
        }
        texture = texture.texture;
      }
      setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
      if (texture && texture.isWebGLCubeRenderTarget) {
        if (warnedTextureCube === false) {
          console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warnedTextureCube = true;
        }
        texture = texture.texture;
      }
      setTextureCube(texture, slot);
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p2, encoding = null) {
      let extension;
      if (p2 === UnsignedByteType)
        return 5121;
      if (p2 === UnsignedShort4444Type)
        return 32819;
      if (p2 === UnsignedShort5551Type)
        return 32820;
      if (p2 === ByteType)
        return 5120;
      if (p2 === ShortType)
        return 5122;
      if (p2 === UnsignedShortType)
        return 5123;
      if (p2 === IntType)
        return 5124;
      if (p2 === UnsignedIntType)
        return 5125;
      if (p2 === FloatType)
        return 5126;
      if (p2 === HalfFloatType) {
        if (isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p2 === AlphaFormat)
        return 6406;
      if (p2 === RGBAFormat)
        return 6408;
      if (p2 === LuminanceFormat)
        return 6409;
      if (p2 === LuminanceAlphaFormat)
        return 6410;
      if (p2 === DepthFormat)
        return 6402;
      if (p2 === DepthStencilFormat)
        return 34041;
      if (p2 === RedFormat)
        return 6403;
      if (p2 === RGBFormat) {
        console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
        return 6408;
      }
      if (p2 === _SRGBAFormat) {
        extension = extensions.get("EXT_sRGB");
        if (extension !== null) {
          return extension.SRGB_ALPHA_EXT;
        } else {
          return null;
        }
      }
      if (p2 === RedIntegerFormat)
        return 36244;
      if (p2 === RGFormat)
        return 33319;
      if (p2 === RGIntegerFormat)
        return 33320;
      if (p2 === RGBAIntegerFormat)
        return 36249;
      if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
        if (encoding === sRGBEncoding) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
          if (extension !== null) {
            if (p2 === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (p2 === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        } else {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p2 === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p2 === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
      }
      if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p2 === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p2 === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p2 === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p2 === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p2 === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p2 === RGB_ETC2_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
          if (p2 === RGBA_ETC2_EAC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        } else {
          return null;
        }
      }
      if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          if (p2 === RGBA_ASTC_4x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (p2 === RGBA_ASTC_5x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (p2 === RGBA_ASTC_5x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (p2 === RGBA_ASTC_6x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (p2 === RGBA_ASTC_6x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (p2 === RGBA_ASTC_8x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (p2 === RGBA_ASTC_8x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (p2 === RGBA_ASTC_8x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (p2 === RGBA_ASTC_10x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (p2 === RGBA_ASTC_10x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (p2 === RGBA_ASTC_10x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (p2 === RGBA_ASTC_10x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (p2 === RGBA_ASTC_12x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (p2 === RGBA_ASTC_12x12_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else {
          return null;
        }
      }
      if (p2 === RGBA_BPTC_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          if (p2 === RGBA_BPTC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        } else {
          return null;
        }
      }
      if (p2 === UnsignedInt248Type) {
        if (isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
    }
    return { convert };
  }
  function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
      uniforms.fogColor.value.copy(fog.color);
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsLambert(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        } else {
          refreshUniformsStandard(uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDepth(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsNormal(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      } else if (material.clearcoatMap) {
        uvScaleMap = material.clearcoatMap;
      } else if (material.clearcoatNormalMap) {
        uvScaleMap = material.clearcoatNormalMap;
      } else if (material.clearcoatRoughnessMap) {
        uvScaleMap = material.clearcoatRoughnessMap;
      } else if (material.specularIntensityMap) {
        uvScaleMap = material.specularIntensityMap;
      } else if (material.specularColorMap) {
        uvScaleMap = material.specularColorMap;
      } else if (material.transmissionMap) {
        uvScaleMap = material.transmissionMap;
      } else if (material.thicknessMap) {
        uvScaleMap = material.thicknessMap;
      } else if (material.sheenColorMap) {
        uvScaleMap = material.sheenColorMap;
      } else if (material.sheenRoughnessMap) {
        uvScaleMap = material.sheenRoughnessMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
      let uv2ScaleMap;
      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }
      if (uv2ScaleMap !== void 0) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }
        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }
        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsLambert(uniforms, material) {
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      refreshUniformsStandard(uniforms, material);
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
        if (material.sheenColorMap) {
          uniforms.sheenColorMap.value = material.sheenColorMap;
        }
        if (material.sheenRoughnessMap) {
          uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        }
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationColor.value.copy(material.attenuationColor);
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularColor.value.copy(material.specularColor);
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
      }
      if (material.specularColorMap) {
        uniforms.specularColorMap.value = material.specularColorMap;
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDepth(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function createCanvasElement() {
    const canvas = createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
  }
  function WebGLRenderer(parameters = {}) {
    const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = _canvas2;
    this.debug = {
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width2 = _canvas2.width;
    let _height2 = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width2, _height2);
    const _scissor = new Vector4(0, 0, _width2, _height2);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context2;
    function getContext(contextNames, contextAttributes) {
      for (let i2 = 0; i2 < contextNames.length; i2++) {
        const contextName = contextNames[i2];
        const context = _canvas2.getContext(contextName, contextAttributes);
        if (context !== null)
          return context;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in _canvas2)
        _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width2, _height2, false);
    };
    this.getSize = function(target) {
      return target.set(_width2, _height2);
    };
    this.setSize = function(width, height, updateStyle) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width2 = width;
      _height2 = height;
      _canvas2.width = Math.floor(width * _pixelRatio);
      _canvas2.height = Math.floor(height * _pixelRatio);
      if (updateStyle !== false) {
        _canvas2.style.width = width + "px";
        _canvas2.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width2 * _pixelRatio, _height2 * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width2 = width;
      _height2 = height;
      _pixelRatio = pixelRatio;
      _canvas2.width = Math.floor(width * pixelRatio);
      _canvas2.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
      let bits = 0;
      if (color === void 0 || color)
        bits |= 16384;
      if (depth === void 0 || depth)
        bits |= 256;
      if (stencil === void 0 || stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      const position = geometry.attributes.position;
      if (index === null) {
        if (position === void 0 || position.count === 0)
          return;
      } else if (index.count === 0) {
        return;
      }
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      const dataCount = index !== null ? index.count : position.count;
      const rangeStart = geometry.drawRange.start * rangeFactor;
      const rangeCount = geometry.drawRange.count * rangeFactor;
      const groupStart = group !== null ? group.start * rangeFactor : 0;
      const groupCount = group !== null ? group.count * rangeFactor : Infinity;
      const drawStart = Math.max(rangeStart, groupStart);
      const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      const drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0)
        return;
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(1);
        } else {
          renderer.setMode(4);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(1);
        } else if (object.isLineLoop) {
          renderer.setMode(2);
        } else {
          renderer.setMode(3);
        }
      } else if (object.isPoints) {
        renderer.setMode(0);
      } else if (object.isSprite) {
        renderer.setMode(4);
      }
      if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene, camera) {
      currentRenderState = renderStates.get(scene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      scene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i2 = 0; i2 < material.length; i2++) {
              const material2 = material[i2];
              getProgram(material2, scene, object);
            }
          } else {
            getProgram(material, scene, object);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== "undefined")
      animation.setContext(window);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.autoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null)
        camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true)
          xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i2 = 0, l = cameras.length; i2 < l; i2++) {
          const camera2 = cameras[i2];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info.render.frame;
            }
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i2 = 0, l = groups.length; i2 < l; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        projectObject(children[i2], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, scene, camera);
      if (viewport)
        state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
    }
    function renderTransmissionPass(opaqueObjects, scene, camera) {
      if (_transmissionRenderTarget === null) {
        const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
        const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
        _transmissionRenderTarget = new renderTargetType(1024, 1024, {
          generateMipmaps: true,
          type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          magFilter: NearestFilter,
          wrapS: ClampToEdgeWrapping,
          wrapT: ClampToEdgeWrapping,
          useRenderToTexture: extensions.has("WEBGL_multisampled_render_to_texture")
        });
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      _this.toneMapping = currentToneMapping;
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      _this.setRenderTarget(currentRenderTarget);
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i2 = 0, l = renderList.length; i2 < l; i2++) {
        const renderItem = renderList[i2];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputEncoding = parameters2.outputEncoding;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphTargetsCount = !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
      const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputEncoding !== encoding) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
          }
        }
      }
      if (!!geometry && (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0)) {
        morphtargets.update(object, geometry, material, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height2, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (renderTarget.useRenderToTexture) {
            console.warn("render-to-texture extension was disabled because an external texture was provided");
            renderTarget.useRenderToTexture = false;
            renderTarget.useRenderbuffer = true;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(36160, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
      }
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const texture = renderTarget.texture;
        if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (renderTarget.useRenderbuffer) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(36160, framebuffer);
      if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(36160, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (_gl.checkFramebufferStatus(36160) === 36053) {
            if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
              _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
            }
          } else {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(36160, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      if (texture.isFramebufferTexture !== true) {
        console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
        return;
      }
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(3553);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width = sourceBox.max.x - sourceBox.min.x + 1;
      const height = sourceBox.max.y - sourceBox.min.y + 1;
      const depth = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isDataTexture3D) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = 32879;
      } else if (dstTexture.isDataTexture2DArray) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = 35866;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(3314);
      const unpackImageHeight = _gl.getParameter(32878);
      const unpackSkipPixels = _gl.getParameter(3316);
      const unpackSkipRows = _gl.getParameter(3315);
      const unpackSkipImages = _gl.getParameter(32877);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(3314, image.width);
      _gl.pixelStorei(32878, image.height);
      _gl.pixelStorei(3316, sourceBox.min.x);
      _gl.pixelStorei(3315, sourceBox.min.y);
      _gl.pixelStorei(32877, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(3314, unpackRowLen);
      _gl.pixelStorei(32878, unpackImageHeight);
      _gl.pixelStorei(3316, unpackSkipPixels);
      _gl.pixelStorei(3315, unpackSkipRows);
      _gl.pixelStorei(32877, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      textures.setTexture2D(texture, 0);
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    if (sin !== void 0) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index,
        face: null,
        object
      });
    }
  }
  function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init10(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init10(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init10(x1, x2, t1, t2);
      },
      calc: function(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }
  function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  function QuadraticBezierP0(t, p2) {
    const k = 1 - t;
    return k * k * p2;
  }
  function QuadraticBezierP1(t, p2) {
    return 2 * (1 - t) * t * p2;
  }
  function QuadraticBezierP2(t, p2) {
    return t * t * p2;
  }
  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }
  function CubicBezierP0(t, p2) {
    const k = 1 - t;
    return k * k * k * p2;
  }
  function CubicBezierP1(t, p2) {
    const k = 1 - t;
    return 3 * k * k * t * p2;
  }
  function CubicBezierP2(t, p2) {
    return 3 * (1 - t) * t * t * p2;
  }
  function CubicBezierP3(t, p2) {
    return t * t * t * p2;
  }
  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }
  function linkedList(data, start, end, dim, clockwise) {
    let i2, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i2 = start; i2 < end; i2 += dim)
        last = insertNode(i2, data[i2], data[i2 + 1], last);
    } else {
      for (i2 = end - dim; i2 >= start; i2 -= dim)
        last = insertNode(i2, data[i2], data[i2 + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p2 = start, again;
    do {
      again = false;
      if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end = p2.prev;
        if (p2 === p2.next)
          break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    let p2 = ear.next.next;
    while (p2 !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p2 = ear.prevZ, n = ear.nextZ;
    while (p2 && p2.z >= minZ && n && n.z <= maxZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p2 && p2.z >= minZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p2 = start;
    do {
      const a = p2.prev, b = p2.next.next;
      if (!equals(a, b) && intersects(a, p2, p2.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p2.i / dim);
        triangles.push(b.i / dim);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start = b;
      }
      p2 = p2.next;
    } while (p2 !== start);
    return filterPoints(p2);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i2, len, start, end, list;
    for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      start = holeIndices[i2] * dim;
      end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i2 = 0; i2 < queue.length; i2++) {
      eliminateHole(queue[i2], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p2 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    do {
      if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        const x = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p2.y)
              return p2;
            if (hy === p2.next.y)
              return p2.next;
          }
          m = p2.x < p2.next.x ? p2 : p2.next;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p2 = m;
    do {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        tan = Math.abs(hy - p2.y) / (hx - p2.x);
        if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector(m, p2)))) {
          m = p2;
          tanMin = tan;
        }
      }
      p2 = p2.next;
    } while (p2 !== stop);
    return m;
  }
  function sectorContainsSector(m, p2) {
    return area(m.prev, m, p2.prev) < 0 && area(p2.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p2 = start;
    do {
      if (p2.z === null)
        p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  }
  function sortLinked(list) {
    let i2, p2, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p2 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        q = p2;
        pSize = 0;
        for (i2 = 0; i2 < inSize; i2++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
            e = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p2 = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    let p2 = start, leftmost = start;
    do {
      if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
        leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p2, q, r) {
    return (q.y - p2.y) * (r.x - q.x) - (q.x - p2.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p2, q, r) {
    return q.x <= Math.max(p2.x, r.x) && q.x >= Math.min(p2.x, r.x) && q.y <= Math.max(p2.y, r.y) && q.y >= Math.min(p2.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p2 = a;
    do {
      if (p2.i !== a.i && p2.next.i !== a.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a, b))
        return true;
      p2 = p2.next;
    } while (p2 !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p2 = a, inside = false;
    const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
      if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x)
        inside = !inside;
      p2 = p2.next;
    } while (p2 !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i2, x, y, last) {
    const p2 = new Node(i2, x, y);
    if (!last) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last.next;
      p2.prev = last;
      last.next.prev = p2;
      last.next = p2;
    }
    return p2;
  }
  function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ)
      p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ)
      p2.nextZ.prevZ = p2.prevZ;
  }
  function Node(i2, x, y) {
    this.i = i2;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i2 = start, j = end - dim; i2 < end; i2 += dim) {
      sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
      j = i2;
    }
    return sum;
  }
  function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (let i2 = 0; i2 < contour.length; i2++) {
      vertices.push(contour[i2].x);
      vertices.push(contour[i2].y);
    }
  }
  function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
        const shape = shapes[i2];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  function toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
        const shape = shapes[i2];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  function now() {
    return (typeof performance === "undefined" ? Date : performance).now();
  }
  function getBoneList(object) {
    const boneList = [];
    if (object && object.isBone) {
      boneList.push(object);
    }
    for (let i2 = 0; i2 < object.children.length; i2++) {
      boneList.push.apply(boneList, getBoneList(object.children[i2]));
    }
    return boneList;
  }
  var REVISION, CullFaceNone, CullFaceBack, CullFaceFront, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, KeepStencilOp, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, GLSL3, _SRGBAFormat, EventDispatcher, _lut, _seed, DEG2RAD, RAD2DEG, MathUtils, Vector2, Matrix3, _colorKeywords, _hslA, _hslB, Color, _canvas, ImageUtils, textureId, Texture, Vector4, WebGLRenderTarget, WebGLMultipleRenderTargets, WebGLMultisampleRenderTarget, Quaternion, Vector3, _vector$c, _quaternion$4, Box3, _points, _vector$b, _box$3, _v0$2, _v1$7, _v2$3, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$2, _v1$6, _toFarthestPoint, _toPoint, Sphere, _vector$a, _segCenter, _segDir, _diff, _edge1, _edge2, _normal$1, Ray, Matrix4, _v1$5, _m1$2, _zero, _one, _x, _y, _z, _matrix$1, _quaternion$3, Euler, Layers, _object3DId, _v1$4, _q1, _m1$1, _target, _position$3, _scale$2, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, Object3D, _v0$1, _v1$3, _v2$2, _v3$1, _vab, _vac, _vbc, _vap, _vbp, _vcp, Triangle, materialId, Material, MeshBasicMaterial, _vector$9, _vector2$1, BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute, Float16BufferAttribute, Float32BufferAttribute, _id$1, _m1, _obj, _offset, _box$1, _boxMorphTargets, _vector$8, BufferGeometry, _inverseMatrix$2, _ray$2, _sphere$3, _vA$1, _vB$1, _vC$1, _tempA, _tempB, _tempC, _morphA, _morphB, _morphC, _uvA$1, _uvB$1, _uvC$1, _intersectionPoint, _intersectionPointWorld, Mesh, BoxGeometry, UniformsUtils, default_vertex, default_fragment, ShaderMaterial, Camera, PerspectiveCamera, fov, aspect, CubeCamera, CubeTexture, WebGLCubeRenderTarget, _vector1, _vector2, _normalMatrix, Plane, _sphere$2, _vector$7, Frustum, PlaneGeometry, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_vertex, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, output_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, vertex$g, fragment$g, vertex$f, fragment$f, vertex$e, fragment$e, vertex$d, fragment$d, vertex$c, fragment$c, vertex$b, fragment$b, vertex$a, fragment$a, vertex$9, fragment$9, vertex$8, fragment$8, vertex$7, fragment$7, vertex$6, fragment$6, vertex$5, fragment$5, vertex$4, fragment$4, vertex$3, fragment$3, vertex$2, fragment$2, vertex$1, fragment$1, ShaderChunk, UniformsLib, ShaderLib, OrthographicCamera, RawShaderMaterial, LOD_MIN, LOD_MAX, SIZE_MAX, EXTRA_LOD_SIGMA, TOTAL_LODS, MAX_SAMPLES, _flatCamera, _lodPlanes, _sizeLods, _sigmas, _clearColor, _oldTarget, PHI, INV_PHI, _axisDirections, PMREMGenerator, DataTexture2DArray, DataTexture3D, emptyTexture, emptyTexture2dArray, emptyTexture3d, emptyCubeTexture, arrayCacheF32, arrayCacheI32, mat4array, mat3array, mat2array, RePathPart, programIdCount, includePattern, deprecatedUnrollLoopPattern, unrollLoopPattern, _id, WebGLShaderCache, WebGLShaderStage, nextVersion, MeshDepthMaterial, MeshDistanceMaterial, vertex, fragment, ArrayCamera, Group, _moveEvent, WebXRController, DepthTexture, WebXRManager, WebGL1Renderer, FogExp2, Fog, Scene, InterleavedBuffer, _vector$6, InterleavedBufferAttribute, SpriteMaterial, _geometry, _intersectPoint, _worldScale, _mvPosition, _alignedPosition, _rotatedPosition, _viewWorldMatrix, _vA, _vB, _vC, _uvA, _uvB, _uvC, Sprite, _basePosition, _skinIndex, _skinWeight, _vector$5, _matrix, SkinnedMesh, Bone, DataTexture, _offsetMatrix, _identityMatrix, Skeleton, InstancedBufferAttribute, _instanceLocalMatrix, _instanceWorldMatrix, _instanceIntersects, _mesh, InstancedMesh, LineBasicMaterial, _start$1, _end$1, _inverseMatrix$1, _ray$1, _sphere$1, Line, _start, _end, LineSegments, LineLoop, PointsMaterial, _inverseMatrix, _ray, _sphere, _position$2, Points, VideoTexture, FramebufferTexture, CompressedTexture, CanvasTexture, _v0, _v1$1, _normal, _triangle, Curve, EllipseCurve, ArcCurve, tmp, px, py, pz, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve, Curves, CurvePath, Path, Shape, Earcut, ShapeUtils, ExtrudeGeometry, WorldUVGenerator, ShapeGeometry, ShadowMaterial, MeshStandardMaterial, MeshPhysicalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshMatcapMaterial, LineDashedMaterial, AnimationUtils, Interpolant, CubicInterpolant, LinearInterpolant, DiscreteInterpolant, KeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack, NumberKeyframeTrack, QuaternionLinearInterpolant, QuaternionKeyframeTrack, StringKeyframeTrack, VectorKeyframeTrack, AnimationClip, Cache, LoadingManager, DefaultLoadingManager, Loader, loading, FileLoader, CompressedTextureLoader, ImageLoader, CubeTextureLoader, TextureLoader, Light, HemisphereLight, _projScreenMatrix$1, _lightPositionWorld$1, _lookTarget$1, LightShadow, SpotLightShadow, SpotLight, _projScreenMatrix, _lightPositionWorld, _lookTarget, PointLightShadow, PointLight, DirectionalLightShadow, DirectionalLight, AmbientLight, RectAreaLight, SphericalHarmonics3, LightProbe, LoaderUtils, InstancedBufferGeometry, ImageBitmapLoader, _context, AudioContext, AudioLoader, HemisphereLightProbe, AmbientLightProbe, Clock, Audio, AudioAnalyser, PropertyMixer, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, Composite, PropertyBinding, AnimationObjectGroup, AnimationAction, AnimationMixer, Uniform, InstancedInterleavedBuffer, GLBufferAttribute, _vector$4, Box2, _startP, _startEnd, Line3, _vector$2, _boneMatrix, _matrixWorldInv, SkeletonHelper, GridHelper, _floatView, _int32View;
  var init_three_module = __esm({
    "node_modules/three/build/three.module.js"() {
      REVISION = "137";
      CullFaceNone = 0;
      CullFaceBack = 1;
      CullFaceFront = 2;
      PCFShadowMap = 1;
      PCFSoftShadowMap = 2;
      VSMShadowMap = 3;
      FrontSide = 0;
      BackSide = 1;
      DoubleSide = 2;
      FlatShading = 1;
      NoBlending = 0;
      NormalBlending = 1;
      AdditiveBlending = 2;
      SubtractiveBlending = 3;
      MultiplyBlending = 4;
      CustomBlending = 5;
      AddEquation = 100;
      SubtractEquation = 101;
      ReverseSubtractEquation = 102;
      MinEquation = 103;
      MaxEquation = 104;
      ZeroFactor = 200;
      OneFactor = 201;
      SrcColorFactor = 202;
      OneMinusSrcColorFactor = 203;
      SrcAlphaFactor = 204;
      OneMinusSrcAlphaFactor = 205;
      DstAlphaFactor = 206;
      OneMinusDstAlphaFactor = 207;
      DstColorFactor = 208;
      OneMinusDstColorFactor = 209;
      SrcAlphaSaturateFactor = 210;
      NeverDepth = 0;
      AlwaysDepth = 1;
      LessDepth = 2;
      LessEqualDepth = 3;
      EqualDepth = 4;
      GreaterEqualDepth = 5;
      GreaterDepth = 6;
      NotEqualDepth = 7;
      MultiplyOperation = 0;
      MixOperation = 1;
      AddOperation = 2;
      NoToneMapping = 0;
      LinearToneMapping = 1;
      ReinhardToneMapping = 2;
      CineonToneMapping = 3;
      ACESFilmicToneMapping = 4;
      CustomToneMapping = 5;
      UVMapping = 300;
      CubeReflectionMapping = 301;
      CubeRefractionMapping = 302;
      EquirectangularReflectionMapping = 303;
      EquirectangularRefractionMapping = 304;
      CubeUVReflectionMapping = 306;
      CubeUVRefractionMapping = 307;
      RepeatWrapping = 1e3;
      ClampToEdgeWrapping = 1001;
      MirroredRepeatWrapping = 1002;
      NearestFilter = 1003;
      NearestMipmapNearestFilter = 1004;
      NearestMipmapLinearFilter = 1005;
      LinearFilter = 1006;
      LinearMipmapNearestFilter = 1007;
      LinearMipmapLinearFilter = 1008;
      UnsignedByteType = 1009;
      ByteType = 1010;
      ShortType = 1011;
      UnsignedShortType = 1012;
      IntType = 1013;
      UnsignedIntType = 1014;
      FloatType = 1015;
      HalfFloatType = 1016;
      UnsignedShort4444Type = 1017;
      UnsignedShort5551Type = 1018;
      UnsignedInt248Type = 1020;
      AlphaFormat = 1021;
      RGBFormat = 1022;
      RGBAFormat = 1023;
      LuminanceFormat = 1024;
      LuminanceAlphaFormat = 1025;
      DepthFormat = 1026;
      DepthStencilFormat = 1027;
      RedFormat = 1028;
      RedIntegerFormat = 1029;
      RGFormat = 1030;
      RGIntegerFormat = 1031;
      RGBAIntegerFormat = 1033;
      RGB_S3TC_DXT1_Format = 33776;
      RGBA_S3TC_DXT1_Format = 33777;
      RGBA_S3TC_DXT3_Format = 33778;
      RGBA_S3TC_DXT5_Format = 33779;
      RGB_PVRTC_4BPPV1_Format = 35840;
      RGB_PVRTC_2BPPV1_Format = 35841;
      RGBA_PVRTC_4BPPV1_Format = 35842;
      RGBA_PVRTC_2BPPV1_Format = 35843;
      RGB_ETC1_Format = 36196;
      RGB_ETC2_Format = 37492;
      RGBA_ETC2_EAC_Format = 37496;
      RGBA_ASTC_4x4_Format = 37808;
      RGBA_ASTC_5x4_Format = 37809;
      RGBA_ASTC_5x5_Format = 37810;
      RGBA_ASTC_6x5_Format = 37811;
      RGBA_ASTC_6x6_Format = 37812;
      RGBA_ASTC_8x5_Format = 37813;
      RGBA_ASTC_8x6_Format = 37814;
      RGBA_ASTC_8x8_Format = 37815;
      RGBA_ASTC_10x5_Format = 37816;
      RGBA_ASTC_10x6_Format = 37817;
      RGBA_ASTC_10x8_Format = 37818;
      RGBA_ASTC_10x10_Format = 37819;
      RGBA_ASTC_12x10_Format = 37820;
      RGBA_ASTC_12x12_Format = 37821;
      RGBA_BPTC_Format = 36492;
      LoopOnce = 2200;
      LoopRepeat = 2201;
      LoopPingPong = 2202;
      InterpolateDiscrete = 2300;
      InterpolateLinear = 2301;
      InterpolateSmooth = 2302;
      ZeroCurvatureEnding = 2400;
      ZeroSlopeEnding = 2401;
      WrapAroundEnding = 2402;
      NormalAnimationBlendMode = 2500;
      AdditiveAnimationBlendMode = 2501;
      TrianglesDrawMode = 0;
      TriangleStripDrawMode = 1;
      TriangleFanDrawMode = 2;
      LinearEncoding = 3e3;
      sRGBEncoding = 3001;
      BasicDepthPacking = 3200;
      RGBADepthPacking = 3201;
      TangentSpaceNormalMap = 0;
      ObjectSpaceNormalMap = 1;
      KeepStencilOp = 7680;
      AlwaysStencilFunc = 519;
      StaticDrawUsage = 35044;
      DynamicDrawUsage = 35048;
      GLSL3 = "300 es";
      _SRGBAFormat = 1035;
      EventDispatcher = class {
        addEventListener(type, listener) {
          if (this._listeners === void 0)
            this._listeners = {};
          const listeners = this._listeners;
          if (listeners[type] === void 0) {
            listeners[type] = [];
          }
          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }
        }
        hasEventListener(type, listener) {
          if (this._listeners === void 0)
            return false;
          const listeners = this._listeners;
          return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[type];
          if (listenerArray !== void 0) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
              listenerArray.splice(index, 1);
            }
          }
        }
        dispatchEvent(event) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[event.type];
          if (listenerArray !== void 0) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i2 = 0, l = array.length; i2 < l; i2++) {
              array[i2].call(this, event);
            }
            event.target = null;
          }
        }
      };
      _lut = [];
      for (let i2 = 0; i2 < 256; i2++) {
        _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
      }
      _seed = 1234567;
      DEG2RAD = Math.PI / 180;
      RAD2DEG = 180 / Math.PI;
      MathUtils = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        DEG2RAD,
        RAD2DEG,
        generateUUID,
        clamp,
        euclideanModulo,
        mapLinear,
        inverseLerp,
        lerp,
        damp,
        pingpong,
        smoothstep,
        smootherstep,
        randInt,
        randFloat,
        randFloatSpread,
        seededRandom,
        degToRad,
        radToDeg,
        isPowerOfTwo,
        ceilPowerOfTwo,
        floorPowerOfTwo,
        setQuaternionFromProperEuler
      });
      Vector2 = class {
        constructor(x = 0, y = 0) {
          this.x = x;
          this.y = y;
        }
        get width() {
          return this.x;
        }
        set width(value) {
          this.x = value;
        }
        get height() {
          return this.y;
        }
        set height(value) {
          this.y = value;
        }
        set(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6];
          this.y = e[1] * x + e[4] * y + e[7];
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y;
        }
        cross(v) {
          return this.x * v.y - this.y * v.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const angle = Math.atan2(-this.y, -this.x) + Math.PI;
          return angle;
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y;
          return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          return this;
        }
        rotateAround(center, angle) {
          const c = Math.cos(angle), s = Math.sin(angle);
          const x = this.x - center.x;
          const y = this.y - center.y;
          this.x = x * c - y * s + center.x;
          this.y = x * s + y * c + center.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
        }
      };
      Vector2.prototype.isVector2 = true;
      Matrix3 = class {
        constructor() {
          this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ];
          if (arguments.length > 0) {
            console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          const te = this.elements;
          te[0] = n11;
          te[1] = n21;
          te[2] = n31;
          te[3] = n12;
          te[4] = n22;
          te[5] = n32;
          te[6] = n13;
          te[7] = n23;
          te[8] = n33;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
          return this;
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(m) {
          const me = m.elements;
          this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
          return this;
        }
        multiply(m) {
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[3], a13 = ae[6];
          const a21 = ae[1], a22 = ae[4], a23 = ae[7];
          const a31 = ae[2], a32 = ae[5], a33 = ae[8];
          const b11 = be[0], b12 = be[3], b13 = be[6];
          const b21 = be[1], b22 = be[4], b23 = be[7];
          const b31 = be[2], b32 = be[5], b33 = be[8];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te[6] = a11 * b13 + a12 * b23 + a13 * b33;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te[7] = a21 * b13 + a22 * b23 + a23 * b33;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te[8] = a31 * b13 + a32 * b23 + a33 * b33;
          return this;
        }
        multiplyScalar(s) {
          const te = this.elements;
          te[0] *= s;
          te[3] *= s;
          te[6] *= s;
          te[1] *= s;
          te[4] *= s;
          te[7] *= s;
          te[2] *= s;
          te[5] *= s;
          te[8] *= s;
          return this;
        }
        determinant() {
          const te = this.elements;
          const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
          return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n31 * n23 - n33 * n21) * detInv;
          te[2] = (n32 * n21 - n31 * n22) * detInv;
          te[3] = t12 * detInv;
          te[4] = (n33 * n11 - n31 * n13) * detInv;
          te[5] = (n31 * n12 - n32 * n11) * detInv;
          te[6] = t13 * detInv;
          te[7] = (n21 * n13 - n23 * n11) * detInv;
          te[8] = (n22 * n11 - n21 * n12) * detInv;
          return this;
        }
        transpose() {
          let tmp3;
          const m = this.elements;
          tmp3 = m[1];
          m[1] = m[3];
          m[3] = tmp3;
          tmp3 = m[2];
          m[2] = m[6];
          m[6] = tmp3;
          tmp3 = m[5];
          m[5] = m[7];
          m[7] = tmp3;
          return this;
        }
        getNormalMatrix(matrix4) {
          return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r) {
          const m = this.elements;
          r[0] = m[0];
          r[1] = m[3];
          r[2] = m[6];
          r[3] = m[1];
          r[4] = m[4];
          r[5] = m[7];
          r[6] = m[2];
          r[7] = m[5];
          r[8] = m[8];
          return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
          const c = Math.cos(rotation);
          const s = Math.sin(rotation);
          this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
          return this;
        }
        scale(sx, sy) {
          const te = this.elements;
          te[0] *= sx;
          te[3] *= sx;
          te[6] *= sx;
          te[1] *= sy;
          te[4] *= sy;
          te[7] *= sy;
          return this;
        }
        rotate(theta) {
          const c = Math.cos(theta);
          const s = Math.sin(theta);
          const te = this.elements;
          const a11 = te[0], a12 = te[3], a13 = te[6];
          const a21 = te[1], a22 = te[4], a23 = te[7];
          te[0] = c * a11 + s * a21;
          te[3] = c * a12 + s * a22;
          te[6] = c * a13 + s * a23;
          te[1] = -s * a11 + c * a21;
          te[4] = -s * a12 + c * a22;
          te[7] = -s * a13 + c * a23;
          return this;
        }
        translate(tx, ty) {
          const te = this.elements;
          te[0] += tx * te[2];
          te[3] += tx * te[5];
          te[6] += tx * te[8];
          te[1] += ty * te[2];
          te[4] += ty * te[5];
          te[7] += ty * te[8];
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i2 = 0; i2 < 9; i2++) {
            if (te[i2] !== me[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          return array;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      };
      Matrix3.prototype.isMatrix3 = true;
      _colorKeywords = {
        "aliceblue": 15792383,
        "antiquewhite": 16444375,
        "aqua": 65535,
        "aquamarine": 8388564,
        "azure": 15794175,
        "beige": 16119260,
        "bisque": 16770244,
        "black": 0,
        "blanchedalmond": 16772045,
        "blue": 255,
        "blueviolet": 9055202,
        "brown": 10824234,
        "burlywood": 14596231,
        "cadetblue": 6266528,
        "chartreuse": 8388352,
        "chocolate": 13789470,
        "coral": 16744272,
        "cornflowerblue": 6591981,
        "cornsilk": 16775388,
        "crimson": 14423100,
        "cyan": 65535,
        "darkblue": 139,
        "darkcyan": 35723,
        "darkgoldenrod": 12092939,
        "darkgray": 11119017,
        "darkgreen": 25600,
        "darkgrey": 11119017,
        "darkkhaki": 12433259,
        "darkmagenta": 9109643,
        "darkolivegreen": 5597999,
        "darkorange": 16747520,
        "darkorchid": 10040012,
        "darkred": 9109504,
        "darksalmon": 15308410,
        "darkseagreen": 9419919,
        "darkslateblue": 4734347,
        "darkslategray": 3100495,
        "darkslategrey": 3100495,
        "darkturquoise": 52945,
        "darkviolet": 9699539,
        "deeppink": 16716947,
        "deepskyblue": 49151,
        "dimgray": 6908265,
        "dimgrey": 6908265,
        "dodgerblue": 2003199,
        "firebrick": 11674146,
        "floralwhite": 16775920,
        "forestgreen": 2263842,
        "fuchsia": 16711935,
        "gainsboro": 14474460,
        "ghostwhite": 16316671,
        "gold": 16766720,
        "goldenrod": 14329120,
        "gray": 8421504,
        "green": 32768,
        "greenyellow": 11403055,
        "grey": 8421504,
        "honeydew": 15794160,
        "hotpink": 16738740,
        "indianred": 13458524,
        "indigo": 4915330,
        "ivory": 16777200,
        "khaki": 15787660,
        "lavender": 15132410,
        "lavenderblush": 16773365,
        "lawngreen": 8190976,
        "lemonchiffon": 16775885,
        "lightblue": 11393254,
        "lightcoral": 15761536,
        "lightcyan": 14745599,
        "lightgoldenrodyellow": 16448210,
        "lightgray": 13882323,
        "lightgreen": 9498256,
        "lightgrey": 13882323,
        "lightpink": 16758465,
        "lightsalmon": 16752762,
        "lightseagreen": 2142890,
        "lightskyblue": 8900346,
        "lightslategray": 7833753,
        "lightslategrey": 7833753,
        "lightsteelblue": 11584734,
        "lightyellow": 16777184,
        "lime": 65280,
        "limegreen": 3329330,
        "linen": 16445670,
        "magenta": 16711935,
        "maroon": 8388608,
        "mediumaquamarine": 6737322,
        "mediumblue": 205,
        "mediumorchid": 12211667,
        "mediumpurple": 9662683,
        "mediumseagreen": 3978097,
        "mediumslateblue": 8087790,
        "mediumspringgreen": 64154,
        "mediumturquoise": 4772300,
        "mediumvioletred": 13047173,
        "midnightblue": 1644912,
        "mintcream": 16121850,
        "mistyrose": 16770273,
        "moccasin": 16770229,
        "navajowhite": 16768685,
        "navy": 128,
        "oldlace": 16643558,
        "olive": 8421376,
        "olivedrab": 7048739,
        "orange": 16753920,
        "orangered": 16729344,
        "orchid": 14315734,
        "palegoldenrod": 15657130,
        "palegreen": 10025880,
        "paleturquoise": 11529966,
        "palevioletred": 14381203,
        "papayawhip": 16773077,
        "peachpuff": 16767673,
        "peru": 13468991,
        "pink": 16761035,
        "plum": 14524637,
        "powderblue": 11591910,
        "purple": 8388736,
        "rebeccapurple": 6697881,
        "red": 16711680,
        "rosybrown": 12357519,
        "royalblue": 4286945,
        "saddlebrown": 9127187,
        "salmon": 16416882,
        "sandybrown": 16032864,
        "seagreen": 3050327,
        "seashell": 16774638,
        "sienna": 10506797,
        "silver": 12632256,
        "skyblue": 8900331,
        "slateblue": 6970061,
        "slategray": 7372944,
        "slategrey": 7372944,
        "snow": 16775930,
        "springgreen": 65407,
        "steelblue": 4620980,
        "tan": 13808780,
        "teal": 32896,
        "thistle": 14204888,
        "tomato": 16737095,
        "turquoise": 4251856,
        "violet": 15631086,
        "wheat": 16113331,
        "white": 16777215,
        "whitesmoke": 16119285,
        "yellow": 16776960,
        "yellowgreen": 10145074
      };
      _hslA = { h: 0, s: 0, l: 0 };
      _hslB = { h: 0, s: 0, l: 0 };
      Color = class {
        constructor(r, g, b) {
          if (g === void 0 && b === void 0) {
            return this.set(r);
          }
          return this.setRGB(r, g, b);
        }
        set(value) {
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === "number") {
            this.setHex(value);
          } else if (typeof value === "string") {
            this.setStyle(value);
          }
          return this;
        }
        setScalar(scalar) {
          this.r = scalar;
          this.g = scalar;
          this.b = scalar;
          return this;
        }
        setHex(hex) {
          hex = Math.floor(hex);
          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;
          return this;
        }
        setRGB(r, g, b) {
          this.r = r;
          this.g = g;
          this.b = b;
          return this;
        }
        setHSL(h, s, l) {
          h = euclideanModulo(h, 1);
          s = clamp(s, 0, 1);
          l = clamp(l, 0, 1);
          if (s === 0) {
            this.r = this.g = this.b = l;
          } else {
            const p2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p2;
            this.r = hue2rgb(q, p2, h + 1 / 3);
            this.g = hue2rgb(q, p2, h);
            this.b = hue2rgb(q, p2, h - 1 / 3);
          }
          return this;
        }
        setStyle(style) {
          function handleAlpha(string) {
            if (string === void 0)
              return;
            if (parseFloat(string) < 1) {
              console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
          }
          let m;
          if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            let color;
            const name = m[1];
            const components = m[2];
            switch (name) {
              case "rgb":
              case "rgba":
                if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                  this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                  this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                  handleAlpha(color[4]);
                  return this;
                }
                if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                  this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                  this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                  handleAlpha(color[4]);
                  return this;
                }
                break;
              case "hsl":
              case "hsla":
                if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  const h = parseFloat(color[1]) / 360;
                  const s = parseInt(color[2], 10) / 100;
                  const l = parseInt(color[3], 10) / 100;
                  handleAlpha(color[4]);
                  return this.setHSL(h, s, l);
                }
                break;
            }
          } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
              this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
              this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
              return this;
            } else if (size === 6) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
              this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
              this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
              return this;
            }
          }
          if (style && style.length > 0) {
            return this.setColorName(style);
          }
          return this;
        }
        setColorName(style) {
          const hex = _colorKeywords[style.toLowerCase()];
          if (hex !== void 0) {
            this.setHex(hex);
          } else {
            console.warn("THREE.Color: Unknown color " + style);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          return this;
        }
        copySRGBToLinear(color) {
          this.r = SRGBToLinear(color.r);
          this.g = SRGBToLinear(color.g);
          this.b = SRGBToLinear(color.b);
          return this;
        }
        copyLinearToSRGB(color) {
          this.r = LinearToSRGB(color.r);
          this.g = LinearToSRGB(color.g);
          this.b = LinearToSRGB(color.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex() {
          return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(target) {
          const r = this.r, g = this.g, b = this.b;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let hue, saturation;
          const lightness = (min + max) / 2;
          if (min === max) {
            hue = 0;
            saturation = 0;
          } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
              case r:
                hue = (g - b) / delta + (g < b ? 6 : 0);
                break;
              case g:
                hue = (b - r) / delta + 2;
                break;
              case b:
                hue = (r - g) / delta + 4;
                break;
            }
            hue /= 6;
          }
          target.h = hue;
          target.s = saturation;
          target.l = lightness;
          return target;
        }
        getStyle() {
          return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
        }
        offsetHSL(h, s, l) {
          this.getHSL(_hslA);
          _hslA.h += h;
          _hslA.s += s;
          _hslA.l += l;
          this.setHSL(_hslA.h, _hslA.s, _hslA.l);
          return this;
        }
        add(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          return this;
        }
        addColors(color1, color2) {
          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;
          return this;
        }
        addScalar(s) {
          this.r += s;
          this.g += s;
          this.b += s;
          return this;
        }
        sub(color) {
          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);
          return this;
        }
        multiply(color) {
          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;
          return this;
        }
        multiplyScalar(s) {
          this.r *= s;
          this.g *= s;
          this.b *= s;
          return this;
        }
        lerp(color, alpha) {
          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;
          return this;
        }
        lerpColors(color1, color2, alpha) {
          this.r = color1.r + (color2.r - color1.r) * alpha;
          this.g = color1.g + (color2.g - color1.g) * alpha;
          this.b = color1.b + (color2.b - color1.b) * alpha;
          return this;
        }
        lerpHSL(color, alpha) {
          this.getHSL(_hslA);
          color.getHSL(_hslB);
          const h = lerp(_hslA.h, _hslB.h, alpha);
          const s = lerp(_hslA.s, _hslB.s, alpha);
          const l = lerp(_hslA.l, _hslB.l, alpha);
          this.setHSL(h, s, l);
          return this;
        }
        equals(c) {
          return c.r === this.r && c.g === this.g && c.b === this.b;
        }
        fromArray(array, offset = 0) {
          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.r = attribute.getX(index);
          this.g = attribute.getY(index);
          this.b = attribute.getZ(index);
          if (attribute.normalized === true) {
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
          }
          return this;
        }
        toJSON() {
          return this.getHex();
        }
      };
      Color.NAMES = _colorKeywords;
      Color.prototype.isColor = true;
      Color.prototype.r = 1;
      Color.prototype.g = 1;
      Color.prototype.b = 1;
      ImageUtils = class {
        static getDataURL(image) {
          if (/^data:/i.test(image.src)) {
            return image.src;
          }
          if (typeof HTMLCanvasElement == "undefined") {
            return image.src;
          }
          let canvas;
          if (image instanceof HTMLCanvasElement) {
            canvas = image;
          } else {
            if (_canvas === void 0)
              _canvas = createElementNS("canvas");
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext("2d");
            if (image instanceof ImageData) {
              context.putImageData(image, 0, 0);
            } else {
              context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas = _canvas;
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas.toDataURL("image/jpeg", 0.6);
          } else {
            return canvas.toDataURL("image/png");
          }
        }
        static sRGBToLinear(image) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            const canvas = createElementNS("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height);
            const imageData = context.getImageData(0, 0, image.width, image.height);
            const data = imageData.data;
            for (let i2 = 0; i2 < data.length; i2++) {
              data[i2] = SRGBToLinear(data[i2] / 255) * 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
          } else if (image.data) {
            const data = image.data.slice(0);
            for (let i2 = 0; i2 < data.length; i2++) {
              if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
              } else {
                data[i2] = SRGBToLinear(data[i2]);
              }
            }
            return {
              data,
              width: image.width,
              height: image.height
            };
          } else {
            console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
            return image;
          }
        }
      };
      textureId = 0;
      Texture = class extends EventDispatcher {
        constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
          super();
          Object.defineProperty(this, "id", { value: textureId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.image = image;
          this.mipmaps = [];
          this.mapping = mapping;
          this.wrapS = wrapS;
          this.wrapT = wrapT;
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.anisotropy = anisotropy;
          this.format = format;
          this.internalFormat = null;
          this.type = type;
          this.offset = new Vector2(0, 0);
          this.repeat = new Vector2(1, 1);
          this.center = new Vector2(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Matrix3();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          this.encoding = encoding;
          this.userData = {};
          this.version = 0;
          this.onUpdate = null;
          this.isRenderTargetTexture = false;
          this.needsPMREMUpdate = false;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.image = source.image;
          this.mipmaps = source.mipmaps.slice(0);
          this.mapping = source.mapping;
          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;
          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;
          this.anisotropy = source.anisotropy;
          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;
          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);
          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.encoding = source.encoding;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.textures[this.uuid] !== void 0) {
            return meta.textures[this.uuid];
          }
          const output = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (this.image !== void 0) {
            const image = this.image;
            if (image.uuid === void 0) {
              image.uuid = generateUUID();
            }
            if (!isRootObject && meta.images[image.uuid] === void 0) {
              let url;
              if (Array.isArray(image)) {
                url = [];
                for (let i2 = 0, l = image.length; i2 < l; i2++) {
                  if (image[i2].isDataTexture) {
                    url.push(serializeImage(image[i2].image));
                  } else {
                    url.push(serializeImage(image[i2]));
                  }
                }
              } else {
                url = serializeImage(image);
              }
              meta.images[image.uuid] = {
                uuid: image.uuid,
                url
              };
            }
            output.image = image.uuid;
          }
          if (JSON.stringify(this.userData) !== "{}")
            output.userData = this.userData;
          if (!isRootObject) {
            meta.textures[this.uuid] = output;
          }
          return output;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(uv) {
          if (this.mapping !== UVMapping)
            return uv;
          uv.applyMatrix3(this.matrix);
          if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
              case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
              case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                  uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                  uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
          }
          if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
              case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
              case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                  uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                  uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
          }
          if (this.flipY) {
            uv.y = 1 - uv.y;
          }
          return uv;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      };
      Texture.DEFAULT_IMAGE = void 0;
      Texture.DEFAULT_MAPPING = UVMapping;
      Texture.prototype.isTexture = true;
      Vector4 = class {
        constructor(x = 0, y = 0, z = 0, w = 1) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }
        get width() {
          return this.z;
        }
        set width(value) {
          this.z = value;
        }
        get height() {
          return this.w;
        }
        set height(value) {
          this.w = value;
        }
        set(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setW(w) {
          this.w = w;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            case 3:
              this.w = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          this.w = v.w !== void 0 ? v.w : 1;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          this.w += v.w;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          this.z += s;
          this.w += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          this.w = a.w + b.w;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;
          this.w += v.w * s;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          this.w -= v.w;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          this.z -= s;
          this.w -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          this.w = a.w - b.w;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          this.w *= v.w;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z = this.z, w = this.w;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
          this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
          this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
          this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q) {
          this.w = 2 * Math.acos(q.w);
          const s = Math.sqrt(1 - q.w * q.w);
          if (s < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(m) {
          let angle, x, y, z;
          const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
          if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
              this.set(1, 0, 0, 0);
              return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
              if (xx < epsilon) {
                x = 0;
                y = 0.707106781;
                z = 0.707106781;
              } else {
                x = Math.sqrt(xx);
                y = xy / x;
                z = xz / x;
              }
            } else if (yy > zz) {
              if (yy < epsilon) {
                x = 0.707106781;
                y = 0;
                z = 0.707106781;
              } else {
                y = Math.sqrt(yy);
                x = xy / y;
                z = yz / y;
              }
            } else {
              if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
              } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
              }
            }
            this.set(x, y, z, angle);
            return this;
          }
          let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
          if (Math.abs(s) < 1e-3)
            s = 1;
          this.x = (m32 - m23) / s;
          this.y = (m13 - m31) / s;
          this.z = (m21 - m12) / s;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          this.w = Math.min(this.w, v.w);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          this.w = Math.max(this.w, v.w);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          this.w = Math.max(min.w, Math.min(max.w, this.w));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          this.w += (v.w - this.w) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          this.w = v1.w + (v2.w - v1.w) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          this.w = attribute.getW(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
          yield this.w;
        }
      };
      Vector4.prototype.isVector4 = true;
      WebGLRenderTarget = class extends EventDispatcher {
        constructor(width, height, options = {}) {
          super();
          this.width = width;
          this.height = height;
          this.depth = 1;
          this.scissor = new Vector4(0, 0, width, height);
          this.scissorTest = false;
          this.viewport = new Vector4(0, 0, width, height);
          this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.image = { width, height, depth: 1 };
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
          this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
          this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
          this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
        }
        setTexture(texture) {
          texture.image = {
            width: this.width,
            height: this.height,
            depth: this.depth
          };
          this.texture = texture;
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.copy(source.viewport);
          this.texture = source.texture.clone();
          this.texture.image = Object.assign({}, source.texture.image);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
      WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
        constructor(width, height, count) {
          super(width, height);
          const texture = this.texture;
          this.texture = [];
          for (let i2 = 0; i2 < count; i2++) {
            this.texture[i2] = texture.clone();
          }
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
              this.texture[i2].image.width = width;
              this.texture[i2].image.height = height;
              this.texture[i2].image.depth = depth;
            }
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
          return this;
        }
        copy(source) {
          this.dispose();
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.set(0, 0, this.width, this.height);
          this.scissor.set(0, 0, this.width, this.height);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          this.texture.length = 0;
          for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
            this.texture[i2] = source.texture[i2].clone();
          }
          return this;
        }
      };
      WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
      WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
        constructor(width, height, options = {}) {
          super(width, height, options);
          this.samples = 4;
          this.ignoreDepthForMultisampleCopy = options.ignoreDepth !== void 0 ? options.ignoreDepth : true;
          this.useRenderToTexture = options.useRenderToTexture !== void 0 ? options.useRenderToTexture : false;
          this.useRenderbuffer = this.useRenderToTexture === false;
        }
        copy(source) {
          super.copy.call(this, source);
          this.samples = source.samples;
          this.useRenderToTexture = source.useRenderToTexture;
          this.useRenderbuffer = source.useRenderbuffer;
          return this;
        }
      };
      WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
      Quaternion = class {
        constructor(x = 0, y = 0, z = 0, w = 1) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._w = w;
        }
        static slerp(qa, qb, qm, t) {
          console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
          return qm.slerpQuaternions(qa, qb, t);
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
          let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
          if (t === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
          }
          if (t === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
          }
          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s = 1 - t;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
              const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
              s = Math.sin(s * len) / sin;
              t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            if (s === 1 - t) {
              const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
              x0 *= f;
              y0 *= f;
              z0 *= f;
              w0 *= f;
            }
          }
          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];
          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
          return dst;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(value) {
          this._w = value;
          this._onChangeCallback();
        }
        set(x, y, z, w) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._w = w;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(euler, update) {
          if (!(euler && euler.isEuler)) {
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
          const cos = Math.cos;
          const sin = Math.sin;
          const c1 = cos(x / 2);
          const c2 = cos(y / 2);
          const c3 = cos(z / 2);
          const s1 = sin(x / 2);
          const s2 = sin(y / 2);
          const s3 = sin(z / 2);
          switch (order) {
            case "XYZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "YXZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "ZXY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "ZYX":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "YZX":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "XZY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
          }
          if (update !== false)
            this._onChangeCallback();
          return this;
        }
        setFromAxisAngle(axis, angle) {
          const halfAngle = angle / 2, s = Math.sin(halfAngle);
          this._x = axis.x * s;
          this._y = axis.y * s;
          this._z = axis.z * s;
          this._w = Math.cos(halfAngle);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m) {
          const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
          if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
          } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
          } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
          } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(vFrom, vTo) {
          let r = vFrom.dot(vTo) + 1;
          if (r < Number.EPSILON) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              this._x = -vFrom.y;
              this._y = vFrom.x;
              this._z = 0;
              this._w = r;
            } else {
              this._x = 0;
              this._y = -vFrom.z;
              this._z = vFrom.y;
              this._w = r;
            }
          } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
          }
          return this.normalize();
        }
        angleTo(q) {
          return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
        }
        rotateTowards(q, step) {
          const angle = this.angleTo(q);
          if (angle === 0)
            return this;
          const t = Math.min(1, step / angle);
          this.slerp(q, t);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(v) {
          return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let l = this.length();
          if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(q, p2) {
          if (p2 !== void 0) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p2);
          }
          return this.multiplyQuaternions(this, q);
        }
        premultiply(q) {
          return this.multiplyQuaternions(q, this);
        }
        multiplyQuaternions(a, b) {
          const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
          const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          this._onChangeCallback();
          return this;
        }
        slerp(qb, t) {
          if (t === 0)
            return this;
          if (t === 1)
            return this.copy(qb);
          const x = this._x, y = this._y, z = this._z, w = this._w;
          let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
          if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
          }
          const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
          if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
          this._w = w * ratioA + this._w * ratioB;
          this._x = x * ratioA + this._x * ratioB;
          this._y = y * ratioA + this._y * ratioB;
          this._z = z * ratioA + this._z * ratioB;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(qa, qb, t) {
          return this.copy(qa).slerp(qb, t);
        }
        random() {
          const u1 = Math.random();
          const sqrt1u1 = Math.sqrt(1 - u1);
          const sqrtu1 = Math.sqrt(u1);
          const u2 = 2 * Math.PI * Math.random();
          const u3 = 2 * Math.PI * Math.random();
          return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
        }
        equals(quaternion) {
          return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        }
        fromArray(array, offset = 0) {
          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this._x = attribute.getX(index);
          this._y = attribute.getY(index);
          this._z = attribute.getZ(index);
          this._w = attribute.getW(index);
          return this;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      };
      Quaternion.prototype.isQuaternion = true;
      Vector3 = class {
        constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        set(x, y, z) {
          if (z === void 0)
            z = this.z;
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          this.z += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          this.z -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          return this;
        }
        multiply(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
          }
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiplyVectors(a, b) {
          this.x = a.x * b.x;
          this.y = a.y * b.y;
          this.z = a.z * b.z;
          return this;
        }
        applyEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle) {
          return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6] * z;
          this.y = e[1] * x + e[4] * y + e[7] * z;
          this.z = e[2] * x + e[5] * y + e[8] * z;
          return this;
        }
        applyNormalMatrix(m) {
          return this.applyMatrix3(m).normalize();
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
          this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
          this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
          this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
          return this;
        }
        applyQuaternion(q) {
          const x = this.x, y = this.y, z = this.z;
          const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
          const ix = qw * x + qy * z - qz * y;
          const iy = qw * y + qz * x - qx * z;
          const iz = qw * z + qx * y - qy * x;
          const iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        }
        project(camera) {
          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z;
          this.y = e[1] * x + e[5] * y + e[9] * z;
          this.z = e[2] * x + e[6] * y + e[10] * z;
          return this.normalize();
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          return this;
        }
        cross(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
          }
          return this.crossVectors(this, v);
        }
        crossVectors(a, b) {
          const ax = a.x, ay = a.y, az = a.z;
          const bx = b.x, by = b.y, bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        projectOnVector(v) {
          const denominator = v.lengthSq();
          if (denominator === 0)
            return this.set(0, 0, 0);
          const scalar = v.dot(this) / denominator;
          return this.copy(v).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
          _vector$c.copy(this).projectOnVector(planeNormal);
          return this.sub(_vector$c);
        }
        reflect(normal) {
          return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v) {
          const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v) / denominator;
          return Math.acos(clamp(theta, -1, 1));
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
          return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        }
        setFromSpherical(s) {
          return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
          const sinPhiRadius = Math.sin(phi) * radius;
          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);
          return this;
        }
        setFromCylindrical(c) {
          return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
        }
        setFromCylindricalCoords(radius, theta, y) {
          this.x = radius * Math.sin(theta);
          this.y = y;
          this.z = radius * Math.cos(theta);
          return this;
        }
        setFromMatrixPosition(m) {
          const e = m.elements;
          this.x = e[12];
          this.y = e[13];
          this.z = e[14];
          return this;
        }
        setFromMatrixScale(m) {
          const sx = this.setFromMatrixColumn(m, 0).length();
          const sy = this.setFromMatrixColumn(m, 1).length();
          const sz = this.setFromMatrixColumn(m, 2).length();
          this.x = sx;
          this.y = sy;
          this.z = sz;
          return this;
        }
        setFromMatrixColumn(m, index) {
          return this.fromArray(m.elements, index * 4);
        }
        setFromMatrix3Column(m, index) {
          return this.fromArray(m.elements, index * 3);
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
        randomDirection() {
          const u = (Math.random() - 0.5) * 2;
          const t = Math.random() * Math.PI * 2;
          const f = Math.sqrt(1 - u ** 2);
          this.x = f * Math.cos(t);
          this.y = f * Math.sin(t);
          this.z = u;
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
        }
      };
      Vector3.prototype.isVector3 = true;
      _vector$c = /* @__PURE__ */ new Vector3();
      _quaternion$4 = /* @__PURE__ */ new Quaternion();
      Box3 = class {
        constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromArray(array) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
            const x = array[i2];
            const y = array[i2 + 1];
            const z = array[i2 + 2];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromBufferAttribute(attribute) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l = attribute.count; i2 < l; i2++) {
            const x = attribute.getX(i2);
            const y = attribute.getY(i2);
            const z = attribute.getZ(i2);
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        setFromObject(object, precise = false) {
          this.makeEmpty();
          return this.expandByObject(object, precise);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        expandByObject(object, precise = false) {
          object.updateWorldMatrix(false, false);
          const geometry = object.geometry;
          if (geometry !== void 0) {
            if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
              const position = geometry.attributes.position;
              for (let i2 = 0, l = position.count; i2 < l; i2++) {
                _vector$b.fromBufferAttribute(position, i2).applyMatrix4(object.matrixWorld);
                this.expandByPoint(_vector$b);
              }
            } else {
              if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
              }
              _box$3.copy(geometry.boundingBox);
              _box$3.applyMatrix4(object.matrixWorld);
              this.union(_box$3);
            }
          }
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            this.expandByObject(children[i2], precise);
          }
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
          this.clampPoint(sphere.center, _vector$b);
          return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        }
        intersectsPlane(plane) {
          let min, max;
          if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
          } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
          } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
          } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
          }
          return min <= -plane.constant && max >= -plane.constant;
        }
        intersectsTriangle(triangle) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(_center);
          _extents.subVectors(this.max, _center);
          _v0$2.subVectors(triangle.a, _center);
          _v1$7.subVectors(triangle.b, _center);
          _v2$3.subVectors(triangle.c, _center);
          _f0.subVectors(_v1$7, _v0$2);
          _f1.subVectors(_v2$3, _v1$7);
          _f2.subVectors(_v0$2, _v2$3);
          let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
          ];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
            return false;
          }
          _triangleNormal.crossVectors(_f0, _f1);
          axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
          return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        getBoundingSphere(target) {
          this.getCenter(target.center);
          target.radius = this.getSize(_vector$b).length() * 0.5;
          return target;
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          if (this.isEmpty())
            this.makeEmpty();
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        applyMatrix4(matrix) {
          if (this.isEmpty())
            return this;
          _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.setFromPoints(_points);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      Box3.prototype.isBox3 = true;
      _points = [
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3()
      ];
      _vector$b = /* @__PURE__ */ new Vector3();
      _box$3 = /* @__PURE__ */ new Box3();
      _v0$2 = /* @__PURE__ */ new Vector3();
      _v1$7 = /* @__PURE__ */ new Vector3();
      _v2$3 = /* @__PURE__ */ new Vector3();
      _f0 = /* @__PURE__ */ new Vector3();
      _f1 = /* @__PURE__ */ new Vector3();
      _f2 = /* @__PURE__ */ new Vector3();
      _center = /* @__PURE__ */ new Vector3();
      _extents = /* @__PURE__ */ new Vector3();
      _triangleNormal = /* @__PURE__ */ new Vector3();
      _testAxis = /* @__PURE__ */ new Vector3();
      _box$2 = /* @__PURE__ */ new Box3();
      _v1$6 = /* @__PURE__ */ new Vector3();
      _toFarthestPoint = /* @__PURE__ */ new Vector3();
      _toPoint = /* @__PURE__ */ new Vector3();
      Sphere = class {
        constructor(center = new Vector3(), radius = -1) {
          this.center = center;
          this.radius = radius;
        }
        set(center, radius) {
          this.center.copy(center);
          this.radius = radius;
          return this;
        }
        setFromPoints(points, optionalCenter) {
          const center = this.center;
          if (optionalCenter !== void 0) {
            center.copy(optionalCenter);
          } else {
            _box$2.setFromPoints(points).getCenter(center);
          }
          let maxRadiusSq = 0;
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        }
        copy(sphere) {
          this.center.copy(sphere.center);
          this.radius = sphere.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(point) {
          return point.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(point) {
          return point.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(sphere) {
          const radiusSum = this.radius + sphere.radius;
          return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        }
        intersectsBox(box) {
          return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
          const deltaLengthSq = this.center.distanceToSquared(point);
          target.copy(point);
          if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
          }
          return target;
        }
        getBoundingBox(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
            return target;
          }
          target.set(this.center, this.center);
          target.expandByScalar(this.radius);
          return target;
        }
        applyMatrix4(matrix) {
          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();
          return this;
        }
        translate(offset) {
          this.center.add(offset);
          return this;
        }
        expandByPoint(point) {
          _toPoint.subVectors(point, this.center);
          const lengthSq = _toPoint.lengthSq();
          if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
          }
          return this;
        }
        union(sphere) {
          if (this.center.equals(sphere.center) === true) {
            _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
          } else {
            _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
          }
          this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
          this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
          return this;
        }
        equals(sphere) {
          return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _vector$a = /* @__PURE__ */ new Vector3();
      _segCenter = /* @__PURE__ */ new Vector3();
      _segDir = /* @__PURE__ */ new Vector3();
      _diff = /* @__PURE__ */ new Vector3();
      _edge1 = /* @__PURE__ */ new Vector3();
      _edge2 = /* @__PURE__ */ new Vector3();
      _normal$1 = /* @__PURE__ */ new Vector3();
      Ray = class {
        constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
          this.origin = origin;
          this.direction = direction;
        }
        set(origin, direction) {
          this.origin.copy(origin);
          this.direction.copy(direction);
          return this;
        }
        copy(ray) {
          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);
          return this;
        }
        at(t, target) {
          return target.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(v) {
          this.direction.copy(v).sub(this.origin).normalize();
          return this;
        }
        recast(t) {
          this.origin.copy(this.at(t, _vector$a));
          return this;
        }
        closestPointToPoint(point, target) {
          target.subVectors(point, this.origin);
          const directionDistance = target.dot(this.direction);
          if (directionDistance < 0) {
            return target.copy(this.origin);
          }
          return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        }
        distanceToPoint(point) {
          return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
          const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return _vector$a.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir.copy(v1).sub(v0).normalize();
          _diff.copy(this.origin).sub(_segCenter);
          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir);
          const b0 = _diff.dot(this.direction);
          const b1 = -_diff.dot(_segDir);
          const c = _diff.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  const invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
          }
          return sqrDist;
        }
        intersectSphere(sphere, target) {
          _vector$a.subVectors(sphere.center, this.origin);
          const tca = _vector$a.dot(this.direction);
          const d2 = _vector$a.dot(_vector$a) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          const thc = Math.sqrt(radius2 - d2);
          const t0 = tca - thc;
          const t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, target);
          return this.at(t0, target);
        }
        intersectsSphere(sphere) {
          return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        }
        distanceToPlane(plane) {
          const denominator = plane.normal.dot(this.direction);
          if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
              return 0;
            }
            return null;
          }
          const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
          return t >= 0 ? t : null;
        }
        intersectPlane(plane, target) {
          const t = this.distanceToPlane(plane);
          if (t === null) {
            return null;
          }
          return this.at(t, target);
        }
        intersectsPlane(plane) {
          const distToPoint = plane.distanceToPoint(this.origin);
          if (distToPoint === 0) {
            return true;
          }
          const denominator = plane.normal.dot(this.direction);
          if (denominator * distToPoint < 0) {
            return true;
          }
          return false;
        }
        intersectBox(box, target) {
          let tmin, tmax, tymin, tymax, tzmin, tzmax;
          const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
          const origin = this.origin;
          if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
          } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
          }
          if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
          } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
          }
          if (tmin > tymax || tymin > tmax)
            return null;
          if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
          if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
          if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
          } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
          }
          if (tmin > tzmax || tzmin > tmax)
            return null;
          if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
          if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
          if (tmax < 0)
            return null;
          return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
          return this.intersectBox(box, _vector$a) !== null;
        }
        intersectTriangle(a, b, c, backfaceCulling, target) {
          _edge1.subVectors(b, a);
          _edge2.subVectors(c, a);
          _normal$1.crossVectors(_edge1, _edge2);
          let DdN = this.direction.dot(_normal$1);
          let sign2;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign2 = 1;
          } else if (DdN < 0) {
            sign2 = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          _diff.subVectors(this.origin, a);
          const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          const QdN = -sign2 * _diff.dot(_normal$1);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);
          return this;
        }
        equals(ray) {
          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Matrix4 = class {
        constructor() {
          this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ];
          if (arguments.length > 0) {
            console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          const te = this.elements;
          te[0] = n11;
          te[4] = n12;
          te[8] = n13;
          te[12] = n14;
          te[1] = n21;
          te[5] = n22;
          te[9] = n23;
          te[13] = n24;
          te[2] = n31;
          te[6] = n32;
          te[10] = n33;
          te[14] = n34;
          te[3] = n41;
          te[7] = n42;
          te[11] = n43;
          te[15] = n44;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        clone() {
          return new Matrix4().fromArray(this.elements);
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          te[9] = me[9];
          te[10] = me[10];
          te[11] = me[11];
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          te[15] = me[15];
          return this;
        }
        copyPosition(m) {
          const te = this.elements, me = m.elements;
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          return this;
        }
        setFromMatrix3(m) {
          const me = m.elements;
          this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
          this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
          return this;
        }
        extractRotation(m) {
          const te = this.elements;
          const me = m.elements;
          const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
          const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
          const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[3] = 0;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[7] = 0;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          }
          const te = this.elements;
          const x = euler.x, y = euler.y, z = euler.z;
          const a = Math.cos(x), b = Math.sin(x);
          const c = Math.cos(y), d = Math.sin(y);
          const e = Math.cos(z), f = Math.sin(z);
          if (euler.order === "XYZ") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
          } else if (euler.order === "YXZ") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
          } else if (euler.order === "ZXY") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
          } else if (euler.order === "ZYX") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
          } else if (euler.order === "YZX") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
          } else if (euler.order === "XZY") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
          }
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(q) {
          return this.compose(_zero, q, _one);
        }
        lookAt(eye, target, up) {
          const te = this.elements;
          _z.subVectors(eye, target);
          if (_z.lengthSq() === 0) {
            _z.z = 1;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
          if (_x.lengthSq() === 0) {
            if (Math.abs(up.z) === 1) {
              _z.x += 1e-4;
            } else {
              _z.z += 1e-4;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
          }
          _x.normalize();
          _y.crossVectors(_z, _x);
          te[0] = _x.x;
          te[4] = _y.x;
          te[8] = _z.x;
          te[1] = _x.y;
          te[5] = _y.y;
          te[9] = _z.y;
          te[2] = _x.z;
          te[6] = _y.z;
          te[10] = _z.z;
          return this;
        }
        multiply(m, n) {
          if (n !== void 0) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m, n);
          }
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
          const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
          const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
          const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
          const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
          const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
          const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
          const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
          te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
          return this;
        }
        multiplyScalar(s) {
          const te = this.elements;
          te[0] *= s;
          te[4] *= s;
          te[8] *= s;
          te[12] *= s;
          te[1] *= s;
          te[5] *= s;
          te[9] *= s;
          te[13] *= s;
          te[2] *= s;
          te[6] *= s;
          te[10] *= s;
          te[14] *= s;
          te[3] *= s;
          te[7] *= s;
          te[11] *= s;
          te[15] *= s;
          return this;
        }
        determinant() {
          const te = this.elements;
          const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
          const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
          const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
          const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
          return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        }
        transpose() {
          const te = this.elements;
          let tmp3;
          tmp3 = te[1];
          te[1] = te[4];
          te[4] = tmp3;
          tmp3 = te[2];
          te[2] = te[8];
          te[8] = tmp3;
          tmp3 = te[6];
          te[6] = te[9];
          te[9] = tmp3;
          tmp3 = te[3];
          te[3] = te[12];
          te[12] = tmp3;
          tmp3 = te[7];
          te[7] = te[13];
          te[13] = tmp3;
          tmp3 = te[11];
          te[11] = te[14];
          te[14] = tmp3;
          return this;
        }
        setPosition(x, y, z) {
          const te = this.elements;
          if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
          } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
          }
          return this;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
          te[4] = t12 * detInv;
          te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
          te[8] = t13 * detInv;
          te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
          te[12] = t14 * detInv;
          te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
          return this;
        }
        scale(v) {
          const te = this.elements;
          const x = v.x, y = v.y, z = v.z;
          te[0] *= x;
          te[4] *= y;
          te[8] *= z;
          te[1] *= x;
          te[5] *= y;
          te[9] *= z;
          te[2] *= x;
          te[6] *= y;
          te[10] *= z;
          te[3] *= x;
          te[7] *= y;
          te[11] *= z;
          return this;
        }
        getMaxScaleOnAxis() {
          const te = this.elements;
          const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
          const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
          const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x, y, z) {
          this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
          return this;
        }
        makeRotationX(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationY(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationZ(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationAxis(axis, angle) {
          const c = Math.cos(angle);
          const s = Math.sin(angle);
          const t = 1 - c;
          const x = axis.x, y = axis.y, z = axis.z;
          const tx = t * x, ty = t * y;
          this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
          return this;
        }
        makeScale(x, y, z) {
          this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
          return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
          this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
          return this;
        }
        compose(position, quaternion, scale) {
          const te = this.elements;
          const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
          const x2 = x + x, y2 = y + y, z2 = z + z;
          const xx = x * x2, xy = x * y2, xz = x * z2;
          const yy = y * y2, yz = y * z2, zz = z * z2;
          const wx = w * x2, wy = w * y2, wz = w * z2;
          const sx = scale.x, sy = scale.y, sz = scale.z;
          te[0] = (1 - (yy + zz)) * sx;
          te[1] = (xy + wz) * sx;
          te[2] = (xz - wy) * sx;
          te[3] = 0;
          te[4] = (xy - wz) * sy;
          te[5] = (1 - (xx + zz)) * sy;
          te[6] = (yz + wx) * sy;
          te[7] = 0;
          te[8] = (xz + wy) * sz;
          te[9] = (yz - wx) * sz;
          te[10] = (1 - (xx + yy)) * sz;
          te[11] = 0;
          te[12] = position.x;
          te[13] = position.y;
          te[14] = position.z;
          te[15] = 1;
          return this;
        }
        decompose(position, quaternion, scale) {
          const te = this.elements;
          let sx = _v1$5.set(te[0], te[1], te[2]).length();
          const sy = _v1$5.set(te[4], te[5], te[6]).length();
          const sz = _v1$5.set(te[8], te[9], te[10]).length();
          const det = this.determinant();
          if (det < 0)
            sx = -sx;
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          _m1$2.copy(this);
          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;
          _m1$2.elements[0] *= invSX;
          _m1$2.elements[1] *= invSX;
          _m1$2.elements[2] *= invSX;
          _m1$2.elements[4] *= invSY;
          _m1$2.elements[5] *= invSY;
          _m1$2.elements[6] *= invSY;
          _m1$2.elements[8] *= invSZ;
          _m1$2.elements[9] *= invSZ;
          _m1$2.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(_m1$2);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        }
        makePerspective(left, right, top, bottom, near, far) {
          if (far === void 0) {
            console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          }
          const te = this.elements;
          const x = 2 * near / (right - left);
          const y = 2 * near / (top - bottom);
          const a = (right + left) / (right - left);
          const b = (top + bottom) / (top - bottom);
          const c = -(far + near) / (far - near);
          const d = -2 * far * near / (far - near);
          te[0] = x;
          te[4] = 0;
          te[8] = a;
          te[12] = 0;
          te[1] = 0;
          te[5] = y;
          te[9] = b;
          te[13] = 0;
          te[2] = 0;
          te[6] = 0;
          te[10] = c;
          te[14] = d;
          te[3] = 0;
          te[7] = 0;
          te[11] = -1;
          te[15] = 0;
          return this;
        }
        makeOrthographic(left, right, top, bottom, near, far) {
          const te = this.elements;
          const w = 1 / (right - left);
          const h = 1 / (top - bottom);
          const p2 = 1 / (far - near);
          const x = (right + left) * w;
          const y = (top + bottom) * h;
          const z = (far + near) * p2;
          te[0] = 2 * w;
          te[4] = 0;
          te[8] = 0;
          te[12] = -x;
          te[1] = 0;
          te[5] = 2 * h;
          te[9] = 0;
          te[13] = -y;
          te[2] = 0;
          te[6] = 0;
          te[10] = -2 * p2;
          te[14] = -z;
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[15] = 1;
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i2 = 0; i2 < 16; i2++) {
            if (te[i2] !== me[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 16; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          array[offset + 9] = te[9];
          array[offset + 10] = te[10];
          array[offset + 11] = te[11];
          array[offset + 12] = te[12];
          array[offset + 13] = te[13];
          array[offset + 14] = te[14];
          array[offset + 15] = te[15];
          return array;
        }
      };
      Matrix4.prototype.isMatrix4 = true;
      _v1$5 = /* @__PURE__ */ new Vector3();
      _m1$2 = /* @__PURE__ */ new Matrix4();
      _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
      _one = /* @__PURE__ */ new Vector3(1, 1, 1);
      _x = /* @__PURE__ */ new Vector3();
      _y = /* @__PURE__ */ new Vector3();
      _z = /* @__PURE__ */ new Vector3();
      _matrix$1 = /* @__PURE__ */ new Matrix4();
      _quaternion$3 = /* @__PURE__ */ new Quaternion();
      Euler = class {
        constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(value) {
          this._order = value;
          this._onChangeCallback();
        }
        set(x, y, z, order = this._order) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m, order = this._order, update = true) {
          const te = m.elements;
          const m11 = te[0], m12 = te[4], m13 = te[8];
          const m21 = te[1], m22 = te[5], m23 = te[9];
          const m31 = te[2], m32 = te[6], m33 = te[10];
          switch (order) {
            case "XYZ":
              this._y = Math.asin(clamp(m13, -1, 1));
              if (Math.abs(m13) < 0.9999999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
              } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-clamp(m23, -1, 1));
              if (Math.abs(m23) < 0.9999999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
              } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(clamp(m32, -1, 1));
              if (Math.abs(m32) < 0.9999999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
              } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-clamp(m31, -1, 1));
              if (Math.abs(m31) < 0.9999999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
              } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
              }
              break;
            case "YZX":
              this._z = Math.asin(clamp(m21, -1, 1));
              if (Math.abs(m21) < 0.9999999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
              } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
              }
              break;
            case "XZY":
              this._z = Math.asin(-clamp(m12, -1, 1));
              if (Math.abs(m12) < 0.9999999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
              } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
          }
          this._order = order;
          if (update === true)
            this._onChangeCallback();
          return this;
        }
        setFromQuaternion(q, order, update) {
          _matrix$1.makeRotationFromQuaternion(q);
          return this.setFromRotationMatrix(_matrix$1, order, update);
        }
        setFromVector3(v, order = this._order) {
          return this.set(v.x, v.y, v.z, order);
        }
        reorder(newOrder) {
          _quaternion$3.setFromEuler(this);
          return this.setFromQuaternion(_quaternion$3, newOrder);
        }
        equals(euler) {
          return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        }
        fromArray(array) {
          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== void 0)
            this._order = array[3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;
          return array;
        }
        toVector3(optionalResult) {
          if (optionalResult) {
            return optionalResult.set(this._x, this._y, this._z);
          } else {
            return new Vector3(this._x, this._y, this._z);
          }
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      };
      Euler.prototype.isEuler = true;
      Euler.DefaultOrder = "XYZ";
      Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      Layers = class {
        constructor() {
          this.mask = 1 | 0;
        }
        set(channel) {
          this.mask = (1 << channel | 0) >>> 0;
        }
        enable(channel) {
          this.mask |= 1 << channel | 0;
        }
        enableAll() {
          this.mask = 4294967295 | 0;
        }
        toggle(channel) {
          this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
          this.mask &= ~(1 << channel | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(layers) {
          return (this.mask & layers.mask) !== 0;
        }
        isEnabled(channel) {
          return (this.mask & (1 << channel | 0)) !== 0;
        }
      };
      _object3DId = 0;
      _v1$4 = /* @__PURE__ */ new Vector3();
      _q1 = /* @__PURE__ */ new Quaternion();
      _m1$1 = /* @__PURE__ */ new Matrix4();
      _target = /* @__PURE__ */ new Vector3();
      _position$3 = /* @__PURE__ */ new Vector3();
      _scale$2 = /* @__PURE__ */ new Vector3();
      _quaternion$2 = /* @__PURE__ */ new Quaternion();
      _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
      _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
      _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
      _addedEvent = { type: "added" };
      _removedEvent = { type: "removed" };
      Object3D = class extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", { value: _object3DId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = Object3D.DefaultUp.clone();
          const position = new Vector3();
          const rotation = new Euler();
          const quaternion = new Quaternion();
          const scale = new Vector3(1, 1, 1);
          function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
          }
          function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, false);
          }
          rotation._onChange(onRotationChange);
          quaternion._onChange(onQuaternionChange);
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: position
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: rotation
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: scale
            },
            modelViewMatrix: {
              value: new Matrix4()
            },
            normalMatrix: {
              value: new Matrix3()
            }
          });
          this.matrix = new Matrix4();
          this.matrixWorld = new Matrix4();
          this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
          this.matrixWorldNeedsUpdate = false;
          this.layers = new Layers();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(matrix) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          this.matrix.premultiply(matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q) {
          this.quaternion.premultiply(q);
          return this;
        }
        setRotationFromAxisAngle(axis, angle) {
          this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
          this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m) {
          this.quaternion.setFromRotationMatrix(m);
        }
        setRotationFromQuaternion(q) {
          this.quaternion.copy(q);
        }
        rotateOnAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(_q1);
          return this;
        }
        rotateOnWorldAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.premultiply(_q1);
          return this;
        }
        rotateX(angle) {
          return this.rotateOnAxis(_xAxis, angle);
        }
        rotateY(angle) {
          return this.rotateOnAxis(_yAxis, angle);
        }
        rotateZ(angle) {
          return this.rotateOnAxis(_zAxis, angle);
        }
        translateOnAxis(axis, distance) {
          _v1$4.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(_v1$4.multiplyScalar(distance));
          return this;
        }
        translateX(distance) {
          return this.translateOnAxis(_xAxis, distance);
        }
        translateY(distance) {
          return this.translateOnAxis(_yAxis, distance);
        }
        translateZ(distance) {
          return this.translateOnAxis(_zAxis, distance);
        }
        localToWorld(vector) {
          return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
          return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        }
        lookAt(x, y, z) {
          if (x.isVector3) {
            _target.copy(x);
          } else {
            _target.set(x, y, z);
          }
          const parent = this.parent;
          this.updateWorldMatrix(true, false);
          _position$3.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            _m1$1.lookAt(_position$3, _target, this.up);
          } else {
            _m1$1.lookAt(_target, _position$3, this.up);
          }
          this.quaternion.setFromRotationMatrix(_m1$1);
          if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
          }
        }
        add(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.add(arguments[i2]);
            }
            return this;
          }
          if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
          }
          if (object && object.isObject3D) {
            if (object.parent !== null) {
              object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
          } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
          }
          return this;
        }
        remove(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.remove(arguments[i2]);
            }
            return this;
          }
          const index = this.children.indexOf(object);
          if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
          }
          return this;
        }
        removeFromParent() {
          const parent = this.parent;
          if (parent !== null) {
            parent.remove(this);
          }
          return this;
        }
        clear() {
          for (let i2 = 0; i2 < this.children.length; i2++) {
            const object = this.children[i2];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
          }
          this.children.length = 0;
          return this;
        }
        attach(object) {
          this.updateWorldMatrix(true, false);
          _m1$1.copy(this.matrixWorld).invert();
          if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
          }
          object.applyMatrix4(_m1$1);
          this.add(object);
          object.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(id) {
          return this.getObjectByProperty("id", id);
        }
        getObjectByName(name) {
          return this.getObjectByProperty("name", name);
        }
        getObjectByProperty(name, value) {
          if (this[name] === value)
            return this;
          for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
            const child = this.children[i2];
            const object = child.getObjectByProperty(name, value);
            if (object !== void 0) {
              return object;
            }
          }
          return void 0;
        }
        getWorldPosition(target) {
          this.updateWorldMatrix(true, false);
          return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, target, _scale$2);
          return target;
        }
        getWorldScale(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, _quaternion$2, target);
          return target;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {
        }
        traverse(callback) {
          callback(this);
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].traverse(callback);
          }
        }
        traverseVisible(callback) {
          if (this.visible === false)
            return;
          callback(this);
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].traverseVisible(callback);
          }
        }
        traverseAncestors(callback) {
          const parent = this.parent;
          if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
          }
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].updateMatrixWorld(force);
          }
        }
        updateWorldMatrix(updateParents, updateChildren) {
          const parent = this.parent;
          if (updateParents === true && parent !== null) {
            parent.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (updateChildren === true) {
            const children = this.children;
            for (let i2 = 0, l = children.length; i2 < l; i2++) {
              children[i2].updateWorldMatrix(false, true);
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          const output = {};
          if (isRootObject) {
            meta = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {}
            };
            output.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const object = {};
          object.uuid = this.uuid;
          object.type = this.type;
          if (this.name !== "")
            object.name = this.name;
          if (this.castShadow === true)
            object.castShadow = true;
          if (this.receiveShadow === true)
            object.receiveShadow = true;
          if (this.visible === false)
            object.visible = false;
          if (this.frustumCulled === false)
            object.frustumCulled = false;
          if (this.renderOrder !== 0)
            object.renderOrder = this.renderOrder;
          if (JSON.stringify(this.userData) !== "{}")
            object.userData = this.userData;
          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();
          if (this.matrixAutoUpdate === false)
            object.matrixAutoUpdate = false;
          if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null)
              object.instanceColor = this.instanceColor.toJSON();
          }
          function serialize(library, element) {
            if (library[element.uuid] === void 0) {
              library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                object.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                object.background = this.background.toJSON(meta).uuid;
              }
            }
            if (this.environment && this.environment.isTexture) {
              object.environment = this.environment.toJSON(meta).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== void 0 && parameters.shapes !== void 0) {
              const shapes = parameters.shapes;
              if (Array.isArray(shapes)) {
                for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
                  const shape = shapes[i2];
                  serialize(meta.shapes, shape);
                }
              } else {
                serialize(meta.shapes, shapes);
              }
            }
          }
          if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== void 0) {
              serialize(meta.skeletons, this.skeleton);
              object.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== void 0) {
            if (Array.isArray(this.material)) {
              const uuids = [];
              for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
                uuids.push(serialize(meta.materials, this.material[i2]));
              }
              object.material = uuids;
            } else {
              object.material = serialize(meta.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            object.children = [];
            for (let i2 = 0; i2 < this.children.length; i2++) {
              object.children.push(this.children[i2].toJSON(meta).object);
            }
          }
          if (this.animations.length > 0) {
            object.animations = [];
            for (let i2 = 0; i2 < this.animations.length; i2++) {
              const animation = this.animations[i2];
              object.animations.push(serialize(meta.animations, animation));
            }
          }
          if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            if (geometries.length > 0)
              output.geometries = geometries;
            if (materials.length > 0)
              output.materials = materials;
            if (textures.length > 0)
              output.textures = textures;
            if (images.length > 0)
              output.images = images;
            if (shapes.length > 0)
              output.shapes = shapes;
            if (skeletons.length > 0)
              output.skeletons = skeletons;
            if (animations.length > 0)
              output.animations = animations;
          }
          output.object = object;
          return output;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data = cache[key];
              delete data.metadata;
              values.push(data);
            }
            return values;
          }
        }
        clone(recursive) {
          return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
          this.name = source.name;
          this.up.copy(source.up);
          this.position.copy(source.position);
          this.rotation.order = source.rotation.order;
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);
          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
          this.layers.mask = source.layers.mask;
          this.visible = source.visible;
          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;
          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          if (recursive === true) {
            for (let i2 = 0; i2 < source.children.length; i2++) {
              const child = source.children[i2];
              this.add(child.clone());
            }
          }
          return this;
        }
      };
      Object3D.DefaultUp = new Vector3(0, 1, 0);
      Object3D.DefaultMatrixAutoUpdate = true;
      Object3D.prototype.isObject3D = true;
      _v0$1 = /* @__PURE__ */ new Vector3();
      _v1$3 = /* @__PURE__ */ new Vector3();
      _v2$2 = /* @__PURE__ */ new Vector3();
      _v3$1 = /* @__PURE__ */ new Vector3();
      _vab = /* @__PURE__ */ new Vector3();
      _vac = /* @__PURE__ */ new Vector3();
      _vbc = /* @__PURE__ */ new Vector3();
      _vap = /* @__PURE__ */ new Vector3();
      _vbp = /* @__PURE__ */ new Vector3();
      _vcp = /* @__PURE__ */ new Vector3();
      Triangle = class {
        constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
          this.a = a;
          this.b = b;
          this.c = c;
        }
        static getNormal(a, b, c, target) {
          target.subVectors(c, b);
          _v0$1.subVectors(a, b);
          target.cross(_v0$1);
          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
          }
          return target.set(0, 0, 0);
        }
        static getBarycoord(point, a, b, c, target) {
          _v0$1.subVectors(c, a);
          _v1$3.subVectors(b, a);
          _v2$2.subVectors(point, a);
          const dot00 = _v0$1.dot(_v0$1);
          const dot01 = _v0$1.dot(_v1$3);
          const dot02 = _v0$1.dot(_v2$2);
          const dot11 = _v1$3.dot(_v1$3);
          const dot12 = _v1$3.dot(_v2$2);
          const denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          const invDenom = 1 / denom;
          const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        }
        static containsPoint(point, a, b, c) {
          this.getBarycoord(point, a, b, c, _v3$1);
          return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
        }
        static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          this.getBarycoord(point, p1, p2, p3, _v3$1);
          target.set(0, 0);
          target.addScaledVector(uv1, _v3$1.x);
          target.addScaledVector(uv2, _v3$1.y);
          target.addScaledVector(uv3, _v3$1.z);
          return target;
        }
        static isFrontFacing(a, b, c, direction) {
          _v0$1.subVectors(c, b);
          _v1$3.subVectors(a, b);
          return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
        }
        set(a, b, c) {
          this.a.copy(a);
          this.b.copy(b);
          this.c.copy(c);
          return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i2]);
          return this;
        }
        setFromAttributeAndIndices(attribute, i0, i1, i2) {
          this.a.fromBufferAttribute(attribute, i0);
          this.b.fromBufferAttribute(attribute, i1);
          this.c.fromBufferAttribute(attribute, i2);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(triangle) {
          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);
          return this;
        }
        getArea() {
          _v0$1.subVectors(this.c, this.b);
          _v1$3.subVectors(this.a, this.b);
          return _v0$1.cross(_v1$3).length() * 0.5;
        }
        getMidpoint(target) {
          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
          return Triangle.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
          return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
          return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getUV(point, uv1, uv2, uv3, target) {
          return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        }
        containsPoint(point) {
          return Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
          return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
          return box.intersectsTriangle(this);
        }
        closestPointToPoint(p2, target) {
          const a = this.a, b = this.b, c = this.c;
          let v, w;
          _vab.subVectors(b, a);
          _vac.subVectors(c, a);
          _vap.subVectors(p2, a);
          const d1 = _vab.dot(_vap);
          const d2 = _vac.dot(_vap);
          if (d1 <= 0 && d2 <= 0) {
            return target.copy(a);
          }
          _vbp.subVectors(p2, b);
          const d3 = _vab.dot(_vbp);
          const d4 = _vac.dot(_vbp);
          if (d3 >= 0 && d4 <= d3) {
            return target.copy(b);
          }
          const vc = d1 * d4 - d3 * d2;
          if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            return target.copy(a).addScaledVector(_vab, v);
          }
          _vcp.subVectors(p2, c);
          const d5 = _vab.dot(_vcp);
          const d6 = _vac.dot(_vcp);
          if (d6 >= 0 && d5 <= d6) {
            return target.copy(c);
          }
          const vb = d5 * d2 - d1 * d6;
          if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            return target.copy(a).addScaledVector(_vac, w);
          }
          const va = d3 * d6 - d5 * d4;
          if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b).addScaledVector(_vbc, w);
          }
          const denom = 1 / (va + vb + vc);
          v = vb * denom;
          w = vc * denom;
          return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
        }
        equals(triangle) {
          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
      };
      materialId = 0;
      Material = class extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", { value: materialId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Material";
          this.fog = true;
          this.blending = NormalBlending;
          this.side = FrontSide;
          this.vertexColors = false;
          this.opacity = 1;
          this.transparent = false;
          this.blendSrc = SrcAlphaFactor;
          this.blendDst = OneMinusSrcAlphaFactor;
          this.blendEquation = AddEquation;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.depthFunc = LessEqualDepth;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = AlwaysStencilFunc;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = KeepStencilOp;
          this.stencilZFail = KeepStencilOp;
          this.stencilZPass = KeepStencilOp;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
          this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(value) {
          if (this._alphaTest > 0 !== value > 0) {
            this.version++;
          }
          this._alphaTest = value;
        }
        onBuild() {
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(values) {
          if (values === void 0)
            return;
          for (const key in values) {
            const newValue = values[key];
            if (newValue === void 0) {
              console.warn("THREE.Material: '" + key + "' parameter is undefined.");
              continue;
            }
            if (key === "shading") {
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
              this.flatShading = newValue === FlatShading ? true : false;
              continue;
            }
            const currentValue = this[key];
            if (currentValue === void 0) {
              console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
              continue;
            }
            if (currentValue && currentValue.isColor) {
              currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
              currentValue.copy(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
        toJSON(meta) {
          const isRoot = meta === void 0 || typeof meta === "string";
          if (isRoot) {
            meta = {
              textures: {},
              images: {}
            };
          }
          const data = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (this.color && this.color.isColor)
            data.color = this.color.getHex();
          if (this.roughness !== void 0)
            data.roughness = this.roughness;
          if (this.metalness !== void 0)
            data.metalness = this.metalness;
          if (this.sheen !== void 0)
            data.sheen = this.sheen;
          if (this.sheenColor && this.sheenColor.isColor)
            data.sheenColor = this.sheenColor.getHex();
          if (this.sheenRoughness !== void 0)
            data.sheenRoughness = this.sheenRoughness;
          if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1)
            data.emissiveIntensity = this.emissiveIntensity;
          if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
          if (this.specularIntensity !== void 0)
            data.specularIntensity = this.specularIntensity;
          if (this.specularColor && this.specularColor.isColor)
            data.specularColor = this.specularColor.getHex();
          if (this.shininess !== void 0)
            data.shininess = this.shininess;
          if (this.clearcoat !== void 0)
            data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== void 0)
            data.clearcoatRoughness = this.clearcoatRoughness;
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture)
            data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
          if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
          if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
            data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
          if (this.specularColorMap && this.specularColorMap.isTexture)
            data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
          if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== void 0)
              data.combine = this.combine;
          }
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
          if (this.reflectivity !== void 0)
            data.reflectivity = this.reflectivity;
          if (this.refractionRatio !== void 0)
            data.refractionRatio = this.refractionRatio;
          if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
          }
          if (this.transmission !== void 0)
            data.transmission = this.transmission;
          if (this.transmissionMap && this.transmissionMap.isTexture)
            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
          if (this.thickness !== void 0)
            data.thickness = this.thickness;
          if (this.thicknessMap && this.thicknessMap.isTexture)
            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
          if (this.attenuationDistance !== void 0)
            data.attenuationDistance = this.attenuationDistance;
          if (this.attenuationColor !== void 0)
            data.attenuationColor = this.attenuationColor.getHex();
          if (this.size !== void 0)
            data.size = this.size;
          if (this.shadowSide !== null)
            data.shadowSide = this.shadowSide;
          if (this.sizeAttenuation !== void 0)
            data.sizeAttenuation = this.sizeAttenuation;
          if (this.blending !== NormalBlending)
            data.blending = this.blending;
          if (this.side !== FrontSide)
            data.side = this.side;
          if (this.vertexColors)
            data.vertexColors = true;
          if (this.opacity < 1)
            data.opacity = this.opacity;
          if (this.transparent === true)
            data.transparent = this.transparent;
          data.depthFunc = this.depthFunc;
          data.depthTest = this.depthTest;
          data.depthWrite = this.depthWrite;
          data.colorWrite = this.colorWrite;
          data.stencilWrite = this.stencilWrite;
          data.stencilWriteMask = this.stencilWriteMask;
          data.stencilFunc = this.stencilFunc;
          data.stencilRef = this.stencilRef;
          data.stencilFuncMask = this.stencilFuncMask;
          data.stencilFail = this.stencilFail;
          data.stencilZFail = this.stencilZFail;
          data.stencilZPass = this.stencilZPass;
          if (this.rotation && this.rotation !== 0)
            data.rotation = this.rotation;
          if (this.polygonOffset === true)
            data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0)
            data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0)
            data.polygonOffsetUnits = this.polygonOffsetUnits;
          if (this.linewidth && this.linewidth !== 1)
            data.linewidth = this.linewidth;
          if (this.dashSize !== void 0)
            data.dashSize = this.dashSize;
          if (this.gapSize !== void 0)
            data.gapSize = this.gapSize;
          if (this.scale !== void 0)
            data.scale = this.scale;
          if (this.dithering === true)
            data.dithering = true;
          if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
          if (this.alphaToCoverage === true)
            data.alphaToCoverage = this.alphaToCoverage;
          if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
          if (this.wireframe === true)
            data.wireframe = this.wireframe;
          if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== "round")
            data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== "round")
            data.wireframeLinejoin = this.wireframeLinejoin;
          if (this.flatShading === true)
            data.flatShading = this.flatShading;
          if (this.visible === false)
            data.visible = false;
          if (this.toneMapped === false)
            data.toneMapped = false;
          if (JSON.stringify(this.userData) !== "{}")
            data.userData = this.userData;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data2 = cache[key];
              delete data2.metadata;
              values.push(data2);
            }
            return values;
          }
          if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0)
              data.textures = textures;
            if (images.length > 0)
              data.images = images;
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.fog = source.fog;
          this.blending = source.blending;
          this.side = source.side;
          this.vertexColors = source.vertexColors;
          this.opacity = source.opacity;
          this.transparent = source.transparent;
          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;
          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;
          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;
          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;
          if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for (let i2 = 0; i2 !== n; ++i2) {
              dstPlanes[i2] = srcPlanes[i2].clone();
            }
          }
          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;
          this.shadowSide = source.shadowSide;
          this.colorWrite = source.colorWrite;
          this.precision = source.precision;
          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;
          this.dithering = source.dithering;
          this.alphaTest = source.alphaTest;
          this.alphaToCoverage = source.alphaToCoverage;
          this.premultipliedAlpha = source.premultipliedAlpha;
          this.visible = source.visible;
          this.toneMapped = source.toneMapped;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      };
      Material.prototype.isMaterial = true;
      MeshBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshBasicMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
      _vector$9 = /* @__PURE__ */ new Vector3();
      _vector2$1 = /* @__PURE__ */ new Vector2();
      BufferAttribute = class {
        constructor(array, itemSize, normalized) {
          if (Array.isArray(array)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.name = "";
          this.array = array;
          this.itemSize = itemSize;
          this.count = array !== void 0 ? array.length / itemSize : 0;
          this.normalized = normalized === true;
          this.usage = StaticDrawUsage;
          this.updateRange = { offset: 0, count: -1 };
          this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.itemSize;
          index2 *= attribute.itemSize;
          for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        copyArray(array) {
          this.array.set(array);
          return this;
        }
        copyColorsArray(colors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = colors.length; i2 < l; i2++) {
            let color = colors[i2];
            if (color === void 0) {
              console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
              color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
          }
          return this;
        }
        copyVector2sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
              vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
          }
          return this;
        }
        copyVector3sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
              vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
          }
          return this;
        }
        copyVector4sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
              vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
          }
          return this;
        }
        applyMatrix3(m) {
          if (this.itemSize === 2) {
            for (let i2 = 0, l = this.count; i2 < l; i2++) {
              _vector2$1.fromBufferAttribute(this, i2);
              _vector2$1.applyMatrix3(m);
              this.setXY(i2, _vector2$1.x, _vector2$1.y);
            }
          } else if (this.itemSize === 3) {
            for (let i2 = 0, l = this.count; i2 < l; i2++) {
              _vector$9.fromBufferAttribute(this, i2);
              _vector$9.applyMatrix3(m);
              this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
            }
          }
          return this;
        }
        applyMatrix4(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.applyMatrix4(m);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.applyNormalMatrix(m);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.x = this.getX(i2);
            _vector$9.y = this.getY(i2);
            _vector$9.z = this.getZ(i2);
            _vector$9.transformDirection(m);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        getX(index) {
          return this.array[index * this.itemSize];
        }
        setX(index, x) {
          this.array[index * this.itemSize] = x;
          return this;
        }
        getY(index) {
          return this.array[index * this.itemSize + 1];
        }
        setY(index, y) {
          this.array[index * this.itemSize + 1] = y;
          return this;
        }
        getZ(index) {
          return this.array[index * this.itemSize + 2];
        }
        setZ(index, z) {
          this.array[index * this.itemSize + 2] = z;
          return this;
        }
        getW(index) {
          return this.array[index * this.itemSize + 3];
        }
        setW(index, w) {
          this.array[index * this.itemSize + 3] = w;
          return this;
        }
        setXY(index, x, y) {
          index *= this.itemSize;
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x, y, z) {
          index *= this.itemSize;
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x, y, z, w) {
          index *= this.itemSize;
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          this.array[index + 3] = w;
          return this;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
          };
          if (this.name !== "")
            data.name = this.name;
          if (this.usage !== StaticDrawUsage)
            data.usage = this.usage;
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
            data.updateRange = this.updateRange;
          return data;
        }
      };
      BufferAttribute.prototype.isBufferAttribute = true;
      Uint16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      Uint32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint32Array(array), itemSize, normalized);
        }
      };
      Float16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
      Float32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float32Array(array), itemSize, normalized);
        }
      };
      _id$1 = 0;
      _m1 = /* @__PURE__ */ new Matrix4();
      _obj = /* @__PURE__ */ new Object3D();
      _offset = /* @__PURE__ */ new Vector3();
      _box$1 = /* @__PURE__ */ new Box3();
      _boxMorphTargets = /* @__PURE__ */ new Box3();
      _vector$8 = /* @__PURE__ */ new Vector3();
      BufferGeometry = class extends EventDispatcher {
        constructor() {
          super();
          Object.defineProperty(this, "id", { value: _id$1++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = { start: 0, count: Infinity };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(index) {
          if (Array.isArray(index)) {
            this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
          } else {
            this.index = index;
          }
          return this;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        setAttribute(name, attribute) {
          this.attributes[name] = attribute;
          return this;
        }
        deleteAttribute(name) {
          delete this.attributes[name];
          return this;
        }
        hasAttribute(name) {
          return this.attributes[name] !== void 0;
        }
        addGroup(start, count, materialIndex = 0) {
          this.groups.push({
            start,
            count,
            materialIndex
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(start, count) {
          this.drawRange.start = start;
          this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
          const position = this.attributes.position;
          if (position !== void 0) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
          }
          const normal = this.attributes.normal;
          if (normal !== void 0) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
          }
          const tangent = this.attributes.tangent;
          if (tangent !== void 0) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(q) {
          _m1.makeRotationFromQuaternion(q);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateX(angle) {
          _m1.makeRotationX(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateY(angle) {
          _m1.makeRotationY(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateZ(angle) {
          _m1.makeRotationZ(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        translate(x, y, z) {
          _m1.makeTranslation(x, y, z);
          this.applyMatrix4(_m1);
          return this;
        }
        scale(x, y, z) {
          _m1.makeScale(x, y, z);
          this.applyMatrix4(_m1);
          return this;
        }
        lookAt(vector) {
          _obj.lookAt(vector);
          _obj.updateMatrix();
          this.applyMatrix4(_obj.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(_offset).negate();
          this.translate(_offset.x, _offset.y, _offset.z);
          return this;
        }
        setFromPoints(points) {
          const position = [];
          for (let i2 = 0, l = points.length; i2 < l; i2++) {
            const point = points[i2];
            position.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute("position", new Float32BufferAttribute(position, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
            return;
          }
          if (position !== void 0) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                  this.boundingBox.expandByPoint(_vector$8);
                  _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                  this.boundingBox.expandByPoint(_vector$8);
                } else {
                  this.boundingBox.expandByPoint(_box$1.min);
                  this.boundingBox.expandByPoint(_box$1.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
          }
          if (position) {
            const center = this.boundingSphere.center;
            _box$1.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                  _box$1.expandByPoint(_vector$8);
                  _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                  _box$1.expandByPoint(_vector$8);
                } else {
                  _box$1.expandByPoint(_boxMorphTargets.min);
                  _box$1.expandByPoint(_boxMorphTargets.max);
                }
              }
            }
            _box$1.getCenter(center);
            let maxRadiusSq = 0;
            for (let i2 = 0, il = position.count; i2 < il; i2++) {
              _vector$8.fromBufferAttribute(position, i2);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                const morphTargetsRelative = this.morphTargetsRelative;
                for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                  _vector$8.fromBufferAttribute(morphAttribute, j);
                  if (morphTargetsRelative) {
                    _offset.fromBufferAttribute(position, j);
                    _vector$8.add(_offset);
                  }
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        }
        computeTangents() {
          const index = this.index;
          const attributes = this.attributes;
          if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const indices = index.array;
          const positions = attributes.position.array;
          const normals = attributes.normal.array;
          const uvs = attributes.uv.array;
          const nVertices = positions.length / 3;
          if (attributes.tangent === void 0) {
            this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
          }
          const tangents = attributes.tangent.array;
          const tan1 = [], tan2 = [];
          for (let i2 = 0; i2 < nVertices; i2++) {
            tan1[i2] = new Vector3();
            tan2[i2] = new Vector3();
          }
          const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
          function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            if (!isFinite(r))
              return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
          }
          let groups = this.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.length
            }];
          }
          for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
            }
          }
          const tmp3 = new Vector3(), tmp22 = new Vector3();
          const n = new Vector3(), n2 = new Vector3();
          function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            tmp3.copy(t);
            tmp3.sub(n.multiplyScalar(n.dot(t))).normalize();
            tmp22.crossVectors(n2, t);
            const test = tmp22.dot(tan2[v]);
            const w = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp3.x;
            tangents[v * 4 + 1] = tmp3.y;
            tangents[v * 4 + 2] = tmp3.z;
            tangents[v * 4 + 3] = w;
          }
          for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleVertex(indices[j + 0]);
              handleVertex(indices[j + 1]);
              handleVertex(indices[j + 2]);
            }
          }
        }
        computeVertexNormals() {
          const index = this.index;
          const positionAttribute = this.getAttribute("position");
          if (positionAttribute !== void 0) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === void 0) {
              normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
              this.setAttribute("normal", normalAttribute);
            } else {
              for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
                normalAttribute.setXYZ(i2, 0, 0, 0);
              }
            }
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            if (index) {
              for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
                const vA = index.getX(i2 + 0);
                const vB = index.getX(i2 + 1);
                const vC = index.getX(i2 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
              }
            } else {
              for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
                pA.fromBufferAttribute(positionAttribute, i2 + 0);
                pB.fromBufferAttribute(positionAttribute, i2 + 1);
                pC.fromBufferAttribute(positionAttribute, i2 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
              }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
          }
        }
        merge(geometry, offset) {
          if (!(geometry && geometry.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
          }
          if (offset === void 0) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            if (geometry.attributes[key] === void 0)
              continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for (let i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
              attributeArray1[j] = attributeArray2[i2];
            }
          }
          return this;
        }
        normalizeNormals() {
          const normals = this.attributes.normal;
          for (let i2 = 0, il = normals.count; i2 < il; i2++) {
            _vector$8.fromBufferAttribute(normals, i2);
            _vector$8.normalize();
            normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
          }
        }
        toNonIndexed() {
          function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index = 0, index2 = 0;
            for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
              if (attribute.isInterleavedBufferAttribute) {
                index = indices2[i2] * attribute.data.stride + attribute.offset;
              } else {
                index = indices2[i2] * itemSize;
              }
              for (let j = 0; j < itemSize; j++) {
                array2[index2++] = array[index++];
              }
            }
            return new BufferAttribute(array2, itemSize, normalized);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const geometry2 = new BufferGeometry();
          const indices = this.index.array;
          const attributes = this.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
          }
          const morphAttributes = this.morphAttributes;
          for (const name in morphAttributes) {
            const morphArray = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
              const attribute = morphAttribute[i2];
              const newAttribute = convertBufferAttribute(attribute, indices);
              morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
          }
          geometry2.morphTargetsRelative = this.morphTargetsRelative;
          const groups = this.groups;
          for (let i2 = 0, l = groups.length; i2 < l; i2++) {
            const group = groups[i2];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
          }
          return geometry2;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          if (this.parameters !== void 0) {
            const parameters = this.parameters;
            for (const key in parameters) {
              if (parameters[key] !== void 0)
                data[key] = parameters[key];
            }
            return data;
          }
          data.data = { attributes: {} };
          const index = this.index;
          if (index !== null) {
            data.data.index = {
              type: index.array.constructor.name,
              array: Array.prototype.slice.call(index.array)
            };
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
          }
          const morphAttributes = {};
          let hasMorphAttributes = false;
          for (const key in this.morphAttributes) {
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
              const attribute = attributeArray[i2];
              array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
              morphAttributes[key] = array;
              hasMorphAttributes = true;
            }
          }
          if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const groups = this.groups;
          if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
          }
          const boundingSphere = this.boundingSphere;
          if (boundingSphere !== null) {
            data.data.boundingSphere = {
              center: boundingSphere.center.toArray(),
              radius: boundingSphere.radius
            };
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const data = {};
          this.name = source.name;
          const index = source.index;
          if (index !== null) {
            this.setIndex(index.clone(data));
          }
          const attributes = source.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
          }
          const morphAttributes = source.morphAttributes;
          for (const name in morphAttributes) {
            const array = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
              array.push(morphAttribute[i2].clone(data));
            }
            this.morphAttributes[name] = array;
          }
          this.morphTargetsRelative = source.morphTargetsRelative;
          const groups = source.groups;
          for (let i2 = 0, l = groups.length; i2 < l; i2++) {
            const group = groups[i2];
            this.addGroup(group.start, group.count, group.materialIndex);
          }
          const boundingBox = source.boundingBox;
          if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
          }
          const boundingSphere = source.boundingSphere;
          if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
          }
          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;
          this.userData = source.userData;
          if (source.parameters !== void 0)
            this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      BufferGeometry.prototype.isBufferGeometry = true;
      _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
      _ray$2 = /* @__PURE__ */ new Ray();
      _sphere$3 = /* @__PURE__ */ new Sphere();
      _vA$1 = /* @__PURE__ */ new Vector3();
      _vB$1 = /* @__PURE__ */ new Vector3();
      _vC$1 = /* @__PURE__ */ new Vector3();
      _tempA = /* @__PURE__ */ new Vector3();
      _tempB = /* @__PURE__ */ new Vector3();
      _tempC = /* @__PURE__ */ new Vector3();
      _morphA = /* @__PURE__ */ new Vector3();
      _morphB = /* @__PURE__ */ new Vector3();
      _morphC = /* @__PURE__ */ new Vector3();
      _uvA$1 = /* @__PURE__ */ new Vector2();
      _uvB$1 = /* @__PURE__ */ new Vector2();
      _uvC$1 = /* @__PURE__ */ new Vector2();
      _intersectionPoint = /* @__PURE__ */ new Vector3();
      _intersectionPointWorld = /* @__PURE__ */ new Vector3();
      Mesh = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
          super();
          this.type = "Mesh";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          if (source.morphTargetInfluences !== void 0) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
          }
          if (source.morphTargetDictionary !== void 0) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
          }
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const material = this.material;
          const matrixWorld = this.matrixWorld;
          if (material === void 0)
            return;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$3.copy(geometry.boundingSphere);
          _sphere$3.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$3) === false)
            return;
          _inverseMatrix$2.copy(matrixWorld).invert();
          _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
          if (geometry.boundingBox !== null) {
            if (_ray$2.intersectsBox(geometry.boundingBox) === false)
              return;
          }
          let intersection;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
              if (Array.isArray(material)) {
                for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = index.getX(j);
                    const b = index.getX(j + 1);
                    const c = index.getX(j + 2);
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for (let i2 = start, il = end; i2 < il; i2 += 3) {
                  const a = index.getX(i2);
                  const b = index.getX(i2 + 1);
                  const c = index.getX(i2 + 2);
                  intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            } else if (position !== void 0) {
              if (Array.isArray(material)) {
                for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = j;
                    const b = j + 1;
                    const c = j + 2;
                    intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects2.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(position.count, drawRange.start + drawRange.count);
                for (let i2 = start, il = end; i2 < il; i2 += 3) {
                  const a = i2;
                  const b = i2 + 1;
                  const c = i2 + 2;
                  intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects2.push(intersection);
                  }
                }
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      };
      Mesh.prototype.isMesh = true;
      BoxGeometry = class extends BufferGeometry {
        constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width,
            height,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          };
          const scope = this;
          widthSegments = Math.floor(widthSegments);
          heightSegments = Math.floor(heightSegments);
          depthSegments = Math.floor(depthSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let numberOfVertices = 0;
          let groupStart = 0;
          buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
          buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
          buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
          buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
          buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
          buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
            const segmentWidth = width2 / gridX;
            const segmentHeight = height2 / gridY;
            const widthHalf = width2 / 2;
            const heightHalf = height2 / 2;
            const depthHalf = depth2 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            for (let iy = 0; iy < gridY1; iy++) {
              const y = iy * segmentHeight - heightHalf;
              for (let ix = 0; ix < gridX1; ix++) {
                const x = ix * segmentWidth - widthHalf;
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                vertices.push(vector.x, vector.y, vector.z);
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth2 > 0 ? 1 : -1;
                normals.push(vector.x, vector.y, vector.z);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                vertexCounter += 1;
              }
            }
            for (let iy = 0; iy < gridY; iy++) {
              for (let ix = 0; ix < gridX; ix++) {
                const a = numberOfVertices + ix + gridX1 * iy;
                const b = numberOfVertices + ix + gridX1 * (iy + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
          }
        }
        static fromJSON(data) {
          return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
      };
      UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
      default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
      default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      ShaderMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.vertexShader = default_vertex;
          this.fragmentShader = default_fragment;
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
          };
          this.defaultAttributeValues = {
            "color": [1, 1, 1],
            "uv": [0, 0],
            "uv2": [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (parameters !== void 0) {
            if (parameters.attributes !== void 0) {
              console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
            }
            this.setValues(parameters);
          }
        }
        copy(source) {
          super.copy(source);
          this.fragmentShader = source.fragmentShader;
          this.vertexShader = source.vertexShader;
          this.uniforms = cloneUniforms(source.uniforms);
          this.defines = Object.assign({}, source.defines);
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.lights = source.lights;
          this.clipping = source.clipping;
          this.extensions = Object.assign({}, source.extensions);
          this.glslVersion = source.glslVersion;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.glslVersion = this.glslVersion;
          data.uniforms = {};
          for (const name in this.uniforms) {
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) {
              data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
              };
            } else if (value && value.isColor) {
              data.uniforms[name] = {
                type: "c",
                value: value.getHex()
              };
            } else if (value && value.isVector2) {
              data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
              };
            } else if (value && value.isVector3) {
              data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
              };
            } else if (value && value.isVector4) {
              data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
              };
            } else if (value && value.isMatrix3) {
              data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
              };
            } else if (value && value.isMatrix4) {
              data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
              };
            } else {
              data.uniforms[name] = {
                value
              };
            }
          }
          if (Object.keys(this.defines).length > 0)
            data.defines = this.defines;
          data.vertexShader = this.vertexShader;
          data.fragmentShader = this.fragmentShader;
          const extensions = {};
          for (const key in this.extensions) {
            if (this.extensions[key] === true)
              extensions[key] = true;
          }
          if (Object.keys(extensions).length > 0)
            data.extensions = extensions;
          return data;
        }
      };
      ShaderMaterial.prototype.isShaderMaterial = true;
      Camera = class extends Object3D {
        constructor() {
          super();
          this.type = "Camera";
          this.matrixWorldInverse = new Matrix4();
          this.projectionMatrix = new Matrix4();
          this.projectionMatrixInverse = new Matrix4();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.matrixWorldInverse.copy(source.matrixWorldInverse);
          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
          return this;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(-e[8], -e[9], -e[10]).normalize();
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
          super.updateWorldMatrix(updateParents, updateChildren);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Camera.prototype.isCamera = true;
      PerspectiveCamera = class extends Camera {
        constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
          super();
          this.type = "PerspectiveCamera";
          this.fov = fov2;
          this.zoom = 1;
          this.near = near;
          this.far = far;
          this.focus = 10;
          this.aspect = aspect2;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.fov = source.fov;
          this.zoom = source.zoom;
          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;
          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;
          return this;
        }
        setFocalLength(focalLength) {
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
          this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();
        }
        getFocalLength() {
          const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
          return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const near = this.near;
          let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
          let height = 2 * top;
          let width = this.aspect * height;
          let left = -0.5 * width;
          const view = this.view;
          if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
          }
          const skew = this.filmOffset;
          if (skew !== 0)
            left += near * skew / this.getFilmWidth();
          this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.fov = this.fov;
          data.object.zoom = this.zoom;
          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;
          data.object.aspect = this.aspect;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;
          return data;
        }
      };
      PerspectiveCamera.prototype.isPerspectiveCamera = true;
      fov = 90;
      aspect = 1;
      CubeCamera = class extends Object3D {
        constructor(near, far, renderTarget) {
          super();
          this.type = "CubeCamera";
          if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return;
          }
          this.renderTarget = renderTarget;
          const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
          cameraPX.layers = this.layers;
          cameraPX.up.set(0, -1, 0);
          cameraPX.lookAt(new Vector3(1, 0, 0));
          this.add(cameraPX);
          const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
          cameraNX.layers = this.layers;
          cameraNX.up.set(0, -1, 0);
          cameraNX.lookAt(new Vector3(-1, 0, 0));
          this.add(cameraNX);
          const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
          cameraPY.layers = this.layers;
          cameraPY.up.set(0, 0, 1);
          cameraPY.lookAt(new Vector3(0, 1, 0));
          this.add(cameraPY);
          const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
          cameraNY.layers = this.layers;
          cameraNY.up.set(0, 0, -1);
          cameraNY.lookAt(new Vector3(0, -1, 0));
          this.add(cameraNY);
          const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraPZ.layers = this.layers;
          cameraPZ.up.set(0, -1, 0);
          cameraPZ.lookAt(new Vector3(0, 0, 1));
          this.add(cameraPZ);
          const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraNZ.layers = this.layers;
          cameraNZ.up.set(0, -1, 0);
          cameraNZ.lookAt(new Vector3(0, 0, -1));
          this.add(cameraNZ);
        }
        update(renderer, scene) {
          if (this.parent === null)
            this.updateMatrixWorld();
          const renderTarget = this.renderTarget;
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
          const currentXrEnabled = renderer.xr.enabled;
          const currentRenderTarget = renderer.getRenderTarget();
          renderer.xr.enabled = false;
          const generateMipmaps = renderTarget.texture.generateMipmaps;
          renderTarget.texture.generateMipmaps = false;
          renderer.setRenderTarget(renderTarget, 0);
          renderer.render(scene, cameraPX);
          renderer.setRenderTarget(renderTarget, 1);
          renderer.render(scene, cameraNX);
          renderer.setRenderTarget(renderTarget, 2);
          renderer.render(scene, cameraPY);
          renderer.setRenderTarget(renderTarget, 3);
          renderer.render(scene, cameraNY);
          renderer.setRenderTarget(renderTarget, 4);
          renderer.render(scene, cameraPZ);
          renderTarget.texture.generateMipmaps = generateMipmaps;
          renderer.setRenderTarget(renderTarget, 5);
          renderer.render(scene, cameraNZ);
          renderer.setRenderTarget(currentRenderTarget);
          renderer.xr.enabled = currentXrEnabled;
          renderTarget.texture.needsPMREMUpdate = true;
        }
      };
      CubeTexture = class extends Texture {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
          images = images !== void 0 ? images : [];
          mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
          super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(value) {
          this.image = value;
        }
      };
      CubeTexture.prototype.isCubeTexture = true;
      WebGLCubeRenderTarget = class extends WebGLRenderTarget {
        constructor(size, options, dummy) {
          if (Number.isInteger(options)) {
            console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
            options = dummy;
          }
          super(size, size, options);
          options = options || {};
          this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
        }
        fromEquirectangularTexture(renderer, texture) {
          this.texture.type = texture.type;
          this.texture.format = RGBAFormat;
          this.texture.encoding = texture.encoding;
          this.texture.generateMipmaps = texture.generateMipmaps;
          this.texture.minFilter = texture.minFilter;
          this.texture.magFilter = texture.magFilter;
          const shader = {
            uniforms: {
              tEquirect: { value: null }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          };
          const geometry = new BoxGeometry(5, 5, 5);
          const material = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
          });
          material.uniforms.tEquirect.value = texture;
          const mesh = new Mesh(geometry, material);
          const currentMinFilter = texture.minFilter;
          if (texture.minFilter === LinearMipmapLinearFilter)
            texture.minFilter = LinearFilter;
          const camera = new CubeCamera(1, 10, this);
          camera.update(renderer, mesh);
          texture.minFilter = currentMinFilter;
          mesh.geometry.dispose();
          mesh.material.dispose();
          return this;
        }
        clear(renderer, color, depth, stencil) {
          const currentRenderTarget = renderer.getRenderTarget();
          for (let i2 = 0; i2 < 6; i2++) {
            renderer.setRenderTarget(this, i2);
            renderer.clear(color, depth, stencil);
          }
          renderer.setRenderTarget(currentRenderTarget);
        }
      };
      WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
      _vector1 = /* @__PURE__ */ new Vector3();
      _vector2 = /* @__PURE__ */ new Vector3();
      _normalMatrix = /* @__PURE__ */ new Matrix3();
      Plane = class {
        constructor(normal = new Vector3(1, 0, 0), constant = 0) {
          this.normal = normal;
          this.constant = constant;
        }
        set(normal, constant) {
          this.normal.copy(normal);
          this.constant = constant;
          return this;
        }
        setComponents(x, y, z, w) {
          this.normal.set(x, y, z);
          this.constant = w;
          return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(a, b, c) {
          const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        }
        copy(plane) {
          this.normal.copy(plane.normal);
          this.constant = plane.constant;
          return this;
        }
        normalize() {
          const inverseNormalLength = 1 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(point) {
          return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
          return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
          return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        }
        intersectLine(line, target) {
          const direction = line.delta(_vector1);
          const denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return target.copy(line.start);
            }
            return null;
          }
          const t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return null;
          }
          return target.copy(direction).multiplyScalar(t).add(line.start);
        }
        intersectsLine(line) {
          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);
          return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        }
        intersectsBox(box) {
          return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
          return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
          return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
          const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
          const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
          const normal = this.normal.applyMatrix3(normalMatrix).normalize();
          this.constant = -referencePoint.dot(normal);
          return this;
        }
        translate(offset) {
          this.constant -= offset.dot(this.normal);
          return this;
        }
        equals(plane) {
          return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Plane.prototype.isPlane = true;
      _sphere$2 = /* @__PURE__ */ new Sphere();
      _vector$7 = /* @__PURE__ */ new Vector3();
      Frustum = class {
        constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
          this.planes = [p0, p1, p2, p3, p4, p5];
        }
        set(p0, p1, p2, p3, p4, p5) {
          const planes = this.planes;
          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p2);
          planes[3].copy(p3);
          planes[4].copy(p4);
          planes[5].copy(p5);
          return this;
        }
        copy(frustum) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            planes[i2].copy(frustum.planes[i2]);
          }
          return this;
        }
        setFromProjectionMatrix(m) {
          const planes = this.planes;
          const me = m.elements;
          const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
          const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
          const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
          const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
          planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
          return this;
        }
        intersectsObject(object) {
          const geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSprite(sprite) {
          _sphere$2.center.set(0, 0, 0);
          _sphere$2.radius = 0.7071067811865476;
          _sphere$2.applyMatrix4(sprite.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSphere(sphere) {
          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;
          for (let i2 = 0; i2 < 6; i2++) {
            const distance = planes[i2].distanceToPoint(center);
            if (distance < negRadius) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(box) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            const plane = planes[i2];
            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$7) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(point) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            if (planes[i2].distanceToPoint(point) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      PlaneGeometry = class extends BufferGeometry {
        constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width,
            height,
            widthSegments,
            heightSegments
          };
          const width_half = width / 2;
          const height_half = height / 2;
          const gridX = Math.floor(widthSegments);
          const gridY = Math.floor(heightSegments);
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          const segment_width = width / gridX;
          const segment_height = height / gridY;
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy < gridY1; iy++) {
            const y = iy * segment_height - height_half;
            for (let ix = 0; ix < gridX1; ix++) {
              const x = ix * segment_width - width_half;
              vertices.push(x, -y, 0);
              normals.push(0, 0, 1);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = ix + gridX1 * iy;
              const b = ix + gridX1 * (iy + 1);
              const c = ix + 1 + gridX1 * (iy + 1);
              const d = ix + 1 + gridX1 * iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
        }
      };
      alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
      alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
      alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
      aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
      aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
      begin_vertex = "vec3 transformed = vec3( position );";
      beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
      bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
      bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
      clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
      clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
      clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
      clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
      color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
      color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
      color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
      color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
      common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
      cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		return texture2D( envMap, uv ).rgb;\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
      defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
      displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
      displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
      emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
      emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
      encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
      encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
      envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
      envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
      envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
      envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
      envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
      fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
      fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
      fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
      fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
      gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
      lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
      lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
      lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
      lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
      envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
      lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
      lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
      lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
      lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
      lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
      lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
      lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
      lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
      lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
      logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
      logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
      logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
      logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
      map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
      map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
      map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
      map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
      metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
      morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
      morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
      morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
      normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
      normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
      normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
      normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
      clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
      clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
      clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
      output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
      packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
      premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
      project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
      dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
      dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
      roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
      roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
      shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
      shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
      shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
      shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
      skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
      skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
      skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
      specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
      specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
      tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
      tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
      transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
      transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
      uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
      uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
      uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
      uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
      uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
      uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
      worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
      vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
      fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
      fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
      vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
      fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
      vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
      fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
      fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
      fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
      vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
      fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
      fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      ShaderChunk = {
        alphamap_fragment,
        alphamap_pars_fragment,
        alphatest_fragment,
        alphatest_pars_fragment,
        aomap_fragment,
        aomap_pars_fragment,
        begin_vertex,
        beginnormal_vertex,
        bsdfs,
        bumpmap_pars_fragment,
        clipping_planes_fragment,
        clipping_planes_pars_fragment,
        clipping_planes_pars_vertex,
        clipping_planes_vertex,
        color_fragment,
        color_pars_fragment,
        color_pars_vertex,
        color_vertex,
        common,
        cube_uv_reflection_fragment,
        defaultnormal_vertex,
        displacementmap_pars_vertex,
        displacementmap_vertex,
        emissivemap_fragment,
        emissivemap_pars_fragment,
        encodings_fragment,
        encodings_pars_fragment,
        envmap_fragment,
        envmap_common_pars_fragment,
        envmap_pars_fragment,
        envmap_pars_vertex,
        envmap_physical_pars_fragment,
        envmap_vertex,
        fog_vertex,
        fog_pars_vertex,
        fog_fragment,
        fog_pars_fragment,
        gradientmap_pars_fragment,
        lightmap_fragment,
        lightmap_pars_fragment,
        lights_lambert_vertex,
        lights_pars_begin,
        lights_toon_fragment,
        lights_toon_pars_fragment,
        lights_phong_fragment,
        lights_phong_pars_fragment,
        lights_physical_fragment,
        lights_physical_pars_fragment,
        lights_fragment_begin,
        lights_fragment_maps,
        lights_fragment_end,
        logdepthbuf_fragment,
        logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex,
        logdepthbuf_vertex,
        map_fragment,
        map_pars_fragment,
        map_particle_fragment,
        map_particle_pars_fragment,
        metalnessmap_fragment,
        metalnessmap_pars_fragment,
        morphnormal_vertex,
        morphtarget_pars_vertex,
        morphtarget_vertex,
        normal_fragment_begin,
        normal_fragment_maps,
        normal_pars_fragment,
        normal_pars_vertex,
        normal_vertex,
        normalmap_pars_fragment,
        clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment,
        output_fragment,
        packing,
        premultiplied_alpha_fragment,
        project_vertex,
        dithering_fragment,
        dithering_pars_fragment,
        roughnessmap_fragment,
        roughnessmap_pars_fragment,
        shadowmap_pars_fragment,
        shadowmap_pars_vertex,
        shadowmap_vertex,
        shadowmask_pars_fragment,
        skinbase_vertex,
        skinning_pars_vertex,
        skinning_vertex,
        skinnormal_vertex,
        specularmap_fragment,
        specularmap_pars_fragment,
        tonemapping_fragment,
        tonemapping_pars_fragment,
        transmission_fragment,
        transmission_pars_fragment,
        uv_pars_fragment,
        uv_pars_vertex,
        uv_vertex,
        uv2_pars_fragment,
        uv2_pars_vertex,
        uv2_vertex,
        worldpos_vertex,
        background_vert: vertex$g,
        background_frag: fragment$g,
        cube_vert: vertex$f,
        cube_frag: fragment$f,
        depth_vert: vertex$e,
        depth_frag: fragment$e,
        distanceRGBA_vert: vertex$d,
        distanceRGBA_frag: fragment$d,
        equirect_vert: vertex$c,
        equirect_frag: fragment$c,
        linedashed_vert: vertex$b,
        linedashed_frag: fragment$b,
        meshbasic_vert: vertex$a,
        meshbasic_frag: fragment$a,
        meshlambert_vert: vertex$9,
        meshlambert_frag: fragment$9,
        meshmatcap_vert: vertex$8,
        meshmatcap_frag: fragment$8,
        meshnormal_vert: vertex$7,
        meshnormal_frag: fragment$7,
        meshphong_vert: vertex$6,
        meshphong_frag: fragment$6,
        meshphysical_vert: vertex$5,
        meshphysical_frag: fragment$5,
        meshtoon_vert: vertex$4,
        meshtoon_frag: fragment$4,
        points_vert: vertex$3,
        points_frag: fragment$3,
        shadow_vert: vertex$2,
        shadow_frag: fragment$2,
        sprite_vert: vertex$1,
        sprite_frag: fragment$1
      };
      UniformsLib = {
        common: {
          diffuse: { value: new Color(16777215) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new Matrix3() },
          uv2Transform: { value: new Matrix3() },
          alphaMap: { value: null },
          alphaTest: { value: 0 }
        },
        specularmap: {
          specularMap: { value: null }
        },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          ior: { value: 1.5 },
          refractionRatio: { value: 0.98 }
        },
        aomap: {
          aoMap: { value: null },
          aoMapIntensity: { value: 1 }
        },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 }
        },
        emissivemap: {
          emissiveMap: { value: null }
        },
        bumpmap: {
          bumpMap: { value: null },
          bumpScale: { value: 1 }
        },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new Vector2(1, 1) }
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 }
        },
        roughnessmap: {
          roughnessMap: { value: null }
        },
        metalnessmap: {
          metalnessMap: { value: null }
        },
        gradientmap: {
          gradientMap: { value: null }
        },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new Color(16777215) }
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: { value: [], properties: {
            direction: {},
            color: {}
          } },
          directionalLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          } },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: { value: [], properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          } },
          spotLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          } },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: { value: [], properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          } },
          pointLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          } },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: { value: [], properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          } },
          rectAreaLights: { value: [], properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          } },
          ltc_1: { value: null },
          ltc_2: { value: null }
        },
        points: {
          diffuse: { value: new Color(16777215) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new Matrix3() }
        },
        sprite: {
          diffuse: { value: new Color(16777215) },
          opacity: { value: 1 },
          center: { value: new Vector2(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: new Matrix3() }
        }
      };
      ShaderLib = {
        basic: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.meshbasic_vert,
          fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: new Color(0) }
            }
          ]),
          vertexShader: ShaderChunk.meshlambert_vert,
          fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: new Color(0) },
              specular: { value: new Color(1118481) },
              shininess: { value: 30 }
            }
          ]),
          vertexShader: ShaderChunk.meshphong_vert,
          fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: new Color(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: new Color(0) }
            }
          ]),
          vertexShader: ShaderChunk.meshtoon_vert,
          fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
              matcap: { value: null }
            }
          ]),
          vertexShader: ShaderChunk.meshmatcap_vert,
          fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
          uniforms: mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.points_vert,
          fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 }
            }
          ]),
          vertexShader: ShaderChunk.linedashed_vert,
          fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap
          ]),
          vertexShader: ShaderChunk.depth_vert,
          fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
              opacity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.meshnormal_vert,
          fragmentShader: ShaderChunk.meshnormal_frag
        },
        sprite: {
          uniforms: mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.sprite_vert,
          fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: { value: new Matrix3() },
            t2D: { value: null }
          },
          vertexShader: ShaderChunk.background_vert,
          fragmentShader: ShaderChunk.background_frag
        },
        cube: {
          uniforms: mergeUniforms([
            UniformsLib.envmap,
            {
              opacity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.cube_vert,
          fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: { value: null }
          },
          vertexShader: ShaderChunk.equirect_vert,
          fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
          uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
              referencePosition: { value: new Vector3() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 }
            }
          ]),
          vertexShader: ShaderChunk.distanceRGBA_vert,
          fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
          uniforms: mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
              color: { value: new Color(0) },
              opacity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.shadow_vert,
          fragmentShader: ShaderChunk.shadow_frag
        }
      };
      ShaderLib.physical = {
        uniforms: mergeUniforms([
          ShaderLib.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new Vector2(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new Color(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new Vector2() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Color(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: new Color(1, 1, 1) },
            specularColorMap: { value: null }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      };
      OrthographicCamera = class extends Camera {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
          super();
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = left;
          this.right = right;
          this.top = top;
          this.bottom = bottom;
          this.near = near;
          this.far = far;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;
          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          return this;
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;
          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;
          if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          return data;
        }
      };
      OrthographicCamera.prototype.isOrthographicCamera = true;
      RawShaderMaterial = class extends ShaderMaterial {
        constructor(parameters) {
          super(parameters);
          this.type = "RawShaderMaterial";
        }
      };
      RawShaderMaterial.prototype.isRawShaderMaterial = true;
      LOD_MIN = 4;
      LOD_MAX = 8;
      SIZE_MAX = Math.pow(2, LOD_MAX);
      EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
      MAX_SAMPLES = 20;
      _flatCamera = /* @__PURE__ */ new OrthographicCamera();
      ({ _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes());
      _clearColor = /* @__PURE__ */ new Color();
      _oldTarget = null;
      PHI = (1 + Math.sqrt(5)) / 2;
      INV_PHI = 1 / PHI;
      _axisDirections = [
        /* @__PURE__ */ new Vector3(1, 1, 1),
        /* @__PURE__ */ new Vector3(-1, 1, 1),
        /* @__PURE__ */ new Vector3(1, 1, -1),
        /* @__PURE__ */ new Vector3(-1, 1, -1),
        /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
        /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
        /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
        /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
        /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
        /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
      ];
      PMREMGenerator = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._pingPongRenderTarget = null;
          this._blurMaterial = _getBlurShader(MAX_SAMPLES);
          this._equirectShader = null;
          this._cubemapShader = null;
          this._compileMaterial(this._blurMaterial);
        }
        fromScene(scene, sigma = 0, near = 0.1, far = 100) {
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets();
          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {
            this._blur(cubeUVRenderTarget, 0, 0, sigma);
          }
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        fromEquirectangular(equirectangular, renderTarget = null) {
          return this._fromTexture(equirectangular, renderTarget);
        }
        fromCubemap(cubemap, renderTarget = null) {
          return this._fromTexture(cubemap, renderTarget);
        }
        compileCubemapShader() {
          if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader();
            this._compileMaterial(this._cubemapShader);
          }
        }
        compileEquirectangularShader() {
          if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader();
            this._compileMaterial(this._equirectShader);
          }
        }
        dispose() {
          this._blurMaterial.dispose();
          if (this._pingPongRenderTarget !== null)
            this._pingPongRenderTarget.dispose();
          if (this._cubemapShader !== null)
            this._cubemapShader.dispose();
          if (this._equirectShader !== null)
            this._equirectShader.dispose();
          for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
            _lodPlanes[i2].dispose();
          }
        }
        _cleanup(outputTarget) {
          this._renderer.setRenderTarget(_oldTarget);
          outputTarget.scissorTest = false;
          _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture, renderTarget) {
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = renderTarget || this._allocateTargets(texture);
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        _allocateTargets(texture) {
          const params = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: false,
            type: HalfFloatType,
            format: RGBAFormat,
            encoding: LinearEncoding,
            depthBuffer: false
          };
          const cubeUVRenderTarget = _createRenderTarget(params);
          cubeUVRenderTarget.depthBuffer = texture ? false : true;
          if (this._pingPongRenderTarget === null) {
            this._pingPongRenderTarget = _createRenderTarget(params);
          }
          return cubeUVRenderTarget;
        }
        _compileMaterial(material) {
          const tmpMesh = new Mesh(_lodPlanes[0], material);
          this._renderer.compile(tmpMesh, _flatCamera);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
          const fov2 = 90;
          const aspect2 = 1;
          const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;
          const originalAutoClear = renderer.autoClear;
          const toneMapping = renderer.toneMapping;
          renderer.getClearColor(_clearColor);
          renderer.toneMapping = NoToneMapping;
          renderer.autoClear = false;
          const backgroundMaterial = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: false,
            depthTest: false
          });
          const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
          let useSolidColor = false;
          const background = scene.background;
          if (background) {
            if (background.isColor) {
              backgroundMaterial.color.copy(background);
              scene.background = null;
              useSolidColor = true;
            }
          } else {
            backgroundMaterial.color.copy(_clearColor);
            useSolidColor = true;
          }
          for (let i2 = 0; i2 < 6; i2++) {
            const col = i2 % 3;
            if (col === 0) {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(forwardSign[i2], 0, 0);
            } else if (col === 1) {
              cubeCamera.up.set(0, 0, upSign[i2]);
              cubeCamera.lookAt(0, forwardSign[i2], 0);
            } else {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(0, 0, forwardSign[i2]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i2 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) {
              renderer.render(backgroundBox, cubeCamera);
            }
            renderer.render(scene, cubeCamera);
          }
          backgroundBox.geometry.dispose();
          backgroundBox.material.dispose();
          renderer.toneMapping = toneMapping;
          renderer.autoClear = originalAutoClear;
          scene.background = background;
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
          const renderer = this._renderer;
          const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
          if (isCubeTexture) {
            if (this._cubemapShader === null) {
              this._cubemapShader = _getCubemapShader();
            }
            this._cubemapShader.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
          } else {
            if (this._equirectShader === null) {
              this._equirectShader = _getEquirectShader();
            }
          }
          const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
          const mesh = new Mesh(_lodPlanes[0], material);
          const uniforms = material.uniforms;
          uniforms["envMap"].value = texture;
          if (!isCubeTexture) {
            uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
          }
          _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera);
        }
        _applyPMREM(cubeUVRenderTarget) {
          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;
          for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
            const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
            const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
          }
          renderer.autoClear = autoClear;
        }
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
          const pingPongRenderTarget = this._pingPongRenderTarget;
          this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
          this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;
          if (direction !== "latitudinal" && direction !== "longitudinal") {
            console.error("blur direction must be either latitudinal or longitudinal!");
          }
          const STANDARD_DEVIATIONS = 3;
          const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;
          const pixels = _sizeLods[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
          if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
          }
          const weights = [];
          let sum = 0;
          for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
            const x2 = i2 / sigmaPixels;
            const weight = Math.exp(-x2 * x2 / 2);
            weights.push(weight);
            if (i2 === 0) {
              sum += weight;
            } else if (i2 < samples) {
              sum += 2 * weight;
            }
          }
          for (let i2 = 0; i2 < weights.length; i2++) {
            weights[i2] = weights[i2] / sum;
          }
          blurUniforms["envMap"].value = targetIn.texture;
          blurUniforms["samples"].value = samples;
          blurUniforms["weights"].value = weights;
          blurUniforms["latitudinal"].value = direction === "latitudinal";
          if (poleAxis) {
            blurUniforms["poleAxis"].value = poleAxis;
          }
          blurUniforms["dTheta"].value = radiansPerPixel;
          blurUniforms["mipInt"].value = LOD_MAX - lodIn;
          const outputSize = _sizeLods[lodOut];
          const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
          const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
          _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera);
        }
      };
      DataTexture2DArray = class extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = { data, width, height, depth };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataTexture2DArray.prototype.isDataTexture2DArray = true;
      DataTexture3D = class extends Texture {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = { data, width, height, depth };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataTexture3D.prototype.isDataTexture3D = true;
      emptyTexture = new Texture();
      emptyTexture2dArray = new DataTexture2DArray();
      emptyTexture3d = new DataTexture3D();
      emptyCubeTexture = new CubeTexture();
      arrayCacheF32 = [];
      arrayCacheI32 = [];
      mat4array = new Float32Array(16);
      mat3array = new Float32Array(9);
      mat2array = new Float32Array(4);
      PureArrayUniform.prototype.updateCache = function(data) {
        const cache = this.cache;
        if (data instanceof Float32Array && cache.length !== data.length) {
          this.cache = new Float32Array(data.length);
        }
        copyArray(cache, data);
      };
      StructuredUniform.prototype.setValue = function(gl, value, textures) {
        const seq = this.seq;
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2];
          u.setValue(gl, value[u.id], textures);
        }
      };
      RePathPart = /(\w+)(\])?(\[|\.)?/g;
      WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
        const u = this.map[name];
        if (u !== void 0)
          u.setValue(gl, value, textures);
      };
      WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        const v = object[name];
        if (v !== void 0)
          this.setValue(gl, name, v);
      };
      WebGLUniforms.upload = function(gl, seq, values, textures) {
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2], v = values[u.id];
          if (v.needsUpdate !== false) {
            u.setValue(gl, v.value, textures);
          }
        }
      };
      WebGLUniforms.seqWithValue = function(seq, values) {
        const r = [];
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2];
          if (u.id in values)
            r.push(u);
        }
        return r;
      };
      programIdCount = 0;
      includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
      deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
      unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      _id = 0;
      WebGLShaderCache = class {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map();
          this.materialCache = /* @__PURE__ */ new Map();
        }
        update(material) {
          const vertexShader = material.vertexShader;
          const fragmentShader = material.fragmentShader;
          const vertexShaderStage = this._getShaderStage(vertexShader);
          const fragmentShaderStage = this._getShaderStage(fragmentShader);
          const materialShaders = this._getShaderCacheForMaterial(material);
          if (materialShaders.has(vertexShaderStage) === false) {
            materialShaders.add(vertexShaderStage);
            vertexShaderStage.usedTimes++;
          }
          if (materialShaders.has(fragmentShaderStage) === false) {
            materialShaders.add(fragmentShaderStage);
            fragmentShaderStage.usedTimes++;
          }
          return this;
        }
        remove(material) {
          const materialShaders = this.materialCache.get(material);
          for (const shaderStage of materialShaders) {
            shaderStage.usedTimes--;
            if (shaderStage.usedTimes === 0)
              this.shaderCache.delete(shaderStage);
          }
          this.materialCache.delete(material);
          return this;
        }
        getVertexShaderID(material) {
          return this._getShaderStage(material.vertexShader).id;
        }
        getFragmentShaderID(material) {
          return this._getShaderStage(material.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear();
          this.materialCache.clear();
        }
        _getShaderCacheForMaterial(material) {
          const cache = this.materialCache;
          if (cache.has(material) === false) {
            cache.set(material, /* @__PURE__ */ new Set());
          }
          return cache.get(material);
        }
        _getShaderStage(code) {
          const cache = this.shaderCache;
          if (cache.has(code) === false) {
            const stage = new WebGLShaderStage();
            cache.set(code, stage);
          }
          return cache.get(code);
        }
      };
      WebGLShaderStage = class {
        constructor() {
          this.id = _id++;
          this.usedTimes = 0;
        }
      };
      nextVersion = 0;
      MeshDepthMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDepthMaterial";
          this.depthPacking = BasicDepthPacking;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.depthPacking = source.depthPacking;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          return this;
        }
      };
      MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
      MeshDistanceMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new Vector3();
          this.nearDistance = 1;
          this.farDistance = 1e3;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.referencePosition.copy(source.referencePosition);
          this.nearDistance = source.nearDistance;
          this.farDistance = source.farDistance;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          return this;
        }
      };
      MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
      vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
      fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      ArrayCamera = class extends PerspectiveCamera {
        constructor(array = []) {
          super();
          this.cameras = array;
        }
      };
      ArrayCamera.prototype.isArrayCamera = true;
      Group = class extends Object3D {
        constructor() {
          super();
          this.type = "Group";
        }
      };
      Group.prototype.isGroup = true;
      _moveEvent = { type: "move" };
      WebXRController = class {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = { pinching: false };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector3();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector3();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector3();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector3();
          }
          return this._grip;
        }
        dispatchEvent(event) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(event);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(event);
          }
          return this;
        }
        disconnect(inputSource) {
          this.dispatchEvent({ type: "disconnected", data: inputSource });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(inputSource, frame, referenceSpace) {
          let inputPose = null;
          let gripPose = null;
          let handPose = null;
          const targetRay = this._targetRay;
          const grip = this._grip;
          const hand = this._hand;
          if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                if (inputPose.linearVelocity) {
                  targetRay.hasLinearVelocity = true;
                  targetRay.linearVelocity.copy(inputPose.linearVelocity);
                } else {
                  targetRay.hasLinearVelocity = false;
                }
                if (inputPose.angularVelocity) {
                  targetRay.hasAngularVelocity = true;
                  targetRay.angularVelocity.copy(inputPose.angularVelocity);
                } else {
                  targetRay.hasAngularVelocity = false;
                }
                this.dispatchEvent(_moveEvent);
              }
            }
            if (hand && inputSource.hand) {
              handPose = true;
              for (const inputjoint of inputSource.hand.values()) {
                const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                if (hand.joints[inputjoint.jointName] === void 0) {
                  const joint2 = new Group();
                  joint2.matrixAutoUpdate = false;
                  joint2.visible = false;
                  hand.joints[inputjoint.jointName] = joint2;
                  hand.add(joint2);
                }
                const joint = hand.joints[inputjoint.jointName];
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
              }
              const indexTip = hand.joints["index-finger-tip"];
              const thumbTip = hand.joints["thumb-tip"];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            } else {
              if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                  grip.matrix.fromArray(gripPose.transform.matrix);
                  grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                  if (gripPose.linearVelocity) {
                    grip.hasLinearVelocity = true;
                    grip.linearVelocity.copy(gripPose.linearVelocity);
                  } else {
                    grip.hasLinearVelocity = false;
                  }
                  if (gripPose.angularVelocity) {
                    grip.hasAngularVelocity = true;
                    grip.angularVelocity.copy(gripPose.angularVelocity);
                  } else {
                    grip.hasAngularVelocity = false;
                  }
                }
              }
            }
          }
          if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
          }
          if (grip !== null) {
            grip.visible = gripPose !== null;
          }
          if (hand !== null) {
            hand.visible = handPose !== null;
          }
          return this;
        }
      };
      DepthTexture = class extends Texture {
        constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
          format = format !== void 0 ? format : DepthFormat;
          if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (type === void 0 && format === DepthFormat)
            type = UnsignedShortType;
          if (type === void 0 && format === DepthStencilFormat)
            type = UnsignedInt248Type;
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.image = { width, height };
          this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
          this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      DepthTexture.prototype.isDepthTexture = true;
      WebXRManager = class extends EventDispatcher {
        constructor(renderer, gl) {
          super();
          const scope = this;
          let session = null;
          let framebufferScaleFactor = 1;
          let referenceSpace = null;
          let referenceSpaceType = "local-floor";
          const hasMultisampledRenderToTexture = renderer.extensions.has("WEBGL_multisampled_render_to_texture");
          let pose = null;
          let glBinding = null;
          let glProjLayer = null;
          let glBaseLayer = null;
          let isMultisample = false;
          let xrFrame = null;
          const attributes = gl.getContextAttributes();
          let initialRenderTarget = null;
          let newRenderTarget = null;
          const controllers = [];
          const inputSourcesMap = /* @__PURE__ */ new Map();
          const cameraL = new PerspectiveCamera();
          cameraL.layers.enable(1);
          cameraL.viewport = new Vector4();
          const cameraR = new PerspectiveCamera();
          cameraR.layers.enable(2);
          cameraR.viewport = new Vector4();
          const cameras = [cameraL, cameraR];
          const cameraVR = new ArrayCamera();
          cameraVR.layers.enable(1);
          cameraVR.layers.enable(2);
          let _currentDepthNear = null;
          let _currentDepthFar = null;
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
          };
          this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getGripSpace();
          };
          this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getHandSpace();
          };
          function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller) {
              controller.dispatchEvent({ type: event.type, data: event.inputSource });
            }
          }
          function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
              controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            renderer.setRenderTarget(initialRenderTarget);
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            newRenderTarget = null;
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({ type: "sessionend" });
          }
          this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function() {
            return referenceSpace;
          };
          this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
          };
          this.getBinding = function() {
            return glBinding;
          };
          this.getFrame = function() {
            return xrFrame;
          };
          this.getSession = function() {
            return session;
          };
          this.setSession = async function(value) {
            session = value;
            if (session !== null) {
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              if (attributes.xrCompatible !== true) {
                await gl.makeXRCompatible();
              }
              if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
                const layerInit = {
                  antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({ baseLayer: glBaseLayer });
                newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  encoding: renderer.outputEncoding
                });
              } else {
                isMultisample = attributes.antialias;
                let depthFormat = null;
                let depthType = null;
                let glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? 35056 : 33190;
                  depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                  depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
                }
                const projectionlayerInit = {
                  colorFormat: renderer.outputEncoding === sRGBEncoding ? 35907 : 32856,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({ layers: [glProjLayer] });
                if (isMultisample) {
                  newRenderTarget = new WebGLMultisampleRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    ignoreDepth: glProjLayer.ignoreDepthValues,
                    useRenderToTexture: hasMultisampledRenderToTexture,
                    encoding: renderer.outputEncoding
                  });
                } else {
                  newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    ignoreDepth: glProjLayer.ignoreDepthValues,
                    encoding: renderer.outputEncoding
                  });
                }
              }
              newRenderTarget.isXRRenderTarget = true;
              this.setFoveation(1);
              referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({ type: "sessionstart" });
            }
          };
          function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              inputSourcesMap.set(inputSources[i2], controllers[i2]);
            }
            for (let i2 = 0; i2 < event.removed.length; i2++) {
              const inputSource = event.removed[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({ type: "disconnected", data: inputSource });
                inputSourcesMap.delete(inputSource);
              }
            }
            for (let i2 = 0; i2 < event.added.length; i2++) {
              const inputSource = event.added[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({ type: "connected", data: inputSource });
              }
            }
          }
          const cameraLPos = new Vector3();
          const cameraRPos = new Vector3();
          function setProjectionFromUnion(camera, cameraL2, cameraR2) {
            cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL2.projectionMatrix.elements;
            const projR = cameraR2.projectionMatrix.elements;
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          }
          function updateCamera(camera, parent) {
            if (parent === null) {
              camera.matrixWorld.copy(camera.matrix);
            } else {
              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          }
          this.updateCamera = function(camera) {
            if (session === null)
              return;
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
              session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
              });
              _currentDepthNear = cameraVR.near;
              _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras2 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for (let i2 = 0; i2 < cameras2.length; i2++) {
              updateCamera(cameras2[i2], parent);
            }
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for (let i2 = 0, l = children.length; i2 < l; i2++) {
              children[i2].updateMatrixWorld(true);
            }
            if (cameras2.length === 2) {
              setProjectionFromUnion(cameraVR, cameraL, cameraR);
            } else {
              cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
          };
          this.getCamera = function() {
            return cameraVR;
          };
          this.getFoveation = function() {
            if (glProjLayer !== null) {
              return glProjLayer.fixedFoveation;
            }
            if (glBaseLayer !== null) {
              return glBaseLayer.fixedFoveation;
            }
            return void 0;
          };
          this.setFoveation = function(foveation) {
            if (glProjLayer !== null) {
              glProjLayer.fixedFoveation = foveation;
            }
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
              glBaseLayer.fixedFoveation = foveation;
            }
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
              const views = pose.views;
              if (glBaseLayer !== null) {
                renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                renderer.setRenderTarget(newRenderTarget);
              }
              let cameraVRNeedsUpdate = false;
              if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
              }
              for (let i2 = 0; i2 < views.length; i2++) {
                const view = views[i2];
                let viewport = null;
                if (glBaseLayer !== null) {
                  viewport = glBaseLayer.getViewport(view);
                } else {
                  const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                  viewport = glSubImage.viewport;
                  if (i2 === 0) {
                    renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
                    renderer.setRenderTarget(newRenderTarget);
                  }
                }
                const camera = cameras[i2];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i2 === 0) {
                  cameraVR.matrix.copy(camera.matrix);
                }
                if (cameraVRNeedsUpdate === true) {
                  cameraVR.cameras.push(camera);
                }
              }
            }
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              const controller = controllers[i2];
              const inputSource = inputSources[i2];
              controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time, frame);
            xrFrame = null;
          }
          const animation = new WebGLAnimation();
          animation.setAnimationLoop(onAnimationFrame);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
          };
          this.dispose = function() {
          };
        }
      };
      WebGLRenderer.prototype.isWebGLRenderer = true;
      WebGL1Renderer = class extends WebGLRenderer {
      };
      WebGL1Renderer.prototype.isWebGL1Renderer = true;
      FogExp2 = class {
        constructor(color, density = 25e-5) {
          this.name = "";
          this.color = new Color(color);
          this.density = density;
        }
        clone() {
          return new FogExp2(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      };
      FogExp2.prototype.isFogExp2 = true;
      Fog = class {
        constructor(color, near = 1, far = 1e3) {
          this.name = "";
          this.color = new Color(color);
          this.near = near;
          this.far = far;
        }
        clone() {
          return new Fog(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      };
      Fog.prototype.isFog = true;
      Scene = class extends Object3D {
        constructor() {
          super();
          this.type = "Scene";
          this.background = null;
          this.environment = null;
          this.fog = null;
          this.overrideMaterial = null;
          this.autoUpdate = true;
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.background !== null)
            this.background = source.background.clone();
          if (source.environment !== null)
            this.environment = source.environment.clone();
          if (source.fog !== null)
            this.fog = source.fog.clone();
          if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
          this.autoUpdate = source.autoUpdate;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.fog !== null)
            data.object.fog = this.fog.toJSON();
          return data;
        }
      };
      Scene.prototype.isScene = true;
      InterleavedBuffer = class {
        constructor(array, stride) {
          this.array = array;
          this.stride = stride;
          this.count = array !== void 0 ? array.length / stride : 0;
          this.usage = StaticDrawUsage;
          this.updateRange = { offset: 0, count: -1 };
          this.version = 0;
          this.uuid = generateUUID();
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.stride;
          index2 *= attribute.stride;
          for (let i2 = 0, l = this.stride; i2 < l; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        clone(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
          }
          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
          const ib = new this.constructor(array, this.stride);
          ib.setUsage(this.usage);
          return ib;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        toJSON(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
          }
          return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      };
      InterleavedBuffer.prototype.isInterleavedBuffer = true;
      _vector$6 = /* @__PURE__ */ new Vector3();
      InterleavedBufferAttribute = class {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
          this.name = "";
          this.data = interleavedBuffer;
          this.itemSize = itemSize;
          this.offset = offset;
          this.normalized = normalized === true;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(value) {
          this.data.needsUpdate = value;
        }
        applyMatrix4(m) {
          for (let i2 = 0, l = this.data.count; i2 < l; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.applyMatrix4(m);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.applyNormalMatrix(m);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$6.x = this.getX(i2);
            _vector$6.y = this.getY(i2);
            _vector$6.z = this.getZ(i2);
            _vector$6.transformDirection(m);
            this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        setX(index, x) {
          this.data.array[index * this.data.stride + this.offset] = x;
          return this;
        }
        setY(index, y) {
          this.data.array[index * this.data.stride + this.offset + 1] = y;
          return this;
        }
        setZ(index, z) {
          this.data.array[index * this.data.stride + this.offset + 2] = z;
          return this;
        }
        setW(index, w) {
          this.data.array[index * this.data.stride + this.offset + 3] = w;
          return this;
        }
        getX(index) {
          return this.data.array[index * this.data.stride + this.offset];
        }
        getY(index) {
          return this.data.array[index * this.data.stride + this.offset + 1];
        }
        getZ(index) {
          return this.data.array[index * this.data.stride + this.offset + 2];
        }
        getW(index) {
          return this.data.array[index * this.data.stride + this.offset + 3];
        }
        setXY(index, x, y) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x, y, z) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x, y, z, w) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          this.data.array[index + 3] = w;
          return this;
        }
        clone(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
          }
        }
        toJSON(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array,
              normalized: this.normalized
            };
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
              isInterleavedBufferAttribute: true,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized
            };
          }
        }
      };
      InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
      SpriteMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "SpriteMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.rotation = 0;
          this.sizeAttenuation = true;
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.rotation = source.rotation;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      };
      SpriteMaterial.prototype.isSpriteMaterial = true;
      _intersectPoint = /* @__PURE__ */ new Vector3();
      _worldScale = /* @__PURE__ */ new Vector3();
      _mvPosition = /* @__PURE__ */ new Vector3();
      _alignedPosition = /* @__PURE__ */ new Vector2();
      _rotatedPosition = /* @__PURE__ */ new Vector2();
      _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
      _vA = /* @__PURE__ */ new Vector3();
      _vB = /* @__PURE__ */ new Vector3();
      _vC = /* @__PURE__ */ new Vector3();
      _uvA = /* @__PURE__ */ new Vector2();
      _uvB = /* @__PURE__ */ new Vector2();
      _uvC = /* @__PURE__ */ new Vector2();
      Sprite = class extends Object3D {
        constructor(material) {
          super();
          this.type = "Sprite";
          if (_geometry === void 0) {
            _geometry = new BufferGeometry();
            const float32Array = new Float32Array([
              -0.5,
              -0.5,
              0,
              0,
              0,
              0.5,
              -0.5,
              0,
              1,
              0,
              0.5,
              0.5,
              0,
              1,
              1,
              -0.5,
              0.5,
              0,
              0,
              1
            ]);
            const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
            _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
          }
          this.geometry = _geometry;
          this.material = material !== void 0 ? material : new SpriteMaterial();
          this.center = new Vector2(0.5, 0.5);
        }
        raycast(raycaster, intersects2) {
          if (raycaster.camera === null) {
            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
          }
          _worldScale.setFromMatrixScale(this.matrixWorld);
          _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
          this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
          _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
          if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
            _worldScale.multiplyScalar(-_mvPosition.z);
          }
          const rotation = this.material.rotation;
          let sin, cos;
          if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
          }
          const center = this.center;
          transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvA.set(0, 0);
          _uvB.set(1, 0);
          _uvC.set(1, 1);
          let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
          if (intersect === null) {
            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
            if (intersect === null) {
              return;
            }
          }
          const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
            face: null,
            object: this
          });
        }
        copy(source) {
          super.copy(source);
          if (source.center !== void 0)
            this.center.copy(source.center);
          this.material = source.material;
          return this;
        }
      };
      Sprite.prototype.isSprite = true;
      _basePosition = /* @__PURE__ */ new Vector3();
      _skinIndex = /* @__PURE__ */ new Vector4();
      _skinWeight = /* @__PURE__ */ new Vector4();
      _vector$5 = /* @__PURE__ */ new Vector3();
      _matrix = /* @__PURE__ */ new Matrix4();
      SkinnedMesh = class extends Mesh {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "SkinnedMesh";
          this.bindMode = "attached";
          this.bindMatrix = new Matrix4();
          this.bindMatrixInverse = new Matrix4();
        }
        copy(source) {
          super.copy(source);
          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);
          this.skeleton = source.skeleton;
          return this;
        }
        bind(skeleton, bindMatrix) {
          this.skeleton = skeleton;
          if (bindMatrix === void 0) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
          }
          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const vector = new Vector4();
          const skinWeight = this.geometry.attributes.skinWeight;
          for (let i2 = 0, l = skinWeight.count; i2 < l; i2++) {
            vector.x = skinWeight.getX(i2);
            vector.y = skinWeight.getY(i2);
            vector.z = skinWeight.getZ(i2);
            vector.w = skinWeight.getW(i2);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) {
              vector.multiplyScalar(scale);
            } else {
              vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
          }
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.bindMode === "attached") {
            this.bindMatrixInverse.copy(this.matrixWorld).invert();
          } else if (this.bindMode === "detached") {
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
          } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
        }
        boneTransform(index, target) {
          const skeleton = this.skeleton;
          const geometry = this.geometry;
          _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
          _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
          _basePosition.copy(target).applyMatrix4(this.bindMatrix);
          target.set(0, 0, 0);
          for (let i2 = 0; i2 < 4; i2++) {
            const weight = _skinWeight.getComponent(i2);
            if (weight !== 0) {
              const boneIndex = _skinIndex.getComponent(i2);
              _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
            }
          }
          return target.applyMatrix4(this.bindMatrixInverse);
        }
      };
      SkinnedMesh.prototype.isSkinnedMesh = true;
      Bone = class extends Object3D {
        constructor() {
          super();
          this.type = "Bone";
        }
      };
      Bone.prototype.isBone = true;
      DataTexture = class extends Texture {
        constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.image = { data, width, height };
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataTexture.prototype.isDataTexture = true;
      _offsetMatrix = /* @__PURE__ */ new Matrix4();
      _identityMatrix = /* @__PURE__ */ new Matrix4();
      Skeleton = class {
        constructor(bones = [], boneInverses = []) {
          this.uuid = generateUUID();
          this.bones = bones.slice(0);
          this.boneInverses = boneInverses;
          this.boneMatrices = null;
          this.boneTexture = null;
          this.boneTextureSize = 0;
          this.frame = -1;
          this.init();
        }
        init() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          this.boneMatrices = new Float32Array(bones.length * 16);
          if (boneInverses.length === 0) {
            this.calculateInverses();
          } else {
            if (bones.length !== boneInverses.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
              this.boneInverses = [];
              for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
                this.boneInverses.push(new Matrix4());
              }
            }
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const inverse = new Matrix4();
            if (this.bones[i2]) {
              inverse.copy(this.bones[i2].matrixWorld).invert();
            }
            this.boneInverses.push(inverse);
          }
        }
        pose() {
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              bone.matrixWorld.copy(this.boneInverses[i2]).invert();
            }
          }
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              if (bone.parent && bone.parent.isBone) {
                bone.matrix.copy(bone.parent.matrixWorld).invert();
                bone.matrix.multiply(bone.matrixWorld);
              } else {
                bone.matrix.copy(bone.matrixWorld);
              }
              bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
          }
        }
        update() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;
          for (let i2 = 0, il = bones.length; i2 < il; i2++) {
            const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
            _offsetMatrix.toArray(boneMatrices, i2 * 16);
          }
          if (boneTexture !== null) {
            boneTexture.needsUpdate = true;
          }
        }
        clone() {
          return new Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let size = Math.sqrt(this.bones.length * 4);
          size = ceilPowerOfTwo(size);
          size = Math.max(size, 4);
          const boneMatrices = new Float32Array(size * size * 4);
          boneMatrices.set(this.boneMatrices);
          const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
          boneTexture.needsUpdate = true;
          this.boneMatrices = boneMatrices;
          this.boneTexture = boneTexture;
          this.boneTextureSize = size;
          return this;
        }
        getBoneByName(name) {
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone.name === name) {
              return bone;
            }
          }
          return void 0;
        }
        dispose() {
          if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
          }
        }
        fromJSON(json, bones) {
          this.uuid = json.uuid;
          for (let i2 = 0, l = json.bones.length; i2 < l; i2++) {
            const uuid = json.bones[i2];
            let bone = bones[uuid];
            if (bone === void 0) {
              console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
              bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
          }
          this.init();
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          data.uuid = this.uuid;
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          for (let i2 = 0, l = bones.length; i2 < l; i2++) {
            const bone = bones[i2];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i2];
            data.boneInverses.push(boneInverse.toArray());
          }
          return data;
        }
      };
      InstancedBufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
          if (typeof normalized === "number") {
            meshPerAttribute = normalized;
            normalized = false;
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
          }
          super(array, itemSize, normalized);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.meshPerAttribute = this.meshPerAttribute;
          data.isInstancedBufferAttribute = true;
          return data;
        }
      };
      InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
      _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
      _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
      _instanceIntersects = [];
      _mesh = /* @__PURE__ */ new Mesh();
      InstancedMesh = class extends Mesh {
        constructor(geometry, material, count) {
          super(geometry, material);
          this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
          this.instanceColor = null;
          this.count = count;
          this.frustumCulled = false;
        }
        copy(source) {
          super.copy(source);
          this.instanceMatrix.copy(source.instanceMatrix);
          if (source.instanceColor !== null)
            this.instanceColor = source.instanceColor.clone();
          this.count = source.count;
          return this;
        }
        getColorAt(index, color) {
          color.fromArray(this.instanceColor.array, index * 3);
        }
        getMatrixAt(index, matrix) {
          matrix.fromArray(this.instanceMatrix.array, index * 16);
        }
        raycast(raycaster, intersects2) {
          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;
          _mesh.geometry = this.geometry;
          _mesh.material = this.material;
          if (_mesh.material === void 0)
            return;
          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for (let i2 = 0, l = _instanceIntersects.length; i2 < l; i2++) {
              const intersect = _instanceIntersects[i2];
              intersect.instanceId = instanceId;
              intersect.object = this;
              intersects2.push(intersect);
            }
            _instanceIntersects.length = 0;
          }
        }
        setColorAt(index, color) {
          if (this.instanceColor === null) {
            this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
          }
          color.toArray(this.instanceColor.array, index * 3);
        }
        setMatrixAt(index, matrix) {
          matrix.toArray(this.instanceMatrix.array, index * 16);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      InstancedMesh.prototype.isInstancedMesh = true;
      LineBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "LineBasicMaterial";
          this.color = new Color(16777215);
          this.linewidth = 1;
          this.linecap = "round";
          this.linejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.linewidth = source.linewidth;
          this.linecap = source.linecap;
          this.linejoin = source.linejoin;
          return this;
        }
      };
      LineBasicMaterial.prototype.isLineBasicMaterial = true;
      _start$1 = /* @__PURE__ */ new Vector3();
      _end$1 = /* @__PURE__ */ new Vector3();
      _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
      _ray$1 = /* @__PURE__ */ new Ray();
      _sphere$1 = /* @__PURE__ */ new Sphere();
      Line = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
          super();
          this.type = "Line";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [0];
              for (let i2 = 1, l = positionAttribute.count; i2 < l; i2++) {
                _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
                _end$1.fromBufferAttribute(positionAttribute, i2);
                lineDistances[i2] = lineDistances[i2 - 1];
                lineDistances[i2] += _start$1.distanceTo(_end$1);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$1.copy(geometry.boundingSphere);
          _sphere$1.applyMatrix4(matrixWorld);
          _sphere$1.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere$1) === false)
            return;
          _inverseMatrix$1.copy(matrixWorld).invert();
          _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const vStart = new Vector3();
          const vEnd = new Vector3();
          const interSegment = new Vector3();
          const interRay = new Vector3();
          const step = this.isLineSegments ? 2 : 1;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
                const a = index.getX(i2);
                const b = index.getX(i2 + 1);
                vStart.fromBufferAttribute(positionAttribute, a);
                vEnd.fromBufferAttribute(positionAttribute, b);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
                vStart.fromBufferAttribute(positionAttribute, i2);
                vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects2.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      };
      Line.prototype.isLine = true;
      _start = /* @__PURE__ */ new Vector3();
      _end = /* @__PURE__ */ new Vector3();
      LineSegments = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineSegments";
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [];
              for (let i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2) {
                _start.fromBufferAttribute(positionAttribute, i2);
                _end.fromBufferAttribute(positionAttribute, i2 + 1);
                lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
                lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
            } else {
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
      };
      LineSegments.prototype.isLineSegments = true;
      LineLoop = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineLoop";
        }
      };
      LineLoop.prototype.isLineLoop = true;
      PointsMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "PointsMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.size = 1;
          this.sizeAttenuation = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.size = source.size;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      };
      PointsMaterial.prototype.isPointsMaterial = true;
      _inverseMatrix = /* @__PURE__ */ new Matrix4();
      _ray = /* @__PURE__ */ new Ray();
      _sphere = /* @__PURE__ */ new Sphere();
      _position$2 = /* @__PURE__ */ new Vector3();
      Points = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
          super();
          this.type = "Points";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere.copy(geometry.boundingSphere);
          _sphere.applyMatrix4(matrixWorld);
          _sphere.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere) === false)
            return;
          _inverseMatrix.copy(matrixWorld).invert();
          _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2++) {
                const a = index.getX(i2);
                _position$2.fromBufferAttribute(positionAttribute, a);
                testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end; i2 < l; i2++) {
                _position$2.fromBufferAttribute(positionAttribute, i2);
                testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            }
          } else {
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      };
      Points.prototype.isPoints = true;
      VideoTexture = class extends Texture {
        constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
          super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
          this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
          this.generateMipmaps = false;
          const scope = this;
          function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
          }
          if ("requestVideoFrameCallback" in video) {
            video.requestVideoFrameCallback(updateVideo);
          }
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const video = this.image;
          const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
          if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
            this.needsUpdate = true;
          }
        }
      };
      VideoTexture.prototype.isVideoTexture = true;
      FramebufferTexture = class extends Texture {
        constructor(width, height, format) {
          super({ width, height });
          this.format = format;
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.generateMipmaps = false;
          this.needsUpdate = true;
        }
      };
      FramebufferTexture.prototype.isFramebufferTexture = true;
      CompressedTexture = class extends Texture {
        constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.image = { width, height };
          this.mipmaps = mipmaps;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      CompressedTexture.prototype.isCompressedTexture = true;
      CanvasTexture = class extends Texture {
        constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
          super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.needsUpdate = true;
        }
      };
      CanvasTexture.prototype.isCanvasTexture = true;
      _v0 = new Vector3();
      _v1$1 = new Vector3();
      _normal = new Vector3();
      _triangle = new Triangle();
      Curve = class {
        constructor() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
          return null;
        }
        getPointAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getPoint(t, optionalTarget);
        }
        getPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPoint(d / divisions));
          }
          return points;
        }
        getSpacedPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPointAt(d / divisions));
          }
          return points;
        }
        getLength() {
          const lengths = this.getLengths();
          return lengths[lengths.length - 1];
        }
        getLengths(divisions = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          const cache = [];
          let current, last = this.getPoint(0);
          let sum = 0;
          cache.push(0);
          for (let p2 = 1; p2 <= divisions; p2++) {
            current = this.getPoint(p2 / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
          }
          this.cacheArcLengths = cache;
          return cache;
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.getLengths();
        }
        getUtoTmapping(u, distance) {
          const arcLengths = this.getLengths();
          let i2 = 0;
          const il = arcLengths.length;
          let targetArcLength;
          if (distance) {
            targetArcLength = distance;
          } else {
            targetArcLength = u * arcLengths[il - 1];
          }
          let low = 0, high = il - 1, comparison;
          while (low <= high) {
            i2 = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i2] - targetArcLength;
            if (comparison < 0) {
              low = i2 + 1;
            } else if (comparison > 0) {
              high = i2 - 1;
            } else {
              high = i2;
              break;
            }
          }
          i2 = high;
          if (arcLengths[i2] === targetArcLength) {
            return i2 / (il - 1);
          }
          const lengthBefore = arcLengths[i2];
          const lengthAfter = arcLengths[i2 + 1];
          const segmentLength = lengthAfter - lengthBefore;
          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          const t = (i2 + segmentFraction) / (il - 1);
          return t;
        }
        getTangent(t, optionalTarget) {
          const delta = 1e-4;
          let t1 = t - delta;
          let t2 = t + delta;
          if (t1 < 0)
            t1 = 0;
          if (t2 > 1)
            t2 = 1;
          const pt1 = this.getPoint(t1);
          const pt2 = this.getPoint(t2);
          const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
          tangent.copy(pt2).sub(pt1).normalize();
          return tangent;
        }
        getTangentAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getTangent(t, optionalTarget);
        }
        computeFrenetFrames(segments, closed) {
          const normal = new Vector3();
          const tangents = [];
          const normals = [];
          const binormals = [];
          const vec = new Vector3();
          const mat = new Matrix4();
          for (let i2 = 0; i2 <= segments; i2++) {
            const u = i2 / segments;
            tangents[i2] = this.getTangentAt(u, new Vector3());
          }
          normals[0] = new Vector3();
          binormals[0] = new Vector3();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);
          if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
          }
          if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
          }
          if (tz <= min) {
            normal.set(0, 0, 1);
          }
          vec.crossVectors(tangents[0], normal).normalize();
          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2] = normals[i2 - 1].clone();
            binormals[i2] = binormals[i2 - 1].clone();
            vec.crossVectors(tangents[i2 - 1], tangents[i2]);
            if (vec.length() > Number.EPSILON) {
              vec.normalize();
              const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
              normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
          if (closed === true) {
            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
              theta = -theta;
            }
            for (let i2 = 1; i2 <= segments; i2++) {
              normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
              binormals[i2].crossVectors(tangents[i2], normals[i2]);
            }
          }
          return {
            tangents,
            normals,
            binormals
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.arcLengthDivisions = source.arcLengthDivisions;
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;
          return data;
        }
        fromJSON(json) {
          this.arcLengthDivisions = json.arcLengthDivisions;
          return this;
        }
      };
      EllipseCurve = class extends Curve {
        constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
          super();
          this.type = "EllipseCurve";
          this.aX = aX;
          this.aY = aY;
          this.xRadius = xRadius;
          this.yRadius = yRadius;
          this.aStartAngle = aStartAngle;
          this.aEndAngle = aEndAngle;
          this.aClockwise = aClockwise;
          this.aRotation = aRotation;
        }
        getPoint(t, optionalTarget) {
          const point = optionalTarget || new Vector2();
          const twoPi = Math.PI * 2;
          let deltaAngle = this.aEndAngle - this.aStartAngle;
          const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
          while (deltaAngle < 0)
            deltaAngle += twoPi;
          while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
          if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
              deltaAngle = 0;
            } else {
              deltaAngle = twoPi;
            }
          }
          if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
              deltaAngle = -twoPi;
            } else {
              deltaAngle = deltaAngle - twoPi;
            }
          }
          const angle = this.aStartAngle + t * deltaAngle;
          let x = this.aX + this.xRadius * Math.cos(angle);
          let y = this.aY + this.yRadius * Math.sin(angle);
          if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x - this.aX;
            const ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
          }
          return point.set(x, y);
        }
        copy(source) {
          super.copy(source);
          this.aX = source.aX;
          this.aY = source.aY;
          this.xRadius = source.xRadius;
          this.yRadius = source.yRadius;
          this.aStartAngle = source.aStartAngle;
          this.aEndAngle = source.aEndAngle;
          this.aClockwise = source.aClockwise;
          this.aRotation = source.aRotation;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.aX = this.aX;
          data.aY = this.aY;
          data.xRadius = this.xRadius;
          data.yRadius = this.yRadius;
          data.aStartAngle = this.aStartAngle;
          data.aEndAngle = this.aEndAngle;
          data.aClockwise = this.aClockwise;
          data.aRotation = this.aRotation;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.aX = json.aX;
          this.aY = json.aY;
          this.xRadius = json.xRadius;
          this.yRadius = json.yRadius;
          this.aStartAngle = json.aStartAngle;
          this.aEndAngle = json.aEndAngle;
          this.aClockwise = json.aClockwise;
          this.aRotation = json.aRotation;
          return this;
        }
      };
      EllipseCurve.prototype.isEllipseCurve = true;
      ArcCurve = class extends EllipseCurve {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          this.type = "ArcCurve";
        }
      };
      ArcCurve.prototype.isArcCurve = true;
      tmp = new Vector3();
      px = new CubicPoly();
      py = new CubicPoly();
      pz = new CubicPoly();
      CatmullRomCurve3 = class extends Curve {
        constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
          super();
          this.type = "CatmullRomCurve3";
          this.points = points;
          this.closed = closed;
          this.curveType = curveType;
          this.tension = tension;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const points = this.points;
          const l = points.length;
          const p2 = (l - (this.closed ? 0 : 1)) * t;
          let intPoint = Math.floor(p2);
          let weight = p2 - intPoint;
          if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
          } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
          }
          let p0, p3;
          if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
          } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
          }
          const p1 = points[intPoint % l];
          const p22 = points[(intPoint + 1) % l];
          if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
          } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
          }
          if (this.curveType === "centripetal" || this.curveType === "chordal") {
            const pow = this.curveType === "chordal" ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
            let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
            if (dt1 < 1e-4)
              dt1 = 1;
            if (dt0 < 1e-4)
              dt0 = dt1;
            if (dt2 < 1e-4)
              dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
          } else if (this.curveType === "catmullrom") {
            px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
          }
          point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          this.closed = source.closed;
          this.curveType = source.curveType;
          this.tension = source.tension;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          data.closed = this.closed;
          data.curveType = this.curveType;
          data.tension = this.tension;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector3().fromArray(point));
          }
          this.closed = json.closed;
          this.curveType = json.curveType;
          this.tension = json.tension;
          return this;
        }
      };
      CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
      CubicBezierCurve = class extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
          super();
          this.type = "CubicBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      CubicBezierCurve.prototype.isCubicBezierCurve = true;
      CubicBezierCurve3 = class extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
          super();
          this.type = "CubicBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
      LineCurve = class extends Curve {
        constructor(v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.type = "LineCurve";
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        getTangent(t, optionalTarget) {
          const tangent = optionalTarget || new Vector2();
          tangent.copy(this.v2).sub(this.v1).normalize();
          return tangent;
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      LineCurve.prototype.isLineCurve = true;
      LineCurve3 = class extends Curve {
        constructor(v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.type = "LineCurve3";
          this.isLineCurve3 = true;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve = class extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.type = "QuadraticBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
      QuadraticBezierCurve3 = class extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.type = "QuadraticBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
      SplineCurve = class extends Curve {
        constructor(points = []) {
          super();
          this.type = "SplineCurve";
          this.points = points;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const points = this.points;
          const p2 = (points.length - 1) * t;
          const intPoint = Math.floor(p2);
          const weight = p2 - intPoint;
          const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
          const p1 = points[intPoint];
          const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
          const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
          point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector2().fromArray(point));
          }
          return this;
        }
      };
      SplineCurve.prototype.isSplineCurve = true;
      Curves = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcCurve,
        CatmullRomCurve3,
        CubicBezierCurve,
        CubicBezierCurve3,
        EllipseCurve,
        LineCurve,
        LineCurve3,
        QuadraticBezierCurve,
        QuadraticBezierCurve3,
        SplineCurve
      });
      CurvePath = class extends Curve {
        constructor() {
          super();
          this.type = "CurvePath";
          this.curves = [];
          this.autoClose = false;
        }
        add(curve) {
          this.curves.push(curve);
        }
        closePath() {
          const startPoint = this.curves[0].getPoint(0);
          const endPoint = this.curves[this.curves.length - 1].getPoint(1);
          if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
          }
        }
        getPoint(t, optionalTarget) {
          const d = t * this.getLength();
          const curveLengths = this.getCurveLengths();
          let i2 = 0;
          while (i2 < curveLengths.length) {
            if (curveLengths[i2] >= d) {
              const diff = curveLengths[i2] - d;
              const curve = this.curves[i2];
              const segmentLength = curve.getLength();
              const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
              return curve.getPointAt(u, optionalTarget);
            }
            i2++;
          }
          return null;
        }
        getLength() {
          const lens = this.getCurveLengths();
          return lens[lens.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.cacheLengths = null;
          this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
          }
          const lengths = [];
          let sums = 0;
          for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
            sums += this.curves[i2].getLength();
            lengths.push(sums);
          }
          this.cacheLengths = lengths;
          return lengths;
        }
        getSpacedPoints(divisions = 40) {
          const points = [];
          for (let i2 = 0; i2 <= divisions; i2++) {
            points.push(this.getPoint(i2 / divisions));
          }
          if (this.autoClose) {
            points.push(points[0]);
          }
          return points;
        }
        getPoints(divisions = 12) {
          const points = [];
          let last;
          for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
            const curve = curves[i2];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for (let j = 0; j < pts.length; j++) {
              const point = pts[j];
              if (last && last.equals(point))
                continue;
              points.push(point);
              last = point;
            }
          }
          if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
          }
          return points;
        }
        copy(source) {
          super.copy(source);
          this.curves = [];
          for (let i2 = 0, l = source.curves.length; i2 < l; i2++) {
            const curve = source.curves[i2];
            this.curves.push(curve.clone());
          }
          this.autoClose = source.autoClose;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.autoClose = this.autoClose;
          data.curves = [];
          for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
            const curve = this.curves[i2];
            data.curves.push(curve.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.autoClose = json.autoClose;
          this.curves = [];
          for (let i2 = 0, l = json.curves.length; i2 < l; i2++) {
            const curve = json.curves[i2];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
          }
          return this;
        }
      };
      Path = class extends CurvePath {
        constructor(points) {
          super();
          this.type = "Path";
          this.currentPoint = new Vector2();
          if (points) {
            this.setFromPoints(points);
          }
        }
        setFromPoints(points) {
          this.moveTo(points[0].x, points[0].y);
          for (let i2 = 1, l = points.length; i2 < l; i2++) {
            this.lineTo(points[i2].x, points[i2].y);
          }
          return this;
        }
        moveTo(x, y) {
          this.currentPoint.set(x, y);
          return this;
        }
        lineTo(x, y) {
          const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
          this.curves.push(curve);
          this.currentPoint.set(x, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        splineThru(pts) {
          const npts = [this.currentPoint.clone()].concat(pts);
          const curve = new SplineCurve(npts);
          this.curves.push(curve);
          this.currentPoint.copy(pts[pts.length - 1]);
          return this;
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          return this;
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
              this.lineTo(firstPoint.x, firstPoint.y);
            }
          }
          this.curves.push(curve);
          const lastPoint = curve.getPoint(1);
          this.currentPoint.copy(lastPoint);
          return this;
        }
        copy(source) {
          super.copy(source);
          this.currentPoint.copy(source.currentPoint);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.currentPoint = this.currentPoint.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.currentPoint.fromArray(json.currentPoint);
          return this;
        }
      };
      Shape = class extends Path {
        constructor(points) {
          super(points);
          this.uuid = generateUUID();
          this.type = "Shape";
          this.holes = [];
        }
        getPointsHoles(divisions) {
          const holesPts = [];
          for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
            holesPts[i2] = this.holes[i2].getPoints(divisions);
          }
          return holesPts;
        }
        extractPoints(divisions) {
          return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
          };
        }
        copy(source) {
          super.copy(source);
          this.holes = [];
          for (let i2 = 0, l = source.holes.length; i2 < l; i2++) {
            const hole = source.holes[i2];
            this.holes.push(hole.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.uuid = this.uuid;
          data.holes = [];
          for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
            const hole = this.holes[i2];
            data.holes.push(hole.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.uuid = json.uuid;
          this.holes = [];
          for (let i2 = 0, l = json.holes.length; i2 < l; i2++) {
            const hole = json.holes[i2];
            this.holes.push(new Path().fromJSON(hole));
          }
          return this;
        }
      };
      Earcut = {
        triangulate: function(data, holeIndices, dim = 2) {
          const hasHoles = holeIndices && holeIndices.length;
          const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
          let outerNode = linkedList(data, 0, outerLen, dim, true);
          const triangles = [];
          if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
          let minX, minY, maxX, maxY, x, y, invSize;
          if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
          if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i2 = dim; i2 < outerLen; i2 += dim) {
              x = data[i2];
              y = data[i2 + 1];
              if (x < minX)
                minX = x;
              if (y < minY)
                minY = y;
              if (x > maxX)
                maxX = x;
              if (y > maxY)
                maxY = y;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
          }
          earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
          return triangles;
        }
      };
      ShapeUtils = class {
        static area(contour) {
          const n = contour.length;
          let a = 0;
          for (let p2 = n - 1, q = 0; q < n; p2 = q++) {
            a += contour[p2].x * contour[q].y - contour[q].x * contour[p2].y;
          }
          return a * 0.5;
        }
        static isClockWise(pts) {
          return ShapeUtils.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
          const vertices = [];
          const holeIndices = [];
          const faces = [];
          removeDupEndPts(contour);
          addContour(vertices, contour);
          let holeIndex = contour.length;
          holes.forEach(removeDupEndPts);
          for (let i2 = 0; i2 < holes.length; i2++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i2].length;
            addContour(vertices, holes[i2]);
          }
          const triangles = Earcut.triangulate(vertices, holeIndices);
          for (let i2 = 0; i2 < triangles.length; i2 += 3) {
            faces.push(triangles.slice(i2, i2 + 3));
          }
          return faces;
        }
      };
      ExtrudeGeometry = class extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
          super();
          this.type = "ExtrudeGeometry";
          this.parameters = {
            shapes,
            options
          };
          shapes = Array.isArray(shapes) ? shapes : [shapes];
          const scope = this;
          const verticesArray = [];
          const uvArray = [];
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            addShape(shape);
          }
          this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
          this.computeVertexNormals();
          function addShape(shape) {
            const placeholder = [];
            const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
            const steps = options.steps !== void 0 ? options.steps : 1;
            let depth = options.depth !== void 0 ? options.depth : 1;
            let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
            let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
            let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
            if (options.amount !== void 0) {
              console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
              depth = options.amount;
            }
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
              extrudePts = extrudePath.getSpacedPoints(steps);
              extrudeByPath = true;
              bevelEnabled = false;
              splineTube = extrudePath.computeFrenetFrames(steps, false);
              binormal = new Vector3();
              normal = new Vector3();
              position2 = new Vector3();
            }
            if (!bevelEnabled) {
              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
              bevelOffset = 0;
            }
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) {
                  holes[h] = ahole.reverse();
                }
              }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            const contour = vertices;
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
              if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
              return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
              let v_trans_x, v_trans_y, shrink_by;
              const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
              const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
              const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
              const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
              if (Math.abs(collinear0) > Number.EPSILON) {
                const v_prev_len = Math.sqrt(v_prev_lensq);
                const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                  return new Vector2(v_trans_x, v_trans_y);
                } else {
                  shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
              } else {
                let direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                  if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                      direction_eq = true;
                    }
                  }
                }
                if (direction_eq) {
                  v_trans_x = -v_prev_y;
                  v_trans_y = v_prev_x;
                  shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                  v_trans_x = v_prev_x;
                  v_trans_y = v_prev_y;
                  shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
              }
              return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = [];
              for (let i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
                if (j === il)
                  j = 0;
                if (k === il)
                  k = 0;
                oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
              }
              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (let b = 0; b < bevelSegments; b++) {
              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il = contour.length; i2 < il; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
                v(vert.x, vert.y, -z);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                  v(vert.x, vert.y, -z);
                }
              }
            }
            const bs = bevelSize + bevelOffset;
            for (let i2 = 0; i2 < vlen; i2++) {
              const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
              if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
              } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
            for (let s = 1; s <= steps; s++) {
              for (let i2 = 0; i2 < vlen; i2++) {
                const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
                if (!extrudeByPath) {
                  v(vert.x, vert.y, depth / steps * s);
                } else {
                  normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                  position2.copy(extrudePts[s]).add(normal).add(binormal);
                  v(position2.x, position2.y, position2.z);
                }
              }
            }
            for (let b = bevelSegments - 1; b >= 0; b--) {
              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il = contour.length; i2 < il; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
                v(vert.x, vert.y, depth + z);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                  if (!extrudeByPath) {
                    v(vert.x, vert.y, depth + z);
                  } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                  }
                }
              }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
              const start = verticesArray.length / 3;
              if (bevelEnabled) {
                let layer = 0;
                let offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
              } else {
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2], face[1], face[0]);
                }
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            function buildSideFaces() {
              const start = verticesArray.length / 3;
              let layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour2, layeroffset) {
              let i2 = contour2.length;
              while (--i2 >= 0) {
                const j = i2;
                let k = i2 - 1;
                if (k < 0)
                  k = contour2.length - 1;
                for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
                  const slen1 = vlen * s;
                  const slen2 = vlen * (s + 1);
                  const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                  f4(a, b, c, d);
                }
              }
            }
            function v(x, y, z) {
              placeholder.push(x);
              placeholder.push(y);
              placeholder.push(z);
            }
            function f3(a, b, c) {
              addVertex(a);
              addVertex(b);
              addVertex(c);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
              addVertex(a);
              addVertex(b);
              addVertex(d);
              addVertex(b);
              addVertex(c);
              addVertex(d);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[3]);
              addUV(uvs[1]);
              addUV(uvs[2]);
              addUV(uvs[3]);
            }
            function addVertex(index) {
              verticesArray.push(placeholder[index * 3 + 0]);
              verticesArray.push(placeholder[index * 3 + 1]);
              verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
              uvArray.push(vector2.x);
              uvArray.push(vector2.y);
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          const options = this.parameters.options;
          return toJSON$1(shapes, options, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          const extrudePath = data.options.extrudePath;
          if (extrudePath !== void 0) {
            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
          }
          return new ExtrudeGeometry(geometryShapes, data.options);
        }
      };
      WorldUVGenerator = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          return [
            new Vector2(a_x, a_y),
            new Vector2(b_x, b_y),
            new Vector2(c_x, c_y)
          ];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const a_z = vertices[indexA * 3 + 2];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const b_z = vertices[indexB * 3 + 2];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          const c_z = vertices[indexC * 3 + 2];
          const d_x = vertices[indexD * 3];
          const d_y = vertices[indexD * 3 + 1];
          const d_z = vertices[indexD * 3 + 2];
          if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [
              new Vector2(a_x, 1 - a_z),
              new Vector2(b_x, 1 - b_z),
              new Vector2(c_x, 1 - c_z),
              new Vector2(d_x, 1 - d_z)
            ];
          } else {
            return [
              new Vector2(a_y, 1 - a_z),
              new Vector2(b_y, 1 - b_z),
              new Vector2(c_y, 1 - c_z),
              new Vector2(d_y, 1 - d_z)
            ];
          }
        }
      };
      ShapeGeometry = class extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
          super();
          this.type = "ShapeGeometry";
          this.parameters = {
            shapes,
            curveSegments
          };
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let groupStart = 0;
          let groupCount = 0;
          if (Array.isArray(shapes) === false) {
            addShape(shapes);
          } else {
            for (let i2 = 0; i2 < shapes.length; i2++) {
              addShape(shapes[i2]);
              this.addGroup(groupStart, groupCount, i2);
              groupStart += groupCount;
              groupCount = 0;
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
              shapeVertices = shapeVertices.reverse();
            }
            for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
              const shapeHole = shapeHoles[i2];
              if (ShapeUtils.isClockWise(shapeHole) === true) {
                shapeHoles[i2] = shapeHole.reverse();
              }
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
              const shapeHole = shapeHoles[i2];
              shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (let i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
              const vertex2 = shapeVertices[i2];
              vertices.push(vertex2.x, vertex2.y, 0);
              normals.push(0, 0, 1);
              uvs.push(vertex2.x, vertex2.y);
            }
            for (let i2 = 0, l = faces.length; i2 < l; i2++) {
              const face = faces[i2];
              const a = face[0] + indexOffset;
              const b = face[1] + indexOffset;
              const c = face[2] + indexOffset;
              indices.push(a, b, c);
              groupCount += 3;
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          return toJSON(shapes, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          return new ShapeGeometry(geometryShapes, data.curveSegments);
        }
      };
      ShadowMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "ShadowMaterial";
          this.color = new Color(0);
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          return this;
        }
      };
      ShadowMaterial.prototype.isShadowMaterial = true;
      MeshStandardMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.defines = { "STANDARD": "" };
          this.type = "MeshStandardMaterial";
          this.color = new Color(16777215);
          this.roughness = 1;
          this.metalness = 0;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.roughnessMap = null;
          this.metalnessMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.envMapIntensity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = { "STANDARD": "" };
          this.color.copy(source.color);
          this.roughness = source.roughness;
          this.metalness = source.metalness;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.roughnessMap = source.roughnessMap;
          this.metalnessMap = source.metalnessMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.envMapIntensity = source.envMapIntensity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
      MeshPhysicalMaterial = class extends MeshStandardMaterial {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.type = "MeshPhysicalMaterial";
          this.clearcoatMap = null;
          this.clearcoatRoughness = 0;
          this.clearcoatRoughnessMap = null;
          this.clearcoatNormalScale = new Vector2(1, 1);
          this.clearcoatNormalMap = null;
          this.ior = 1.5;
          Object.defineProperty(this, "reflectivity", {
            get: function() {
              return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
              this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
          });
          this.sheenColor = new Color(0);
          this.sheenColorMap = null;
          this.sheenRoughness = 1;
          this.sheenRoughnessMap = null;
          this.transmissionMap = null;
          this.thickness = 0;
          this.thicknessMap = null;
          this.attenuationDistance = 0;
          this.attenuationColor = new Color(1, 1, 1);
          this.specularIntensity = 1;
          this.specularIntensityMap = null;
          this.specularColor = new Color(1, 1, 1);
          this.specularColorMap = null;
          this._sheen = 0;
          this._clearcoat = 0;
          this._transmission = 0;
          this.setValues(parameters);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(value) {
          if (this._sheen > 0 !== value > 0) {
            this.version++;
          }
          this._sheen = value;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(value) {
          if (this._clearcoat > 0 !== value > 0) {
            this.version++;
          }
          this._clearcoat = value;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(value) {
          if (this._transmission > 0 !== value > 0) {
            this.version++;
          }
          this._transmission = value;
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.clearcoat = source.clearcoat;
          this.clearcoatMap = source.clearcoatMap;
          this.clearcoatRoughness = source.clearcoatRoughness;
          this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
          this.clearcoatNormalMap = source.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
          this.ior = source.ior;
          this.sheen = source.sheen;
          this.sheenColor.copy(source.sheenColor);
          this.sheenColorMap = source.sheenColorMap;
          this.sheenRoughness = source.sheenRoughness;
          this.sheenRoughnessMap = source.sheenRoughnessMap;
          this.transmission = source.transmission;
          this.transmissionMap = source.transmissionMap;
          this.thickness = source.thickness;
          this.thicknessMap = source.thicknessMap;
          this.attenuationDistance = source.attenuationDistance;
          this.attenuationColor.copy(source.attenuationColor);
          this.specularIntensity = source.specularIntensity;
          this.specularIntensityMap = source.specularIntensityMap;
          this.specularColor.copy(source.specularColor);
          this.specularColorMap = source.specularColorMap;
          return this;
        }
      };
      MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
      MeshPhongMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshPhongMaterial";
          this.color = new Color(16777215);
          this.specular = new Color(1118481);
          this.shininess = 30;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.specular.copy(source.specular);
          this.shininess = source.shininess;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
      MeshToonMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.defines = { "TOON": "" };
          this.type = "MeshToonMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.gradientMap = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.gradientMap = source.gradientMap;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshToonMaterial.prototype.isMeshToonMaterial = true;
      MeshNormalMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshNormalMaterial";
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
      MeshLambertMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.type = "MeshLambertMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
      MeshMatcapMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.defines = { "MATCAP": "" };
          this.type = "MeshMatcapMaterial";
          this.color = new Color(16777215);
          this.matcap = null;
          this.map = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = { "MATCAP": "" };
          this.color.copy(source.color);
          this.matcap = source.matcap;
          this.map = source.map;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
      LineDashedMaterial = class extends LineBasicMaterial {
        constructor(parameters) {
          super();
          this.type = "LineDashedMaterial";
          this.scale = 1;
          this.dashSize = 3;
          this.gapSize = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.scale = source.scale;
          this.dashSize = source.dashSize;
          this.gapSize = source.gapSize;
          return this;
        }
      };
      LineDashedMaterial.prototype.isLineDashedMaterial = true;
      AnimationUtils = {
        arraySlice: function(array, from, to) {
          if (AnimationUtils.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
          }
          return array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
          if (!array || !forceClone && array.constructor === type)
            return array;
          if (typeof type.BYTES_PER_ELEMENT === "number") {
            return new type(array);
          }
          return Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
          return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
          function compareTime(i2, j) {
            return times[i2] - times[j];
          }
          const n = times.length;
          const result = new Array(n);
          for (let i2 = 0; i2 !== n; ++i2)
            result[i2] = i2;
          result.sort(compareTime);
          return result;
        },
        sortedArray: function(values, stride, order) {
          const nValues = values.length;
          const result = new values.constructor(nValues);
          for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
            const srcOffset = order[i2] * stride;
            for (let j = 0; j !== stride; ++j) {
              result[dstOffset++] = values[srcOffset + j];
            }
          }
          return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
          let i2 = 1, key = jsonKeys[0];
          while (key !== void 0 && key[valuePropertyName] === void 0) {
            key = jsonKeys[i2++];
          }
          if (key === void 0)
            return;
          let value = key[valuePropertyName];
          if (value === void 0)
            return;
          if (Array.isArray(value)) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push.apply(values, value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else if (value.toArray !== void 0) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                value.toArray(values, values.length);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push(value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          }
        },
        subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
          const clip = sourceClip.clone();
          clip.name = name;
          const tracks = [];
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            const track = clip.tracks[i2];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for (let j = 0; j < track.times.length; ++j) {
              const frame = track.times[j] * fps;
              if (frame < startFrame || frame >= endFrame)
                continue;
              times.push(track.times[j]);
              for (let k = 0; k < valueSize; ++k) {
                values.push(track.values[j * valueSize + k]);
              }
            }
            if (times.length === 0)
              continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
          }
          clip.tracks = tracks;
          let minStartTime = Infinity;
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            if (minStartTime > clip.tracks[i2].times[0]) {
              minStartTime = clip.tracks[i2].times[0];
            }
          }
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            clip.tracks[i2].shift(-1 * minStartTime);
          }
          clip.resetDuration();
          return clip;
        },
        makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
          if (fps <= 0)
            fps = 30;
          const numTracks = referenceClip.tracks.length;
          const referenceTime = referenceFrame / fps;
          for (let i2 = 0; i2 < numTracks; ++i2) {
            const referenceTrack = referenceClip.tracks[i2];
            const referenceTrackType = referenceTrack.ValueTypeName;
            if (referenceTrackType === "bool" || referenceTrackType === "string")
              continue;
            const targetTrack = targetClip.tracks.find(function(track) {
              return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === void 0)
              continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              referenceOffset = referenceValueSize / 3;
            }
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              targetOffset = targetValueSize / 3;
            }
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            if (referenceTime <= referenceTrack.times[0]) {
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
              const startIndex = lastIndex * referenceValueSize + referenceOffset;
              const endIndex = startIndex + referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
              const interpolant = referenceTrack.createInterpolant();
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              interpolant.evaluate(referenceTime);
              referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            if (referenceTrackType === "quaternion") {
              const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
              referenceQuat.toArray(referenceValue);
            }
            const numTimes = targetTrack.times.length;
            for (let j = 0; j < numTimes; ++j) {
              const valueStart = j * targetValueSize + targetOffset;
              if (referenceTrackType === "quaternion") {
                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
              } else {
                const valueEnd = targetValueSize - targetOffset * 2;
                for (let k = 0; k < valueEnd; ++k) {
                  targetTrack.values[valueStart + k] -= referenceValue[k];
                }
              }
            }
          }
          targetClip.blendMode = AdditiveAnimationBlendMode;
          return targetClip;
        }
      };
      Interpolant = class {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          this.parameterPositions = parameterPositions;
          this._cachedIndex = 0;
          this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
          this.sampleValues = sampleValues;
          this.valueSize = sampleSize;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(t) {
          const pp = this.parameterPositions;
          let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
          validate_interval: {
            seek: {
              let right;
              linear_scan: {
                forward_scan:
                  if (!(t < t1)) {
                    for (let giveUpAt = i1 + 2; ; ) {
                      if (t1 === void 0) {
                        if (t < t0)
                          break forward_scan;
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t, t0);
                      }
                      if (i1 === giveUpAt)
                        break;
                      t0 = t1;
                      t1 = pp[++i1];
                      if (t < t1) {
                        break seek;
                      }
                    }
                    right = pp.length;
                    break linear_scan;
                  }
                if (!(t >= t0)) {
                  const t1global = pp[1];
                  if (t < t1global) {
                    i1 = 2;
                    t0 = t1global;
                  }
                  for (let giveUpAt = i1 - 2; ; ) {
                    if (t0 === void 0) {
                      this._cachedIndex = 0;
                      return this.beforeStart_(0, t, t1);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t1 = t0;
                    t0 = pp[--i1 - 1];
                    if (t >= t0) {
                      break seek;
                    }
                  }
                  right = i1;
                  i1 = 0;
                  break linear_scan;
                }
                break validate_interval;
              }
              while (i1 < right) {
                const mid = i1 + right >>> 1;
                if (t < pp[mid]) {
                  right = mid;
                } else {
                  i1 = mid + 1;
                }
              }
              t1 = pp[i1];
              t0 = pp[i1 - 1];
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (t1 === void 0) {
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t0, t);
              }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
          }
          return this.interpolate_(i1, t0, t, t1);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset + i2];
          }
          return result;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      };
      Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
      Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
      CubicInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
        }
        intervalChanged_(i1, t0, t1) {
          const pp = this.parameterPositions;
          let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
          if (tPrev === void 0) {
            switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
              case WrapAroundEnding:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
              default:
                iPrev = i1;
                tPrev = t1;
            }
          }
          if (tNext === void 0) {
            switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
              case WrapAroundEnding:
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
              default:
                iNext = i1 - 1;
                tNext = t0;
            }
          }
          const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
          const sP = -wP * ppp + 2 * wP * pp - wP * p2;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
          const sN = wN * ppp - wN * pp;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
          }
          return result;
        }
      };
      LinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
          }
          return result;
        }
      };
      DiscreteInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1) {
          return this.copySampleValue_(i1 - 1);
        }
      };
      KeyframeTrack = class {
        constructor(name, times, values, interpolation) {
          if (name === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (times === void 0 || times.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
          this.name = name;
          this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
          this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
          this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        static toJSON(track) {
          const trackType = track.constructor;
          let json;
          if (trackType.toJSON !== this.toJSON) {
            json = trackType.toJSON(track);
          } else {
            json = {
              "name": track.name,
              "times": AnimationUtils.convertArray(track.times, Array),
              "values": AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
              json.interpolation = interpolation;
            }
          }
          json.type = track.ValueTypeName;
          return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
          return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
          return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
          return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
          let factoryMethod;
          switch (interpolation) {
            case InterpolateDiscrete:
              factoryMethod = this.InterpolantFactoryMethodDiscrete;
              break;
            case InterpolateLinear:
              factoryMethod = this.InterpolantFactoryMethodLinear;
              break;
            case InterpolateSmooth:
              factoryMethod = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (factoryMethod === void 0) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (interpolation !== this.DefaultInterpolation) {
                this.setInterpolation(this.DefaultInterpolation);
              } else {
                throw new Error(message);
              }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
          }
          this.createInterpolant = factoryMethod;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
              return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
              return InterpolateSmooth;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(timeOffset) {
          if (timeOffset !== 0) {
            const times = this.times;
            for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
              times[i2] += timeOffset;
            }
          }
          return this;
        }
        scale(timeScale) {
          if (timeScale !== 1) {
            const times = this.times;
            for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
              times[i2] *= timeScale;
            }
          }
          return this;
        }
        trim(startTime, endTime) {
          const times = this.times, nKeys = times.length;
          let from = 0, to = nKeys - 1;
          while (from !== nKeys && times[from] < startTime) {
            ++from;
          }
          while (to !== -1 && times[to] > endTime) {
            --to;
          }
          ++to;
          if (from !== 0 || to !== nKeys) {
            if (from >= to) {
              to = Math.max(to, 1);
              from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
          }
          return this;
        }
        validate() {
          let valid = true;
          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
          }
          const times = this.times, values = this.values, nKeys = times.length;
          if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
          }
          let prevTime = null;
          for (let i2 = 0; i2 !== nKeys; i2++) {
            const currTime = times[i2];
            if (typeof currTime === "number" && isNaN(currTime)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
              valid = false;
              break;
            }
            if (prevTime !== null && prevTime > currTime) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
              valid = false;
              break;
            }
            prevTime = currTime;
          }
          if (values !== void 0) {
            if (AnimationUtils.isTypedArray(values)) {
              for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
                const value = values[i2];
                if (isNaN(value)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                  valid = false;
                  break;
                }
              }
            }
          }
          return valid;
        }
        optimize() {
          const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
          let writeIndex = 1;
          for (let i2 = 1; i2 < lastIndex; ++i2) {
            let keep = false;
            const time = times[i2];
            const timeNext = times[i2 + 1];
            if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
              if (!smoothInterpolation) {
                const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (let j = 0; j !== stride; ++j) {
                  const value = values[offset + j];
                  if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                    keep = true;
                    break;
                  }
                }
              } else {
                keep = true;
              }
            }
            if (keep) {
              if (i2 !== writeIndex) {
                times[writeIndex] = times[i2];
                const readOffset = i2 * stride, writeOffset = writeIndex * stride;
                for (let j = 0; j !== stride; ++j) {
                  values[writeOffset + j] = values[readOffset + j];
                }
              }
              ++writeIndex;
            }
          }
          if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
            ++writeIndex;
          }
          if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
          } else {
            this.times = times;
            this.values = values;
          }
          return this;
        }
        clone() {
          const times = AnimationUtils.arraySlice(this.times, 0);
          const values = AnimationUtils.arraySlice(this.values, 0);
          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values);
          track.createInterpolant = this.createInterpolant;
          return track;
        }
      };
      KeyframeTrack.prototype.TimeBufferType = Float32Array;
      KeyframeTrack.prototype.ValueBufferType = Float32Array;
      KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      BooleanKeyframeTrack = class extends KeyframeTrack {
      };
      BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
      BooleanKeyframeTrack.prototype.ValueBufferType = Array;
      BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      ColorKeyframeTrack = class extends KeyframeTrack {
      };
      ColorKeyframeTrack.prototype.ValueTypeName = "color";
      NumberKeyframeTrack = class extends KeyframeTrack {
      };
      NumberKeyframeTrack.prototype.ValueTypeName = "number";
      QuaternionLinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
          let offset = i1 * stride;
          for (let end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
          }
          return result;
        }
      };
      QuaternionKeyframeTrack = class extends KeyframeTrack {
        InterpolantFactoryMethodLinear(result) {
          return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
      };
      QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
      QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      StringKeyframeTrack = class extends KeyframeTrack {
      };
      StringKeyframeTrack.prototype.ValueTypeName = "string";
      StringKeyframeTrack.prototype.ValueBufferType = Array;
      StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      VectorKeyframeTrack = class extends KeyframeTrack {
      };
      VectorKeyframeTrack.prototype.ValueTypeName = "vector";
      AnimationClip = class {
        constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
          this.name = name;
          this.tracks = tracks;
          this.duration = duration;
          this.blendMode = blendMode;
          this.uuid = generateUUID();
          if (this.duration < 0) {
            this.resetDuration();
          }
        }
        static parse(json) {
          const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
          for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
            tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
          }
          const clip = new this(json.name, json.duration, tracks, json.blendMode);
          clip.uuid = json.uuid;
          return clip;
        }
        static toJSON(clip) {
          const tracks = [], clipTracks = clip.tracks;
          const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
          };
          for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
            tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
          }
          return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];
          for (let i2 = 0; i2 < numMorphTargets; i2++) {
            let times = [];
            let values = [];
            times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
              times.push(numMorphTargets);
              values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
          }
          return new this(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
          let clipArray = objectOrClipArray;
          if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
          }
          for (let i2 = 0; i2 < clipArray.length; i2++) {
            if (clipArray[i2].name === name) {
              return clipArray[i2];
            }
          }
          return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
          const animationToMorphTargets = {};
          const pattern = /^([\w-]*?)([\d]+)$/;
          for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
            const morphTarget = morphTargets[i2];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
              const name = parts[1];
              let animationMorphTargets = animationToMorphTargets[name];
              if (!animationMorphTargets) {
                animationToMorphTargets[name] = animationMorphTargets = [];
              }
              animationMorphTargets.push(morphTarget);
            }
          }
          const clips = [];
          for (const name in animationToMorphTargets) {
            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
          }
          return clips;
        }
        static parseAnimation(animation, bones) {
          if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
          }
          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
              const times = [];
              const values = [];
              AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
              if (times.length !== 0) {
                destTracks.push(new trackType(trackName, times, values));
              }
            }
          };
          const tracks = [];
          const clipName = animation.name || "default";
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;
          let duration = animation.length || -1;
          const hierarchyTracks = animation.hierarchy || [];
          for (let h = 0; h < hierarchyTracks.length; h++) {
            const animationKeys = hierarchyTracks[h].keys;
            if (!animationKeys || animationKeys.length === 0)
              continue;
            if (animationKeys[0].morphTargets) {
              const morphTargetNames = {};
              let k;
              for (k = 0; k < animationKeys.length; k++) {
                if (animationKeys[k].morphTargets) {
                  for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                    morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                  }
                }
              }
              for (const morphTargetName in morphTargetNames) {
                const times = [];
                const values = [];
                for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                  const animationKey = animationKeys[k];
                  times.push(animationKey.time);
                  values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                }
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
              }
              duration = morphTargetNames.length * (fps || 1);
            } else {
              const boneName = ".bones[" + bones[h].name + "]";
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
              addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
              addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
            }
          }
          if (tracks.length === 0) {
            return null;
          }
          const clip = new this(clipName, duration, tracks, blendMode);
          return clip;
        }
        resetDuration() {
          const tracks = this.tracks;
          let duration = 0;
          for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
            const track = this.tracks[i2];
            duration = Math.max(duration, track.times[track.times.length - 1]);
          }
          this.duration = duration;
          return this;
        }
        trim() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].trim(0, this.duration);
          }
          return this;
        }
        validate() {
          let valid = true;
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            valid = valid && this.tracks[i2].validate();
          }
          return valid;
        }
        optimize() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].optimize();
          }
          return this;
        }
        clone() {
          const tracks = [];
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            tracks.push(this.tracks[i2].clone());
          }
          return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      };
      Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
          if (this.enabled === false)
            return;
          this.files[key] = file;
        },
        get: function(key) {
          if (this.enabled === false)
            return;
          return this.files[key];
        },
        remove: function(key) {
          delete this.files[key];
        },
        clear: function() {
          this.files = {};
        }
      };
      LoadingManager = class {
        constructor(onLoad, onProgress, onError) {
          const scope = this;
          let isLoading = false;
          let itemsLoaded = 0;
          let itemsTotal = 0;
          let urlModifier = void 0;
          const handlers = [];
          this.onStart = void 0;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== void 0) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== void 0) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== void 0) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function(url) {
            if (scope.onError !== void 0) {
              scope.onError(url);
            }
          };
          this.resolveURL = function(url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
          };
          this.addHandler = function(regex, loader4) {
            handlers.push(regex, loader4);
            return this;
          };
          this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) {
              handlers.splice(index, 2);
            }
            return this;
          };
          this.getHandler = function(file) {
            for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {
              const regex = handlers[i2];
              const loader4 = handlers[i2 + 1];
              if (regex.global)
                regex.lastIndex = 0;
              if (regex.test(file)) {
                return loader4;
              }
            }
            return null;
          };
        }
      };
      DefaultLoadingManager = new LoadingManager();
      Loader = class {
        constructor(manager) {
          this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {
        }
        loadAsync(url, onProgress) {
          const scope = this;
          return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
          });
        }
        parse() {
        }
        setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        }
        setWithCredentials(value) {
          this.withCredentials = value;
          return this;
        }
        setPath(path) {
          this.path = path;
          return this;
        }
        setResourcePath(resourcePath) {
          this.resourcePath = resourcePath;
          return this;
        }
        setRequestHeader(requestHeader) {
          this.requestHeader = requestHeader;
          return this;
        }
      };
      loading = {};
      FileLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const cached = Cache.get(url);
          if (cached !== void 0) {
            this.manager.itemStart(url);
            setTimeout(() => {
              if (onLoad)
                onLoad(cached);
              this.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          if (loading[url] !== void 0) {
            loading[url].push({
              onLoad,
              onProgress,
              onError
            });
            return;
          }
          loading[url] = [];
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          const req = new Request(url, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          });
          const mimeType = this.mimeType;
          const responseType = this.responseType;
          fetch(req).then((response) => {
            if (response.status === 200 || response.status === 0) {
              if (response.status === 0) {
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              }
              if (typeof ReadableStream === "undefined" || response.body.getReader === void 0) {
                return response;
              }
              const callbacks = loading[url];
              const reader = response.body.getReader();
              const contentLength = response.headers.get("Content-Length");
              const total = contentLength ? parseInt(contentLength) : 0;
              const lengthComputable = total !== 0;
              let loaded = 0;
              const stream = new ReadableStream({
                start(controller) {
                  readData();
                  function readData() {
                    reader.read().then(({ done, value }) => {
                      if (done) {
                        controller.close();
                      } else {
                        loaded += value.byteLength;
                        const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                          const callback = callbacks[i2];
                          if (callback.onProgress)
                            callback.onProgress(event);
                        }
                        controller.enqueue(value);
                        readData();
                      }
                    });
                  }
                }
              });
              return new Response(stream);
            } else {
              throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
            }
          }).then((response) => {
            switch (responseType) {
              case "arraybuffer":
                return response.arrayBuffer();
              case "blob":
                return response.blob();
              case "document":
                return response.text().then((text) => {
                  const parser = new DOMParser();
                  return parser.parseFromString(text, mimeType);
                });
              case "json":
                return response.json();
              default:
                if (mimeType === void 0) {
                  return response.text();
                } else {
                  const re = /charset="?([^;"\s]*)"?/i;
                  const exec = re.exec(mimeType);
                  const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
                  const decoder = new TextDecoder(label);
                  return response.arrayBuffer().then((ab) => decoder.decode(ab));
                }
            }
          }).then((data) => {
            Cache.add(url, data);
            const callbacks = loading[url];
            delete loading[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onLoad)
                callback.onLoad(data);
            }
          }).catch((err) => {
            const callbacks = loading[url];
            if (callbacks === void 0) {
              this.manager.itemError(url);
              throw err;
            }
            delete loading[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onError)
                callback.onError(err);
            }
            this.manager.itemError(url);
          }).finally(() => {
            this.manager.itemEnd(url);
          });
          this.manager.itemStart(url);
        }
        setResponseType(value) {
          this.responseType = value;
          return this;
        }
        setMimeType(value) {
          this.mimeType = value;
          return this;
        }
      };
      CompressedTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const images = [];
          const texture = new CompressedTexture();
          const loader4 = new FileLoader(this.manager);
          loader4.setPath(this.path);
          loader4.setResponseType("arraybuffer");
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(scope.withCredentials);
          let loaded = 0;
          function loadTexture(i2) {
            loader4.load(url[i2], function(buffer) {
              const texDatas = scope.parse(buffer, true);
              images[i2] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = LinearFilter;
                texture.image = images;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          }
          if (Array.isArray(url)) {
            for (let i2 = 0, il = url.length; i2 < il; ++i2) {
              loadTexture(i2);
            }
          } else {
            loader4.load(url, function(buffer) {
              const texDatas = scope.parse(buffer, true);
              if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for (let f = 0; f < faces; f++) {
                  images[f] = { mipmaps: [] };
                  for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                    images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
                    images[f].format = texDatas.format;
                    images[f].width = texDatas.width;
                    images[f].height = texDatas.height;
                  }
                }
                texture.image = images;
              } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
              }
              if (texDatas.mipmapCount === 1) {
                texture.minFilter = LinearFilter;
              }
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }, onProgress, onError);
          }
          return texture;
        }
      };
      ImageLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const image = createElementNS("img");
          function onImageLoad() {
            removeEventListeners();
            Cache.add(url, this);
            if (onLoad)
              onLoad(this);
            scope.manager.itemEnd(url);
          }
          function onImageError(event) {
            removeEventListeners();
            if (onError)
              onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
          function removeEventListeners() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
          }
          image.addEventListener("load", onImageLoad, false);
          image.addEventListener("error", onImageError, false);
          if (url.substr(0, 5) !== "data:") {
            if (this.crossOrigin !== void 0)
              image.crossOrigin = this.crossOrigin;
          }
          scope.manager.itemStart(url);
          image.src = url;
          return image;
        }
      };
      CubeTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(urls, onLoad, onProgress, onError) {
          const texture = new CubeTexture();
          const loader4 = new ImageLoader(this.manager);
          loader4.setCrossOrigin(this.crossOrigin);
          loader4.setPath(this.path);
          let loaded = 0;
          function loadTexture(i2) {
            loader4.load(urls[i2], function(image) {
              texture.images[i2] = image;
              loaded++;
              if (loaded === 6) {
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, void 0, onError);
          }
          for (let i2 = 0; i2 < urls.length; ++i2) {
            loadTexture(i2);
          }
          return texture;
        }
      };
      TextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture();
          const loader4 = new ImageLoader(this.manager);
          loader4.setCrossOrigin(this.crossOrigin);
          loader4.setPath(this.path);
          loader4.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== void 0) {
              onLoad(texture);
            }
          }, onProgress, onError);
          return texture;
        }
      };
      Light = class extends Object3D {
        constructor(color, intensity = 1) {
          super();
          this.type = "Light";
          this.color = new Color(color);
          this.intensity = intensity;
        }
        dispose() {
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.intensity = source.intensity;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;
          if (this.groundColor !== void 0)
            data.object.groundColor = this.groundColor.getHex();
          if (this.distance !== void 0)
            data.object.distance = this.distance;
          if (this.angle !== void 0)
            data.object.angle = this.angle;
          if (this.decay !== void 0)
            data.object.decay = this.decay;
          if (this.penumbra !== void 0)
            data.object.penumbra = this.penumbra;
          if (this.shadow !== void 0)
            data.object.shadow = this.shadow.toJSON();
          return data;
        }
      };
      Light.prototype.isLight = true;
      HemisphereLight = class extends Light {
        constructor(skyColor, groundColor, intensity) {
          super(skyColor, intensity);
          this.type = "HemisphereLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.groundColor = new Color(groundColor);
        }
        copy(source) {
          Light.prototype.copy.call(this, source);
          this.groundColor.copy(source.groundColor);
          return this;
        }
      };
      HemisphereLight.prototype.isHemisphereLight = true;
      _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
      _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
      _lookTarget$1 = /* @__PURE__ */ new Vector3();
      LightShadow = class {
        constructor(camera) {
          this.camera = camera;
          this.bias = 0;
          this.normalBias = 0;
          this.radius = 1;
          this.blurSamples = 8;
          this.mapSize = new Vector2(512, 512);
          this.map = null;
          this.mapPass = null;
          this.matrix = new Matrix4();
          this.autoUpdate = true;
          this.needsUpdate = false;
          this._frustum = new Frustum();
          this._frameExtents = new Vector2(1, 1);
          this._viewportCount = 1;
          this._viewports = [
            new Vector4(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(light) {
          const shadowCamera = this.camera;
          const shadowMatrix = this.matrix;
          _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld$1);
          _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget$1);
          shadowCamera.updateMatrixWorld();
          _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
          shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        }
        getViewport(viewportIndex) {
          return this._viewports[viewportIndex];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          if (this.map) {
            this.map.dispose();
          }
          if (this.mapPass) {
            this.mapPass.dispose();
          }
        }
        copy(source) {
          this.camera = source.camera.clone();
          this.bias = source.bias;
          this.radius = source.radius;
          this.mapSize.copy(source.mapSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const object = {};
          if (this.bias !== 0)
            object.bias = this.bias;
          if (this.normalBias !== 0)
            object.normalBias = this.normalBias;
          if (this.radius !== 1)
            object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;
          return object;
        }
      };
      SpotLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(50, 1, 0.5, 500));
          this.focus = 1;
        }
        updateMatrices(light) {
          const camera = this.camera;
          const fov2 = RAD2DEG * 2 * light.angle * this.focus;
          const aspect2 = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;
          if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
            camera.fov = fov2;
            camera.aspect = aspect2;
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          super.updateMatrices(light);
        }
        copy(source) {
          super.copy(source);
          this.focus = source.focus;
          return this;
        }
      };
      SpotLightShadow.prototype.isSpotLightShadow = true;
      SpotLight = class extends Light {
        constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
          super(color, intensity);
          this.type = "SpotLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D();
          this.distance = distance;
          this.angle = angle;
          this.penumbra = penumbra;
          this.decay = decay;
          this.shadow = new SpotLightShadow();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(power) {
          this.intensity = power / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      SpotLight.prototype.isSpotLight = true;
      _projScreenMatrix = /* @__PURE__ */ new Matrix4();
      _lightPositionWorld = /* @__PURE__ */ new Vector3();
      _lookTarget = /* @__PURE__ */ new Vector3();
      PointLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(90, 1, 0.5, 500));
          this._frameExtents = new Vector2(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            new Vector4(2, 1, 1, 1),
            new Vector4(0, 1, 1, 1),
            new Vector4(3, 1, 1, 1),
            new Vector4(1, 1, 1, 1),
            new Vector4(3, 0, 1, 1),
            new Vector4(1, 0, 1, 1)
          ];
          this._cubeDirections = [
            new Vector3(1, 0, 0),
            new Vector3(-1, 0, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1),
            new Vector3(0, 1, 0),
            new Vector3(0, -1, 0)
          ];
          this._cubeUps = [
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1)
          ];
        }
        updateMatrices(light, viewportIndex = 0) {
          const camera = this.camera;
          const shadowMatrix = this.matrix;
          const far = light.distance || camera.far;
          if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(_lightPositionWorld);
          _lookTarget.copy(camera.position);
          _lookTarget.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(_lookTarget);
          camera.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
          _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix);
        }
      };
      PointLightShadow.prototype.isPointLightShadow = true;
      PointLight = class extends Light {
        constructor(color, intensity, distance = 0, decay = 1) {
          super(color, intensity);
          this.type = "PointLight";
          this.distance = distance;
          this.decay = decay;
          this.shadow = new PointLightShadow();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(power) {
          this.intensity = power / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.decay = source.decay;
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      PointLight.prototype.isPointLight = true;
      DirectionalLightShadow = class extends LightShadow {
        constructor() {
          super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
        }
      };
      DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
      DirectionalLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "DirectionalLight";
          this.position.copy(Object3D.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D();
          this.shadow = new DirectionalLightShadow();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      DirectionalLight.prototype.isDirectionalLight = true;
      AmbientLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "AmbientLight";
        }
      };
      AmbientLight.prototype.isAmbientLight = true;
      RectAreaLight = class extends Light {
        constructor(color, intensity, width = 10, height = 10) {
          super(color, intensity);
          this.type = "RectAreaLight";
          this.width = width;
          this.height = height;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(power) {
          this.intensity = power / (this.width * this.height * Math.PI);
        }
        copy(source) {
          super.copy(source);
          this.width = source.width;
          this.height = source.height;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.width = this.width;
          data.object.height = this.height;
          return data;
        }
      };
      RectAreaLight.prototype.isRectAreaLight = true;
      SphericalHarmonics3 = class {
        constructor() {
          this.coefficients = [];
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients.push(new Vector3());
          }
        }
        set(coefficients) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].copy(coefficients[i2]);
          }
          return this;
        }
        zero() {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].set(0, 0, 0);
          }
          return this;
        }
        getAt(normal, target) {
          const x = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.282095);
          target.addScaledVector(coeff[1], 0.488603 * y);
          target.addScaledVector(coeff[2], 0.488603 * z);
          target.addScaledVector(coeff[3], 0.488603 * x);
          target.addScaledVector(coeff[4], 1.092548 * (x * y));
          target.addScaledVector(coeff[5], 1.092548 * (y * z));
          target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
          target.addScaledVector(coeff[7], 1.092548 * (x * z));
          target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
          return target;
        }
        getIrradianceAt(normal, target) {
          const x = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.886227);
          target.addScaledVector(coeff[1], 2 * 0.511664 * y);
          target.addScaledVector(coeff[2], 2 * 0.511664 * z);
          target.addScaledVector(coeff[3], 2 * 0.511664 * x);
          target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
          target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
          target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
          target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
          target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
          return target;
        }
        add(sh) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].add(sh.coefficients[i2]);
          }
          return this;
        }
        addScaledSH(sh, s) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].addScaledVector(sh.coefficients[i2], s);
          }
          return this;
        }
        scale(s) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].multiplyScalar(s);
          }
          return this;
        }
        lerp(sh, alpha) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
          }
          return this;
        }
        equals(sh) {
          for (let i2 = 0; i2 < 9; i2++) {
            if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
              return false;
            }
          }
          return true;
        }
        copy(sh) {
          return this.set(sh.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(array, offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].fromArray(array, offset + i2 * 3);
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].toArray(array, offset + i2 * 3);
          }
          return array;
        }
        static getBasisAt(normal, shBasis) {
          const x = normal.x, y = normal.y, z = normal.z;
          shBasis[0] = 0.282095;
          shBasis[1] = 0.488603 * y;
          shBasis[2] = 0.488603 * z;
          shBasis[3] = 0.488603 * x;
          shBasis[4] = 1.092548 * x * y;
          shBasis[5] = 1.092548 * y * z;
          shBasis[6] = 0.315392 * (3 * z * z - 1);
          shBasis[7] = 1.092548 * x * z;
          shBasis[8] = 0.546274 * (x * x - y * y);
        }
      };
      SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
      LightProbe = class extends Light {
        constructor(sh = new SphericalHarmonics3(), intensity = 1) {
          super(void 0, intensity);
          this.sh = sh;
        }
        copy(source) {
          super.copy(source);
          this.sh.copy(source.sh);
          return this;
        }
        fromJSON(json) {
          this.intensity = json.intensity;
          this.sh.fromArray(json.sh);
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.sh = this.sh.toArray();
          return data;
        }
      };
      LightProbe.prototype.isLightProbe = true;
      LoaderUtils = class {
        static decodeText(array) {
          if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
          }
          let s = "";
          for (let i2 = 0, il = array.length; i2 < il; i2++) {
            s += String.fromCharCode(array[i2]);
          }
          try {
            return decodeURIComponent(escape(s));
          } catch (e) {
            return s;
          }
        }
        static extractUrlBase(url) {
          const index = url.lastIndexOf("/");
          if (index === -1)
            return "./";
          return url.substr(0, index + 1);
        }
        static resolveURL(url, path) {
          if (typeof url !== "string" || url === "")
            return "";
          if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
            path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
          }
          if (/^(https?:)?\/\//i.test(url))
            return url;
          if (/^data:.*,.*$/i.test(url))
            return url;
          if (/^blob:.*$/i.test(url))
            return url;
          return path + url;
        }
      };
      InstancedBufferGeometry = class extends BufferGeometry {
        constructor() {
          super();
          this.type = "InstancedBufferGeometry";
          this.instanceCount = Infinity;
        }
        copy(source) {
          super.copy(source);
          this.instanceCount = source.instanceCount;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const data = super.toJSON(this);
          data.instanceCount = this.instanceCount;
          data.isInstancedBufferGeometry = true;
          return data;
        }
      };
      InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
      ImageBitmapLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          if (typeof createImageBitmap === "undefined") {
            console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
          }
          if (typeof fetch === "undefined") {
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          }
          this.options = { premultiplyAlpha: "none" };
        }
        setOptions(options) {
          this.options = options;
          return this;
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const fetchOptions = {};
          fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
          fetchOptions.headers = this.requestHeader;
          fetch(url, fetchOptions).then(function(res) {
            return res.blob();
          }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
          }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad)
              onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function(e) {
            if (onError)
              onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
          scope.manager.itemStart(url);
        }
      };
      ImageBitmapLoader.prototype.isImageBitmapLoader = true;
      AudioContext = {
        getContext: function() {
          if (_context === void 0) {
            _context = new (window.AudioContext || window.webkitAudioContext)();
          }
          return _context;
        },
        setContext: function(value) {
          _context = value;
        }
      };
      AudioLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader4 = new FileLoader(this.manager);
          loader4.setResponseType("arraybuffer");
          loader4.setPath(this.path);
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(this.withCredentials);
          loader4.load(url, function(buffer) {
            try {
              const bufferCopy = buffer.slice(0);
              const context = AudioContext.getContext();
              context.decodeAudioData(bufferCopy, function(audioBuffer) {
                onLoad(audioBuffer);
              });
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
      };
      HemisphereLightProbe = class extends LightProbe {
        constructor(skyColor, groundColor, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(skyColor);
          const color2 = new Color().set(groundColor);
          const sky = new Vector3(color1.r, color1.g, color1.b);
          const ground = new Vector3(color2.r, color2.g, color2.b);
          const c0 = Math.sqrt(Math.PI);
          const c1 = c0 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
          this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
        }
      };
      HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
      AmbientLightProbe = class extends LightProbe {
        constructor(color, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color().set(color);
          this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      };
      AmbientLightProbe.prototype.isAmbientLightProbe = true;
      Clock = class {
        constructor(autoStart = true) {
          this.autoStart = autoStart;
          this.startTime = 0;
          this.oldTime = 0;
          this.elapsedTime = 0;
          this.running = false;
        }
        start() {
          this.startTime = now();
          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;
        }
        stop() {
          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;
        }
        getElapsedTime() {
          this.getDelta();
          return this.elapsedTime;
        }
        getDelta() {
          let diff = 0;
          if (this.autoStart && !this.running) {
            this.start();
            return 0;
          }
          if (this.running) {
            const newTime = now();
            diff = (newTime - this.oldTime) / 1e3;
            this.oldTime = newTime;
            this.elapsedTime += diff;
          }
          return diff;
        }
      };
      Audio = class extends Object3D {
        constructor(listener) {
          super();
          this.type = "Audio";
          this.listener = listener;
          this.context = listener.context;
          this.gain = this.context.createGain();
          this.gain.connect(listener.getInput());
          this.autoplay = false;
          this.buffer = null;
          this.detune = 0;
          this.loop = false;
          this.loopStart = 0;
          this.loopEnd = 0;
          this.offset = 0;
          this.duration = void 0;
          this.playbackRate = 1;
          this.isPlaying = false;
          this.hasPlaybackControl = true;
          this.source = null;
          this.sourceType = "empty";
          this._startedAt = 0;
          this._progress = 0;
          this._connected = false;
          this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(audioNode) {
          this.hasPlaybackControl = false;
          this.sourceType = "audioNode";
          this.source = audioNode;
          this.connect();
          return this;
        }
        setMediaElementSource(mediaElement) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaNode";
          this.source = this.context.createMediaElementSource(mediaElement);
          this.connect();
          return this;
        }
        setMediaStreamSource(mediaStream) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaStreamNode";
          this.source = this.context.createMediaStreamSource(mediaStream);
          this.connect();
          return this;
        }
        setBuffer(audioBuffer) {
          this.buffer = audioBuffer;
          this.sourceType = "buffer";
          if (this.autoplay)
            this.play();
          return this;
        }
        play(delay = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + delay;
          const source = this.context.createBufferSource();
          source.buffer = this.buffer;
          source.loop = this.loop;
          source.loopStart = this.loopStart;
          source.loopEnd = this.loopEnd;
          source.onended = this.onEnded.bind(this);
          source.start(this._startedAt, this._progress + this.offset, this.duration);
          this.isPlaying = true;
          this.source = source;
          this.setDetune(this.detune);
          this.setPlaybackRate(this.playbackRate);
          return this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) {
              this._progress = this._progress % (this.duration || this.buffer.duration);
            }
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
          }
          return this;
        }
        stop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._progress = 0;
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
          return this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
              this.filters[i2 - 1].connect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else {
            this.source.connect(this.getOutput());
          }
          this._connected = true;
          return this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
              this.filters[i2 - 1].disconnect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else {
            this.source.disconnect(this.getOutput());
          }
          this._connected = false;
          return this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(value) {
          if (!value)
            value = [];
          if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
          } else {
            this.filters = value.slice();
          }
          return this;
        }
        setDetune(value) {
          this.detune = value;
          if (this.source.detune === void 0)
            return;
          if (this.isPlaying === true) {
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
          }
          return this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(filter) {
          return this.setFilters(filter ? [filter] : []);
        }
        setPlaybackRate(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.playbackRate = value;
          if (this.isPlaying === true) {
            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
          }
          return this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
          }
          return this.loop;
        }
        setLoop(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.loop = value;
          if (this.isPlaying === true) {
            this.source.loop = this.loop;
          }
          return this;
        }
        setLoopStart(value) {
          this.loopStart = value;
          return this;
        }
        setLoopEnd(value) {
          this.loopEnd = value;
          return this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
      };
      AudioAnalyser = class {
        constructor(audio, fftSize = 2048) {
          this.analyser = audio.context.createAnalyser();
          this.analyser.fftSize = fftSize;
          this.data = new Uint8Array(this.analyser.frequencyBinCount);
          audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          this.analyser.getByteFrequencyData(this.data);
          return this.data;
        }
        getAverageFrequency() {
          let value = 0;
          const data = this.getFrequencyData();
          for (let i2 = 0; i2 < data.length; i2++) {
            value += data[i2];
          }
          return value / data.length;
        }
      };
      PropertyMixer = class {
        constructor(binding, typeName, valueSize) {
          this.binding = binding;
          this.valueSize = valueSize;
          let mixFunction, mixFunctionAdditive, setIdentity;
          switch (typeName) {
            case "quaternion":
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;
              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;
            case "string":
            case "bool":
              mixFunction = this._select;
              mixFunctionAdditive = this._select;
              setIdentity = this._setAdditiveIdentityOther;
              this.buffer = new Array(valueSize * 5);
              break;
            default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;
              this.buffer = new Float64Array(valueSize * 5);
          }
          this._mixBufferRegion = mixFunction;
          this._mixBufferRegionAdditive = mixFunctionAdditive;
          this._setIdentity = setIdentity;
          this._origIndex = 3;
          this._addIndex = 4;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          this.useCount = 0;
          this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
          let currentWeight = this.cumulativeWeight;
          if (currentWeight === 0) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[offset + i2] = buffer[i2];
            }
            currentWeight = weight;
          } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
          }
          this.cumulativeWeight = currentWeight;
        }
        accumulateAdditive(weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
          if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
          }
          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;
        }
        apply(accuIndex) {
          const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
          }
          if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
          }
          for (let i2 = stride, e = stride + stride; i2 !== e; ++i2) {
            if (buffer[i2] !== buffer[i2 + stride]) {
              binding.setValue(buffer, offset);
              break;
            }
          }
        }
        saveOriginalState() {
          const binding = this.binding;
          const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
          binding.getValue(buffer, originalValueOffset);
          for (let i2 = stride, e = originalValueOffset; i2 !== e; ++i2) {
            buffer[i2] = buffer[originalValueOffset + i2 % stride];
          }
          this._setIdentity();
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);
        }
        _setAdditiveIdentityNumeric() {
          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;
          for (let i2 = startIndex; i2 < endIndex; i2++) {
            this.buffer[i2] = 0;
          }
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;
          for (let i2 = 0; i2 < this.valueSize; i2++) {
            this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
          }
        }
        _select(buffer, dstOffset, srcOffset, t, stride) {
          if (t >= 0.5) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[dstOffset + i2] = buffer[srcOffset + i2];
            }
          }
        }
        _slerp(buffer, dstOffset, srcOffset, t) {
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          const workOffset = this._workIndex * stride;
          Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
        }
        _lerp(buffer, dstOffset, srcOffset, t, stride) {
          const s = 1 - t;
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j = dstOffset + i2;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i2] * t;
          }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j = dstOffset + i2;
            buffer[j] = buffer[j] + buffer[srcOffset + i2] * t;
          }
        }
      };
      _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
      _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
      _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
      _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
      _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
      _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
      _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
      _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
      _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
      _supportedObjectNames = ["material", "materials", "bones"];
      Composite = class {
        constructor(targetGroup, path, optionalParsedPath) {
          const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
          this._targetGroup = targetGroup;
          this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
          this.bind();
          const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
          if (binding !== void 0)
            binding.getValue(array, offset);
        }
        setValue(array, offset) {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].setValue(array, offset);
          }
        }
        bind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].bind();
          }
        }
        unbind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].unbind();
          }
        }
      };
      PropertyBinding = class {
        constructor(rootNode, path, parsedPath) {
          this.path = path;
          this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
          this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
          this.rootNode = rootNode;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(root, path, parsedPath) {
          if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding(root, path, parsedPath);
          } else {
            return new PropertyBinding.Composite(root, path, parsedPath);
          }
        }
        static sanitizeNodeName(name) {
          return name.replace(/\s/g, "_").replace(_reservedRe, "");
        }
        static parseTrackName(trackName) {
          const matches = _trackRe.exec(trackName);
          if (!matches) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
          }
          const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
          };
          const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
          if (lastDot !== void 0 && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
              results.nodeName = results.nodeName.substring(0, lastDot);
              results.objectName = objectName;
            }
          }
          if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
          }
          return results;
        }
        static findNode(root, nodeName) {
          if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
          }
          if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== void 0) {
              return bone;
            }
          }
          if (root.children) {
            const searchNodeSubtree = function(children) {
              for (let i2 = 0; i2 < children.length; i2++) {
                const childNode = children[i2];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                  return childNode;
                }
                const result = searchNodeSubtree(childNode.children);
                if (result)
                  return result;
              }
              return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
              return subTreeNode;
            }
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(buffer, offset) {
          buffer[offset] = this.targetObject[this.propertyName];
        }
        _getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
            buffer[offset++] = source[i2];
          }
        }
        _getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
        _setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
          this.bind();
          this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
          this.bind();
          this.setValue(sourceArray, offset);
        }
        bind() {
          let targetObject = this.node;
          const parsedPath = this.parsedPath;
          const objectName = parsedPath.objectName;
          const propertyName = parsedPath.propertyName;
          let propertyIndex = parsedPath.propertyIndex;
          if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
          }
          if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch (objectName) {
              case "materials":
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                targetObject = targetObject.material.materials;
                break;
              case "bones":
                if (!targetObject.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                targetObject = targetObject.skeleton.bones;
                for (let i2 = 0; i2 < targetObject.length; i2++) {
                  if (targetObject[i2].name === objectIndex) {
                    objectIndex = i2;
                    break;
                  }
                }
                break;
              default:
                if (targetObject[objectName] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== void 0) {
              if (targetObject[objectIndex] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                return;
              }
              targetObject = targetObject[objectIndex];
            }
          }
          const nodeProperty = targetObject[propertyName];
          if (nodeProperty === void 0) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
          }
          let versioning = this.Versioning.None;
          this.targetObject = targetObject;
          if (targetObject.needsUpdate !== void 0) {
            versioning = this.Versioning.NeedsUpdate;
          } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let bindingType = this.BindingType.Direct;
          if (propertyIndex !== void 0) {
            if (propertyName === "morphTargetInfluences") {
              if (!targetObject.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (targetObject.geometry.isBufferGeometry) {
                if (!targetObject.geometry.morphAttributes) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  return;
                }
                if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                  propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                }
              } else {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                return;
              }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
          } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
          } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
          } else {
            this.propertyName = propertyName;
          }
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      };
      PropertyBinding.Composite = Composite;
      PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      PropertyBinding.prototype.GetterByBindingType = [
        PropertyBinding.prototype._getValue_direct,
        PropertyBinding.prototype._getValue_array,
        PropertyBinding.prototype._getValue_arrayElement,
        PropertyBinding.prototype._getValue_toArray
      ];
      PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
        [
          PropertyBinding.prototype._setValue_direct,
          PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
          PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
          PropertyBinding.prototype._setValue_array,
          PropertyBinding.prototype._setValue_array_setNeedsUpdate,
          PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
          PropertyBinding.prototype._setValue_arrayElement,
          PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
          PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
          PropertyBinding.prototype._setValue_fromArray,
          PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
          PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
      ];
      AnimationObjectGroup = class {
        constructor() {
          this.uuid = generateUUID();
          this._objects = Array.prototype.slice.call(arguments);
          this.nCachedObjects_ = 0;
          const indices = {};
          this._indicesByUUID = indices;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            indices[arguments[i2].uuid] = i2;
          }
          this._paths = [];
          this._parsedPaths = [];
          this._bindings = [];
          this._bindingsIndicesByPath = {};
          const scope = this;
          this.stats = {
            objects: {
              get total() {
                return scope._objects.length;
              },
              get inUse() {
                return this.total - scope.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return scope._bindings.length;
            }
          };
        }
        add() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
          let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === void 0) {
              index = nObjects++;
              indicesByUUID[uuid] = index;
              objects.push(object);
              for (let j = 0, m = nBindings; j !== m; ++j) {
                bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
              }
            } else if (index < nCachedObjects) {
              knownObject = objects[index];
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[uuid] = firstActiveIndex;
              objects[firstActiveIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                let binding = bindingsForPath[index];
                bindingsForPath[index] = lastCached;
                if (binding === void 0) {
                  binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                }
                bindingsForPath[firstActiveIndex] = binding;
              }
            } else if (objects[index] !== knownObject) {
              console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0 && index >= nCachedObjects) {
              const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
              indicesByUUID[firstActiveObject.uuid] = index;
              objects[index] = firstActiveObject;
              indicesByUUID[uuid] = lastCachedIndex;
              objects[lastCachedIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                bindingsForPath[index] = firstActive;
                bindingsForPath[lastCachedIndex] = binding;
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        uncache() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0) {
              delete indicesByUUID[uuid];
              if (index < nCachedObjects) {
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                objects[firstActiveIndex] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                  bindingsForPath[index] = lastCached;
                  bindingsForPath[firstActiveIndex] = last;
                  bindingsForPath.pop();
                }
              } else {
                const lastIndex = --nObjects, lastObject = objects[lastIndex];
                if (lastIndex > 0) {
                  indicesByUUID[lastObject.uuid] = index;
                }
                objects[index] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j];
                  bindingsForPath[index] = bindingsForPath[lastIndex];
                  bindingsForPath.pop();
                }
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        subscribe_(path, parsedPath) {
          const indicesByPath = this._bindingsIndicesByPath;
          let index = indicesByPath[path];
          const bindings = this._bindings;
          if (index !== void 0)
            return bindings[index];
          const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
          index = bindings.length;
          indicesByPath[path] = index;
          paths.push(path);
          parsedPaths.push(parsedPath);
          bindings.push(bindingsForPath);
          for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
            const object = objects[i2];
            bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
          }
          return bindingsForPath;
        }
        unsubscribe_(path) {
          const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
          if (index !== void 0) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
          }
        }
      };
      AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
      AnimationAction = class {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
          this._mixer = mixer;
          this._clip = clip;
          this._localRoot = localRoot;
          this.blendMode = blendMode;
          const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
          const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const interpolant = tracks[i2].createInterpolant(null);
            interpolants[i2] = interpolant;
            interpolant.settings = interpolantSettings;
          }
          this._interpolantSettings = interpolantSettings;
          this._interpolants = interpolants;
          this._propertyBindings = new Array(nTracks);
          this._cacheIndex = null;
          this._byClipCacheIndex = null;
          this._timeScaleInterpolant = null;
          this._weightInterpolant = null;
          this.loop = LoopRepeat;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this.timeScale = 1;
          this._effectiveTimeScale = 1;
          this.weight = 1;
          this._effectiveWeight = 1;
          this.repetitions = Infinity;
          this.paused = false;
          this.enabled = true;
          this.clampWhenFinished = false;
          this.zeroSlopeAtStart = true;
          this.zeroSlopeAtEnd = true;
        }
        play() {
          this._mixer._activateAction(this);
          return this;
        }
        stop() {
          this._mixer._deactivateAction(this);
          return this.reset();
        }
        reset() {
          this.paused = false;
          this.enabled = true;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(time) {
          this._startTime = time;
          return this;
        }
        setLoop(mode, repetitions) {
          this.loop = mode;
          this.repetitions = repetitions;
          return this;
        }
        setEffectiveWeight(weight) {
          this.weight = weight;
          this._effectiveWeight = this.enabled ? weight : 0;
          return this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(duration) {
          return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
          return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);
          if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
          }
          return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
          return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
          const weightInterpolant = this._weightInterpolant;
          if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
          }
          return this;
        }
        setEffectiveTimeScale(timeScale) {
          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;
          return this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(duration) {
          this.timeScale = this._clip.duration / duration;
          return this.stopWarping();
        }
        syncWith(action) {
          this.time = action.time;
          this.timeScale = action.timeScale;
          return this.stopWarping();
        }
        halt(duration) {
          return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
          const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
          let interpolant = this._timeScaleInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now2;
          times[1] = now2 + duration;
          values[0] = startTimeScale / timeScale;
          values[1] = endTimeScale / timeScale;
          return this;
        }
        stopWarping() {
          const timeScaleInterpolant = this._timeScaleInterpolant;
          if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
          }
          return this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(time, deltaTime, timeDirection, accuIndex) {
          if (!this.enabled) {
            this._updateWeight(time);
            return;
          }
          const startTime = this._startTime;
          if (startTime !== null) {
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
              return;
            }
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
          }
          deltaTime *= this._updateTimeScale(time);
          const clipTime = this._updateTime(deltaTime);
          const weight = this._updateWeight(time);
          if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch (this.blendMode) {
              case AdditiveAnimationBlendMode:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulateAdditive(weight);
                }
                break;
              case NormalAnimationBlendMode:
              default:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
          }
        }
        _updateWeight(time) {
          let weight = 0;
          if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              weight *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopFading();
                if (interpolantValue === 0) {
                  this.enabled = false;
                }
              }
            }
          }
          this._effectiveWeight = weight;
          return weight;
        }
        _updateTimeScale(time) {
          let timeScale = 0;
          if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              timeScale *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopWarping();
                if (timeScale === 0) {
                  this.paused = true;
                } else {
                  this.timeScale = timeScale;
                }
              }
            }
          }
          this._effectiveTimeScale = timeScale;
          return timeScale;
        }
        _updateTime(deltaTime) {
          const duration = this._clip.duration;
          const loop = this.loop;
          let time = this.time + deltaTime;
          let loopCount = this._loopCount;
          const pingPong = loop === LoopPingPong;
          if (deltaTime === 0) {
            if (loopCount === -1)
              return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
          }
          if (loop === LoopOnce) {
            if (loopCount === -1) {
              this._loopCount = 0;
              this._setEndings(true, true, false);
            }
            handle_stop: {
              if (time >= duration) {
                time = duration;
              } else if (time < 0) {
                time = 0;
              } else {
                this.time = time;
                break handle_stop;
              }
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime < 0 ? -1 : 1
              });
            }
          } else {
            if (loopCount === -1) {
              if (deltaTime >= 0) {
                loopCount = 0;
                this._setEndings(true, this.repetitions === 0, pingPong);
              } else {
                this._setEndings(this.repetitions === 0, true, pingPong);
              }
            }
            if (time >= duration || time < 0) {
              const loopDelta = Math.floor(time / duration);
              time -= duration * loopDelta;
              loopCount += Math.abs(loopDelta);
              const pending = this.repetitions - loopCount;
              if (pending <= 0) {
                if (this.clampWhenFinished)
                  this.paused = true;
                else
                  this.enabled = false;
                time = deltaTime > 0 ? duration : 0;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: deltaTime > 0 ? 1 : -1
                });
              } else {
                if (pending === 1) {
                  const atStart = deltaTime < 0;
                  this._setEndings(atStart, !atStart, pingPong);
                } else {
                  this._setEndings(false, false, pingPong);
                }
                this._loopCount = loopCount;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta
                });
              }
            } else {
              this.time = time;
            }
            if (pingPong && (loopCount & 1) === 1) {
              return duration - time;
            }
          }
          return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
          const settings = this._interpolantSettings;
          if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
          } else {
            if (atStart) {
              settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
              settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingEnd = WrapAroundEnding;
            }
          }
        }
        _scheduleFading(duration, weightNow, weightThen) {
          const mixer = this._mixer, now2 = mixer.time;
          let interpolant = this._weightInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now2;
          values[0] = weightNow;
          times[1] = now2 + duration;
          values[1] = weightThen;
          return this;
        }
      };
      AnimationMixer = class extends EventDispatcher {
        constructor(root) {
          super();
          this._root = root;
          this._initMemoryManager();
          this._accuIndex = 0;
          this.time = 0;
          this.timeScale = 1;
        }
        _bindAction(action, prototypeAction) {
          const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
          let bindingsByName = bindingsByRoot[rootUuid];
          if (bindingsByName === void 0) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
          }
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const track = tracks[i2], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== void 0) {
              ++binding.referenceCount;
              bindings[i2] = binding;
            } else {
              binding = bindings[i2];
              if (binding !== void 0) {
                if (binding._cacheIndex === null) {
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                }
                continue;
              }
              const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
              binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
              bindings[i2] = binding;
            }
            interpolants[i2].resultBuffer = binding.buffer;
          }
        }
        _activateAction(action) {
          if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
              const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
              this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
              this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
              const binding = bindings[i2];
              if (binding.useCount++ === 0) {
                this._lendBinding(binding);
                binding.saveOriginalState();
              }
            }
            this._lendAction(action);
          }
        }
        _deactivateAction(action) {
          if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
              const binding = bindings[i2];
              if (--binding.useCount === 0) {
                binding.restoreOriginalState();
                this._takeBackBinding(binding);
              }
            }
            this._takeBackAction(action);
          }
        }
        _initMemoryManager() {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          const scope = this;
          this.stats = {
            actions: {
              get total() {
                return scope._actions.length;
              },
              get inUse() {
                return scope._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return scope._bindings.length;
              },
              get inUse() {
                return scope._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return scope._controlInterpolants.length;
              },
              get inUse() {
                return scope._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(action) {
          const index = action._cacheIndex;
          return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
          const actions = this._actions, actionsByClip = this._actionsByClip;
          let actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip === void 0) {
            actionsForClip = {
              knownActions: [action],
              actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
          } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
          }
          action._cacheIndex = actions.length;
          actions.push(action);
          actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
          const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          action._cacheIndex = null;
          const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();
          action._byClipCacheIndex = null;
          const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
          delete actionByRoot[rootUuid];
          if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
          }
          this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (--binding.referenceCount === 0) {
              this._removeInactiveBinding(binding);
            }
          }
        }
        _lendAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;
          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;
          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;
        }
        _addInactiveBinding(binding, rootUuid, trackName) {
          const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
          let bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName === void 0) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
          }
          bindingByName[trackName] = binding;
          binding._cacheIndex = bindings.length;
          bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
          const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();
          delete bindingByName[trackName];
          if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
          }
        }
        _lendBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;
          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;
          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;
        }
        _lendControlInterpolant() {
          const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
          let interpolant = interpolants[lastActiveIndex];
          if (interpolant === void 0) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
          }
          return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
          const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;
          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;
        }
        clipAction(clip, optionalRoot, blendMode) {
          const root = optionalRoot || this._root, rootUuid = root.uuid;
          let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
          const clipUuid = clipObject !== null ? clipObject.uuid : clip;
          const actionsForClip = this._actionsByClip[clipUuid];
          let prototypeAction = null;
          if (blendMode === void 0) {
            if (clipObject !== null) {
              blendMode = clipObject.blendMode;
            } else {
              blendMode = NormalAnimationBlendMode;
            }
          }
          if (actionsForClip !== void 0) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
              return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
              clipObject = prototypeAction._clip;
          }
          if (clipObject === null)
            return null;
          const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
          this._bindAction(newAction, prototypeAction);
          this._addInactiveAction(newAction, clipUuid, rootUuid);
          return newAction;
        }
        existingAction(clip, optionalRoot) {
          const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            return actionsForClip.actionByRoot[rootUuid] || null;
          }
          return null;
        }
        stopAllAction() {
          const actions = this._actions, nActions = this._nActiveActions;
          for (let i2 = nActions - 1; i2 >= 0; --i2) {
            actions[i2].stop();
          }
          return this;
        }
        update(deltaTime) {
          deltaTime *= this.timeScale;
          const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
          for (let i2 = 0; i2 !== nActions; ++i2) {
            const action = actions[i2];
            action._update(time, deltaTime, timeDirection, accuIndex);
          }
          const bindings = this._bindings, nBindings = this._nActiveBindings;
          for (let i2 = 0; i2 !== nBindings; ++i2) {
            bindings[i2].apply(accuIndex);
          }
          return this;
        }
        setTime(timeInSeconds) {
          this.time = 0;
          for (let i2 = 0; i2 < this._actions.length; i2++) {
            this._actions[i2].time = 0;
          }
          return this.update(timeInSeconds);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(clip) {
          const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            const actionsToRemove = actionsForClip.knownActions;
            for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
              const action = actionsToRemove[i2];
              this._deactivateAction(action);
              const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
              action._cacheIndex = null;
              action._byClipCacheIndex = null;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
          }
        }
        uncacheRoot(root) {
          const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
          for (const clipUuid in actionsByClip) {
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== void 0) {
              this._deactivateAction(action);
              this._removeInactiveAction(action);
            }
          }
          const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName !== void 0) {
            for (const trackName in bindingByName) {
              const binding = bindingByName[trackName];
              binding.restoreOriginalState();
              this._removeInactiveBinding(binding);
            }
          }
        }
        uncacheAction(clip, optionalRoot) {
          const action = this.existingAction(clip, optionalRoot);
          if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
      };
      AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      Uniform = class {
        constructor(value) {
          if (typeof value === "string") {
            console.warn("THREE.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
          }
          this.value = value;
        }
        clone() {
          return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
        }
      };
      InstancedInterleavedBuffer = class extends InterleavedBuffer {
        constructor(array, stride, meshPerAttribute = 1) {
          super(array, stride);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        clone(data) {
          const ib = super.clone(data);
          ib.meshPerAttribute = this.meshPerAttribute;
          return ib;
        }
        toJSON(data) {
          const json = super.toJSON(data);
          json.isInstancedInterleavedBuffer = true;
          json.meshPerAttribute = this.meshPerAttribute;
          return json;
        }
      };
      InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
      GLBufferAttribute = class {
        constructor(buffer, type, itemSize, elementSize, count) {
          this.buffer = buffer;
          this.type = type;
          this.itemSize = itemSize;
          this.elementSize = elementSize;
          this.count = count;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setBuffer(buffer) {
          this.buffer = buffer;
          return this;
        }
        setType(type, elementSize) {
          this.type = type;
          this.elementSize = elementSize;
          return this;
        }
        setItemSize(itemSize) {
          this.itemSize = itemSize;
          return this;
        }
        setCount(count) {
          this.count = count;
          return this;
        }
      };
      GLBufferAttribute.prototype.isGLBufferAttribute = true;
      _vector$4 = /* @__PURE__ */ new Vector2();
      Box2 = class {
        constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = Infinity;
          this.max.x = this.max.y = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      Box2.prototype.isBox2 = true;
      _startP = /* @__PURE__ */ new Vector3();
      _startEnd = /* @__PURE__ */ new Vector3();
      Line3 = class {
        constructor(start = new Vector3(), end = new Vector3()) {
          this.start = start;
          this.end = end;
        }
        set(start, end) {
          this.start.copy(start);
          this.end.copy(end);
          return this;
        }
        copy(line) {
          this.start.copy(line.start);
          this.end.copy(line.end);
          return this;
        }
        getCenter(target) {
          return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
          return target.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, target) {
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
          _startP.subVectors(point, this.start);
          _startEnd.subVectors(this.end, this.start);
          const startEnd2 = _startEnd.dot(_startEnd);
          const startEnd_startP = _startEnd.dot(_startP);
          let t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = clamp(t, 0, 1);
          }
          return t;
        }
        closestPointToPoint(point, clampToLine, target) {
          const t = this.closestPointToPointParameter(point, clampToLine);
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        applyMatrix4(matrix) {
          this.start.applyMatrix4(matrix);
          this.end.applyMatrix4(matrix);
          return this;
        }
        equals(line) {
          return line.start.equals(this.start) && line.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _vector$2 = /* @__PURE__ */ new Vector3();
      _boneMatrix = /* @__PURE__ */ new Matrix4();
      _matrixWorldInv = /* @__PURE__ */ new Matrix4();
      SkeletonHelper = class extends LineSegments {
        constructor(object) {
          const bones = getBoneList(object);
          const geometry = new BufferGeometry();
          const vertices = [];
          const colors = [];
          const color1 = new Color(0, 0, 1);
          const color2 = new Color(0, 1, 0);
          for (let i2 = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);
            }
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
          super(geometry, material);
          this.type = "SkeletonHelper";
          this.isSkeletonHelper = true;
          this.root = object;
          this.bones = bones;
          this.matrix = object.matrixWorld;
          this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
          const bones = this.bones;
          const geometry = this.geometry;
          const position = geometry.getAttribute("position");
          _matrixWorldInv.copy(this.root.matrixWorld).invert();
          for (let i2 = 0, j = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
              j += 2;
            }
          }
          geometry.getAttribute("position").needsUpdate = true;
          super.updateMatrixWorld(force);
        }
      };
      GridHelper = class extends LineSegments {
        constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const center = divisions / 2;
          const step = size / divisions;
          const halfSize = size / 2;
          const vertices = [], colors = [];
          for (let i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i2 === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
          }
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
          super(geometry, material);
          this.type = "GridHelper";
        }
      };
      _floatView = new Float32Array(1);
      _int32View = new Int32Array(_floatView.buffer);
      Curve.create = function(construct, getPoint) {
        console.log("THREE.Curve.create() has been deprecated");
        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
      };
      Path.prototype.fromPoints = function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
      };
      GridHelper.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      };
      SkeletonHelper.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      };
      Loader.prototype.extractUrlBase = function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url);
      };
      Loader.Handlers = {
        add: function() {
          console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
        },
        get: function() {
          console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
        }
      };
      Box2.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box2.prototype.empty = function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box2.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box2.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Box3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box3.prototype.empty = function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box3.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box3.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Box3.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Sphere.prototype.empty = function() {
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Frustum.prototype.setFromMatrix = function(m) {
        console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
        return this.setFromProjectionMatrix(m);
      };
      Line3.prototype.center = function(optionalTarget) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix3.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
      };
      Matrix3.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      };
      Matrix3.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
        return attribute.applyMatrix3(this);
      };
      Matrix3.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      };
      Matrix3.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Matrix4.prototype.extractPosition = function(m) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m);
      };
      Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix4.prototype.getPosition = function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector3().setFromMatrixColumn(this, 3);
      };
      Matrix4.prototype.setRotationFromQuaternion = function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
      };
      Matrix4.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      Matrix4.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector4 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      };
      Matrix4.prototype.rotateAxis = function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
      };
      Matrix4.prototype.crossVector = function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix4.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      Matrix4.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      Matrix4.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      Matrix4.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      Matrix4.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      Matrix4.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
        return attribute.applyMatrix4(this);
      };
      Matrix4.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      };
      Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
      };
      Matrix4.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Plane.prototype.isIntersectionLine = function(line) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(line);
      };
      Quaternion.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return vector.applyQuaternion(this);
      };
      Quaternion.prototype.inverse = function() {
        console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
        return this.invert();
      };
      Ray.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Ray.prototype.isIntersectionPlane = function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
      };
      Ray.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Triangle.prototype.area = function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
      };
      Triangle.prototype.barycoordFromPoint = function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
      };
      Triangle.prototype.midpoint = function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
      };
      Triangle.prototypenormal = function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
      };
      Triangle.prototype.plane = function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
      };
      Triangle.barycoordFromPoint = function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a, b, c, target);
      };
      Triangle.normal = function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a, b, c, target);
      };
      Shape.prototype.extractAllPoints = function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
      };
      Shape.prototype.extrude = function(options) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options);
      };
      Shape.prototype.makeGeometry = function(options) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options);
      };
      Vector2.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector2.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector2.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector3.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      };
      Vector3.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      };
      Vector3.prototype.getPositionFromMatrix = function(m) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m);
      };
      Vector3.prototype.getScaleFromMatrix = function(m) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m);
      };
      Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
      };
      Vector3.prototype.applyProjection = function(m) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m);
      };
      Vector3.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector3.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector3.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector4.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector4.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Object3D.prototype.getChildByName = function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
      };
      Object3D.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      };
      Object3D.prototype.translate = function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
      };
      Object3D.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      };
      Object3D.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
          get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
          },
          set: function(value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
          }
        },
        useQuaternion: {
          get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          },
          set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          }
        }
      });
      Mesh.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      };
      Object.defineProperties(Mesh.prototype, {
        drawMode: {
          get: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
            return TrianglesDrawMode;
          },
          set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
          }
        }
      });
      SkinnedMesh.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== void 0)
          this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
      };
      Object.defineProperties(Light.prototype, {
        onlyShadow: {
          set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          }
        },
        shadowCameraFov: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = value;
          }
        },
        shadowCameraLeft: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = value;
          }
        },
        shadowCameraRight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = value;
          }
        },
        shadowCameraTop: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = value;
          }
        },
        shadowCameraBottom: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = value;
          }
        },
        shadowCameraNear: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = value;
          }
        },
        shadowCameraFar: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = value;
          }
        },
        shadowCameraVisible: {
          set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
          }
        },
        shadowBias: {
          set: function(value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
          }
        },
        shadowDarkness: {
          set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          }
        },
        shadowMapWidth: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
          }
        },
        shadowMapHeight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
          }
        }
      });
      Object.defineProperties(BufferAttribute.prototype, {
        length: {
          get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length;
          }
        },
        dynamic: {
          get: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            return this.usage === DynamicDrawUsage;
          },
          set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            this.setUsage(DynamicDrawUsage);
          }
        }
      });
      BufferAttribute.prototype.setDynamic = function(value) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      BufferAttribute.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, BufferAttribute.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      BufferGeometry.prototype.addIndex = function(index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
      };
      BufferGeometry.prototype.addAttribute = function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
          console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
          return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
          console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
          this.setIndex(attribute);
          return this;
        }
        return this.setAttribute(name, attribute);
      };
      BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
        if (indexOffset !== void 0) {
          console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
      };
      BufferGeometry.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
      };
      BufferGeometry.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      };
      BufferGeometry.prototype.removeAttribute = function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
      };
      BufferGeometry.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
          get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
          }
        },
        offsets: {
          get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
          }
        }
      });
      InterleavedBuffer.prototype.setDynamic = function(value) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
      };
      InterleavedBuffer.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      ExtrudeGeometry.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      ExtrudeGeometry.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
      };
      ExtrudeGeometry.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Scene.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Uniform.prototype.onUpdate = function() {
        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
        return this;
      };
      Object.defineProperties(Material.prototype, {
        wrapAround: {
          get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          }
        },
        overdraw: {
          get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          }
        },
        wrapRGB: {
          get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new Color();
          }
        },
        shading: {
          get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = value === FlatShading;
          }
        },
        stencilMask: {
          get: function() {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            return this.stencilFuncMask;
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            this.stencilFuncMask = value;
          }
        },
        vertexTangents: {
          get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          },
          set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          }
        }
      });
      Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
          get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
          },
          set: function(value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
          }
        }
      });
      WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      WebGLRenderer.prototype.animate = function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
      };
      WebGLRenderer.prototype.getCurrentRenderTarget = function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
      };
      WebGLRenderer.prototype.getMaxAnisotropy = function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
      };
      WebGLRenderer.prototype.getPrecision = function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
      };
      WebGLRenderer.prototype.resetGLState = function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
      };
      WebGLRenderer.prototype.supportsFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
      };
      WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
      };
      WebGLRenderer.prototype.supportsStandardDerivatives = function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
      };
      WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
      };
      WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
      };
      WebGLRenderer.prototype.supportsBlendMinMax = function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
      };
      WebGLRenderer.prototype.supportsVertexTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
      };
      WebGLRenderer.prototype.supportsInstancedArrays = function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
      };
      WebGLRenderer.prototype.enableScissorTest = function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
      };
      WebGLRenderer.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      WebGLRenderer.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      WebGLRenderer.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      WebGLRenderer.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      };
      WebGLRenderer.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      };
      WebGLRenderer.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      };
      WebGLRenderer.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      WebGLRenderer.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      WebGLRenderer.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      };
      WebGLRenderer.prototype.getActiveMipMapLevel = function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
      };
      Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
          get: function() {
            return this.shadowMap.enabled;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
          }
        },
        shadowMapType: {
          get: function() {
            return this.shadowMap.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
          }
        },
        shadowMapCullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        context: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
            return this.getContext();
          }
        },
        vr: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
            return this.xr;
          }
        },
        gammaInput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
            return false;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          }
        },
        gammaOutput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            return false;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
          }
        },
        toneMappingWhitePoint: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
            return 1;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          }
        },
        gammaFactor: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
            return 2;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          }
        }
      });
      Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        renderReverseSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          }
        },
        renderSingleSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          }
        }
      });
      Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
          }
        },
        wrapT: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
          }
        },
        magFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
          }
        },
        minFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
          }
        },
        anisotropy: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
          }
        },
        offset: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = value;
          }
        },
        repeat: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = value;
          }
        },
        format: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = value;
          }
        },
        type: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = value;
          }
        },
        generateMipmaps: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
          }
        }
      });
      Audio.prototype.load = function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const scope = this;
        const audioLoader = new AudioLoader();
        audioLoader.load(file, function(buffer) {
          scope.setBuffer(buffer);
        });
        return this;
      };
      AudioAnalyser.prototype.getData = function() {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData();
      };
      CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
        return this.update(renderer, scene);
      };
      CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
        console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
        return this.renderTarget.clear(renderer, color, depth, stencil);
      };
      ImageUtils.crossOrigin = void 0;
      ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const loader4 = new TextureLoader();
        loader4.setCrossOrigin(this.crossOrigin);
        const texture = loader4.load(url, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const loader4 = new CubeTextureLoader();
        loader4.setCrossOrigin(this.crossOrigin);
        const texture = loader4.load(urls, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      };
      ImageUtils.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
          revision: REVISION
        } }));
      }
      if (typeof window !== "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = REVISION;
        }
      }
    }
  });

  // node_modules/@jocabola/gfx/lib/glsl/fbo.frag
  var fbo_default;
  var init_fbo = __esm({
    "node_modules/@jocabola/gfx/lib/glsl/fbo.frag"() {
      fbo_default = "#version 100\nprecision lowp float;\n\nuniform sampler2D tInput;\nuniform float opacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n	gl_FragColor = texture2D(tInput, vUv) * opacity;\n}";
    }
  });

  // node_modules/@jocabola/gfx/lib/glsl/fbo.vert
  var fbo_default2;
  var init_fbo2 = __esm({
    "node_modules/@jocabola/gfx/lib/glsl/fbo.vert"() {
      fbo_default2 = "#version 100\n\nprecision lowp float;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nuniform float time;\n\nvarying vec2 vUv;\n\nvoid main () {\n	vec3 pos = position;\n	vUv = uv;\n	vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);\n	gl_Position = projectionMatrix * mvPos;\n}";
    }
  });

  // node_modules/@jocabola/gfx/lib/utils/FboHelper.js
  var TMP, MAT, FboHelper;
  var init_FboHelper = __esm({
    "node_modules/@jocabola/gfx/lib/utils/FboHelper.js"() {
      init_three_module();
      init_fbo();
      init_fbo2();
      TMP = new Vector2();
      MAT = new RawShaderMaterial({
        vertexShader: fbo_default2,
        fragmentShader: fbo_default,
        uniforms: {
          tInput: { value: null },
          opacity: { value: 1 }
        }
      });
      FboHelper = class {
        constructor() {
          this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
          this.material = MAT;
          var postPlane = new PlaneGeometry(1, 1);
          this.quad = new Mesh(postPlane, this.material);
          this.scene = new Scene();
          this.scene.add(this.quad);
        }
        render(target, renderer, x = 0, y = 0, width = 0, height = 0, opacity = 1) {
          if (width == 0 || height == 0) {
            width = target.width;
            height = target.height;
          }
          this.drawTexture(target.texture, renderer, x, y, width, height, opacity);
        }
        renderMRT(target, renderer, index, x = 0, y = 0, width = 0, height = 0) {
          if (width == 0 || height == 0) {
            width = target.width;
            height = target.height;
          }
          this.drawTexture(target.texture[index], renderer, x, y, width, height);
        }
        drawTexture(texture, renderer, x = 0, y = 0, width = 0, height = 0, opacity = 1) {
          const s = new Vector2();
          renderer.getSize(s);
          this.camera.left = -s.width / 2;
          this.camera.right = s.width / 2;
          this.camera.top = s.height / 2;
          this.camera.bottom = -s.height / 2;
          this.camera.updateProjectionMatrix();
          this.quad.scale.set(width, height, 1);
          this.quad.position.set(-s.width / 2 + width / 2 + x, s.height / 2 - height / 2 - y, 0);
          this.quad.material = this.material;
          this.material.uniforms.tInput.value = texture;
          this.material.transparent = texture.format == RGBAFormat;
          this.material.uniforms.opacity.value = opacity;
          renderer.render(this.scene, this.camera);
        }
        renderToFbo(target, renderer, material) {
          let s = new Vector2(target.width, target.height);
          this.camera.left = -s.width / 2;
          this.camera.right = s.width / 2;
          this.camera.top = s.height / 2;
          this.camera.bottom = -s.height / 2;
          this.camera.updateProjectionMatrix();
          this.quad.scale.set(s.width, s.height, 1);
          this.quad.position.set(0, 0, 0);
          this.quad.material = material;
          renderer.setRenderTarget(target);
          renderer.render(this.scene, this.camera);
          renderer.setRenderTarget(null);
        }
        renderToViewport(renderer, material) {
          renderer.getSize(TMP);
          this.camera.left = -TMP.x / 2;
          this.camera.right = TMP.x / 2;
          this.camera.top = TMP.y / 2;
          this.camera.bottom = -TMP.y / 2;
          this.camera.updateProjectionMatrix();
          this.quad.scale.set(TMP.x, TMP.y, 1);
          this.quad.position.set(0, 0, 0);
          this.quad.material = material;
          renderer.setRenderTarget(null);
          renderer.render(this.scene, this.camera);
        }
        dispose() {
          this.quad.geometry.dispose();
        }
      };
    }
  });

  // node_modules/@jocabola/gfx/lib/utils/FboUtils.js
  var FboUtils;
  var init_FboUtils = __esm({
    "node_modules/@jocabola/gfx/lib/utils/FboUtils.js"() {
      init_three_module();
      init_FboHelper();
      FboUtils = class {
        static getRenderTarget(width, height, settings = {}, depth = false) {
          const target = new WebGLRenderTarget(width, height, {
            minFilter: settings.minFilter !== void 0 ? settings.minFilter : LinearFilter,
            magFilter: settings.magFilter !== void 0 ? settings.magFilter : LinearFilter,
            wrapS: settings.wrapS !== void 0 ? settings.wrapS : ClampToEdgeWrapping,
            wrapT: settings.wrapT !== void 0 ? settings.wrapT : ClampToEdgeWrapping,
            format: settings.format ? settings.format : RGBAFormat,
            type: settings.type !== void 0 ? settings.type : UnsignedByteType,
            stencilBuffer: settings.stencilBuffer !== void 0 ? settings.stencilBuffer : true
          });
          if (depth) {
            target.depthTexture = new DepthTexture(width, height, UnsignedShortType);
          }
          return target;
        }
        static drawFbo(fbo, renderer, x = 0, y = 0, width = 0, height = 0, opacity = 1) {
          FboUtils.helper.render(fbo, renderer, x, y, width, height, opacity);
        }
        static drawMRT(mrt, renderer, index, x = 0, y = 0, width = 0, height = 0) {
          FboUtils.helper.renderMRT(mrt, renderer, index, x, y, width, height);
        }
        static drawTexture(texture, renderer, x = 0, y = 0, width = 0, height = 0, opacity = 1) {
          FboUtils.helper.drawTexture(texture, renderer, x, y, width, height, opacity);
        }
        static renderToFbo(fbo, renderer, material) {
          FboUtils.helper.renderToFbo(fbo, renderer, material);
        }
        static renderToViewport(renderer, material) {
          FboUtils.helper.renderToViewport(renderer, material);
        }
      };
      FboUtils.helper = new FboHelper();
    }
  });

  // node_modules/@jocabola/gfx/lib/composer/RenderComposer.js
  var TO_SCREEN;
  var init_RenderComposer = __esm({
    "node_modules/@jocabola/gfx/lib/composer/RenderComposer.js"() {
      init_three_module();
      init_fbo();
      init_fbo2();
      TO_SCREEN = new RawShaderMaterial({
        vertexShader: fbo_default2,
        fragmentShader: fbo_default,
        uniforms: {
          tInput: {
            value: null
          }
        }
      });
    }
  });

  // node_modules/@jocabola/gfx/lib/composer/RenderPass.js
  var init_RenderPass = __esm({
    "node_modules/@jocabola/gfx/lib/composer/RenderPass.js"() {
    }
  });

  // node_modules/@jocabola/gfx/lib/composer/BlurPass.js
  var init_BlurPass = __esm({
    "node_modules/@jocabola/gfx/lib/composer/BlurPass.js"() {
      init_FboUtils();
      init_RenderPass();
    }
  });

  // node_modules/@jocabola/gfx/lib/glsl/vfx/dof.frag
  var dof_default;
  var init_dof = __esm({
    "node_modules/@jocabola/gfx/lib/glsl/vfx/dof.frag"() {
      dof_default = "#version 100\nprecision highp float;\n\n#include <depth>\n\nuniform sampler2D tDepth;\nuniform sampler2D tInput;\nuniform sampler2D tBlur;\nuniform bool debug;\nvarying vec2 vUv;\n\nuniform float aperture;\nuniform float focalDistance;\n\nvoid main () {\n	float depth = smoothstep(0., 1., readDepth (tDepth, vUv));\n	vec3 noBlur = texture2D(tInput, vUv).rgb;\n	vec3 blur = texture2D(tBlur, vUv).rgb;\n\n	float distanceToCamera = mix(cameraNear, cameraFar, depth);\n\n	float CoC = distance(distanceToCamera, focalDistance);\n	float st = smoothstep(0.0, aperture, CoC);\n\n	vec3 color = mix(noBlur, blur, st);\n	\n	if(debug) {\n		gl_FragColor = vec4(vec3(depth), 1.0);\n	}\n	else {\n		gl_FragColor = vec4(color, 1.0);\n	}\n}";
    }
  });

  // node_modules/@jocabola/gfx/lib/composer/DoFPass.js
  var SHADER;
  var init_DoFPass = __esm({
    "node_modules/@jocabola/gfx/lib/composer/DoFPass.js"() {
      init_three_module();
      init_BlurPass();
      init_RenderPass();
      init_fbo2();
      init_dof();
      SHADER = new RawShaderMaterial({
        vertexShader: fbo_default2,
        fragmentShader: dof_default,
        uniforms: {
          tInput: { value: null },
          tBlur: { value: null },
          tDepth: { value: null },
          cameraNear: { value: 0 },
          cameraFar: { value: 100 },
          aperture: { value: 1.5 },
          focalDistance: { value: 1 },
          debug: { value: false }
        }
      });
    }
  });

  // node_modules/@jocabola/gfx/lib/composer/FXAAPass.js
  var init_FXAAPass = __esm({
    "node_modules/@jocabola/gfx/lib/composer/FXAAPass.js"() {
      init_RenderPass();
    }
  });

  // node_modules/@jocabola/gfx/lib/prototype/Sketch.js
  var Sketch;
  var init_Sketch = __esm({
    "node_modules/@jocabola/gfx/lib/prototype/Sketch.js"() {
      Sketch = class {
        constructor() {
          this._paused = false;
          this._raf = null;
          this._rafId = -1;
          this._started = false;
        }
        get started() {
          return this._started;
        }
        start(customRaf = null) {
          if (this._started)
            return;
          this._started = true;
          const animate = () => {
            this.update();
            this.render();
            requestAnimationFrame(animate);
          };
          if (customRaf == null) {
            this._raf = animate;
          } else {
            this._raf = customRaf;
          }
          this._rafId = requestAnimationFrame(this._raf);
          return this._rafId;
        }
        pause() {
          if (!this._started)
            return;
          if (this._paused)
            return;
          this._paused = true;
          cancelAnimationFrame(this._rafId);
        }
        resume() {
          if (!this._started)
            return;
          if (!this._paused)
            return;
          this._paused = false;
          this._rafId = requestAnimationFrame(this._raf);
        }
        update() {
        }
        render() {
        }
      };
    }
  });

  // node_modules/@jocabola/gfx/lib/prototype/WebGLSketch.js
  var WebGLSketch;
  var init_WebGLSketch = __esm({
    "node_modules/@jocabola/gfx/lib/prototype/WebGLSketch.js"() {
      init_three_module();
      init_Sketch();
      WebGLSketch = class extends Sketch {
        constructor(width = window.innerWidth, height = window.innerHeight, opts = {}, autoStart = false) {
          super();
          this.size = new Vector2();
          this.scene = new Scene();
          if (opts.ortho) {
            this.camera = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, opts.near != void 0 ? opts.near : 0.1, opts.far != void 0 ? opts.far : 1e3);
          } else {
            this.camera = new PerspectiveCamera(opts.fov != void 0 ? opts.fov : 35, width / height, opts.near != void 0 ? opts.near : 0.1, opts.far != void 0 ? opts.far : 1e3);
          }
          this.scene.add(this.camera);
          this.renderer = new WebGLRenderer({
            antialias: opts.antialias != void 0 ? opts.antialias : true,
            alpha: opts.alpha != void 0 ? opts.alpha : true
          });
          this.renderer.setSize(width, height);
          if (autoStart)
            this.start();
        }
        start(customRaf = null) {
          if (this.started)
            return;
          this.clock = new Clock(true);
          return super.start(customRaf);
        }
        get domElement() {
          return this.renderer.domElement;
        }
        resize(width, height) {
          if (width === this.size.x && height === this.size.y)
            return;
          this.size.set(width, height);
          this.renderer.setSize(this.size.x, this.size.y);
          if (this.camera.type == "PerspectiveCamera") {
            this.camera.aspect = this.size.x / this.size.y;
          } else {
            this.camera.left = -width / 2;
            this.camera.right = width / 2;
            this.camera.top = height / 2;
            this.camera.bottom = -height / 2;
          }
          this.camera.updateProjectionMatrix();
        }
        render() {
          this.renderer.render(this.scene, this.camera);
        }
      };
    }
  });

  // node_modules/@jocabola/gfx/lib/utils/SceneUtils.js
  var init_SceneUtils = __esm({
    "node_modules/@jocabola/gfx/lib/utils/SceneUtils.js"() {
    }
  });

  // node_modules/@jocabola/gfx/lib/utils/GfxUtils.js
  var RAD2DEG2, DEG2RAD2;
  var init_GfxUtils = __esm({
    "node_modules/@jocabola/gfx/lib/utils/GfxUtils.js"() {
      RAD2DEG2 = 180 / Math.PI;
      DEG2RAD2 = Math.PI / 180;
    }
  });

  // node_modules/@jocabola/io/lib/io.js
  var io, ioInstance;
  var init_io = __esm({
    "node_modules/@jocabola/io/lib/io.js"() {
      io = class {
        constructor() {
        }
        static get Instance() {
          return this._instance || (this._instance = new this());
        }
        static load(url, callback, errorCallback, params) {
          let r = new XMLHttpRequest();
          r.open("GET", url, true);
          if (params != void 0)
            r.responseType = params.responseType;
          r.onload = () => {
            if (r.status >= 400 && errorCallback != void 0)
              errorCallback(r);
            if (r.status == 200 && callback != void 0)
              callback(r.response);
          };
          r.send();
        }
        static loadBinary(url, callback, errorCallback) {
          io.load(url, callback, errorCallback, {
            responseType: "arraybuffer"
          });
        }
        static fetchVimeo(url, callback) {
          const req = new XMLHttpRequest();
          req.responseType = "json";
          req.onload = () => {
            callback(req.responseURL);
          };
          req.open("GET", url);
          req.send();
        }
      };
      ioInstance = io.Instance;
    }
  });

  // node_modules/@jocabola/io/lib/AssetsBundle.js
  var AssetsBundle;
  var init_AssetsBundle = __esm({
    "node_modules/@jocabola/io/lib/AssetsBundle.js"() {
      AssetsBundle = class {
        constructor() {
          this.assets = [];
        }
        add(asset) {
          this.assets.push(asset);
        }
        loadAll(onLoaded = null, onProgress = null) {
          for (const a of this.assets) {
            a.load();
          }
          if (onLoaded != null || onProgress != null) {
            const prog = () => {
              if (this.loaded) {
                onProgress(1);
                return onLoaded();
              }
              if (onProgress != null)
                onProgress(this.getProgress());
              window.setTimeout(prog, 100 / 3);
            };
            prog();
          }
        }
        load(i2) {
          if (i2 < this.assets.length && !this.assets[i2].loaded)
            this.assets[i2].load();
          else
            console.warn("Asset out of range or already loaded");
        }
        getProgress() {
          let p2 = 0;
          let k = 0;
          for (let a of this.assets) {
            if (a.loaded) {
              k++;
              p2 += 1 / this.assets.length;
            }
          }
          if (k === this.assets.length)
            p2 = 1;
          return p2;
        }
        get(i2) {
          if (i2 < 0 || i2 > this.assets.length - 1)
            return null;
          return this.assets[i2];
        }
        getByURL(url) {
          for (let i2 = 0; i2 < this.assets.length; i2++) {
            if (this.assets[i2].url == url)
              return this.assets[i2];
          }
          return null;
        }
        getIndexByURL(url) {
          for (let i2 = 0; i2 < this.assets.length; i2++) {
            if (this.assets[i2].url == url)
              return i2;
          }
          return -1;
        }
        destroy() {
          for (let i2 = 0; i2 < this.assets.length; i2++) {
            this.assets[i2].destroy();
          }
          this.assets.splice(0, this.assets.length);
        }
        get failed() {
          for (let a of this.assets) {
            if (a.failed)
              return true;
          }
          return false;
        }
        get loaded() {
          for (let a of this.assets) {
            if (a.failed || !a.loaded)
              return false;
          }
          return true;
        }
      };
    }
  });

  // node_modules/@jocabola/io/lib/assets/Asset.js
  var Asset;
  var init_Asset = __esm({
    "node_modules/@jocabola/io/lib/assets/Asset.js"() {
      init_io();
      Asset = class {
        constructor(url, binary = false) {
          this.url = url;
          this.binary = binary;
          this.content = null;
          this._failed = false;
          this._loaded = false;
        }
        get loaded() {
          return this._loaded;
        }
        get failed() {
          return this._failed;
        }
        load(callback) {
          if (this.loaded)
            return;
          const onError = (res) => {
            this._failed = true;
            console.warn("Failed loading Asset", res.status);
          };
          if (!this.binary) {
            return io.load(this.url, (res) => {
              this.content = res;
              this._loaded = true;
              if (callback != void 0)
                callback();
            }, onError);
          }
          io.loadBinary(this.url, (res) => {
            this.content = res;
            this._loaded = true;
            if (callback != void 0)
              callback();
          }, onError);
        }
        destroy() {
          this.content = null;
        }
      };
    }
  });

  // node_modules/@jocabola/io/lib/utils/TextureUtils.js
  var TextureUtils;
  var init_TextureUtils = __esm({
    "node_modules/@jocabola/io/lib/utils/TextureUtils.js"() {
      init_three_module();
      TextureUtils = class {
        static applyTextureOptions(tex, opts) {
          const d = TextureUtils.TextureDefaults;
          tex.format = opts.format ? opts.format : d.format;
          tex.wrapS = opts.wrapS ? opts.wrapS : d.wrapS;
          tex.wrapT = opts.wrapT ? opts.wrapT : d.wrapT;
          tex.repeat = opts.repeat ? opts.repeat : d.repeat;
          tex.magFilter = opts.magFilter ? opts.magFilter : d.magFilter;
          tex.minFilter = opts.minFilter ? opts.minFilter : d.minFilter;
          tex.flipY = opts.flipY != void 0 ? opts.flipY : d.flipY;
        }
      };
      TextureUtils.TextureDefaults = {
        format: RGBAFormat,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping,
        repeat: new Vector2(1, 1),
        magFilter: LinearFilter,
        minFilter: LinearMipmapLinearFilter,
        flipY: true
      };
    }
  });

  // node_modules/three/examples/jsm/loaders/DDSLoader.js
  var DDSLoader;
  var init_DDSLoader = __esm({
    "node_modules/three/examples/jsm/loaders/DDSLoader.js"() {
      init_three_module();
      DDSLoader = class extends CompressedTextureLoader {
        constructor(manager) {
          super(manager);
        }
        parse(buffer, loadMipmaps) {
          const dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };
          const DDS_MAGIC = 542327876;
          const DDSD_MIPMAPCOUNT = 131072;
          const DDSCAPS2_CUBEMAP = 512;
          const DDSCAPS2_CUBEMAP_POSITIVEX = 1024;
          const DDSCAPS2_CUBEMAP_NEGATIVEX = 2048;
          const DDSCAPS2_CUBEMAP_POSITIVEY = 4096;
          const DDSCAPS2_CUBEMAP_NEGATIVEY = 8192;
          const DDSCAPS2_CUBEMAP_POSITIVEZ = 16384;
          const DDSCAPS2_CUBEMAP_NEGATIVEZ = 32768;
          const DDPF_FOURCC = 4;
          function fourCCToInt32(value) {
            return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
          }
          function int32ToFourCC(value) {
            return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
          }
          function loadARGBMip(buffer2, dataOffset2, width, height) {
            const dataLength = width * height * 4;
            const srcBuffer = new Uint8Array(buffer2, dataOffset2, dataLength);
            const byteArray = new Uint8Array(dataLength);
            let dst = 0;
            let src = 0;
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const b = srcBuffer[src];
                src++;
                const g = srcBuffer[src];
                src++;
                const r = srcBuffer[src];
                src++;
                const a = srcBuffer[src];
                src++;
                byteArray[dst] = r;
                dst++;
                byteArray[dst] = g;
                dst++;
                byteArray[dst] = b;
                dst++;
                byteArray[dst] = a;
                dst++;
              }
            }
            return byteArray;
          }
          const FOURCC_DXT1 = fourCCToInt32("DXT1");
          const FOURCC_DXT3 = fourCCToInt32("DXT3");
          const FOURCC_DXT5 = fourCCToInt32("DXT5");
          const FOURCC_ETC1 = fourCCToInt32("ETC1");
          const headerLengthInt = 31;
          const off_magic = 0;
          const off_size = 1;
          const off_flags = 2;
          const off_height = 3;
          const off_width = 4;
          const off_mipmapCount = 7;
          const off_pfFlags = 20;
          const off_pfFourCC = 21;
          const off_RGBBitCount = 22;
          const off_RBitMask = 23;
          const off_GBitMask = 24;
          const off_BBitMask = 25;
          const off_ABitMask = 26;
          const off_caps2 = 28;
          const header = new Int32Array(buffer, 0, headerLengthInt);
          if (header[off_magic] !== DDS_MAGIC) {
            console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header.");
            return dds;
          }
          if (!header[off_pfFlags] & DDPF_FOURCC) {
            console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.");
            return dds;
          }
          let blockBytes;
          const fourCC = header[off_pfFourCC];
          let isRGBAUncompressed = false;
          switch (fourCC) {
            case FOURCC_DXT1:
              blockBytes = 8;
              dds.format = RGB_S3TC_DXT1_Format;
              break;
            case FOURCC_DXT3:
              blockBytes = 16;
              dds.format = RGBA_S3TC_DXT3_Format;
              break;
            case FOURCC_DXT5:
              blockBytes = 16;
              dds.format = RGBA_S3TC_DXT5_Format;
              break;
            case FOURCC_ETC1:
              blockBytes = 8;
              dds.format = RGB_ETC1_Format;
              break;
            default:
              if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 16711680 && header[off_GBitMask] & 65280 && header[off_BBitMask] & 255 && header[off_ABitMask] & 4278190080) {
                isRGBAUncompressed = true;
                blockBytes = 64;
                dds.format = RGBAFormat;
              } else {
                console.error("THREE.DDSLoader.parse: Unsupported FourCC code ", int32ToFourCC(fourCC));
                return dds;
              }
          }
          dds.mipmapCount = 1;
          if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
          }
          const caps2 = header[off_caps2];
          dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
          if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {
            console.error("THREE.DDSLoader.parse: Incomplete cubemap faces");
            return dds;
          }
          dds.width = header[off_width];
          dds.height = header[off_height];
          let dataOffset = header[off_size] + 4;
          const faces = dds.isCubemap ? 6 : 1;
          for (let face = 0; face < faces; face++) {
            let width = dds.width;
            let height = dds.height;
            for (let i2 = 0; i2 < dds.mipmapCount; i2++) {
              let byteArray, dataLength;
              if (isRGBAUncompressed) {
                byteArray = loadARGBMip(buffer, dataOffset, width, height);
                dataLength = byteArray.length;
              } else {
                dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                byteArray = new Uint8Array(buffer, dataOffset, dataLength);
              }
              const mipmap = { "data": byteArray, "width": width, "height": height };
              dds.mipmaps.push(mipmap);
              dataOffset += dataLength;
              width = Math.max(width >> 1, 1);
              height = Math.max(height >> 1, 1);
            }
          }
          return dds;
        }
      };
    }
  });

  // node_modules/@jocabola/io/lib/assets/TextureAsset.js
  var loader, compLoader, TextureAsset;
  var init_TextureAsset = __esm({
    "node_modules/@jocabola/io/lib/assets/TextureAsset.js"() {
      init_three_module();
      init_TextureUtils();
      init_Asset();
      init_DDSLoader();
      loader = new TextureLoader();
      compLoader = new DDSLoader();
      TextureAsset = class extends Asset {
        constructor(url, opts = {}, compressed = false) {
          super(url, false);
          this.options = opts;
          this.isCompressed = compressed;
        }
        load(callback = null) {
          const L = this.isCompressed ? compLoader : loader;
          L.load(this.url, (texture) => {
            this.content = texture;
            TextureUtils.applyTextureOptions(texture, this.options);
            if (callback != null)
              callback();
            this._loaded = true;
          }, (event) => {
          }, (event) => {
            console.warn("Error Loading Image Asset");
            this._failed = true;
          });
        }
        destroy() {
          this.content.dispose();
          this.content = null;
        }
      };
    }
  });

  // node_modules/@jocabola/io/lib/assets/CubeTextureAsset.js
  var loader2;
  var init_CubeTextureAsset = __esm({
    "node_modules/@jocabola/io/lib/assets/CubeTextureAsset.js"() {
      init_Asset();
      init_three_module();
      init_TextureUtils();
      loader2 = new CubeTextureLoader();
    }
  });

  // node_modules/@jocabola/io/lib/assets/VideoTextureAsset.js
  var init_VideoTextureAsset = __esm({
    "node_modules/@jocabola/io/lib/assets/VideoTextureAsset.js"() {
      init_TextureUtils();
      init_Asset();
    }
  });

  // node_modules/three/examples/jsm/loaders/GLTFLoader.js
  function GLTFRegistry() {
    let objects = {};
    return {
      get: function(key) {
        return objects[key];
      },
      add: function(key, object) {
        objects[key] = object;
      },
      remove: function(key) {
        delete objects[key];
      },
      removeAll: function() {
        objects = {};
      }
    };
  }
  function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
      cache["DefaultMaterial"] = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }
    return cache["DefaultMaterial"];
  }
  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for (const name in objectDef.extensions) {
      if (knownExtensions[name] === void 0) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
      if (typeof gltfDef.extras === "object") {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
      }
    }
  }
  function addMorphTargets(geometry, targets, parser) {
    let hasMorphPosition = false;
    let hasMorphNormal = false;
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (target.POSITION !== void 0)
        hasMorphPosition = true;
      if (target.NORMAL !== void 0)
        hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal)
        break;
    }
    if (!hasMorphPosition && !hasMorphNormal)
      return Promise.resolve(geometry);
    const pendingPositionAccessors = [];
    const pendingNormalAccessors = [];
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (hasMorphPosition) {
        const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }
      if (hasMorphNormal) {
        const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
    }
    return Promise.all([
      Promise.all(pendingPositionAccessors),
      Promise.all(pendingNormalAccessors)
    ]).then(function(accessors) {
      const morphPositions = accessors[0];
      const morphNormals = accessors[1];
      if (hasMorphPosition)
        geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal)
        geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
      for (let i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
        mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
      }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      const targetNames = meshDef.extras.targetNames;
      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};
        for (let i2 = 0, il = targetNames.length; i2 < il; i2++) {
          mesh.morphTargetDictionary[targetNames[i2]] = i2;
        }
      } else {
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
  }
  function createPrimitiveKey(primitiveDef) {
    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    let geometryKey;
    if (dracoExtension) {
      geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    return geometryKey;
  }
  function createAttributesKey(attributes) {
    let attributesKey = "";
    const keys = Object.keys(attributes).sort();
    for (let i2 = 0, il = keys.length; i2 < il; i2++) {
      attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
    }
    return attributesKey;
  }
  function getNormalizedComponentScale(constructor) {
    switch (constructor) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  function buildNodeHierarchy(nodeId, parentObject, json, parser) {
    const nodeDef = json.nodes[nodeId];
    return parser.getDependency("node", nodeId).then(function(node) {
      if (nodeDef.skin === void 0)
        return node;
      let skinEntry;
      return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
        skinEntry = skin;
        const pendingJoints = [];
        for (let i2 = 0, il = skinEntry.joints.length; i2 < il; i2++) {
          pendingJoints.push(parser.getDependency("node", skinEntry.joints[i2]));
        }
        return Promise.all(pendingJoints);
      }).then(function(jointNodes) {
        node.traverse(function(mesh) {
          if (!mesh.isMesh)
            return;
          const bones = [];
          const boneInverses = [];
          for (let j = 0, jl = jointNodes.length; j < jl; j++) {
            const jointNode = jointNodes[j];
            if (jointNode) {
              bones.push(jointNode);
              const mat = new Matrix4();
              if (skinEntry.inverseBindMatrices !== void 0) {
                mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
              }
              boneInverses.push(mat);
            } else {
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
            }
          }
          mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
        });
        return node;
      });
    }).then(function(node) {
      parentObject.add(node);
      const pending = [];
      if (nodeDef.children) {
        const children = nodeDef.children;
        for (let i2 = 0, il = children.length; i2 < il; i2++) {
          const child = children[i2];
          pending.push(buildNodeHierarchy(child, node, json, parser));
        }
      }
      return Promise.all(pending);
    });
  }
  function computeBounds(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const box = new Box3();
    if (attributes.POSITION !== void 0) {
      const accessor = parser.json.accessors[attributes.POSITION];
      const min = accessor.min;
      const max = accessor.max;
      if (min !== void 0 && max !== void 0) {
        box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
        if (accessor.normalized) {
          const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
          box.min.multiplyScalar(boxScale);
          box.max.multiplyScalar(boxScale);
        }
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else {
      return;
    }
    const targets = primitiveDef.targets;
    if (targets !== void 0) {
      const maxDisplacement = new Vector3();
      const vector = new Vector3();
      for (let i2 = 0, il = targets.length; i2 < il; i2++) {
        const target = targets[i2];
        if (target.POSITION !== void 0) {
          const accessor = parser.json.accessors[target.POSITION];
          const min = accessor.min;
          const max = accessor.max;
          if (min !== void 0 && max !== void 0) {
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
            if (accessor.normalized) {
              const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
              vector.multiplyScalar(boxScale);
            }
            maxDisplacement.max(vector);
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
      }
      box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    const sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }
    for (const gltfAttributeName in attributes) {
      const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
      if (threeAttributeName in geometry.attributes)
        continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
      const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
        geometry.setIndex(accessor2);
      });
      pending.push(accessor);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
      return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  function toTrianglesDrawMode(geometry, drawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i2 = 0; i2 < position.count; i2++) {
          indices.push(i2);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i2 = 1; i2 <= numberOfTriangles; i2++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i2));
        newIndices.push(index.getX(i2 + 1));
      }
    } else {
      for (let i2 = 0; i2 < numberOfTriangles; i2++) {
        if (i2 % 2 === 0) {
          newIndices.push(index.getX(i2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2 + 2));
        } else {
          newIndices.push(index.getX(i2 + 2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }
  var GLTFLoader, EXTENSIONS, GLTFLightsExtension, GLTFMaterialsUnlitExtension, GLTFMaterialsClearcoatExtension, GLTFMaterialsSheenExtension, GLTFMaterialsTransmissionExtension, GLTFMaterialsVolumeExtension, GLTFMaterialsIorExtension, GLTFMaterialsSpecularExtension, GLTFTextureBasisUExtension, GLTFTextureWebPExtension, GLTFMeshoptCompression, BINARY_EXTENSION_HEADER_MAGIC, BINARY_EXTENSION_HEADER_LENGTH, BINARY_EXTENSION_CHUNK_TYPES, GLTFBinaryExtension, GLTFDracoMeshCompressionExtension, GLTFTextureTransformExtension, GLTFMeshStandardSGMaterial, GLTFMaterialsPbrSpecularGlossinessExtension, GLTFMeshQuantizationExtension, GLTFCubicSplineInterpolant, _q, GLTFCubicSplineQuaternionInterpolant, WEBGL_CONSTANTS, WEBGL_COMPONENT_TYPES, WEBGL_FILTERS, WEBGL_WRAPPINGS, WEBGL_TYPE_SIZES, ATTRIBUTES, PATH_PROPERTIES, INTERPOLATION, ALPHA_MODES, GLTFParser;
  var init_GLTFLoader = __esm({
    "node_modules/three/examples/jsm/loaders/GLTFLoader.js"() {
      init_three_module();
      GLTFLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          this.dracoLoader = null;
          this.ktx2Loader = null;
          this.meshoptDecoder = null;
          this.pluginCallbacks = [];
          this.register(function(parser) {
            return new GLTFMaterialsClearcoatExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFTextureBasisUExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFTextureWebPExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsSheenExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsTransmissionExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsVolumeExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsIorExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsSpecularExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFLightsExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMeshoptCompression(parser);
          });
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          let resourcePath;
          if (this.resourcePath !== "") {
            resourcePath = this.resourcePath;
          } else if (this.path !== "") {
            resourcePath = this.path;
          } else {
            resourcePath = LoaderUtils.extractUrlBase(url);
          }
          this.manager.itemStart(url);
          const _onError = function(e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          };
          const loader4 = new FileLoader(this.manager);
          loader4.setPath(this.path);
          loader4.setResponseType("arraybuffer");
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(this.withCredentials);
          loader4.load(url, function(data) {
            try {
              scope.parse(data, resourcePath, function(gltf) {
                onLoad(gltf);
                scope.manager.itemEnd(url);
              }, _onError);
            } catch (e) {
              _onError(e);
            }
          }, onProgress, _onError);
        }
        setDRACOLoader(dracoLoader) {
          this.dracoLoader = dracoLoader;
          return this;
        }
        setDDSLoader() {
          throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
        }
        setKTX2Loader(ktx2Loader2) {
          this.ktx2Loader = ktx2Loader2;
          return this;
        }
        setMeshoptDecoder(meshoptDecoder) {
          this.meshoptDecoder = meshoptDecoder;
          return this;
        }
        register(callback) {
          if (this.pluginCallbacks.indexOf(callback) === -1) {
            this.pluginCallbacks.push(callback);
          }
          return this;
        }
        unregister(callback) {
          if (this.pluginCallbacks.indexOf(callback) !== -1) {
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
          }
          return this;
        }
        parse(data, path, onLoad, onError) {
          let content;
          const extensions = {};
          const plugins = {};
          if (typeof data === "string") {
            content = data;
          } else {
            const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
              try {
                extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
              } catch (error) {
                if (onError)
                  onError(error);
                return;
              }
              content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
            } else {
              content = LoaderUtils.decodeText(new Uint8Array(data));
            }
          }
          const json = JSON.parse(content);
          if (json.asset === void 0 || json.asset.version[0] < 2) {
            if (onError)
              onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          const parser = new GLTFParser(json, {
            path: path || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
          });
          parser.fileLoader.setRequestHeader(this.requestHeader);
          for (let i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
            const plugin = this.pluginCallbacks[i2](parser);
            plugins[plugin.name] = plugin;
            extensions[plugin.name] = true;
          }
          if (json.extensionsUsed) {
            for (let i2 = 0; i2 < json.extensionsUsed.length; ++i2) {
              const extensionName = json.extensionsUsed[i2];
              const extensionsRequired = json.extensionsRequired || [];
              switch (extensionName) {
                case EXTENSIONS.KHR_MATERIALS_UNLIT:
                  extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                  break;
                case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                  break;
                case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                  extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                  break;
                case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                  extensions[extensionName] = new GLTFTextureTransformExtension();
                  break;
                case EXTENSIONS.KHR_MESH_QUANTIZATION:
                  extensions[extensionName] = new GLTFMeshQuantizationExtension();
                  break;
                default:
                  if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                    console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                  }
              }
            }
          }
          parser.setExtensions(extensions);
          parser.setPlugins(plugins);
          parser.parse(onLoad, onError);
        }
        parseAsync(data, path) {
          const scope = this;
          return new Promise(function(resolve, reject) {
            scope.parse(data, path, resolve, reject);
          });
        }
      };
      EXTENSIONS = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
      };
      GLTFLightsExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
          this.cache = { refs: {}, uses: {} };
        }
        _markDefs() {
          const parser = this.parser;
          const nodeDefs = this.parser.json.nodes || [];
          for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
              parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
            }
          }
        }
        _loadLight(lightIndex) {
          const parser = this.parser;
          const cacheKey = "light:" + lightIndex;
          let dependency = parser.cache.get(cacheKey);
          if (dependency)
            return dependency;
          const json = parser.json;
          const extensions = json.extensions && json.extensions[this.name] || {};
          const lightDefs = extensions.lights || [];
          const lightDef = lightDefs[lightIndex];
          let lightNode;
          const color = new Color(16777215);
          if (lightDef.color !== void 0)
            color.fromArray(lightDef.color);
          const range = lightDef.range !== void 0 ? lightDef.range : 0;
          switch (lightDef.type) {
            case "directional":
              lightNode = new DirectionalLight(color);
              lightNode.target.position.set(0, 0, -1);
              lightNode.add(lightNode.target);
              break;
            case "point":
              lightNode = new PointLight(color);
              lightNode.distance = range;
              break;
            case "spot":
              lightNode = new SpotLight(color);
              lightNode.distance = range;
              lightDef.spot = lightDef.spot || {};
              lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
              lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
              lightNode.angle = lightDef.spot.outerConeAngle;
              lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
              lightNode.target.position.set(0, 0, -1);
              lightNode.add(lightNode.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
          }
          lightNode.position.set(0, 0, 0);
          lightNode.decay = 2;
          if (lightDef.intensity !== void 0)
            lightNode.intensity = lightDef.intensity;
          lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
          dependency = Promise.resolve(lightNode);
          parser.cache.add(cacheKey, dependency);
          return dependency;
        }
        createNodeAttachment(nodeIndex) {
          const self2 = this;
          const parser = this.parser;
          const json = parser.json;
          const nodeDef = json.nodes[nodeIndex];
          const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
          const lightIndex = lightDef.light;
          if (lightIndex === void 0)
            return null;
          return this._loadLight(lightIndex).then(function(light) {
            return parser._getNodeRef(self2.cache, lightIndex, light);
          });
        }
      };
      GLTFMaterialsUnlitExtension = class {
        constructor() {
          this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return MeshBasicMaterial;
        }
        extendParams(materialParams, materialDef, parser) {
          const pending = [];
          materialParams.color = new Color(1, 1, 1);
          materialParams.opacity = 1;
          const metallicRoughness = materialDef.pbrMetallicRoughness;
          if (metallicRoughness) {
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
              const array = metallicRoughness.baseColorFactor;
              materialParams.color.fromArray(array);
              materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
            }
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsClearcoatExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.clearcoatFactor !== void 0) {
            materialParams.clearcoat = extension.clearcoatFactor;
          }
          if (extension.clearcoatTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
          }
          if (extension.clearcoatRoughnessFactor !== void 0) {
            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
          }
          if (extension.clearcoatRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
          }
          if (extension.clearcoatNormalTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
            if (extension.clearcoatNormalTexture.scale !== void 0) {
              const scale = extension.clearcoatNormalTexture.scale;
              materialParams.clearcoatNormalScale = new Vector2(scale, scale);
            }
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsSheenExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          materialParams.sheenColor = new Color(0, 0, 0);
          materialParams.sheenRoughness = 0;
          materialParams.sheen = 1;
          const extension = materialDef.extensions[this.name];
          if (extension.sheenColorFactor !== void 0) {
            materialParams.sheenColor.fromArray(extension.sheenColorFactor);
          }
          if (extension.sheenRoughnessFactor !== void 0) {
            materialParams.sheenRoughness = extension.sheenRoughnessFactor;
          }
          if (extension.sheenColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture));
          }
          if (extension.sheenRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsTransmissionExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.transmissionFactor !== void 0) {
            materialParams.transmission = extension.transmissionFactor;
          }
          if (extension.transmissionTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
          }
          return Promise.all(pending);
        }
      };
      GLTFMaterialsVolumeExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
          if (extension.thicknessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
          }
          materialParams.attenuationDistance = extension.attenuationDistance || 0;
          const colorArray = extension.attenuationColor || [1, 1, 1];
          materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
          return Promise.all(pending);
        }
      };
      GLTFMaterialsIorExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_IOR;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const extension = materialDef.extensions[this.name];
          materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
          return Promise.resolve();
        }
      };
      GLTFMaterialsSpecularExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
          if (extension.specularTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
          }
          const colorArray = extension.specularColorFactor || [1, 1, 1];
          materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
          if (extension.specularColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture).then(function(texture) {
              texture.encoding = sRGBEncoding;
            }));
          }
          return Promise.all(pending);
        }
      };
      GLTFTextureBasisUExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
        }
        loadTexture(textureIndex) {
          const parser = this.parser;
          const json = parser.json;
          const textureDef = json.textures[textureIndex];
          if (!textureDef.extensions || !textureDef.extensions[this.name]) {
            return null;
          }
          const extension = textureDef.extensions[this.name];
          const source = json.images[extension.source];
          const loader4 = parser.options.ktx2Loader;
          if (!loader4) {
            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
              throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            } else {
              return null;
            }
          }
          return parser.loadTextureImage(textureIndex, source, loader4);
        }
      };
      GLTFTextureWebPExtension = class {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
          this.isSupported = null;
        }
        loadTexture(textureIndex) {
          const name = this.name;
          const parser = this.parser;
          const json = parser.json;
          const textureDef = json.textures[textureIndex];
          if (!textureDef.extensions || !textureDef.extensions[name]) {
            return null;
          }
          const extension = textureDef.extensions[name];
          const source = json.images[extension.source];
          let loader4 = parser.textureLoader;
          if (source.uri) {
            const handler = parser.options.manager.getHandler(source.uri);
            if (handler !== null)
              loader4 = handler;
          }
          return this.detectSupport().then(function(isSupported) {
            if (isSupported)
              return parser.loadTextureImage(textureIndex, source, loader4);
            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
              throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            }
            return parser.loadTexture(textureIndex);
          });
        }
        detectSupport() {
          if (!this.isSupported) {
            this.isSupported = new Promise(function(resolve) {
              const image = new Image();
              image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
              image.onload = image.onerror = function() {
                resolve(image.height === 1);
              };
            });
          }
          return this.isSupported;
        }
      };
      GLTFMeshoptCompression = class {
        constructor(parser) {
          this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
          this.parser = parser;
        }
        loadBufferView(index) {
          const json = this.parser.json;
          const bufferView = json.bufferViews[index];
          if (bufferView.extensions && bufferView.extensions[this.name]) {
            const extensionDef = bufferView.extensions[this.name];
            const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
            const decoder = this.parser.options.meshoptDecoder;
            if (!decoder || !decoder.supported) {
              if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              } else {
                return null;
              }
            }
            return Promise.all([buffer, decoder.ready]).then(function(res) {
              const byteOffset = extensionDef.byteOffset || 0;
              const byteLength = extensionDef.byteLength || 0;
              const count = extensionDef.count;
              const stride = extensionDef.byteStride;
              const result = new ArrayBuffer(count * stride);
              const source = new Uint8Array(res[0], byteOffset, byteLength);
              decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
              return result;
            });
          } else {
            return null;
          }
        }
      };
      BINARY_EXTENSION_HEADER_MAGIC = "glTF";
      BINARY_EXTENSION_HEADER_LENGTH = 12;
      BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
      GLTFBinaryExtension = class {
        constructor(data) {
          this.name = EXTENSIONS.KHR_BINARY_GLTF;
          this.content = null;
          this.body = null;
          const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
          this.header = {
            magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
          };
          if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          } else if (this.header.version < 2) {
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          }
          const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
          const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
          let chunkIndex = 0;
          while (chunkIndex < chunkContentsLength) {
            const chunkLength = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            const chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
              const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
              this.content = LoaderUtils.decodeText(contentArray);
            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
              const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
              this.body = data.slice(byteOffset, byteOffset + chunkLength);
            }
            chunkIndex += chunkLength;
          }
          if (this.content === null) {
            throw new Error("THREE.GLTFLoader: JSON content not found.");
          }
        }
      };
      GLTFDracoMeshCompressionExtension = class {
        constructor(json, dracoLoader) {
          if (!dracoLoader) {
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          }
          this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
          this.json = json;
          this.dracoLoader = dracoLoader;
          this.dracoLoader.preload();
        }
        decodePrimitive(primitive, parser) {
          const json = this.json;
          const dracoLoader = this.dracoLoader;
          const bufferViewIndex = primitive.extensions[this.name].bufferView;
          const gltfAttributeMap = primitive.extensions[this.name].attributes;
          const threeAttributeMap = {};
          const attributeNormalizedMap = {};
          const attributeTypeMap = {};
          for (const attributeName in gltfAttributeMap) {
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
          }
          for (const attributeName in primitive.attributes) {
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            if (gltfAttributeMap[attributeName] !== void 0) {
              const accessorDef = json.accessors[primitive.attributes[attributeName]];
              const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
              attributeTypeMap[threeAttributeName] = componentType;
              attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
            }
          }
          return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
            return new Promise(function(resolve) {
              dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                for (const attributeName in geometry.attributes) {
                  const attribute = geometry.attributes[attributeName];
                  const normalized = attributeNormalizedMap[attributeName];
                  if (normalized !== void 0)
                    attribute.normalized = normalized;
                }
                resolve(geometry);
              }, threeAttributeMap, attributeTypeMap);
            });
          });
        }
      };
      GLTFTextureTransformExtension = class {
        constructor() {
          this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(texture, transform) {
          if (transform.texCoord !== void 0) {
            console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
          }
          if (transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
            return texture;
          }
          texture = texture.clone();
          if (transform.offset !== void 0) {
            texture.offset.fromArray(transform.offset);
          }
          if (transform.rotation !== void 0) {
            texture.rotation = transform.rotation;
          }
          if (transform.scale !== void 0) {
            texture.repeat.fromArray(transform.scale);
          }
          texture.needsUpdate = true;
          return texture;
        }
      };
      GLTFMeshStandardSGMaterial = class extends MeshStandardMaterial {
        constructor(params) {
          super();
          this.isGLTFSpecularGlossinessMaterial = true;
          const specularMapParsFragmentChunk = [
            "#ifdef USE_SPECULARMAP",
            "	uniform sampler2D specularMap;",
            "#endif"
          ].join("\n");
          const glossinessMapParsFragmentChunk = [
            "#ifdef USE_GLOSSINESSMAP",
            "	uniform sampler2D glossinessMap;",
            "#endif"
          ].join("\n");
          const specularMapFragmentChunk = [
            "vec3 specularFactor = specular;",
            "#ifdef USE_SPECULARMAP",
            "	vec4 texelSpecular = texture2D( specularMap, vUv );",
            "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "	specularFactor *= texelSpecular.rgb;",
            "#endif"
          ].join("\n");
          const glossinessMapFragmentChunk = [
            "float glossinessFactor = glossiness;",
            "#ifdef USE_GLOSSINESSMAP",
            "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
            "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "	glossinessFactor *= texelGlossiness.a;",
            "#endif"
          ].join("\n");
          const lightPhysicalFragmentChunk = [
            "PhysicalMaterial material;",
            "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
            "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
            "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
            "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
            "material.roughness += geometryRoughness;",
            "material.roughness = min( material.roughness, 1.0 );",
            "material.specularColor = specularFactor;"
          ].join("\n");
          const uniforms = {
            specular: { value: new Color().setHex(16777215) },
            glossiness: { value: 1 },
            specularMap: { value: null },
            glossinessMap: { value: null }
          };
          this._extraUniforms = uniforms;
          this.onBeforeCompile = function(shader) {
            for (const uniformName in uniforms) {
              shader.uniforms[uniformName] = uniforms[uniformName];
            }
            shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
          };
          Object.defineProperties(this, {
            specular: {
              get: function() {
                return uniforms.specular.value;
              },
              set: function(v) {
                uniforms.specular.value = v;
              }
            },
            specularMap: {
              get: function() {
                return uniforms.specularMap.value;
              },
              set: function(v) {
                uniforms.specularMap.value = v;
                if (v) {
                  this.defines.USE_SPECULARMAP = "";
                } else {
                  delete this.defines.USE_SPECULARMAP;
                }
              }
            },
            glossiness: {
              get: function() {
                return uniforms.glossiness.value;
              },
              set: function(v) {
                uniforms.glossiness.value = v;
              }
            },
            glossinessMap: {
              get: function() {
                return uniforms.glossinessMap.value;
              },
              set: function(v) {
                uniforms.glossinessMap.value = v;
                if (v) {
                  this.defines.USE_GLOSSINESSMAP = "";
                  this.defines.USE_UV = "";
                } else {
                  delete this.defines.USE_GLOSSINESSMAP;
                  delete this.defines.USE_UV;
                }
              }
            }
          });
          delete this.metalness;
          delete this.roughness;
          delete this.metalnessMap;
          delete this.roughnessMap;
          this.setValues(params);
        }
        copy(source) {
          super.copy(source);
          this.specularMap = source.specularMap;
          this.specular.copy(source.specular);
          this.glossinessMap = source.glossinessMap;
          this.glossiness = source.glossiness;
          delete this.metalness;
          delete this.roughness;
          delete this.metalnessMap;
          delete this.roughnessMap;
          return this;
        }
      };
      GLTFMaterialsPbrSpecularGlossinessExtension = class {
        constructor() {
          this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
          this.specularGlossinessParams = [
            "color",
            "map",
            "lightMap",
            "lightMapIntensity",
            "aoMap",
            "aoMapIntensity",
            "emissive",
            "emissiveIntensity",
            "emissiveMap",
            "bumpMap",
            "bumpScale",
            "normalMap",
            "normalMapType",
            "displacementMap",
            "displacementScale",
            "displacementBias",
            "specularMap",
            "specular",
            "glossinessMap",
            "glossiness",
            "alphaMap",
            "envMap",
            "envMapIntensity",
            "refractionRatio"
          ];
        }
        getMaterialType() {
          return GLTFMeshStandardSGMaterial;
        }
        extendParams(materialParams, materialDef, parser) {
          const pbrSpecularGlossiness = materialDef.extensions[this.name];
          materialParams.color = new Color(1, 1, 1);
          materialParams.opacity = 1;
          const pending = [];
          if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
            const array = pbrSpecularGlossiness.diffuseFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }
          if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
          }
          materialParams.emissive = new Color(0, 0, 0);
          materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
          materialParams.specular = new Color(1, 1, 1);
          if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
            materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
          }
          if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
            const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
            pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
            pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
          }
          return Promise.all(pending);
        }
        createMaterial(materialParams) {
          const material = new GLTFMeshStandardSGMaterial(materialParams);
          material.fog = true;
          material.color = materialParams.color;
          material.map = materialParams.map === void 0 ? null : materialParams.map;
          material.lightMap = null;
          material.lightMapIntensity = 1;
          material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
          material.aoMapIntensity = 1;
          material.emissive = materialParams.emissive;
          material.emissiveIntensity = 1;
          material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
          material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
          material.bumpScale = 1;
          material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
          material.normalMapType = TangentSpaceNormalMap;
          if (materialParams.normalScale)
            material.normalScale = materialParams.normalScale;
          material.displacementMap = null;
          material.displacementScale = 1;
          material.displacementBias = 0;
          material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
          material.specular = materialParams.specular;
          material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
          material.glossiness = materialParams.glossiness;
          material.alphaMap = null;
          material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
          material.envMapIntensity = 1;
          material.refractionRatio = 0.98;
          return material;
        }
      };
      GLTFMeshQuantizationExtension = class {
        constructor() {
          this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
        }
      };
      GLTFCubicSplineInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
          for (let i2 = 0; i2 !== valueSize; i2++) {
            result[i2] = values[offset + i2];
          }
          return result;
        }
      };
      GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
      GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
      GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
        const result = this.resultBuffer;
        const values = this.sampleValues;
        const stride = this.valueSize;
        const stride2 = stride * 2;
        const stride3 = stride * 3;
        const td = t1 - t0;
        const p2 = (t - t0) / td;
        const pp = p2 * p2;
        const ppp = pp * p2;
        const offset1 = i1 * stride3;
        const offset0 = offset1 - stride3;
        const s2 = -2 * ppp + 3 * pp;
        const s3 = ppp - pp;
        const s0 = 1 - s2;
        const s1 = s3 - pp + p2;
        for (let i2 = 0; i2 !== stride; i2++) {
          const p0 = values[offset0 + i2 + stride];
          const m0 = values[offset0 + i2 + stride2] * td;
          const p1 = values[offset1 + i2 + stride];
          const m1 = values[offset1 + i2] * td;
          result[i2] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
        }
        return result;
      };
      _q = new Quaternion();
      GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
        interpolate_(i1, t0, t, t1) {
          const result = super.interpolate_(i1, t0, t, t1);
          _q.fromArray(result).normalize().toArray(result);
          return result;
        }
      };
      WEBGL_CONSTANTS = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
      };
      WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
      };
      WEBGL_FILTERS = {
        9728: NearestFilter,
        9729: LinearFilter,
        9984: NearestMipmapNearestFilter,
        9985: LinearMipmapNearestFilter,
        9986: NearestMipmapLinearFilter,
        9987: LinearMipmapLinearFilter
      };
      WEBGL_WRAPPINGS = {
        33071: ClampToEdgeWrapping,
        33648: MirroredRepeatWrapping,
        10497: RepeatWrapping
      };
      WEBGL_TYPE_SIZES = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
      };
      ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
      };
      PATH_PROPERTIES = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
      };
      INTERPOLATION = {
        CUBICSPLINE: void 0,
        LINEAR: InterpolateLinear,
        STEP: InterpolateDiscrete
      };
      ALPHA_MODES = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
      };
      GLTFParser = class {
        constructor(json = {}, options = {}) {
          this.json = json;
          this.extensions = {};
          this.plugins = {};
          this.options = options;
          this.cache = new GLTFRegistry();
          this.associations = /* @__PURE__ */ new Map();
          this.primitiveCache = {};
          this.meshCache = { refs: {}, uses: {} };
          this.cameraCache = { refs: {}, uses: {} };
          this.lightCache = { refs: {}, uses: {} };
          this.textureCache = {};
          this.nodeNamesUsed = {};
          if (typeof createImageBitmap !== "undefined" && /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) === false) {
            this.textureLoader = new ImageBitmapLoader(this.options.manager);
          } else {
            this.textureLoader = new TextureLoader(this.options.manager);
          }
          this.textureLoader.setCrossOrigin(this.options.crossOrigin);
          this.textureLoader.setRequestHeader(this.options.requestHeader);
          this.fileLoader = new FileLoader(this.options.manager);
          this.fileLoader.setResponseType("arraybuffer");
          if (this.options.crossOrigin === "use-credentials") {
            this.fileLoader.setWithCredentials(true);
          }
        }
        setExtensions(extensions) {
          this.extensions = extensions;
        }
        setPlugins(plugins) {
          this.plugins = plugins;
        }
        parse(onLoad, onError) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          this.cache.removeAll();
          this._invokeAll(function(ext) {
            return ext._markDefs && ext._markDefs();
          });
          Promise.all(this._invokeAll(function(ext) {
            return ext.beforeRoot && ext.beforeRoot();
          })).then(function() {
            return Promise.all([
              parser.getDependencies("scene"),
              parser.getDependencies("animation"),
              parser.getDependencies("camera")
            ]);
          }).then(function(dependencies) {
            const result = {
              scene: dependencies[0][json.scene || 0],
              scenes: dependencies[0],
              animations: dependencies[1],
              cameras: dependencies[2],
              asset: json.asset,
              parser,
              userData: {}
            };
            addUnknownExtensionsToUserData(extensions, result, json);
            assignExtrasToUserData(result, json);
            Promise.all(parser._invokeAll(function(ext) {
              return ext.afterRoot && ext.afterRoot(result);
            })).then(function() {
              onLoad(result);
            });
          }).catch(onError);
        }
        _markDefs() {
          const nodeDefs = this.json.nodes || [];
          const skinDefs = this.json.skins || [];
          const meshDefs = this.json.meshes || [];
          for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
            const joints = skinDefs[skinIndex].joints;
            for (let i2 = 0, il = joints.length; i2 < il; i2++) {
              nodeDefs[joints[i2]].isBone = true;
            }
          }
          for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.mesh !== void 0) {
              this._addNodeRef(this.meshCache, nodeDef.mesh);
              if (nodeDef.skin !== void 0) {
                meshDefs[nodeDef.mesh].isSkinnedMesh = true;
              }
            }
            if (nodeDef.camera !== void 0) {
              this._addNodeRef(this.cameraCache, nodeDef.camera);
            }
          }
        }
        _addNodeRef(cache, index) {
          if (index === void 0)
            return;
          if (cache.refs[index] === void 0) {
            cache.refs[index] = cache.uses[index] = 0;
          }
          cache.refs[index]++;
        }
        _getNodeRef(cache, index, object) {
          if (cache.refs[index] <= 1)
            return object;
          const ref = object.clone();
          const updateMappings = (original, clone) => {
            const mappings = this.associations.get(original);
            if (mappings != null) {
              this.associations.set(clone, mappings);
            }
            for (const [i2, child] of original.children.entries()) {
              updateMappings(child, clone.children[i2]);
            }
          };
          updateMappings(object, ref);
          ref.name += "_instance_" + cache.uses[index]++;
          return ref;
        }
        _invokeOne(func) {
          const extensions = Object.values(this.plugins);
          extensions.push(this);
          for (let i2 = 0; i2 < extensions.length; i2++) {
            const result = func(extensions[i2]);
            if (result)
              return result;
          }
          return null;
        }
        _invokeAll(func) {
          const extensions = Object.values(this.plugins);
          extensions.unshift(this);
          const pending = [];
          for (let i2 = 0; i2 < extensions.length; i2++) {
            const result = func(extensions[i2]);
            if (result)
              pending.push(result);
          }
          return pending;
        }
        getDependency(type, index) {
          const cacheKey = type + ":" + index;
          let dependency = this.cache.get(cacheKey);
          if (!dependency) {
            switch (type) {
              case "scene":
                dependency = this.loadScene(index);
                break;
              case "node":
                dependency = this.loadNode(index);
                break;
              case "mesh":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadMesh && ext.loadMesh(index);
                });
                break;
              case "accessor":
                dependency = this.loadAccessor(index);
                break;
              case "bufferView":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadBufferView && ext.loadBufferView(index);
                });
                break;
              case "buffer":
                dependency = this.loadBuffer(index);
                break;
              case "material":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadMaterial && ext.loadMaterial(index);
                });
                break;
              case "texture":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadTexture && ext.loadTexture(index);
                });
                break;
              case "skin":
                dependency = this.loadSkin(index);
                break;
              case "animation":
                dependency = this.loadAnimation(index);
                break;
              case "camera":
                dependency = this.loadCamera(index);
                break;
              default:
                throw new Error("Unknown type: " + type);
            }
            this.cache.add(cacheKey, dependency);
          }
          return dependency;
        }
        getDependencies(type) {
          let dependencies = this.cache.get(type);
          if (!dependencies) {
            const parser = this;
            const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
            dependencies = Promise.all(defs.map(function(def, index) {
              return parser.getDependency(type, index);
            }));
            this.cache.add(type, dependencies);
          }
          return dependencies;
        }
        loadBuffer(bufferIndex) {
          const bufferDef = this.json.buffers[bufferIndex];
          const loader4 = this.fileLoader;
          if (bufferDef.type && bufferDef.type !== "arraybuffer") {
            throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
          }
          if (bufferDef.uri === void 0 && bufferIndex === 0) {
            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
          }
          const options = this.options;
          return new Promise(function(resolve, reject) {
            loader4.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
              reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
            });
          });
        }
        loadBufferView(bufferViewIndex) {
          const bufferViewDef = this.json.bufferViews[bufferViewIndex];
          return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
            const byteLength = bufferViewDef.byteLength || 0;
            const byteOffset = bufferViewDef.byteOffset || 0;
            return buffer.slice(byteOffset, byteOffset + byteLength);
          });
        }
        loadAccessor(accessorIndex) {
          const parser = this;
          const json = this.json;
          const accessorDef = this.json.accessors[accessorIndex];
          if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
            return Promise.resolve(null);
          }
          const pendingBufferViews = [];
          if (accessorDef.bufferView !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
          } else {
            pendingBufferViews.push(null);
          }
          if (accessorDef.sparse !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
          }
          return Promise.all(pendingBufferViews).then(function(bufferViews) {
            const bufferView = bufferViews[0];
            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            const elementBytes = TypedArray.BYTES_PER_ELEMENT;
            const itemBytes = elementBytes * itemSize;
            const byteOffset = accessorDef.byteOffset || 0;
            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
            const normalized = accessorDef.normalized === true;
            let array, bufferAttribute;
            if (byteStride && byteStride !== itemBytes) {
              const ibSlice = Math.floor(byteOffset / byteStride);
              const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
              let ib = parser.cache.get(ibCacheKey);
              if (!ib) {
                array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
                ib = new InterleavedBuffer(array, byteStride / elementBytes);
                parser.cache.add(ibCacheKey, ib);
              }
              bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
            } else {
              if (bufferView === null) {
                array = new TypedArray(accessorDef.count * itemSize);
              } else {
                array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
              }
              bufferAttribute = new BufferAttribute(array, itemSize, normalized);
            }
            if (accessorDef.sparse !== void 0) {
              const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
              const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
              const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
              const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
              const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
              const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
              if (bufferView !== null) {
                bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
              }
              for (let i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
                const index = sparseIndices[i2];
                bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
                if (itemSize >= 2)
                  bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
                if (itemSize >= 3)
                  bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
                if (itemSize >= 4)
                  bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
                if (itemSize >= 5)
                  throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
            }
            return bufferAttribute;
          });
        }
        loadTexture(textureIndex) {
          const json = this.json;
          const options = this.options;
          const textureDef = json.textures[textureIndex];
          const source = json.images[textureDef.source];
          let loader4 = this.textureLoader;
          if (source.uri) {
            const handler = options.manager.getHandler(source.uri);
            if (handler !== null)
              loader4 = handler;
          }
          return this.loadTextureImage(textureIndex, source, loader4);
        }
        loadTextureImage(textureIndex, source, loader4) {
          const parser = this;
          const json = this.json;
          const options = this.options;
          const textureDef = json.textures[textureIndex];
          const cacheKey = (source.uri || source.bufferView) + ":" + textureDef.sampler;
          if (this.textureCache[cacheKey]) {
            return this.textureCache[cacheKey];
          }
          const URL2 = self.URL || self.webkitURL;
          let sourceURI = source.uri || "";
          let isObjectURL = false;
          if (source.bufferView !== void 0) {
            sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
              isObjectURL = true;
              const blob = new Blob([bufferView], { type: source.mimeType });
              sourceURI = URL2.createObjectURL(blob);
              return sourceURI;
            });
          } else if (source.uri === void 0) {
            throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
          }
          const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
            return new Promise(function(resolve, reject) {
              let onLoad = resolve;
              if (loader4.isImageBitmapLoader === true) {
                onLoad = function(imageBitmap) {
                  const texture = new Texture(imageBitmap);
                  texture.needsUpdate = true;
                  resolve(texture);
                };
              }
              loader4.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
            });
          }).then(function(texture) {
            if (isObjectURL === true) {
              URL2.revokeObjectURL(sourceURI);
            }
            texture.flipY = false;
            if (textureDef.name)
              texture.name = textureDef.name;
            const samplers = json.samplers || {};
            const sampler = samplers[textureDef.sampler] || {};
            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
            parser.associations.set(texture, { textures: textureIndex });
            return texture;
          }).catch(function() {
            console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
            return null;
          });
          this.textureCache[cacheKey] = promise;
          return promise;
        }
        assignTexture(materialParams, mapName, mapDef) {
          const parser = this;
          return this.getDependency("texture", mapDef.index).then(function(texture) {
            if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
              console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
            }
            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
              const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
              if (transform) {
                const gltfReference = parser.associations.get(texture);
                texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                parser.associations.set(texture, gltfReference);
              }
            }
            materialParams[mapName] = texture;
            return texture;
          });
        }
        assignFinalMaterial(mesh) {
          const geometry = mesh.geometry;
          let material = mesh.material;
          const useDerivativeTangents = geometry.attributes.tangent === void 0;
          const useVertexColors = geometry.attributes.color !== void 0;
          const useFlatShading = geometry.attributes.normal === void 0;
          if (mesh.isPoints) {
            const cacheKey = "PointsMaterial:" + material.uuid;
            let pointsMaterial = this.cache.get(cacheKey);
            if (!pointsMaterial) {
              pointsMaterial = new PointsMaterial();
              Material.prototype.copy.call(pointsMaterial, material);
              pointsMaterial.color.copy(material.color);
              pointsMaterial.map = material.map;
              pointsMaterial.sizeAttenuation = false;
              this.cache.add(cacheKey, pointsMaterial);
            }
            material = pointsMaterial;
          } else if (mesh.isLine) {
            const cacheKey = "LineBasicMaterial:" + material.uuid;
            let lineMaterial = this.cache.get(cacheKey);
            if (!lineMaterial) {
              lineMaterial = new LineBasicMaterial();
              Material.prototype.copy.call(lineMaterial, material);
              lineMaterial.color.copy(material.color);
              this.cache.add(cacheKey, lineMaterial);
            }
            material = lineMaterial;
          }
          if (useDerivativeTangents || useVertexColors || useFlatShading) {
            let cacheKey = "ClonedMaterial:" + material.uuid + ":";
            if (material.isGLTFSpecularGlossinessMaterial)
              cacheKey += "specular-glossiness:";
            if (useDerivativeTangents)
              cacheKey += "derivative-tangents:";
            if (useVertexColors)
              cacheKey += "vertex-colors:";
            if (useFlatShading)
              cacheKey += "flat-shading:";
            let cachedMaterial = this.cache.get(cacheKey);
            if (!cachedMaterial) {
              cachedMaterial = material.clone();
              if (useVertexColors)
                cachedMaterial.vertexColors = true;
              if (useFlatShading)
                cachedMaterial.flatShading = true;
              if (useDerivativeTangents) {
                if (cachedMaterial.normalScale)
                  cachedMaterial.normalScale.y *= -1;
                if (cachedMaterial.clearcoatNormalScale)
                  cachedMaterial.clearcoatNormalScale.y *= -1;
              }
              this.cache.add(cacheKey, cachedMaterial);
              this.associations.set(cachedMaterial, this.associations.get(material));
            }
            material = cachedMaterial;
          }
          if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
            geometry.setAttribute("uv2", geometry.attributes.uv);
          }
          mesh.material = material;
        }
        getMaterialType() {
          return MeshStandardMaterial;
        }
        loadMaterial(materialIndex) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          const materialDef = json.materials[materialIndex];
          let materialType;
          const materialParams = {};
          const materialExtensions = materialDef.extensions || {};
          const pending = [];
          if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            materialType = sgExtension.getMaterialType();
            pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
          } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
            materialType = kmuExtension.getMaterialType();
            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
          } else {
            const metallicRoughness = materialDef.pbrMetallicRoughness || {};
            materialParams.color = new Color(1, 1, 1);
            materialParams.opacity = 1;
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
              const array = metallicRoughness.baseColorFactor;
              materialParams.color.fromArray(array);
              materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
            }
            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
            if (metallicRoughness.metallicRoughnessTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
              pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
            }
            materialType = this._invokeOne(function(ext) {
              return ext.getMaterialType && ext.getMaterialType(materialIndex);
            });
            pending.push(Promise.all(this._invokeAll(function(ext) {
              return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
            })));
          }
          if (materialDef.doubleSided === true) {
            materialParams.side = DoubleSide;
          }
          const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
          if (alphaMode === ALPHA_MODES.BLEND) {
            materialParams.transparent = true;
            materialParams.depthWrite = false;
          } else {
            materialParams.transparent = false;
            if (alphaMode === ALPHA_MODES.MASK) {
              materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
            }
          }
          if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
            materialParams.normalScale = new Vector2(1, 1);
            if (materialDef.normalTexture.scale !== void 0) {
              const scale = materialDef.normalTexture.scale;
              materialParams.normalScale.set(scale, scale);
            }
          }
          if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
            if (materialDef.occlusionTexture.strength !== void 0) {
              materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
            }
          }
          if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
            materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
          }
          if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
          }
          return Promise.all(pending).then(function() {
            let material;
            if (materialType === GLTFMeshStandardSGMaterial) {
              material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
            } else {
              material = new materialType(materialParams);
            }
            if (materialDef.name)
              material.name = materialDef.name;
            if (material.map)
              material.map.encoding = sRGBEncoding;
            if (material.emissiveMap)
              material.emissiveMap.encoding = sRGBEncoding;
            assignExtrasToUserData(material, materialDef);
            parser.associations.set(material, { materials: materialIndex });
            if (materialDef.extensions)
              addUnknownExtensionsToUserData(extensions, material, materialDef);
            return material;
          });
        }
        createUniqueName(originalName) {
          const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
          let name = sanitizedName;
          for (let i2 = 1; this.nodeNamesUsed[name]; ++i2) {
            name = sanitizedName + "_" + i2;
          }
          this.nodeNamesUsed[name] = true;
          return name;
        }
        loadGeometries(primitives) {
          const parser = this;
          const extensions = this.extensions;
          const cache = this.primitiveCache;
          function createDracoPrimitive(primitive) {
            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
              return addPrimitiveAttributes(geometry, primitive, parser);
            });
          }
          const pending = [];
          for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
            const primitive = primitives[i2];
            const cacheKey = createPrimitiveKey(primitive);
            const cached = cache[cacheKey];
            if (cached) {
              pending.push(cached.promise);
            } else {
              let geometryPromise;
              if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
                geometryPromise = createDracoPrimitive(primitive);
              } else {
                geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
              }
              cache[cacheKey] = { primitive, promise: geometryPromise };
              pending.push(geometryPromise);
            }
          }
          return Promise.all(pending);
        }
        loadMesh(meshIndex) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          const meshDef = json.meshes[meshIndex];
          const primitives = meshDef.primitives;
          const pending = [];
          for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
            const material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
            pending.push(material);
          }
          pending.push(parser.loadGeometries(primitives));
          return Promise.all(pending).then(function(results) {
            const materials = results.slice(0, results.length - 1);
            const geometries = results[results.length - 1];
            const meshes = [];
            for (let i2 = 0, il = geometries.length; i2 < il; i2++) {
              const geometry = geometries[i2];
              const primitive = primitives[i2];
              let mesh;
              const material = materials[i2];
              if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
                mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
                if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
                  mesh.normalizeSkinWeights();
                }
                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                  mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
                } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                  mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
                }
              } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
                mesh = new LineSegments(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
                mesh = new Line(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
                mesh = new LineLoop(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
                mesh = new Points(geometry, material);
              } else {
                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
              }
              if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
                updateMorphTargets(mesh, meshDef);
              }
              mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
              assignExtrasToUserData(mesh, meshDef);
              if (primitive.extensions)
                addUnknownExtensionsToUserData(extensions, mesh, primitive);
              parser.assignFinalMaterial(mesh);
              meshes.push(mesh);
            }
            for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
              parser.associations.set(meshes[i2], {
                meshes: meshIndex,
                primitives: i2
              });
            }
            if (meshes.length === 1) {
              return meshes[0];
            }
            const group = new Group();
            parser.associations.set(group, { meshes: meshIndex });
            for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
              group.add(meshes[i2]);
            }
            return group;
          });
        }
        loadCamera(cameraIndex) {
          let camera;
          const cameraDef = this.json.cameras[cameraIndex];
          const params = cameraDef[cameraDef.type];
          if (!params) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          if (cameraDef.type === "perspective") {
            camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
          } else if (cameraDef.type === "orthographic") {
            camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
          }
          if (cameraDef.name)
            camera.name = this.createUniqueName(cameraDef.name);
          assignExtrasToUserData(camera, cameraDef);
          return Promise.resolve(camera);
        }
        loadSkin(skinIndex) {
          const skinDef = this.json.skins[skinIndex];
          const skinEntry = { joints: skinDef.joints };
          if (skinDef.inverseBindMatrices === void 0) {
            return Promise.resolve(skinEntry);
          }
          return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
            skinEntry.inverseBindMatrices = accessor;
            return skinEntry;
          });
        }
        loadAnimation(animationIndex) {
          const json = this.json;
          const animationDef = json.animations[animationIndex];
          const pendingNodes = [];
          const pendingInputAccessors = [];
          const pendingOutputAccessors = [];
          const pendingSamplers = [];
          const pendingTargets = [];
          for (let i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
            const channel = animationDef.channels[i2];
            const sampler = animationDef.samplers[channel.sampler];
            const target = channel.target;
            const name = target.node !== void 0 ? target.node : target.id;
            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
            pendingNodes.push(this.getDependency("node", name));
            pendingInputAccessors.push(this.getDependency("accessor", input));
            pendingOutputAccessors.push(this.getDependency("accessor", output));
            pendingSamplers.push(sampler);
            pendingTargets.push(target);
          }
          return Promise.all([
            Promise.all(pendingNodes),
            Promise.all(pendingInputAccessors),
            Promise.all(pendingOutputAccessors),
            Promise.all(pendingSamplers),
            Promise.all(pendingTargets)
          ]).then(function(dependencies) {
            const nodes = dependencies[0];
            const inputAccessors = dependencies[1];
            const outputAccessors = dependencies[2];
            const samplers = dependencies[3];
            const targets = dependencies[4];
            const tracks = [];
            for (let i2 = 0, il = nodes.length; i2 < il; i2++) {
              const node = nodes[i2];
              const inputAccessor = inputAccessors[i2];
              const outputAccessor = outputAccessors[i2];
              const sampler = samplers[i2];
              const target = targets[i2];
              if (node === void 0)
                continue;
              node.updateMatrix();
              node.matrixAutoUpdate = true;
              let TypedKeyframeTrack;
              switch (PATH_PROPERTIES[target.path]) {
                case PATH_PROPERTIES.weights:
                  TypedKeyframeTrack = NumberKeyframeTrack;
                  break;
                case PATH_PROPERTIES.rotation:
                  TypedKeyframeTrack = QuaternionKeyframeTrack;
                  break;
                case PATH_PROPERTIES.position:
                case PATH_PROPERTIES.scale:
                default:
                  TypedKeyframeTrack = VectorKeyframeTrack;
                  break;
              }
              const targetName = node.name ? node.name : node.uuid;
              const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
              const targetNames = [];
              if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
                node.traverse(function(object) {
                  if (object.morphTargetInfluences) {
                    targetNames.push(object.name ? object.name : object.uuid);
                  }
                });
              } else {
                targetNames.push(targetName);
              }
              let outputArray = outputAccessor.array;
              if (outputAccessor.normalized) {
                const scale = getNormalizedComponentScale(outputArray.constructor);
                const scaled = new Float32Array(outputArray.length);
                for (let j = 0, jl = outputArray.length; j < jl; j++) {
                  scaled[j] = outputArray[j] * scale;
                }
                outputArray = scaled;
              }
              for (let j = 0, jl = targetNames.length; j < jl; j++) {
                const track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
                if (sampler.interpolation === "CUBICSPLINE") {
                  track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                    const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                    return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
                  };
                  track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
                }
                tracks.push(track);
              }
            }
            const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
            return new AnimationClip(name, void 0, tracks);
          });
        }
        createNodeMesh(nodeIndex) {
          const json = this.json;
          const parser = this;
          const nodeDef = json.nodes[nodeIndex];
          if (nodeDef.mesh === void 0)
            return null;
          return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
            if (nodeDef.weights !== void 0) {
              node.traverse(function(o) {
                if (!o.isMesh)
                  return;
                for (let i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
                  o.morphTargetInfluences[i2] = nodeDef.weights[i2];
                }
              });
            }
            return node;
          });
        }
        loadNode(nodeIndex) {
          const json = this.json;
          const extensions = this.extensions;
          const parser = this;
          const nodeDef = json.nodes[nodeIndex];
          const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
          return function() {
            const pending = [];
            const meshPromise = parser._invokeOne(function(ext) {
              return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
            });
            if (meshPromise) {
              pending.push(meshPromise);
            }
            if (nodeDef.camera !== void 0) {
              pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
              }));
            }
            parser._invokeAll(function(ext) {
              return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
            }).forEach(function(promise) {
              pending.push(promise);
            });
            return Promise.all(pending);
          }().then(function(objects) {
            let node;
            if (nodeDef.isBone === true) {
              node = new Bone();
            } else if (objects.length > 1) {
              node = new Group();
            } else if (objects.length === 1) {
              node = objects[0];
            } else {
              node = new Object3D();
            }
            if (node !== objects[0]) {
              for (let i2 = 0, il = objects.length; i2 < il; i2++) {
                node.add(objects[i2]);
              }
            }
            if (nodeDef.name) {
              node.userData.name = nodeDef.name;
              node.name = nodeName;
            }
            assignExtrasToUserData(node, nodeDef);
            if (nodeDef.extensions)
              addUnknownExtensionsToUserData(extensions, node, nodeDef);
            if (nodeDef.matrix !== void 0) {
              const matrix = new Matrix4();
              matrix.fromArray(nodeDef.matrix);
              node.applyMatrix4(matrix);
            } else {
              if (nodeDef.translation !== void 0) {
                node.position.fromArray(nodeDef.translation);
              }
              if (nodeDef.rotation !== void 0) {
                node.quaternion.fromArray(nodeDef.rotation);
              }
              if (nodeDef.scale !== void 0) {
                node.scale.fromArray(nodeDef.scale);
              }
            }
            if (!parser.associations.has(node)) {
              parser.associations.set(node, {});
            }
            parser.associations.get(node).nodes = nodeIndex;
            return node;
          });
        }
        loadScene(sceneIndex) {
          const json = this.json;
          const extensions = this.extensions;
          const sceneDef = this.json.scenes[sceneIndex];
          const parser = this;
          const scene = new Group();
          if (sceneDef.name)
            scene.name = parser.createUniqueName(sceneDef.name);
          assignExtrasToUserData(scene, sceneDef);
          if (sceneDef.extensions)
            addUnknownExtensionsToUserData(extensions, scene, sceneDef);
          const nodeIds = sceneDef.nodes || [];
          const pending = [];
          for (let i2 = 0, il = nodeIds.length; i2 < il; i2++) {
            pending.push(buildNodeHierarchy(nodeIds[i2], scene, json, parser));
          }
          return Promise.all(pending).then(function() {
            const reduceAssociations = (node) => {
              const reducedAssociations = /* @__PURE__ */ new Map();
              for (const [key, value] of parser.associations) {
                if (key instanceof Material || key instanceof Texture) {
                  reducedAssociations.set(key, value);
                }
              }
              node.traverse((node2) => {
                const mappings = parser.associations.get(node2);
                if (mappings != null) {
                  reducedAssociations.set(node2, mappings);
                }
              });
              return reducedAssociations;
            };
            parser.associations = reduceAssociations(scene);
            return scene;
          });
        }
      };
    }
  });

  // node_modules/@jocabola/io/lib/assets/GLTFAsset.js
  var loader3, GLTFAsset;
  var init_GLTFAsset = __esm({
    "node_modules/@jocabola/io/lib/assets/GLTFAsset.js"() {
      init_Asset();
      init_GLTFLoader();
      loader3 = new GLTFLoader();
      GLTFAsset = class extends Asset {
        constructor(url) {
          super(url);
        }
        load(callback) {
          let url = this.url;
          loader3.load(this.url, (gltf) => {
            gltf.animations;
            gltf.scene;
            gltf.scenes;
            gltf.cameras;
            gltf.asset;
            this.content = gltf;
            this._loaded = true;
            if (callback != null)
              callback();
          }, function(xhr) {
          }, (error) => {
            console.warn("Error loading", url);
            this._failed = true;
          });
        }
        destroy() {
          const dispose = (scene) => {
            for (let c of scene.children) {
              if (c.geometry)
                c.geometry.dispose();
              if (c.material)
                c.material.dispose();
              dispose(c);
            }
          };
          dispose(this.content.scene);
          this.content.scene = null;
          this.content = null;
        }
      };
    }
  });

  // node_modules/three/examples/jsm/utils/WorkerPool.js
  var WorkerPool;
  var init_WorkerPool = __esm({
    "node_modules/three/examples/jsm/utils/WorkerPool.js"() {
      WorkerPool = class {
        constructor(pool = 4) {
          this.pool = pool;
          this.queue = [];
          this.workers = [];
          this.workersResolve = [];
          this.workerStatus = 0;
        }
        _initWorker(workerId) {
          if (!this.workers[workerId]) {
            const worker = this.workerCreator();
            worker.addEventListener("message", this._onMessage.bind(this, workerId));
            this.workers[workerId] = worker;
          }
        }
        _getIdleWorker() {
          for (let i2 = 0; i2 < this.pool; i2++)
            if (!(this.workerStatus & 1 << i2))
              return i2;
          return -1;
        }
        _onMessage(workerId, msg) {
          const resolve = this.workersResolve[workerId];
          resolve && resolve(msg);
          if (this.queue.length) {
            const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();
            this.workersResolve[workerId] = resolve2;
            this.workers[workerId].postMessage(msg2, transfer);
          } else {
            this.workerStatus ^= 1 << workerId;
          }
        }
        setWorkerCreator(workerCreator) {
          this.workerCreator = workerCreator;
        }
        setWorkerLimit(pool) {
          this.pool = pool;
        }
        postMessage(msg, transfer) {
          return new Promise((resolve) => {
            const workerId = this._getIdleWorker();
            if (workerId !== -1) {
              this._initWorker(workerId);
              this.workerStatus |= 1 << workerId;
              this.workersResolve[workerId] = resolve;
              this.workers[workerId].postMessage(msg, transfer);
            } else {
              this.queue.push({ resolve, msg, transfer });
            }
          });
        }
        dispose() {
          this.workers.forEach((worker) => worker.terminate());
          this.workersResolve.length = 0;
          this.workers.length = 0;
          this.queue.length = 0;
          this.workerStatus = 0;
        }
      };
    }
  });

  // node_modules/three/examples/jsm/loaders/KTX2Loader.js
  var KTX2TransferSRGB, KTX2_ALPHA_PREMULTIPLIED, _taskCache, _activeLoaders, KTX2Loader;
  var init_KTX2Loader = __esm({
    "node_modules/three/examples/jsm/loaders/KTX2Loader.js"() {
      init_three_module();
      init_WorkerPool();
      KTX2TransferSRGB = 2;
      KTX2_ALPHA_PREMULTIPLIED = 1;
      _taskCache = /* @__PURE__ */ new WeakMap();
      _activeLoaders = 0;
      KTX2Loader = class extends Loader {
        constructor(manager) {
          super(manager);
          this.transcoderPath = "";
          this.transcoderBinary = null;
          this.transcoderPending = null;
          this.workerPool = new WorkerPool();
          this.workerSourceURL = "";
          this.workerConfig = null;
          if (typeof MSC_TRANSCODER !== "undefined") {
            console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
          }
        }
        setTranscoderPath(path) {
          this.transcoderPath = path;
          return this;
        }
        setWorkerLimit(num) {
          this.workerPool.setWorkerLimit(num);
          return this;
        }
        detectSupport(renderer) {
          this.workerConfig = {
            astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
            etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
          };
          if (renderer.capabilities.isWebGL2) {
            this.workerConfig.etc1Supported = false;
          }
          return this;
        }
        dispose() {
          this.workerPool.dispose();
          if (this.workerSourceURL)
            URL.revokeObjectURL(this.workerSourceURL);
          return this;
        }
        init() {
          if (!this.transcoderPending) {
            const jsLoader = new FileLoader(this.manager);
            jsLoader.setPath(this.transcoderPath);
            jsLoader.setWithCredentials(this.withCredentials);
            const jsContent = jsLoader.loadAsync("basis_transcoder.js");
            const binaryLoader = new FileLoader(this.manager);
            binaryLoader.setPath(this.transcoderPath);
            binaryLoader.setResponseType("arraybuffer");
            binaryLoader.setWithCredentials(this.withCredentials);
            const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
            this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
              const fn = KTX2Loader.BasisWorker.toString();
              const body = [
                "/* constants */",
                "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat),
                "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat),
                "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat),
                "/* basis_transcoder.js */",
                jsContent2,
                "/* worker */",
                fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
              ].join("\n");
              this.workerSourceURL = URL.createObjectURL(new Blob([body]));
              this.transcoderBinary = binaryContent2;
              this.workerPool.setWorkerCreator(() => {
                const worker = new Worker(this.workerSourceURL);
                const transcoderBinary = this.transcoderBinary.slice(0);
                worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
                return worker;
              });
            });
            if (_activeLoaders > 0) {
              console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.");
            }
            _activeLoaders++;
          }
          return this.transcoderPending;
        }
        load(url, onLoad, onProgress, onError) {
          if (this.workerConfig === null) {
            throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
          }
          const loader4 = new FileLoader(this.manager);
          loader4.setResponseType("arraybuffer");
          loader4.setWithCredentials(this.withCredentials);
          const texture = new CompressedTexture();
          loader4.load(url, (buffer) => {
            if (_taskCache.has(buffer)) {
              const cachedTask = _taskCache.get(buffer);
              return cachedTask.promise.then(onLoad).catch(onError);
            }
            this._createTexture([buffer]).then(function(_texture) {
              texture.copy(_texture);
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }).catch(onError);
          }, onProgress, onError);
          return texture;
        }
        _createTextureFrom(transcodeResult) {
          const { mipmaps, width, height, format, type, error, dfdTransferFn, dfdFlags } = transcodeResult;
          if (type === "error")
            return Promise.reject(error);
          const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
          texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.needsUpdate = true;
          texture.encoding = dfdTransferFn === KTX2TransferSRGB ? sRGBEncoding : LinearEncoding;
          texture.premultiplyAlpha = !!(dfdFlags & KTX2_ALPHA_PREMULTIPLIED);
          return texture;
        }
        _createTexture(buffers, config3 = {}) {
          const taskConfig = config3;
          const texturePending = this.init().then(() => {
            return this.workerPool.postMessage({ type: "transcode", buffers, taskConfig }, buffers);
          }).then((e) => this._createTextureFrom(e.data));
          _taskCache.set(buffers[0], { promise: texturePending });
          return texturePending;
        }
        dispose() {
          URL.revokeObjectURL(this.workerSourceURL);
          this.workerPool.dispose();
          _activeLoaders--;
          return this;
        }
      };
      KTX2Loader.BasisFormat = {
        ETC1S: 0,
        UASTC_4x4: 1
      };
      KTX2Loader.TranscoderFormat = {
        ETC1: 0,
        ETC2: 1,
        BC1: 2,
        BC3: 3,
        BC4: 4,
        BC5: 5,
        BC7_M6_OPAQUE_ONLY: 6,
        BC7_M5: 7,
        PVRTC1_4_RGB: 8,
        PVRTC1_4_RGBA: 9,
        ASTC_4x4: 10,
        ATC_RGB: 11,
        ATC_RGBA_INTERPOLATED_ALPHA: 12,
        RGBA32: 13,
        RGB565: 14,
        BGR565: 15,
        RGBA4444: 16
      };
      KTX2Loader.EngineFormat = {
        RGBAFormat,
        RGBA_ASTC_4x4_Format,
        RGBA_BPTC_Format,
        RGBA_ETC2_EAC_Format,
        RGBA_PVRTC_4BPPV1_Format,
        RGBA_S3TC_DXT5_Format,
        RGB_ETC1_Format,
        RGB_ETC2_Format,
        RGB_PVRTC_4BPPV1_Format,
        RGB_S3TC_DXT1_Format
      };
      KTX2Loader.BasisWorker = function() {
        let config3;
        let transcoderPending;
        let BasisModule;
        const EngineFormat = _EngineFormat;
        const TranscoderFormat = _TranscoderFormat;
        const BasisFormat = _BasisFormat;
        self.addEventListener("message", function(e) {
          const message = e.data;
          switch (message.type) {
            case "init":
              config3 = message.config;
              init10(message.transcoderBinary);
              break;
            case "transcode":
              transcoderPending.then(() => {
                try {
                  const { width, height, hasAlpha, mipmaps, format, dfdTransferFn, dfdFlags } = transcode(message.buffers[0]);
                  const buffers = [];
                  for (let i2 = 0; i2 < mipmaps.length; ++i2) {
                    buffers.push(mipmaps[i2].data.buffer);
                  }
                  self.postMessage({ type: "transcode", id: message.id, width, height, hasAlpha, mipmaps, format, dfdTransferFn, dfdFlags }, buffers);
                } catch (error) {
                  console.error(error);
                  self.postMessage({ type: "error", id: message.id, error: error.message });
                }
              });
              break;
          }
        });
        function init10(wasmBinary) {
          transcoderPending = new Promise((resolve) => {
            BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
            BASIS(BasisModule);
          }).then(() => {
            BasisModule.initializeBasis();
            if (BasisModule.KTX2File === void 0) {
              console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
            }
          });
        }
        function transcode(buffer) {
          const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
          function cleanup() {
            ktx2File.close();
            ktx2File.delete();
          }
          if (!ktx2File.isValid()) {
            cleanup();
            throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
          }
          const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
          const width = ktx2File.getWidth();
          const height = ktx2File.getHeight();
          const levels = ktx2File.getLevels();
          const hasAlpha = ktx2File.getHasAlpha();
          const dfdTransferFn = ktx2File.getDFDTransferFunc();
          const dfdFlags = ktx2File.getDFDFlags();
          const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
          if (!width || !height || !levels) {
            cleanup();
            throw new Error("THREE.KTX2Loader:	Invalid texture");
          }
          if (!ktx2File.startTranscoding()) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .startTranscoding failed");
          }
          const mipmaps = [];
          for (let mip = 0; mip < levels; mip++) {
            const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
            const mipWidth = levelInfo.origWidth;
            const mipHeight = levelInfo.origHeight;
            const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
            const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);
            if (!status) {
              cleanup();
              throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
            }
            mipmaps.push({ data: dst, width: mipWidth, height: mipHeight });
          }
          cleanup();
          return { width, height, hasAlpha, mipmaps, format: engineFormat, dfdTransferFn, dfdFlags };
        }
        const FORMAT_OPTIONS = [
          {
            if: "astcSupported",
            basisFormat: [BasisFormat.UASTC_4x4],
            transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
            engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
            priorityETC1S: Infinity,
            priorityUASTC: 1,
            needsPowerOfTwo: false
          },
          {
            if: "bptcSupported",
            basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
            transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
            engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
            priorityETC1S: 3,
            priorityUASTC: 2,
            needsPowerOfTwo: false
          },
          {
            if: "dxtSupported",
            basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
            transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
            engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
            priorityETC1S: 4,
            priorityUASTC: 5,
            needsPowerOfTwo: false
          },
          {
            if: "etc2Supported",
            basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
            transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
            engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
            priorityETC1S: 1,
            priorityUASTC: 3,
            needsPowerOfTwo: false
          },
          {
            if: "etc1Supported",
            basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
            transcoderFormat: [TranscoderFormat.ETC1],
            engineFormat: [EngineFormat.RGB_ETC1_Format],
            priorityETC1S: 2,
            priorityUASTC: 4,
            needsPowerOfTwo: false
          },
          {
            if: "pvrtcSupported",
            basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
            transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
            engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
            priorityETC1S: 5,
            priorityUASTC: 6,
            needsPowerOfTwo: true
          }
        ];
        const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
          return a.priorityETC1S - b.priorityETC1S;
        });
        const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
          return a.priorityUASTC - b.priorityUASTC;
        });
        function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
          let transcoderFormat;
          let engineFormat;
          const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
          for (let i2 = 0; i2 < options.length; i2++) {
            const opt = options[i2];
            if (!config3[opt.if])
              continue;
            if (!opt.basisFormat.includes(basisFormat))
              continue;
            if (hasAlpha && opt.transcoderFormat.length < 2)
              continue;
            if (opt.needsPowerOfTwo && !(isPowerOfTwo2(width) && isPowerOfTwo2(height)))
              continue;
            transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
            engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
            return { transcoderFormat, engineFormat };
          }
          console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
          transcoderFormat = TranscoderFormat.RGBA32;
          engineFormat = EngineFormat.RGBAFormat;
          return { transcoderFormat, engineFormat };
        }
        function isPowerOfTwo2(value) {
          if (value <= 2)
            return true;
          return (value & value - 1) === 0 && value !== 0;
        }
      };
    }
  });

  // node_modules/@jocabola/io/lib/assets/KTX2Asset.js
  var ktx2Loader;
  var init_KTX2Asset = __esm({
    "node_modules/@jocabola/io/lib/assets/KTX2Asset.js"() {
      init_KTX2Loader();
      init_TextureAsset();
      ktx2Loader = new KTX2Loader();
    }
  });

  // node_modules/@jocabola/io/lib/main.js
  var init_main = __esm({
    "node_modules/@jocabola/io/lib/main.js"() {
      init_io();
      init_AssetsBundle();
      init_Asset();
      init_TextureAsset();
      init_CubeTextureAsset();
      init_VideoTextureAsset();
      init_GLTFAsset();
      init_TextureUtils();
      init_KTX2Asset();
    }
  });

  // node_modules/three/examples/jsm/objects/Reflector.js
  var Reflector;
  var init_Reflector = __esm({
    "node_modules/three/examples/jsm/objects/Reflector.js"() {
      init_three_module();
      Reflector = class extends Mesh {
        constructor(geometry, options = {}) {
          super(geometry);
          this.type = "Reflector";
          const scope = this;
          const color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
          const textureWidth = options.textureWidth || 512;
          const textureHeight = options.textureHeight || 512;
          const clipBias = options.clipBias || 0;
          const shader = options.shader || Reflector.ReflectorShader;
          const reflectorPlane = new Plane();
          const normal = new Vector3();
          const reflectorWorldPosition = new Vector3();
          const cameraWorldPosition = new Vector3();
          const rotationMatrix = new Matrix4();
          const lookAtPosition = new Vector3(0, 0, -1);
          const clipPlane = new Vector4();
          const view = new Vector3();
          const target = new Vector3();
          const q = new Vector4();
          const textureMatrix = new Matrix4();
          const virtualCamera = new PerspectiveCamera();
          const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
          const material = new ShaderMaterial({
            uniforms: UniformsUtils.clone(shader.uniforms),
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader
          });
          material.uniforms["tDiffuse"].value = renderTarget.texture;
          material.uniforms["color"].value = color;
          material.uniforms["textureMatrix"].value = textureMatrix;
          this.material = material;
          this.onBeforeRender = function(renderer, scene, camera) {
            reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
            cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
            rotationMatrix.extractRotation(scope.matrixWorld);
            normal.set(0, 0, 1);
            normal.applyMatrix4(rotationMatrix);
            view.subVectors(reflectorWorldPosition, cameraWorldPosition);
            if (view.dot(normal) > 0)
              return;
            view.reflect(normal).negate();
            view.add(reflectorWorldPosition);
            rotationMatrix.extractRotation(camera.matrixWorld);
            lookAtPosition.set(0, 0, -1);
            lookAtPosition.applyMatrix4(rotationMatrix);
            lookAtPosition.add(cameraWorldPosition);
            target.subVectors(reflectorWorldPosition, lookAtPosition);
            target.reflect(normal).negate();
            target.add(reflectorWorldPosition);
            virtualCamera.position.copy(view);
            virtualCamera.up.set(0, 1, 0);
            virtualCamera.up.applyMatrix4(rotationMatrix);
            virtualCamera.up.reflect(normal);
            virtualCamera.lookAt(target);
            virtualCamera.far = camera.far;
            virtualCamera.updateMatrixWorld();
            virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
            textureMatrix.multiply(virtualCamera.projectionMatrix);
            textureMatrix.multiply(virtualCamera.matrixWorldInverse);
            textureMatrix.multiply(scope.matrixWorld);
            reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
            reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
            clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
            const projectionMatrix = virtualCamera.projectionMatrix;
            q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
            q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
            q.z = -1;
            q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
            clipPlane.multiplyScalar(2 / clipPlane.dot(q));
            projectionMatrix.elements[2] = clipPlane.x;
            projectionMatrix.elements[6] = clipPlane.y;
            projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
            projectionMatrix.elements[14] = clipPlane.w;
            renderTarget.texture.encoding = renderer.outputEncoding;
            scope.visible = false;
            const currentRenderTarget = renderer.getRenderTarget();
            const currentXrEnabled = renderer.xr.enabled;
            const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
            renderer.xr.enabled = false;
            renderer.shadowMap.autoUpdate = false;
            renderer.setRenderTarget(renderTarget);
            renderer.state.buffers.depth.setMask(true);
            if (renderer.autoClear === false)
              renderer.clear();
            renderer.render(scene, virtualCamera);
            renderer.xr.enabled = currentXrEnabled;
            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
            renderer.setRenderTarget(currentRenderTarget);
            const viewport = camera.viewport;
            if (viewport !== void 0) {
              renderer.state.viewport(viewport);
            }
            scope.visible = true;
          };
          this.getRenderTarget = function() {
            return renderTarget;
          };
          this.dispose = function() {
            renderTarget.dispose();
            scope.material.dispose();
          };
        }
      };
      Reflector.prototype.isReflector = true;
      Reflector.ReflectorShader = {
        uniforms: {
          "color": {
            value: null
          },
          "tDiffuse": {
            value: null
          },
          "textureMatrix": {
            value: null
          }
        },
        vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,
        fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`
      };
    }
  });

  // node_modules/three/examples/jsm/objects/ReflectorRTT.js
  var ReflectorRTT;
  var init_ReflectorRTT = __esm({
    "node_modules/three/examples/jsm/objects/ReflectorRTT.js"() {
      init_Reflector();
      ReflectorRTT = class extends Reflector {
        constructor(geometry, options) {
          super(geometry, options);
          this.geometry.setDrawRange(0, 0);
        }
      };
    }
  });

  // node_modules/@jocabola/gfx/lib/sim/Simulator.js
  var floor, groundMirror, bundle, Figures;
  var init_Simulator = __esm({
    "node_modules/@jocabola/gfx/lib/sim/Simulator.js"() {
      init_main();
      init_three_module();
      init_main2();
      init_ReflectorRTT();
      floor = new Mesh(new PlaneGeometry(1, 1), new MeshPhysicalMaterial({
        color: 10066329,
        roughness: 0.3,
        metalness: 0.1,
        envMapIntensity: 0.1
      }));
      groundMirror = new ReflectorRTT(new PlaneGeometry(1, 1), {
        clipBias: 3e-3,
        textureWidth: window.innerWidth,
        textureHeight: window.innerHeight,
        color: 3355443
      });
      bundle = new AssetsBundle();
      bundle.add(new TextureAsset("https://assets.eduprats.com/textures/sim/env/hdri.jpg"));
      bundle.add(new TextureAsset("https://assets.eduprats.com/textures/sim/floor/noise2.png"));
      Figures = {
        boy: new GLTFAsset("https://assets.eduprats.com/models/sim/figures/boy.glb"),
        girl: new GLTFAsset("https://assets.eduprats.com/models/sim/figures/girl.glb"),
        female: new GLTFAsset("https://assets.eduprats.com/models/sim/figures/female.glb"),
        male: new GLTFAsset("https://assets.eduprats.com/models/sim/figures/male.glb"),
        male2: new GLTFAsset("https://assets.eduprats.com/models/sim/figures/male2.glb")
      };
    }
  });

  // node_modules/mersenne/lib/mersenne.js
  var require_mersenne = __commonJS({
    "node_modules/mersenne/lib/mersenne.js"(exports) {
      function MersenneTwister19937() {
        var N, M, MATRIX_A, UPPER_MASK, LOWER_MASK;
        N = 624;
        M = 397;
        MATRIX_A = 2567483615;
        UPPER_MASK = 2147483648;
        LOWER_MASK = 2147483647;
        var mt = new Array(N);
        var mti = N + 1;
        function unsigned32(n1) {
          return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1;
        }
        function subtraction32(n1, n2) {
          return n1 < n2 ? unsigned32(4294967296 - (n2 - n1) & 4294967295) : n1 - n2;
        }
        function addition32(n1, n2) {
          return unsigned32(n1 + n2 & 4294967295);
        }
        function multiplication32(n1, n2) {
          var sum = 0;
          for (var i2 = 0; i2 < 32; ++i2) {
            if (n1 >>> i2 & 1) {
              sum = addition32(sum, unsigned32(n2 << i2));
            }
          }
          return sum;
        }
        this.init_genrand = function(s) {
          mt[0] = unsigned32(s & 4294967295);
          for (mti = 1; mti < N; mti++) {
            mt[mti] = addition32(multiplication32(1812433253, unsigned32(mt[mti - 1] ^ mt[mti - 1] >>> 30)), mti);
            mt[mti] = unsigned32(mt[mti] & 4294967295);
          }
        };
        this.init_by_array = function(init_key, key_length) {
          var i2, j, k;
          this.init_genrand(19650218);
          i2 = 1;
          j = 0;
          k = N > key_length ? N : key_length;
          for (; k; k--) {
            mt[i2] = addition32(addition32(unsigned32(mt[i2] ^ multiplication32(unsigned32(mt[i2 - 1] ^ mt[i2 - 1] >>> 30), 1664525)), init_key[j]), j);
            mt[i2] = unsigned32(mt[i2] & 4294967295);
            i2++;
            j++;
            if (i2 >= N) {
              mt[0] = mt[N - 1];
              i2 = 1;
            }
            if (j >= key_length)
              j = 0;
          }
          for (k = N - 1; k; k--) {
            mt[i2] = subtraction32(unsigned32((dbg = mt[i2]) ^ multiplication32(unsigned32(mt[i2 - 1] ^ mt[i2 - 1] >>> 30), 1566083941)), i2);
            mt[i2] = unsigned32(mt[i2] & 4294967295);
            i2++;
            if (i2 >= N) {
              mt[0] = mt[N - 1];
              i2 = 1;
            }
          }
          mt[0] = 2147483648;
        };
        var mag01 = [0, MATRIX_A];
        this.genrand_int32 = function() {
          var y;
          if (mti >= N) {
            var kk;
            if (mti == N + 1)
              this.init_genrand(5489);
            for (kk = 0; kk < N - M; kk++) {
              y = unsigned32(mt[kk] & UPPER_MASK | mt[kk + 1] & LOWER_MASK);
              mt[kk] = unsigned32(mt[kk + M] ^ y >>> 1 ^ mag01[y & 1]);
            }
            for (; kk < N - 1; kk++) {
              y = unsigned32(mt[kk] & UPPER_MASK | mt[kk + 1] & LOWER_MASK);
              mt[kk] = unsigned32(mt[kk + (M - N)] ^ y >>> 1 ^ mag01[y & 1]);
            }
            y = unsigned32(mt[N - 1] & UPPER_MASK | mt[0] & LOWER_MASK);
            mt[N - 1] = unsigned32(mt[M - 1] ^ y >>> 1 ^ mag01[y & 1]);
            mti = 0;
          }
          y = mt[mti++];
          y = unsigned32(y ^ y >>> 11);
          y = unsigned32(y ^ y << 7 & 2636928640);
          y = unsigned32(y ^ y << 15 & 4022730752);
          y = unsigned32(y ^ y >>> 18);
          return y;
        };
        this.genrand_int31 = function() {
          return this.genrand_int32() >>> 1;
        };
        this.genrand_real1 = function() {
          return this.genrand_int32() * (1 / 4294967295);
        };
        this.genrand_real2 = function() {
          return this.genrand_int32() * (1 / 4294967296);
        };
        this.genrand_real3 = function() {
          return (this.genrand_int32() + 0.5) * (1 / 4294967296);
        };
        this.genrand_res53 = function() {
          var a = this.genrand_int32() >>> 5, b = this.genrand_int32() >>> 6;
          return (a * 67108864 + b) * (1 / 9007199254740992);
        };
      }
      exports.MersenneTwister19937 = MersenneTwister19937;
      var gen = new MersenneTwister19937();
      gen.init_genrand(new Date().getTime() % 1e9);
      exports.rand = function(N) {
        if (!N) {
          N = 32768;
        }
        return Math.floor(gen.genrand_real2() * N);
      };
      exports.seed = function(S) {
        if (typeof S != "number") {
          throw new Error("seed(S) must take numeric argument; is " + typeof S);
        }
        gen.init_genrand(S);
      };
      exports.seed_array = function(A) {
        if (typeof A != "object") {
          throw new Error("seed_array(A) must take array of numbers; is " + typeof A);
        }
        gen.init_by_array(A);
      };
    }
  });

  // node_modules/@jocabola/math/lib/Random.js
  var require_Random = __commonJS({
    "node_modules/@jocabola/math/lib/Random.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var mersenne_1 = __importDefault(require_mersenne());
      var Random4 = class {
        constructor(seed = 0) {
          mersenne_1.default.seed(seed);
        }
        static seed(seed) {
          mersenne_1.default.seed(seed);
        }
        static random() {
          let N = 1e3;
          return mersenne_1.default.rand(N) / (N - 1);
        }
        static randi(min = 0, max = 1) {
          return Math.round(Random4.randf(min, max));
        }
        static randf(min = 0, max = 1) {
          return min + (max - min) * Random4.random();
        }
        static randc() {
          return Random4.random() * 16777215 << 0;
        }
        static randarrind(arr) {
          const n = arr.length;
          const seq = Array.from(new Array(n), (val, index) => index);
          return Random4.randarr(seq);
        }
        static randarr(arr) {
          const n = arr.length;
          for (let i2 = n - 1; i2 > 0; i2--) {
            const j = Random4.randi(0, i2);
            [arr[i2], arr[j]] = [arr[j], arr[i2]];
          }
          return arr;
        }
      };
      exports.default = Random4;
    }
  });

  // node_modules/@jocabola/math/lib/MathUtils.js
  var require_MathUtils = __commonJS({
    "node_modules/@jocabola/math/lib/MathUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var MathUtils6 = class {
        static clamp(v, min, max) {
          return Math.min(max, Math.max(min, v));
        }
        static lerp(v1, v2, alpha) {
          return v1 + (v2 - v1) * alpha;
        }
        static mix(v1, v2, alpha) {
          return MathUtils6.lerp(v1, v2, alpha);
        }
        static smoothstep(min, max, val) {
          if (val < min)
            return 0;
          if (val > max)
            return 1;
          return (val - min) / (max - min);
        }
        static step(thrsh, val) {
          return val < thrsh ? 0 : 1;
        }
        static map(x, a, b, c, d) {
          return (x - a) * (d - c) / (b - a) + c;
        }
        static fract(n) {
          return n % 1;
        }
      };
      exports.default = MathUtils6;
    }
  });

  // node_modules/@jocabola/math/lib/Vector.js
  var require_Vector = __commonJS({
    "node_modules/@jocabola/math/lib/Vector.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var MathUtils_1 = __importDefault(require_MathUtils());
      var Vec3 = class {
        constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        }
        set(x, y, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        }
        clone() {
          return new Vec3(this.x, this.y, this.z);
        }
        add(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
        }
        sub(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
        }
        mul(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          return this;
        }
        div(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
          return this;
        }
        scale(scl) {
          this.x *= scl;
          this.y *= scl;
          this.z *= scl;
          return this;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lerp(target, alpha) {
          this.x = MathUtils_1.default.lerp(this.x, target.x, alpha);
          this.y = MathUtils_1.default.lerp(this.y, target.y, alpha);
          this.z = MathUtils_1.default.lerp(this.z, target.z, alpha);
          return this;
        }
        equals(v) {
          return this.x === v.x && this.y === v.y && this.z === v.z;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        distanceTo(v) {
          return this.clone().sub(v).length();
        }
        normalize() {
          const L = this.length();
          if (L == 0)
            return this;
          this.x /= L;
          this.y /= L;
          this.z /= L;
          return this;
        }
      };
      exports.default = Vec3;
    }
  });

  // node_modules/three/build/three.cjs
  var require_three = __commonJS({
    "node_modules/three/build/three.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var REVISION2 = "137";
      var MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      };
      var TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      };
      var CullFaceNone2 = 0;
      var CullFaceBack2 = 1;
      var CullFaceFront2 = 2;
      var CullFaceFrontBack = 3;
      var BasicShadowMap = 0;
      var PCFShadowMap2 = 1;
      var PCFSoftShadowMap2 = 2;
      var VSMShadowMap2 = 3;
      var FrontSide2 = 0;
      var BackSide2 = 1;
      var DoubleSide3 = 2;
      var FlatShading2 = 1;
      var SmoothShading = 2;
      var NoBlending2 = 0;
      var NormalBlending2 = 1;
      var AdditiveBlending2 = 2;
      var SubtractiveBlending2 = 3;
      var MultiplyBlending2 = 4;
      var CustomBlending2 = 5;
      var AddEquation2 = 100;
      var SubtractEquation2 = 101;
      var ReverseSubtractEquation2 = 102;
      var MinEquation2 = 103;
      var MaxEquation2 = 104;
      var ZeroFactor2 = 200;
      var OneFactor2 = 201;
      var SrcColorFactor2 = 202;
      var OneMinusSrcColorFactor2 = 203;
      var SrcAlphaFactor2 = 204;
      var OneMinusSrcAlphaFactor2 = 205;
      var DstAlphaFactor2 = 206;
      var OneMinusDstAlphaFactor2 = 207;
      var DstColorFactor2 = 208;
      var OneMinusDstColorFactor2 = 209;
      var SrcAlphaSaturateFactor2 = 210;
      var NeverDepth2 = 0;
      var AlwaysDepth2 = 1;
      var LessDepth2 = 2;
      var LessEqualDepth2 = 3;
      var EqualDepth2 = 4;
      var GreaterEqualDepth2 = 5;
      var GreaterDepth2 = 6;
      var NotEqualDepth2 = 7;
      var MultiplyOperation2 = 0;
      var MixOperation2 = 1;
      var AddOperation2 = 2;
      var NoToneMapping2 = 0;
      var LinearToneMapping2 = 1;
      var ReinhardToneMapping2 = 2;
      var CineonToneMapping2 = 3;
      var ACESFilmicToneMapping2 = 4;
      var CustomToneMapping2 = 5;
      var UVMapping2 = 300;
      var CubeReflectionMapping2 = 301;
      var CubeRefractionMapping2 = 302;
      var EquirectangularReflectionMapping2 = 303;
      var EquirectangularRefractionMapping2 = 304;
      var CubeUVReflectionMapping2 = 306;
      var CubeUVRefractionMapping2 = 307;
      var RepeatWrapping2 = 1e3;
      var ClampToEdgeWrapping2 = 1001;
      var MirroredRepeatWrapping2 = 1002;
      var NearestFilter2 = 1003;
      var NearestMipmapNearestFilter2 = 1004;
      var NearestMipMapNearestFilter = 1004;
      var NearestMipmapLinearFilter2 = 1005;
      var NearestMipMapLinearFilter = 1005;
      var LinearFilter2 = 1006;
      var LinearMipmapNearestFilter2 = 1007;
      var LinearMipMapNearestFilter = 1007;
      var LinearMipmapLinearFilter2 = 1008;
      var LinearMipMapLinearFilter = 1008;
      var UnsignedByteType2 = 1009;
      var ByteType2 = 1010;
      var ShortType2 = 1011;
      var UnsignedShortType2 = 1012;
      var IntType2 = 1013;
      var UnsignedIntType2 = 1014;
      var FloatType2 = 1015;
      var HalfFloatType2 = 1016;
      var UnsignedShort4444Type2 = 1017;
      var UnsignedShort5551Type2 = 1018;
      var UnsignedInt248Type2 = 1020;
      var AlphaFormat2 = 1021;
      var RGBFormat2 = 1022;
      var RGBAFormat2 = 1023;
      var LuminanceFormat2 = 1024;
      var LuminanceAlphaFormat2 = 1025;
      var DepthFormat2 = 1026;
      var DepthStencilFormat2 = 1027;
      var RedFormat2 = 1028;
      var RedIntegerFormat2 = 1029;
      var RGFormat2 = 1030;
      var RGIntegerFormat2 = 1031;
      var RGBAIntegerFormat2 = 1033;
      var RGB_S3TC_DXT1_Format2 = 33776;
      var RGBA_S3TC_DXT1_Format2 = 33777;
      var RGBA_S3TC_DXT3_Format2 = 33778;
      var RGBA_S3TC_DXT5_Format2 = 33779;
      var RGB_PVRTC_4BPPV1_Format2 = 35840;
      var RGB_PVRTC_2BPPV1_Format2 = 35841;
      var RGBA_PVRTC_4BPPV1_Format2 = 35842;
      var RGBA_PVRTC_2BPPV1_Format2 = 35843;
      var RGB_ETC1_Format2 = 36196;
      var RGB_ETC2_Format2 = 37492;
      var RGBA_ETC2_EAC_Format2 = 37496;
      var RGBA_ASTC_4x4_Format2 = 37808;
      var RGBA_ASTC_5x4_Format2 = 37809;
      var RGBA_ASTC_5x5_Format2 = 37810;
      var RGBA_ASTC_6x5_Format2 = 37811;
      var RGBA_ASTC_6x6_Format2 = 37812;
      var RGBA_ASTC_8x5_Format2 = 37813;
      var RGBA_ASTC_8x6_Format2 = 37814;
      var RGBA_ASTC_8x8_Format2 = 37815;
      var RGBA_ASTC_10x5_Format2 = 37816;
      var RGBA_ASTC_10x6_Format2 = 37817;
      var RGBA_ASTC_10x8_Format2 = 37818;
      var RGBA_ASTC_10x10_Format2 = 37819;
      var RGBA_ASTC_12x10_Format2 = 37820;
      var RGBA_ASTC_12x12_Format2 = 37821;
      var RGBA_BPTC_Format2 = 36492;
      var LoopOnce2 = 2200;
      var LoopRepeat2 = 2201;
      var LoopPingPong2 = 2202;
      var InterpolateDiscrete2 = 2300;
      var InterpolateLinear2 = 2301;
      var InterpolateSmooth2 = 2302;
      var ZeroCurvatureEnding2 = 2400;
      var ZeroSlopeEnding2 = 2401;
      var WrapAroundEnding2 = 2402;
      var NormalAnimationBlendMode2 = 2500;
      var AdditiveAnimationBlendMode2 = 2501;
      var TrianglesDrawMode2 = 0;
      var TriangleStripDrawMode2 = 1;
      var TriangleFanDrawMode2 = 2;
      var LinearEncoding2 = 3e3;
      var sRGBEncoding2 = 3001;
      var BasicDepthPacking2 = 3200;
      var RGBADepthPacking2 = 3201;
      var TangentSpaceNormalMap2 = 0;
      var ObjectSpaceNormalMap2 = 1;
      var ZeroStencilOp = 0;
      var KeepStencilOp2 = 7680;
      var ReplaceStencilOp = 7681;
      var IncrementStencilOp = 7682;
      var DecrementStencilOp = 7683;
      var IncrementWrapStencilOp = 34055;
      var DecrementWrapStencilOp = 34056;
      var InvertStencilOp = 5386;
      var NeverStencilFunc = 512;
      var LessStencilFunc = 513;
      var EqualStencilFunc = 514;
      var LessEqualStencilFunc = 515;
      var GreaterStencilFunc = 516;
      var NotEqualStencilFunc = 517;
      var GreaterEqualStencilFunc = 518;
      var AlwaysStencilFunc2 = 519;
      var StaticDrawUsage2 = 35044;
      var DynamicDrawUsage2 = 35048;
      var StreamDrawUsage = 35040;
      var StaticReadUsage = 35045;
      var DynamicReadUsage = 35049;
      var StreamReadUsage = 35041;
      var StaticCopyUsage = 35046;
      var DynamicCopyUsage = 35050;
      var StreamCopyUsage = 35042;
      var GLSL1 = "100";
      var GLSL32 = "300 es";
      var _SRGBAFormat2 = 1035;
      var EventDispatcher3 = class {
        addEventListener(type, listener) {
          if (this._listeners === void 0)
            this._listeners = {};
          const listeners = this._listeners;
          if (listeners[type] === void 0) {
            listeners[type] = [];
          }
          if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
          }
        }
        hasEventListener(type, listener) {
          if (this._listeners === void 0)
            return false;
          const listeners = this._listeners;
          return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[type];
          if (listenerArray !== void 0) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
              listenerArray.splice(index, 1);
            }
          }
        }
        dispatchEvent(event) {
          if (this._listeners === void 0)
            return;
          const listeners = this._listeners;
          const listenerArray = listeners[event.type];
          if (listenerArray !== void 0) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i2 = 0, l = array.length; i2 < l; i2++) {
              array[i2].call(this, event);
            }
            event.target = null;
          }
        }
      };
      var _lut2 = [];
      for (let i2 = 0; i2 < 256; i2++) {
        _lut2[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
      }
      var _seed2 = 1234567;
      var DEG2RAD3 = Math.PI / 180;
      var RAD2DEG3 = 180 / Math.PI;
      function generateUUID2() {
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut2[d0 & 255] + _lut2[d0 >> 8 & 255] + _lut2[d0 >> 16 & 255] + _lut2[d0 >> 24 & 255] + "-" + _lut2[d1 & 255] + _lut2[d1 >> 8 & 255] + "-" + _lut2[d1 >> 16 & 15 | 64] + _lut2[d1 >> 24 & 255] + "-" + _lut2[d2 & 63 | 128] + _lut2[d2 >> 8 & 255] + "-" + _lut2[d2 >> 16 & 255] + _lut2[d2 >> 24 & 255] + _lut2[d3 & 255] + _lut2[d3 >> 8 & 255] + _lut2[d3 >> 16 & 255] + _lut2[d3 >> 24 & 255];
        return uuid.toUpperCase();
      }
      function clamp4(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function euclideanModulo2(n, m) {
        return (n % m + m) % m;
      }
      function mapLinear2(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      }
      function inverseLerp2(x, y, value) {
        if (x !== y) {
          return (value - x) / (y - x);
        } else {
          return 0;
        }
      }
      function lerp2(x, y, t) {
        return (1 - t) * x + t * y;
      }
      function damp2(x, y, lambda, dt) {
        return lerp2(x, y, 1 - Math.exp(-lambda * dt));
      }
      function pingpong2(x, length = 1) {
        return length - Math.abs(euclideanModulo2(x, length * 2) - length);
      }
      function smoothstep2(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      }
      function smootherstep2(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      }
      function randInt2(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      }
      function randFloat2(low, high) {
        return low + Math.random() * (high - low);
      }
      function randFloatSpread2(range) {
        return range * (0.5 - Math.random());
      }
      function seededRandom2(s) {
        if (s !== void 0)
          _seed2 = s % 2147483647;
        _seed2 = _seed2 * 16807 % 2147483647;
        return (_seed2 - 1) / 2147483646;
      }
      function degToRad2(degrees) {
        return degrees * DEG2RAD3;
      }
      function radToDeg2(radians) {
        return radians * RAD2DEG3;
      }
      function isPowerOfTwo2(value) {
        return (value & value - 1) === 0 && value !== 0;
      }
      function ceilPowerOfTwo2(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
      }
      function floorPowerOfTwo2(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
      }
      function setQuaternionFromProperEuler2(q, a, b, c, order) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s2 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch (order) {
          case "XYX":
            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
            break;
          case "YZY":
            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
            break;
          case "ZXZ":
            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
            break;
          case "XZX":
            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
            break;
          case "YXY":
            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
            break;
          case "ZYZ":
            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
        }
      }
      var MathUtils6 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        DEG2RAD: DEG2RAD3,
        RAD2DEG: RAD2DEG3,
        generateUUID: generateUUID2,
        clamp: clamp4,
        euclideanModulo: euclideanModulo2,
        mapLinear: mapLinear2,
        inverseLerp: inverseLerp2,
        lerp: lerp2,
        damp: damp2,
        pingpong: pingpong2,
        smoothstep: smoothstep2,
        smootherstep: smootherstep2,
        randInt: randInt2,
        randFloat: randFloat2,
        randFloatSpread: randFloatSpread2,
        seededRandom: seededRandom2,
        degToRad: degToRad2,
        radToDeg: radToDeg2,
        isPowerOfTwo: isPowerOfTwo2,
        ceilPowerOfTwo: ceilPowerOfTwo2,
        floorPowerOfTwo: floorPowerOfTwo2,
        setQuaternionFromProperEuler: setQuaternionFromProperEuler2
      });
      var Vector22 = class {
        constructor(x = 0, y = 0) {
          this.x = x;
          this.y = y;
        }
        get width() {
          return this.x;
        }
        set width(value) {
          this.x = value;
        }
        get height() {
          return this.y;
        }
        set height(value) {
          this.y = value;
        }
        set(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6];
          this.y = e[1] * x + e[4] * y + e[7];
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y;
        }
        cross(v) {
          return this.x * v.y - this.y * v.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const angle = Math.atan2(-this.y, -this.x) + Math.PI;
          return angle;
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y;
          return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          return this;
        }
        rotateAround(center, angle) {
          const c = Math.cos(angle), s = Math.sin(angle);
          const x = this.x - center.x;
          const y = this.y - center.y;
          this.x = x * c - y * s + center.x;
          this.y = x * s + y * c + center.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
        }
      };
      Vector22.prototype.isVector2 = true;
      var Matrix32 = class {
        constructor() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          const te = this.elements;
          te[0] = n11;
          te[1] = n21;
          te[2] = n31;
          te[3] = n12;
          te[4] = n22;
          te[5] = n32;
          te[6] = n13;
          te[7] = n23;
          te[8] = n33;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
          return this;
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(m) {
          const me = m.elements;
          this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
          return this;
        }
        multiply(m) {
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[3], a13 = ae[6];
          const a21 = ae[1], a22 = ae[4], a23 = ae[7];
          const a31 = ae[2], a32 = ae[5], a33 = ae[8];
          const b11 = be[0], b12 = be[3], b13 = be[6];
          const b21 = be[1], b22 = be[4], b23 = be[7];
          const b31 = be[2], b32 = be[5], b33 = be[8];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te[6] = a11 * b13 + a12 * b23 + a13 * b33;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te[7] = a21 * b13 + a22 * b23 + a23 * b33;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te[8] = a31 * b13 + a32 * b23 + a33 * b33;
          return this;
        }
        multiplyScalar(s) {
          const te = this.elements;
          te[0] *= s;
          te[3] *= s;
          te[6] *= s;
          te[1] *= s;
          te[4] *= s;
          te[7] *= s;
          te[2] *= s;
          te[5] *= s;
          te[8] *= s;
          return this;
        }
        determinant() {
          const te = this.elements;
          const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
          return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n31 * n23 - n33 * n21) * detInv;
          te[2] = (n32 * n21 - n31 * n22) * detInv;
          te[3] = t12 * detInv;
          te[4] = (n33 * n11 - n31 * n13) * detInv;
          te[5] = (n31 * n12 - n32 * n11) * detInv;
          te[6] = t13 * detInv;
          te[7] = (n21 * n13 - n23 * n11) * detInv;
          te[8] = (n22 * n11 - n21 * n12) * detInv;
          return this;
        }
        transpose() {
          let tmp4;
          const m = this.elements;
          tmp4 = m[1];
          m[1] = m[3];
          m[3] = tmp4;
          tmp4 = m[2];
          m[2] = m[6];
          m[6] = tmp4;
          tmp4 = m[5];
          m[5] = m[7];
          m[7] = tmp4;
          return this;
        }
        getNormalMatrix(matrix4) {
          return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r) {
          const m = this.elements;
          r[0] = m[0];
          r[1] = m[3];
          r[2] = m[6];
          r[3] = m[1];
          r[4] = m[4];
          r[5] = m[7];
          r[6] = m[2];
          r[7] = m[5];
          r[8] = m[8];
          return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
          const c = Math.cos(rotation);
          const s = Math.sin(rotation);
          this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
          return this;
        }
        scale(sx, sy) {
          const te = this.elements;
          te[0] *= sx;
          te[3] *= sx;
          te[6] *= sx;
          te[1] *= sy;
          te[4] *= sy;
          te[7] *= sy;
          return this;
        }
        rotate(theta) {
          const c = Math.cos(theta);
          const s = Math.sin(theta);
          const te = this.elements;
          const a11 = te[0], a12 = te[3], a13 = te[6];
          const a21 = te[1], a22 = te[4], a23 = te[7];
          te[0] = c * a11 + s * a21;
          te[3] = c * a12 + s * a22;
          te[6] = c * a13 + s * a23;
          te[1] = -s * a11 + c * a21;
          te[4] = -s * a12 + c * a22;
          te[7] = -s * a13 + c * a23;
          return this;
        }
        translate(tx, ty) {
          const te = this.elements;
          te[0] += tx * te[2];
          te[3] += tx * te[5];
          te[6] += tx * te[8];
          te[1] += ty * te[2];
          te[4] += ty * te[5];
          te[7] += ty * te[8];
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i2 = 0; i2 < 9; i2++) {
            if (te[i2] !== me[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          return array;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      };
      Matrix32.prototype.isMatrix3 = true;
      function arrayNeedsUint322(array) {
        for (let i2 = array.length - 1; i2 >= 0; --i2) {
          if (array[i2] > 65535)
            return true;
        }
        return false;
      }
      var TYPED_ARRAYS = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      };
      function getTypedArray(type, buffer) {
        return new TYPED_ARRAYS[type](buffer);
      }
      function createElementNS2(name) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", name);
      }
      var _colorKeywords2 = {
        "aliceblue": 15792383,
        "antiquewhite": 16444375,
        "aqua": 65535,
        "aquamarine": 8388564,
        "azure": 15794175,
        "beige": 16119260,
        "bisque": 16770244,
        "black": 0,
        "blanchedalmond": 16772045,
        "blue": 255,
        "blueviolet": 9055202,
        "brown": 10824234,
        "burlywood": 14596231,
        "cadetblue": 6266528,
        "chartreuse": 8388352,
        "chocolate": 13789470,
        "coral": 16744272,
        "cornflowerblue": 6591981,
        "cornsilk": 16775388,
        "crimson": 14423100,
        "cyan": 65535,
        "darkblue": 139,
        "darkcyan": 35723,
        "darkgoldenrod": 12092939,
        "darkgray": 11119017,
        "darkgreen": 25600,
        "darkgrey": 11119017,
        "darkkhaki": 12433259,
        "darkmagenta": 9109643,
        "darkolivegreen": 5597999,
        "darkorange": 16747520,
        "darkorchid": 10040012,
        "darkred": 9109504,
        "darksalmon": 15308410,
        "darkseagreen": 9419919,
        "darkslateblue": 4734347,
        "darkslategray": 3100495,
        "darkslategrey": 3100495,
        "darkturquoise": 52945,
        "darkviolet": 9699539,
        "deeppink": 16716947,
        "deepskyblue": 49151,
        "dimgray": 6908265,
        "dimgrey": 6908265,
        "dodgerblue": 2003199,
        "firebrick": 11674146,
        "floralwhite": 16775920,
        "forestgreen": 2263842,
        "fuchsia": 16711935,
        "gainsboro": 14474460,
        "ghostwhite": 16316671,
        "gold": 16766720,
        "goldenrod": 14329120,
        "gray": 8421504,
        "green": 32768,
        "greenyellow": 11403055,
        "grey": 8421504,
        "honeydew": 15794160,
        "hotpink": 16738740,
        "indianred": 13458524,
        "indigo": 4915330,
        "ivory": 16777200,
        "khaki": 15787660,
        "lavender": 15132410,
        "lavenderblush": 16773365,
        "lawngreen": 8190976,
        "lemonchiffon": 16775885,
        "lightblue": 11393254,
        "lightcoral": 15761536,
        "lightcyan": 14745599,
        "lightgoldenrodyellow": 16448210,
        "lightgray": 13882323,
        "lightgreen": 9498256,
        "lightgrey": 13882323,
        "lightpink": 16758465,
        "lightsalmon": 16752762,
        "lightseagreen": 2142890,
        "lightskyblue": 8900346,
        "lightslategray": 7833753,
        "lightslategrey": 7833753,
        "lightsteelblue": 11584734,
        "lightyellow": 16777184,
        "lime": 65280,
        "limegreen": 3329330,
        "linen": 16445670,
        "magenta": 16711935,
        "maroon": 8388608,
        "mediumaquamarine": 6737322,
        "mediumblue": 205,
        "mediumorchid": 12211667,
        "mediumpurple": 9662683,
        "mediumseagreen": 3978097,
        "mediumslateblue": 8087790,
        "mediumspringgreen": 64154,
        "mediumturquoise": 4772300,
        "mediumvioletred": 13047173,
        "midnightblue": 1644912,
        "mintcream": 16121850,
        "mistyrose": 16770273,
        "moccasin": 16770229,
        "navajowhite": 16768685,
        "navy": 128,
        "oldlace": 16643558,
        "olive": 8421376,
        "olivedrab": 7048739,
        "orange": 16753920,
        "orangered": 16729344,
        "orchid": 14315734,
        "palegoldenrod": 15657130,
        "palegreen": 10025880,
        "paleturquoise": 11529966,
        "palevioletred": 14381203,
        "papayawhip": 16773077,
        "peachpuff": 16767673,
        "peru": 13468991,
        "pink": 16761035,
        "plum": 14524637,
        "powderblue": 11591910,
        "purple": 8388736,
        "rebeccapurple": 6697881,
        "red": 16711680,
        "rosybrown": 12357519,
        "royalblue": 4286945,
        "saddlebrown": 9127187,
        "salmon": 16416882,
        "sandybrown": 16032864,
        "seagreen": 3050327,
        "seashell": 16774638,
        "sienna": 10506797,
        "silver": 12632256,
        "skyblue": 8900331,
        "slateblue": 6970061,
        "slategray": 7372944,
        "slategrey": 7372944,
        "snow": 16775930,
        "springgreen": 65407,
        "steelblue": 4620980,
        "tan": 13808780,
        "teal": 32896,
        "thistle": 14204888,
        "tomato": 16737095,
        "turquoise": 4251856,
        "violet": 15631086,
        "wheat": 16113331,
        "white": 16777215,
        "whitesmoke": 16119285,
        "yellow": 16776960,
        "yellowgreen": 10145074
      };
      var _hslA2 = {
        h: 0,
        s: 0,
        l: 0
      };
      var _hslB2 = {
        h: 0,
        s: 0,
        l: 0
      };
      function hue2rgb2(p2, q, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p2 + (q - p2) * 6 * t;
        if (t < 1 / 2)
          return q;
        if (t < 2 / 3)
          return p2 + (q - p2) * 6 * (2 / 3 - t);
        return p2;
      }
      function SRGBToLinear2(c) {
        return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
      }
      function LinearToSRGB2(c) {
        return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
      }
      var Color2 = class {
        constructor(r, g, b) {
          if (g === void 0 && b === void 0) {
            return this.set(r);
          }
          return this.setRGB(r, g, b);
        }
        set(value) {
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === "number") {
            this.setHex(value);
          } else if (typeof value === "string") {
            this.setStyle(value);
          }
          return this;
        }
        setScalar(scalar) {
          this.r = scalar;
          this.g = scalar;
          this.b = scalar;
          return this;
        }
        setHex(hex) {
          hex = Math.floor(hex);
          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;
          return this;
        }
        setRGB(r, g, b) {
          this.r = r;
          this.g = g;
          this.b = b;
          return this;
        }
        setHSL(h, s, l) {
          h = euclideanModulo2(h, 1);
          s = clamp4(s, 0, 1);
          l = clamp4(l, 0, 1);
          if (s === 0) {
            this.r = this.g = this.b = l;
          } else {
            const p2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p2;
            this.r = hue2rgb2(q, p2, h + 1 / 3);
            this.g = hue2rgb2(q, p2, h);
            this.b = hue2rgb2(q, p2, h - 1 / 3);
          }
          return this;
        }
        setStyle(style) {
          function handleAlpha(string) {
            if (string === void 0)
              return;
            if (parseFloat(string) < 1) {
              console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
          }
          let m;
          if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            let color;
            const name = m[1];
            const components = m[2];
            switch (name) {
              case "rgb":
              case "rgba":
                if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                  this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                  this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                  handleAlpha(color[4]);
                  return this;
                }
                if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                  this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                  this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                  handleAlpha(color[4]);
                  return this;
                }
                break;
              case "hsl":
              case "hsla":
                if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  const h = parseFloat(color[1]) / 360;
                  const s = parseInt(color[2], 10) / 100;
                  const l = parseInt(color[3], 10) / 100;
                  handleAlpha(color[4]);
                  return this.setHSL(h, s, l);
                }
                break;
            }
          } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
              this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
              this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
              return this;
            } else if (size === 6) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
              this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
              this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
              return this;
            }
          }
          if (style && style.length > 0) {
            return this.setColorName(style);
          }
          return this;
        }
        setColorName(style) {
          const hex = _colorKeywords2[style.toLowerCase()];
          if (hex !== void 0) {
            this.setHex(hex);
          } else {
            console.warn("THREE.Color: Unknown color " + style);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          return this;
        }
        copySRGBToLinear(color) {
          this.r = SRGBToLinear2(color.r);
          this.g = SRGBToLinear2(color.g);
          this.b = SRGBToLinear2(color.b);
          return this;
        }
        copyLinearToSRGB(color) {
          this.r = LinearToSRGB2(color.r);
          this.g = LinearToSRGB2(color.g);
          this.b = LinearToSRGB2(color.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex() {
          return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(target) {
          const r = this.r, g = this.g, b = this.b;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let hue, saturation;
          const lightness = (min + max) / 2;
          if (min === max) {
            hue = 0;
            saturation = 0;
          } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
              case r:
                hue = (g - b) / delta + (g < b ? 6 : 0);
                break;
              case g:
                hue = (b - r) / delta + 2;
                break;
              case b:
                hue = (r - g) / delta + 4;
                break;
            }
            hue /= 6;
          }
          target.h = hue;
          target.s = saturation;
          target.l = lightness;
          return target;
        }
        getStyle() {
          return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
        }
        offsetHSL(h, s, l) {
          this.getHSL(_hslA2);
          _hslA2.h += h;
          _hslA2.s += s;
          _hslA2.l += l;
          this.setHSL(_hslA2.h, _hslA2.s, _hslA2.l);
          return this;
        }
        add(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          return this;
        }
        addColors(color1, color2) {
          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;
          return this;
        }
        addScalar(s) {
          this.r += s;
          this.g += s;
          this.b += s;
          return this;
        }
        sub(color) {
          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);
          return this;
        }
        multiply(color) {
          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;
          return this;
        }
        multiplyScalar(s) {
          this.r *= s;
          this.g *= s;
          this.b *= s;
          return this;
        }
        lerp(color, alpha) {
          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;
          return this;
        }
        lerpColors(color1, color2, alpha) {
          this.r = color1.r + (color2.r - color1.r) * alpha;
          this.g = color1.g + (color2.g - color1.g) * alpha;
          this.b = color1.b + (color2.b - color1.b) * alpha;
          return this;
        }
        lerpHSL(color, alpha) {
          this.getHSL(_hslA2);
          color.getHSL(_hslB2);
          const h = lerp2(_hslA2.h, _hslB2.h, alpha);
          const s = lerp2(_hslA2.s, _hslB2.s, alpha);
          const l = lerp2(_hslA2.l, _hslB2.l, alpha);
          this.setHSL(h, s, l);
          return this;
        }
        equals(c) {
          return c.r === this.r && c.g === this.g && c.b === this.b;
        }
        fromArray(array, offset = 0) {
          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.r = attribute.getX(index);
          this.g = attribute.getY(index);
          this.b = attribute.getZ(index);
          if (attribute.normalized === true) {
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
          }
          return this;
        }
        toJSON() {
          return this.getHex();
        }
      };
      Color2.NAMES = _colorKeywords2;
      Color2.prototype.isColor = true;
      Color2.prototype.r = 1;
      Color2.prototype.g = 1;
      Color2.prototype.b = 1;
      var _canvas2;
      var ImageUtils2 = class {
        static getDataURL(image) {
          if (/^data:/i.test(image.src)) {
            return image.src;
          }
          if (typeof HTMLCanvasElement == "undefined") {
            return image.src;
          }
          let canvas;
          if (image instanceof HTMLCanvasElement) {
            canvas = image;
          } else {
            if (_canvas2 === void 0)
              _canvas2 = createElementNS2("canvas");
            _canvas2.width = image.width;
            _canvas2.height = image.height;
            const context = _canvas2.getContext("2d");
            if (image instanceof ImageData) {
              context.putImageData(image, 0, 0);
            } else {
              context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas = _canvas2;
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas.toDataURL("image/jpeg", 0.6);
          } else {
            return canvas.toDataURL("image/png");
          }
        }
        static sRGBToLinear(image) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            const canvas = createElementNS2("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height);
            const imageData = context.getImageData(0, 0, image.width, image.height);
            const data = imageData.data;
            for (let i2 = 0; i2 < data.length; i2++) {
              data[i2] = SRGBToLinear2(data[i2] / 255) * 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
          } else if (image.data) {
            const data = image.data.slice(0);
            for (let i2 = 0; i2 < data.length; i2++) {
              if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                data[i2] = Math.floor(SRGBToLinear2(data[i2] / 255) * 255);
              } else {
                data[i2] = SRGBToLinear2(data[i2]);
              }
            }
            return {
              data,
              width: image.width,
              height: image.height
            };
          } else {
            console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
            return image;
          }
        }
      };
      var textureId2 = 0;
      var Texture2 = class extends EventDispatcher3 {
        constructor(image = Texture2.DEFAULT_IMAGE, mapping = Texture2.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping2, wrapT = ClampToEdgeWrapping2, magFilter = LinearFilter2, minFilter = LinearMipmapLinearFilter2, format = RGBAFormat2, type = UnsignedByteType2, anisotropy = 1, encoding = LinearEncoding2) {
          super();
          Object.defineProperty(this, "id", {
            value: textureId2++
          });
          this.uuid = generateUUID2();
          this.name = "";
          this.image = image;
          this.mipmaps = [];
          this.mapping = mapping;
          this.wrapS = wrapS;
          this.wrapT = wrapT;
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.anisotropy = anisotropy;
          this.format = format;
          this.internalFormat = null;
          this.type = type;
          this.offset = new Vector22(0, 0);
          this.repeat = new Vector22(1, 1);
          this.center = new Vector22(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Matrix32();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          this.encoding = encoding;
          this.userData = {};
          this.version = 0;
          this.onUpdate = null;
          this.isRenderTargetTexture = false;
          this.needsPMREMUpdate = false;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.image = source.image;
          this.mipmaps = source.mipmaps.slice(0);
          this.mapping = source.mapping;
          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;
          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;
          this.anisotropy = source.anisotropy;
          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;
          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);
          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.encoding = source.encoding;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.textures[this.uuid] !== void 0) {
            return meta.textures[this.uuid];
          }
          const output = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (this.image !== void 0) {
            const image = this.image;
            if (image.uuid === void 0) {
              image.uuid = generateUUID2();
            }
            if (!isRootObject && meta.images[image.uuid] === void 0) {
              let url;
              if (Array.isArray(image)) {
                url = [];
                for (let i2 = 0, l = image.length; i2 < l; i2++) {
                  if (image[i2].isDataTexture) {
                    url.push(serializeImage2(image[i2].image));
                  } else {
                    url.push(serializeImage2(image[i2]));
                  }
                }
              } else {
                url = serializeImage2(image);
              }
              meta.images[image.uuid] = {
                uuid: image.uuid,
                url
              };
            }
            output.image = image.uuid;
          }
          if (JSON.stringify(this.userData) !== "{}")
            output.userData = this.userData;
          if (!isRootObject) {
            meta.textures[this.uuid] = output;
          }
          return output;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(uv) {
          if (this.mapping !== UVMapping2)
            return uv;
          uv.applyMatrix3(this.matrix);
          if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
              case RepeatWrapping2:
                uv.x = uv.x - Math.floor(uv.x);
                break;
              case ClampToEdgeWrapping2:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping2:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                  uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                  uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
          }
          if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
              case RepeatWrapping2:
                uv.y = uv.y - Math.floor(uv.y);
                break;
              case ClampToEdgeWrapping2:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping2:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                  uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                  uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
          }
          if (this.flipY) {
            uv.y = 1 - uv.y;
          }
          return uv;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      };
      Texture2.DEFAULT_IMAGE = void 0;
      Texture2.DEFAULT_MAPPING = UVMapping2;
      Texture2.prototype.isTexture = true;
      function serializeImage2(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          return ImageUtils2.getDataURL(image);
        } else {
          if (image.data) {
            return {
              data: Array.prototype.slice.call(image.data),
              width: image.width,
              height: image.height,
              type: image.data.constructor.name
            };
          } else {
            console.warn("THREE.Texture: Unable to serialize Texture.");
            return {};
          }
        }
      }
      var Vector42 = class {
        constructor(x = 0, y = 0, z = 0, w = 1) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }
        get width() {
          return this.z;
        }
        set width(value) {
          this.z = value;
        }
        get height() {
          return this.w;
        }
        set height(value) {
          this.w = value;
        }
        set(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setW(w) {
          this.w = w;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            case 3:
              this.w = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          this.w = v.w !== void 0 ? v.w : 1;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          this.w += v.w;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          this.z += s;
          this.w += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          this.w = a.w + b.w;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;
          this.w += v.w * s;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          this.w -= v.w;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          this.z -= s;
          this.w -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          this.w = a.w - b.w;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          this.w *= v.w;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z = this.z, w = this.w;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
          this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
          this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
          this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q) {
          this.w = 2 * Math.acos(q.w);
          const s = Math.sqrt(1 - q.w * q.w);
          if (s < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(m) {
          let angle, x, y, z;
          const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
          if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
              this.set(1, 0, 0, 0);
              return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
              if (xx < epsilon) {
                x = 0;
                y = 0.707106781;
                z = 0.707106781;
              } else {
                x = Math.sqrt(xx);
                y = xy / x;
                z = xz / x;
              }
            } else if (yy > zz) {
              if (yy < epsilon) {
                x = 0.707106781;
                y = 0;
                z = 0.707106781;
              } else {
                y = Math.sqrt(yy);
                x = xy / y;
                z = yz / y;
              }
            } else {
              if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
              } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
              }
            }
            this.set(x, y, z, angle);
            return this;
          }
          let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
          if (Math.abs(s) < 1e-3)
            s = 1;
          this.x = (m32 - m23) / s;
          this.y = (m13 - m31) / s;
          this.z = (m21 - m12) / s;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          this.w = Math.min(this.w, v.w);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          this.w = Math.max(this.w, v.w);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          this.w = Math.max(min.w, Math.min(max.w, this.w));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          this.w += (v.w - this.w) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          this.w = v1.w + (v2.w - v1.w) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          this.w = attribute.getW(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
          yield this.w;
        }
      };
      Vector42.prototype.isVector4 = true;
      var WebGLRenderTarget3 = class extends EventDispatcher3 {
        constructor(width, height, options = {}) {
          super();
          this.width = width;
          this.height = height;
          this.depth = 1;
          this.scissor = new Vector42(0, 0, width, height);
          this.scissorTest = false;
          this.viewport = new Vector42(0, 0, width, height);
          this.texture = new Texture2(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.image = {
            width,
            height,
            depth: 1
          };
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter2;
          this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
          this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
          this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
        }
        setTexture(texture) {
          texture.image = {
            width: this.width,
            height: this.height,
            depth: this.depth
          };
          this.texture = texture;
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.copy(source.viewport);
          this.texture = source.texture.clone();
          this.texture.image = Object.assign({}, source.texture.image);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      };
      WebGLRenderTarget3.prototype.isWebGLRenderTarget = true;
      var WebGLMultipleRenderTargets2 = class extends WebGLRenderTarget3 {
        constructor(width, height, count) {
          super(width, height);
          const texture = this.texture;
          this.texture = [];
          for (let i2 = 0; i2 < count; i2++) {
            this.texture[i2] = texture.clone();
          }
        }
        setSize(width, height, depth = 1) {
          if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
              this.texture[i2].image.width = width;
              this.texture[i2].image.height = height;
              this.texture[i2].image.depth = depth;
            }
            this.dispose();
          }
          this.viewport.set(0, 0, width, height);
          this.scissor.set(0, 0, width, height);
          return this;
        }
        copy(source) {
          this.dispose();
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.set(0, 0, this.width, this.height);
          this.scissor.set(0, 0, this.width, this.height);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          this.depthTexture = source.depthTexture;
          this.texture.length = 0;
          for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
            this.texture[i2] = source.texture[i2].clone();
          }
          return this;
        }
      };
      WebGLMultipleRenderTargets2.prototype.isWebGLMultipleRenderTargets = true;
      var WebGLMultisampleRenderTarget2 = class extends WebGLRenderTarget3 {
        constructor(width, height, options = {}) {
          super(width, height, options);
          this.samples = 4;
          this.ignoreDepthForMultisampleCopy = options.ignoreDepth !== void 0 ? options.ignoreDepth : true;
          this.useRenderToTexture = options.useRenderToTexture !== void 0 ? options.useRenderToTexture : false;
          this.useRenderbuffer = this.useRenderToTexture === false;
        }
        copy(source) {
          super.copy.call(this, source);
          this.samples = source.samples;
          this.useRenderToTexture = source.useRenderToTexture;
          this.useRenderbuffer = source.useRenderbuffer;
          return this;
        }
      };
      WebGLMultisampleRenderTarget2.prototype.isWebGLMultisampleRenderTarget = true;
      var Quaternion2 = class {
        constructor(x = 0, y = 0, z = 0, w = 1) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._w = w;
        }
        static slerp(qa, qb, qm, t) {
          console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
          return qm.slerpQuaternions(qa, qb, t);
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
          let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
          if (t === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
          }
          if (t === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
          }
          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s = 1 - t;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
              const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
              s = Math.sin(s * len) / sin;
              t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            if (s === 1 - t) {
              const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
              x0 *= f;
              y0 *= f;
              z0 *= f;
              w0 *= f;
            }
          }
          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];
          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
          return dst;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(value) {
          this._w = value;
          this._onChangeCallback();
        }
        set(x, y, z, w) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._w = w;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(euler, update) {
          if (!(euler && euler.isEuler)) {
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
          const cos = Math.cos;
          const sin = Math.sin;
          const c1 = cos(x / 2);
          const c2 = cos(y / 2);
          const c3 = cos(z / 2);
          const s1 = sin(x / 2);
          const s2 = sin(y / 2);
          const s3 = sin(z / 2);
          switch (order) {
            case "XYZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "YXZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "ZXY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "ZYX":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "YZX":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "XZY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
          }
          if (update !== false)
            this._onChangeCallback();
          return this;
        }
        setFromAxisAngle(axis, angle) {
          const halfAngle = angle / 2, s = Math.sin(halfAngle);
          this._x = axis.x * s;
          this._y = axis.y * s;
          this._z = axis.z * s;
          this._w = Math.cos(halfAngle);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m) {
          const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
          if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
          } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
          } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
          } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(vFrom, vTo) {
          let r = vFrom.dot(vTo) + 1;
          if (r < Number.EPSILON) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              this._x = -vFrom.y;
              this._y = vFrom.x;
              this._z = 0;
              this._w = r;
            } else {
              this._x = 0;
              this._y = -vFrom.z;
              this._z = vFrom.y;
              this._w = r;
            }
          } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
          }
          return this.normalize();
        }
        angleTo(q) {
          return 2 * Math.acos(Math.abs(clamp4(this.dot(q), -1, 1)));
        }
        rotateTowards(q, step) {
          const angle = this.angleTo(q);
          if (angle === 0)
            return this;
          const t = Math.min(1, step / angle);
          this.slerp(q, t);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(v) {
          return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let l = this.length();
          if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(q, p2) {
          if (p2 !== void 0) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p2);
          }
          return this.multiplyQuaternions(this, q);
        }
        premultiply(q) {
          return this.multiplyQuaternions(q, this);
        }
        multiplyQuaternions(a, b) {
          const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
          const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          this._onChangeCallback();
          return this;
        }
        slerp(qb, t) {
          if (t === 0)
            return this;
          if (t === 1)
            return this.copy(qb);
          const x = this._x, y = this._y, z = this._z, w = this._w;
          let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
          if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
          }
          const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
          if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
          this._w = w * ratioA + this._w * ratioB;
          this._x = x * ratioA + this._x * ratioB;
          this._y = y * ratioA + this._y * ratioB;
          this._z = z * ratioA + this._z * ratioB;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(qa, qb, t) {
          return this.copy(qa).slerp(qb, t);
        }
        random() {
          const u1 = Math.random();
          const sqrt1u1 = Math.sqrt(1 - u1);
          const sqrtu1 = Math.sqrt(u1);
          const u2 = 2 * Math.PI * Math.random();
          const u3 = 2 * Math.PI * Math.random();
          return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
        }
        equals(quaternion) {
          return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        }
        fromArray(array, offset = 0) {
          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this._x = attribute.getX(index);
          this._y = attribute.getY(index);
          this._z = attribute.getZ(index);
          this._w = attribute.getW(index);
          return this;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      };
      Quaternion2.prototype.isQuaternion = true;
      var Vector32 = class {
        constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        set(x, y, z) {
          if (z === void 0)
            z = this.z;
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        }
        add(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
          }
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          this.z += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;
          return this;
        }
        sub(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
          }
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          this.z -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          return this;
        }
        multiply(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
          }
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiplyVectors(a, b) {
          this.x = a.x * b.x;
          this.y = a.y * b.y;
          this.z = a.z * b.z;
          return this;
        }
        applyEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
          }
          return this.applyQuaternion(_quaternion$42.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle) {
          return this.applyQuaternion(_quaternion$42.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6] * z;
          this.y = e[1] * x + e[4] * y + e[7] * z;
          this.z = e[2] * x + e[5] * y + e[8] * z;
          return this;
        }
        applyNormalMatrix(m) {
          return this.applyMatrix3(m).normalize();
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
          this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
          this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
          this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
          return this;
        }
        applyQuaternion(q) {
          const x = this.x, y = this.y, z = this.z;
          const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
          const ix = qw * x + qy * z - qz * y;
          const iy = qw * y + qz * x - qx * z;
          const iz = qw * z + qx * y - qy * x;
          const iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        }
        project(camera) {
          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z;
          this.y = e[1] * x + e[5] * y + e[9] * z;
          this.z = e[2] * x + e[6] * y + e[10] * z;
          return this.normalize();
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          return this;
        }
        cross(v, w) {
          if (w !== void 0) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
          }
          return this.crossVectors(this, v);
        }
        crossVectors(a, b) {
          const ax = a.x, ay = a.y, az = a.z;
          const bx = b.x, by = b.y, bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        projectOnVector(v) {
          const denominator = v.lengthSq();
          if (denominator === 0)
            return this.set(0, 0, 0);
          const scalar = v.dot(this) / denominator;
          return this.copy(v).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
          _vector$c2.copy(this).projectOnVector(planeNormal);
          return this.sub(_vector$c2);
        }
        reflect(normal) {
          return this.sub(_vector$c2.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v) {
          const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v) / denominator;
          return Math.acos(clamp4(theta, -1, 1));
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
          return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        }
        setFromSpherical(s) {
          return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
          const sinPhiRadius = Math.sin(phi) * radius;
          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);
          return this;
        }
        setFromCylindrical(c) {
          return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
        }
        setFromCylindricalCoords(radius, theta, y) {
          this.x = radius * Math.sin(theta);
          this.y = y;
          this.z = radius * Math.cos(theta);
          return this;
        }
        setFromMatrixPosition(m) {
          const e = m.elements;
          this.x = e[12];
          this.y = e[13];
          this.z = e[14];
          return this;
        }
        setFromMatrixScale(m) {
          const sx = this.setFromMatrixColumn(m, 0).length();
          const sy = this.setFromMatrixColumn(m, 1).length();
          const sz = this.setFromMatrixColumn(m, 2).length();
          this.x = sx;
          this.y = sy;
          this.z = sz;
          return this;
        }
        setFromMatrixColumn(m, index) {
          return this.fromArray(m.elements, index * 4);
        }
        setFromMatrix3Column(m, index) {
          return this.fromArray(m.elements, index * 3);
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          return array;
        }
        fromBufferAttribute(attribute, index, offset) {
          if (offset !== void 0) {
            console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
          }
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
        randomDirection() {
          const u = (Math.random() - 0.5) * 2;
          const t = Math.random() * Math.PI * 2;
          const f = Math.sqrt(1 - u ** 2);
          this.x = f * Math.cos(t);
          this.y = f * Math.sin(t);
          this.z = u;
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
        }
      };
      Vector32.prototype.isVector3 = true;
      var _vector$c2 = /* @__PURE__ */ new Vector32();
      var _quaternion$42 = /* @__PURE__ */ new Quaternion2();
      var Box32 = class {
        constructor(min = new Vector32(Infinity, Infinity, Infinity), max = new Vector32(-Infinity, -Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromArray(array) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
            const x = array[i2];
            const y = array[i2 + 1];
            const z = array[i2 + 2];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromBufferAttribute(attribute) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i2 = 0, l = attribute.count; i2 < l; i2++) {
            const x = attribute.getX(i2);
            const y = attribute.getY(i2);
            const z = attribute.getZ(i2);
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$b2.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        setFromObject(object, precise = false) {
          this.makeEmpty();
          return this.expandByObject(object, precise);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        expandByObject(object, precise = false) {
          object.updateWorldMatrix(false, false);
          const geometry = object.geometry;
          if (geometry !== void 0) {
            if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
              const position = geometry.attributes.position;
              for (let i2 = 0, l = position.count; i2 < l; i2++) {
                _vector$b2.fromBufferAttribute(position, i2).applyMatrix4(object.matrixWorld);
                this.expandByPoint(_vector$b2);
              }
            } else {
              if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
              }
              _box$32.copy(geometry.boundingBox);
              _box$32.applyMatrix4(object.matrixWorld);
              this.union(_box$32);
            }
          }
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            this.expandByObject(children[i2], precise);
          }
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
          this.clampPoint(sphere.center, _vector$b2);
          return _vector$b2.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        }
        intersectsPlane(plane) {
          let min, max;
          if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
          } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
          } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
          } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
          }
          return min <= -plane.constant && max >= -plane.constant;
        }
        intersectsTriangle(triangle) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(_center2);
          _extents2.subVectors(this.max, _center2);
          _v0$22.subVectors(triangle.a, _center2);
          _v1$72.subVectors(triangle.b, _center2);
          _v2$32.subVectors(triangle.c, _center2);
          _f02.subVectors(_v1$72, _v0$22);
          _f12.subVectors(_v2$32, _v1$72);
          _f22.subVectors(_v0$22, _v2$32);
          let axes = [0, -_f02.z, _f02.y, 0, -_f12.z, _f12.y, 0, -_f22.z, _f22.y, _f02.z, 0, -_f02.x, _f12.z, 0, -_f12.x, _f22.z, 0, -_f22.x, -_f02.y, _f02.x, 0, -_f12.y, _f12.x, 0, -_f22.y, _f22.x, 0];
          if (!satForAxes2(axes, _v0$22, _v1$72, _v2$32, _extents2)) {
            return false;
          }
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes2(axes, _v0$22, _v1$72, _v2$32, _extents2)) {
            return false;
          }
          _triangleNormal2.crossVectors(_f02, _f12);
          axes = [_triangleNormal2.x, _triangleNormal2.y, _triangleNormal2.z];
          return satForAxes2(axes, _v0$22, _v1$72, _v2$32, _extents2);
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$b2.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        getBoundingSphere(target) {
          this.getCenter(target.center);
          target.radius = this.getSize(_vector$b2).length() * 0.5;
          return target;
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          if (this.isEmpty())
            this.makeEmpty();
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        applyMatrix4(matrix) {
          if (this.isEmpty())
            return this;
          _points2[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points2[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points2[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points2[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          _points2[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points2[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points2[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points2[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.setFromPoints(_points2);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      Box32.prototype.isBox3 = true;
      var _points2 = [/* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32(), /* @__PURE__ */ new Vector32()];
      var _vector$b2 = /* @__PURE__ */ new Vector32();
      var _box$32 = /* @__PURE__ */ new Box32();
      var _v0$22 = /* @__PURE__ */ new Vector32();
      var _v1$72 = /* @__PURE__ */ new Vector32();
      var _v2$32 = /* @__PURE__ */ new Vector32();
      var _f02 = /* @__PURE__ */ new Vector32();
      var _f12 = /* @__PURE__ */ new Vector32();
      var _f22 = /* @__PURE__ */ new Vector32();
      var _center2 = /* @__PURE__ */ new Vector32();
      var _extents2 = /* @__PURE__ */ new Vector32();
      var _triangleNormal2 = /* @__PURE__ */ new Vector32();
      var _testAxis2 = /* @__PURE__ */ new Vector32();
      function satForAxes2(axes, v0, v1, v2, extents) {
        for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
          _testAxis2.fromArray(axes, i2);
          const r = extents.x * Math.abs(_testAxis2.x) + extents.y * Math.abs(_testAxis2.y) + extents.z * Math.abs(_testAxis2.z);
          const p0 = v0.dot(_testAxis2);
          const p1 = v1.dot(_testAxis2);
          const p2 = v2.dot(_testAxis2);
          if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
            return false;
          }
        }
        return true;
      }
      var _box$22 = /* @__PURE__ */ new Box32();
      var _v1$62 = /* @__PURE__ */ new Vector32();
      var _toFarthestPoint2 = /* @__PURE__ */ new Vector32();
      var _toPoint2 = /* @__PURE__ */ new Vector32();
      var Sphere2 = class {
        constructor(center = new Vector32(), radius = -1) {
          this.center = center;
          this.radius = radius;
        }
        set(center, radius) {
          this.center.copy(center);
          this.radius = radius;
          return this;
        }
        setFromPoints(points, optionalCenter) {
          const center = this.center;
          if (optionalCenter !== void 0) {
            center.copy(optionalCenter);
          } else {
            _box$22.setFromPoints(points).getCenter(center);
          }
          let maxRadiusSq = 0;
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        }
        copy(sphere) {
          this.center.copy(sphere.center);
          this.radius = sphere.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(point) {
          return point.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(point) {
          return point.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(sphere) {
          const radiusSum = this.radius + sphere.radius;
          return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        }
        intersectsBox(box) {
          return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
          const deltaLengthSq = this.center.distanceToSquared(point);
          target.copy(point);
          if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
          }
          return target;
        }
        getBoundingBox(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
            return target;
          }
          target.set(this.center, this.center);
          target.expandByScalar(this.radius);
          return target;
        }
        applyMatrix4(matrix) {
          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();
          return this;
        }
        translate(offset) {
          this.center.add(offset);
          return this;
        }
        expandByPoint(point) {
          _toPoint2.subVectors(point, this.center);
          const lengthSq = _toPoint2.lengthSq();
          if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            this.center.add(_toPoint2.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
          }
          return this;
        }
        union(sphere) {
          if (this.center.equals(sphere.center) === true) {
            _toFarthestPoint2.set(0, 0, 1).multiplyScalar(sphere.radius);
          } else {
            _toFarthestPoint2.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
          }
          this.expandByPoint(_v1$62.copy(sphere.center).add(_toFarthestPoint2));
          this.expandByPoint(_v1$62.copy(sphere.center).sub(_toFarthestPoint2));
          return this;
        }
        equals(sphere) {
          return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var _vector$a2 = /* @__PURE__ */ new Vector32();
      var _segCenter2 = /* @__PURE__ */ new Vector32();
      var _segDir2 = /* @__PURE__ */ new Vector32();
      var _diff2 = /* @__PURE__ */ new Vector32();
      var _edge12 = /* @__PURE__ */ new Vector32();
      var _edge22 = /* @__PURE__ */ new Vector32();
      var _normal$12 = /* @__PURE__ */ new Vector32();
      var Ray2 = class {
        constructor(origin = new Vector32(), direction = new Vector32(0, 0, -1)) {
          this.origin = origin;
          this.direction = direction;
        }
        set(origin, direction) {
          this.origin.copy(origin);
          this.direction.copy(direction);
          return this;
        }
        copy(ray) {
          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);
          return this;
        }
        at(t, target) {
          return target.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(v) {
          this.direction.copy(v).sub(this.origin).normalize();
          return this;
        }
        recast(t) {
          this.origin.copy(this.at(t, _vector$a2));
          return this;
        }
        closestPointToPoint(point, target) {
          target.subVectors(point, this.origin);
          const directionDistance = target.dot(this.direction);
          if (directionDistance < 0) {
            return target.copy(this.origin);
          }
          return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        }
        distanceToPoint(point) {
          return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
          const directionDistance = _vector$a2.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          _vector$a2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return _vector$a2.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          _segCenter2.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir2.copy(v1).sub(v0).normalize();
          _diff2.copy(this.origin).sub(_segCenter2);
          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir2);
          const b0 = _diff2.dot(this.direction);
          const b1 = -_diff2.dot(_segDir2);
          const c = _diff2.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  const invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segDir2).multiplyScalar(s1).add(_segCenter2);
          }
          return sqrDist;
        }
        intersectSphere(sphere, target) {
          _vector$a2.subVectors(sphere.center, this.origin);
          const tca = _vector$a2.dot(this.direction);
          const d2 = _vector$a2.dot(_vector$a2) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          const thc = Math.sqrt(radius2 - d2);
          const t0 = tca - thc;
          const t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, target);
          return this.at(t0, target);
        }
        intersectsSphere(sphere) {
          return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        }
        distanceToPlane(plane) {
          const denominator = plane.normal.dot(this.direction);
          if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
              return 0;
            }
            return null;
          }
          const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
          return t >= 0 ? t : null;
        }
        intersectPlane(plane, target) {
          const t = this.distanceToPlane(plane);
          if (t === null) {
            return null;
          }
          return this.at(t, target);
        }
        intersectsPlane(plane) {
          const distToPoint = plane.distanceToPoint(this.origin);
          if (distToPoint === 0) {
            return true;
          }
          const denominator = plane.normal.dot(this.direction);
          if (denominator * distToPoint < 0) {
            return true;
          }
          return false;
        }
        intersectBox(box, target) {
          let tmin, tmax, tymin, tymax, tzmin, tzmax;
          const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
          const origin = this.origin;
          if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
          } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
          }
          if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
          } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
          }
          if (tmin > tymax || tymin > tmax)
            return null;
          if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
          if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
          if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
          } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
          }
          if (tmin > tzmax || tzmin > tmax)
            return null;
          if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
          if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
          if (tmax < 0)
            return null;
          return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
          return this.intersectBox(box, _vector$a2) !== null;
        }
        intersectTriangle(a, b, c, backfaceCulling, target) {
          _edge12.subVectors(b, a);
          _edge22.subVectors(c, a);
          _normal$12.crossVectors(_edge12, _edge22);
          let DdN = this.direction.dot(_normal$12);
          let sign3;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign3 = 1;
          } else if (DdN < 0) {
            sign3 = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          _diff2.subVectors(this.origin, a);
          const DdQxE2 = sign3 * this.direction.dot(_edge22.crossVectors(_diff2, _edge22));
          if (DdQxE2 < 0) {
            return null;
          }
          const DdE1xQ = sign3 * this.direction.dot(_edge12.cross(_diff2));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          const QdN = -sign3 * _diff2.dot(_normal$12);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);
          return this;
        }
        equals(ray) {
          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var Matrix42 = class {
        constructor() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          if (arguments.length > 0) {
            console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
          }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          const te = this.elements;
          te[0] = n11;
          te[4] = n12;
          te[8] = n13;
          te[12] = n14;
          te[1] = n21;
          te[5] = n22;
          te[9] = n23;
          te[13] = n24;
          te[2] = n31;
          te[6] = n32;
          te[10] = n33;
          te[14] = n34;
          te[3] = n41;
          te[7] = n42;
          te[11] = n43;
          te[15] = n44;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        clone() {
          return new Matrix42().fromArray(this.elements);
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          te[9] = me[9];
          te[10] = me[10];
          te[11] = me[11];
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          te[15] = me[15];
          return this;
        }
        copyPosition(m) {
          const te = this.elements, me = m.elements;
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          return this;
        }
        setFromMatrix3(m) {
          const me = m.elements;
          this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
          this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
          return this;
        }
        extractRotation(m) {
          const te = this.elements;
          const me = m.elements;
          const scaleX = 1 / _v1$52.setFromMatrixColumn(m, 0).length();
          const scaleY = 1 / _v1$52.setFromMatrixColumn(m, 1).length();
          const scaleZ = 1 / _v1$52.setFromMatrixColumn(m, 2).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[3] = 0;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[7] = 0;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromEuler(euler) {
          if (!(euler && euler.isEuler)) {
            console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          }
          const te = this.elements;
          const x = euler.x, y = euler.y, z = euler.z;
          const a = Math.cos(x), b = Math.sin(x);
          const c = Math.cos(y), d = Math.sin(y);
          const e = Math.cos(z), f = Math.sin(z);
          if (euler.order === "XYZ") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
          } else if (euler.order === "YXZ") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
          } else if (euler.order === "ZXY") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
          } else if (euler.order === "ZYX") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
          } else if (euler.order === "YZX") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
          } else if (euler.order === "XZY") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
          }
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(q) {
          return this.compose(_zero2, q, _one2);
        }
        lookAt(eye, target, up) {
          const te = this.elements;
          _z2.subVectors(eye, target);
          if (_z2.lengthSq() === 0) {
            _z2.z = 1;
          }
          _z2.normalize();
          _x2.crossVectors(up, _z2);
          if (_x2.lengthSq() === 0) {
            if (Math.abs(up.z) === 1) {
              _z2.x += 1e-4;
            } else {
              _z2.z += 1e-4;
            }
            _z2.normalize();
            _x2.crossVectors(up, _z2);
          }
          _x2.normalize();
          _y2.crossVectors(_z2, _x2);
          te[0] = _x2.x;
          te[4] = _y2.x;
          te[8] = _z2.x;
          te[1] = _x2.y;
          te[5] = _y2.y;
          te[9] = _z2.y;
          te[2] = _x2.z;
          te[6] = _y2.z;
          te[10] = _z2.z;
          return this;
        }
        multiply(m, n) {
          if (n !== void 0) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m, n);
          }
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
          const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
          const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
          const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
          const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
          const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
          const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
          const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
          te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
          return this;
        }
        multiplyScalar(s) {
          const te = this.elements;
          te[0] *= s;
          te[4] *= s;
          te[8] *= s;
          te[12] *= s;
          te[1] *= s;
          te[5] *= s;
          te[9] *= s;
          te[13] *= s;
          te[2] *= s;
          te[6] *= s;
          te[10] *= s;
          te[14] *= s;
          te[3] *= s;
          te[7] *= s;
          te[11] *= s;
          te[15] *= s;
          return this;
        }
        determinant() {
          const te = this.elements;
          const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
          const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
          const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
          const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
          return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        }
        transpose() {
          const te = this.elements;
          let tmp4;
          tmp4 = te[1];
          te[1] = te[4];
          te[4] = tmp4;
          tmp4 = te[2];
          te[2] = te[8];
          te[8] = tmp4;
          tmp4 = te[6];
          te[6] = te[9];
          te[9] = tmp4;
          tmp4 = te[3];
          te[3] = te[12];
          te[12] = tmp4;
          tmp4 = te[7];
          te[7] = te[13];
          te[13] = tmp4;
          tmp4 = te[11];
          te[11] = te[14];
          te[14] = tmp4;
          return this;
        }
        setPosition(x, y, z) {
          const te = this.elements;
          if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
          } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
          }
          return this;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
          te[4] = t12 * detInv;
          te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
          te[8] = t13 * detInv;
          te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
          te[12] = t14 * detInv;
          te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
          return this;
        }
        scale(v) {
          const te = this.elements;
          const x = v.x, y = v.y, z = v.z;
          te[0] *= x;
          te[4] *= y;
          te[8] *= z;
          te[1] *= x;
          te[5] *= y;
          te[9] *= z;
          te[2] *= x;
          te[6] *= y;
          te[10] *= z;
          te[3] *= x;
          te[7] *= y;
          te[11] *= z;
          return this;
        }
        getMaxScaleOnAxis() {
          const te = this.elements;
          const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
          const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
          const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x, y, z) {
          this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
          return this;
        }
        makeRotationX(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationY(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationZ(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationAxis(axis, angle) {
          const c = Math.cos(angle);
          const s = Math.sin(angle);
          const t = 1 - c;
          const x = axis.x, y = axis.y, z = axis.z;
          const tx = t * x, ty = t * y;
          this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
          return this;
        }
        makeScale(x, y, z) {
          this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
          return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
          this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
          return this;
        }
        compose(position, quaternion, scale) {
          const te = this.elements;
          const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
          const x2 = x + x, y2 = y + y, z2 = z + z;
          const xx = x * x2, xy = x * y2, xz = x * z2;
          const yy = y * y2, yz = y * z2, zz = z * z2;
          const wx = w * x2, wy = w * y2, wz = w * z2;
          const sx = scale.x, sy = scale.y, sz = scale.z;
          te[0] = (1 - (yy + zz)) * sx;
          te[1] = (xy + wz) * sx;
          te[2] = (xz - wy) * sx;
          te[3] = 0;
          te[4] = (xy - wz) * sy;
          te[5] = (1 - (xx + zz)) * sy;
          te[6] = (yz + wx) * sy;
          te[7] = 0;
          te[8] = (xz + wy) * sz;
          te[9] = (yz - wx) * sz;
          te[10] = (1 - (xx + yy)) * sz;
          te[11] = 0;
          te[12] = position.x;
          te[13] = position.y;
          te[14] = position.z;
          te[15] = 1;
          return this;
        }
        decompose(position, quaternion, scale) {
          const te = this.elements;
          let sx = _v1$52.set(te[0], te[1], te[2]).length();
          const sy = _v1$52.set(te[4], te[5], te[6]).length();
          const sz = _v1$52.set(te[8], te[9], te[10]).length();
          const det = this.determinant();
          if (det < 0)
            sx = -sx;
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          _m1$22.copy(this);
          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;
          _m1$22.elements[0] *= invSX;
          _m1$22.elements[1] *= invSX;
          _m1$22.elements[2] *= invSX;
          _m1$22.elements[4] *= invSY;
          _m1$22.elements[5] *= invSY;
          _m1$22.elements[6] *= invSY;
          _m1$22.elements[8] *= invSZ;
          _m1$22.elements[9] *= invSZ;
          _m1$22.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(_m1$22);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        }
        makePerspective(left, right, top, bottom, near, far) {
          if (far === void 0) {
            console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          }
          const te = this.elements;
          const x = 2 * near / (right - left);
          const y = 2 * near / (top - bottom);
          const a = (right + left) / (right - left);
          const b = (top + bottom) / (top - bottom);
          const c = -(far + near) / (far - near);
          const d = -2 * far * near / (far - near);
          te[0] = x;
          te[4] = 0;
          te[8] = a;
          te[12] = 0;
          te[1] = 0;
          te[5] = y;
          te[9] = b;
          te[13] = 0;
          te[2] = 0;
          te[6] = 0;
          te[10] = c;
          te[14] = d;
          te[3] = 0;
          te[7] = 0;
          te[11] = -1;
          te[15] = 0;
          return this;
        }
        makeOrthographic(left, right, top, bottom, near, far) {
          const te = this.elements;
          const w = 1 / (right - left);
          const h = 1 / (top - bottom);
          const p2 = 1 / (far - near);
          const x = (right + left) * w;
          const y = (top + bottom) * h;
          const z = (far + near) * p2;
          te[0] = 2 * w;
          te[4] = 0;
          te[8] = 0;
          te[12] = -x;
          te[1] = 0;
          te[5] = 2 * h;
          te[9] = 0;
          te[13] = -y;
          te[2] = 0;
          te[6] = 0;
          te[10] = -2 * p2;
          te[14] = -z;
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[15] = 1;
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i2 = 0; i2 < 16; i2++) {
            if (te[i2] !== me[i2])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i2 = 0; i2 < 16; i2++) {
            this.elements[i2] = array[i2 + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          array[offset + 9] = te[9];
          array[offset + 10] = te[10];
          array[offset + 11] = te[11];
          array[offset + 12] = te[12];
          array[offset + 13] = te[13];
          array[offset + 14] = te[14];
          array[offset + 15] = te[15];
          return array;
        }
      };
      Matrix42.prototype.isMatrix4 = true;
      var _v1$52 = /* @__PURE__ */ new Vector32();
      var _m1$22 = /* @__PURE__ */ new Matrix42();
      var _zero2 = /* @__PURE__ */ new Vector32(0, 0, 0);
      var _one2 = /* @__PURE__ */ new Vector32(1, 1, 1);
      var _x2 = /* @__PURE__ */ new Vector32();
      var _y2 = /* @__PURE__ */ new Vector32();
      var _z2 = /* @__PURE__ */ new Vector32();
      var _matrix$12 = /* @__PURE__ */ new Matrix42();
      var _quaternion$32 = /* @__PURE__ */ new Quaternion2();
      var Euler2 = class {
        constructor(x = 0, y = 0, z = 0, order = Euler2.DefaultOrder) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(value) {
          this._order = value;
          this._onChangeCallback();
        }
        set(x, y, z, order = this._order) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m, order = this._order, update = true) {
          const te = m.elements;
          const m11 = te[0], m12 = te[4], m13 = te[8];
          const m21 = te[1], m22 = te[5], m23 = te[9];
          const m31 = te[2], m32 = te[6], m33 = te[10];
          switch (order) {
            case "XYZ":
              this._y = Math.asin(clamp4(m13, -1, 1));
              if (Math.abs(m13) < 0.9999999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
              } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-clamp4(m23, -1, 1));
              if (Math.abs(m23) < 0.9999999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
              } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(clamp4(m32, -1, 1));
              if (Math.abs(m32) < 0.9999999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
              } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-clamp4(m31, -1, 1));
              if (Math.abs(m31) < 0.9999999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
              } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
              }
              break;
            case "YZX":
              this._z = Math.asin(clamp4(m21, -1, 1));
              if (Math.abs(m21) < 0.9999999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
              } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
              }
              break;
            case "XZY":
              this._z = Math.asin(-clamp4(m12, -1, 1));
              if (Math.abs(m12) < 0.9999999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
              } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
          }
          this._order = order;
          if (update === true)
            this._onChangeCallback();
          return this;
        }
        setFromQuaternion(q, order, update) {
          _matrix$12.makeRotationFromQuaternion(q);
          return this.setFromRotationMatrix(_matrix$12, order, update);
        }
        setFromVector3(v, order = this._order) {
          return this.set(v.x, v.y, v.z, order);
        }
        reorder(newOrder) {
          _quaternion$32.setFromEuler(this);
          return this.setFromQuaternion(_quaternion$32, newOrder);
        }
        equals(euler) {
          return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        }
        fromArray(array) {
          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== void 0)
            this._order = array[3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;
          return array;
        }
        toVector3(optionalResult) {
          if (optionalResult) {
            return optionalResult.set(this._x, this._y, this._z);
          } else {
            return new Vector32(this._x, this._y, this._z);
          }
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
      };
      Euler2.prototype.isEuler = true;
      Euler2.DefaultOrder = "XYZ";
      Euler2.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      var Layers2 = class {
        constructor() {
          this.mask = 1 | 0;
        }
        set(channel) {
          this.mask = (1 << channel | 0) >>> 0;
        }
        enable(channel) {
          this.mask |= 1 << channel | 0;
        }
        enableAll() {
          this.mask = 4294967295 | 0;
        }
        toggle(channel) {
          this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
          this.mask &= ~(1 << channel | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(layers) {
          return (this.mask & layers.mask) !== 0;
        }
        isEnabled(channel) {
          return (this.mask & (1 << channel | 0)) !== 0;
        }
      };
      var _object3DId2 = 0;
      var _v1$42 = /* @__PURE__ */ new Vector32();
      var _q12 = /* @__PURE__ */ new Quaternion2();
      var _m1$12 = /* @__PURE__ */ new Matrix42();
      var _target2 = /* @__PURE__ */ new Vector32();
      var _position$32 = /* @__PURE__ */ new Vector32();
      var _scale$22 = /* @__PURE__ */ new Vector32();
      var _quaternion$22 = /* @__PURE__ */ new Quaternion2();
      var _xAxis2 = /* @__PURE__ */ new Vector32(1, 0, 0);
      var _yAxis2 = /* @__PURE__ */ new Vector32(0, 1, 0);
      var _zAxis2 = /* @__PURE__ */ new Vector32(0, 0, 1);
      var _addedEvent2 = {
        type: "added"
      };
      var _removedEvent2 = {
        type: "removed"
      };
      var Object3D2 = class extends EventDispatcher3 {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _object3DId2++
          });
          this.uuid = generateUUID2();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = Object3D2.DefaultUp.clone();
          const position = new Vector32();
          const rotation = new Euler2();
          const quaternion = new Quaternion2();
          const scale = new Vector32(1, 1, 1);
          function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
          }
          function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, false);
          }
          rotation._onChange(onRotationChange);
          quaternion._onChange(onQuaternionChange);
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: position
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: rotation
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: scale
            },
            modelViewMatrix: {
              value: new Matrix42()
            },
            normalMatrix: {
              value: new Matrix32()
            }
          });
          this.matrix = new Matrix42();
          this.matrixWorld = new Matrix42();
          this.matrixAutoUpdate = Object3D2.DefaultMatrixAutoUpdate;
          this.matrixWorldNeedsUpdate = false;
          this.layers = new Layers2();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(matrix) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          this.matrix.premultiply(matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q) {
          this.quaternion.premultiply(q);
          return this;
        }
        setRotationFromAxisAngle(axis, angle) {
          this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
          this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m) {
          this.quaternion.setFromRotationMatrix(m);
        }
        setRotationFromQuaternion(q) {
          this.quaternion.copy(q);
        }
        rotateOnAxis(axis, angle) {
          _q12.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(_q12);
          return this;
        }
        rotateOnWorldAxis(axis, angle) {
          _q12.setFromAxisAngle(axis, angle);
          this.quaternion.premultiply(_q12);
          return this;
        }
        rotateX(angle) {
          return this.rotateOnAxis(_xAxis2, angle);
        }
        rotateY(angle) {
          return this.rotateOnAxis(_yAxis2, angle);
        }
        rotateZ(angle) {
          return this.rotateOnAxis(_zAxis2, angle);
        }
        translateOnAxis(axis, distance) {
          _v1$42.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(_v1$42.multiplyScalar(distance));
          return this;
        }
        translateX(distance) {
          return this.translateOnAxis(_xAxis2, distance);
        }
        translateY(distance) {
          return this.translateOnAxis(_yAxis2, distance);
        }
        translateZ(distance) {
          return this.translateOnAxis(_zAxis2, distance);
        }
        localToWorld(vector) {
          return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
          return vector.applyMatrix4(_m1$12.copy(this.matrixWorld).invert());
        }
        lookAt(x, y, z) {
          if (x.isVector3) {
            _target2.copy(x);
          } else {
            _target2.set(x, y, z);
          }
          const parent = this.parent;
          this.updateWorldMatrix(true, false);
          _position$32.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            _m1$12.lookAt(_position$32, _target2, this.up);
          } else {
            _m1$12.lookAt(_target2, _position$32, this.up);
          }
          this.quaternion.setFromRotationMatrix(_m1$12);
          if (parent) {
            _m1$12.extractRotation(parent.matrixWorld);
            _q12.setFromRotationMatrix(_m1$12);
            this.quaternion.premultiply(_q12.invert());
          }
        }
        add(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.add(arguments[i2]);
            }
            return this;
          }
          if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
          }
          if (object && object.isObject3D) {
            if (object.parent !== null) {
              object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent2);
          } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
          }
          return this;
        }
        remove(object) {
          if (arguments.length > 1) {
            for (let i2 = 0; i2 < arguments.length; i2++) {
              this.remove(arguments[i2]);
            }
            return this;
          }
          const index = this.children.indexOf(object);
          if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent2);
          }
          return this;
        }
        removeFromParent() {
          const parent = this.parent;
          if (parent !== null) {
            parent.remove(this);
          }
          return this;
        }
        clear() {
          for (let i2 = 0; i2 < this.children.length; i2++) {
            const object = this.children[i2];
            object.parent = null;
            object.dispatchEvent(_removedEvent2);
          }
          this.children.length = 0;
          return this;
        }
        attach(object) {
          this.updateWorldMatrix(true, false);
          _m1$12.copy(this.matrixWorld).invert();
          if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$12.multiply(object.parent.matrixWorld);
          }
          object.applyMatrix4(_m1$12);
          this.add(object);
          object.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(id) {
          return this.getObjectByProperty("id", id);
        }
        getObjectByName(name) {
          return this.getObjectByProperty("name", name);
        }
        getObjectByProperty(name, value) {
          if (this[name] === value)
            return this;
          for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
            const child = this.children[i2];
            const object = child.getObjectByProperty(name, value);
            if (object !== void 0) {
              return object;
            }
          }
          return void 0;
        }
        getWorldPosition(target) {
          this.updateWorldMatrix(true, false);
          return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$32, target, _scale$22);
          return target;
        }
        getWorldScale(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$32, _quaternion$22, target);
          return target;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {
        }
        traverse(callback) {
          callback(this);
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].traverse(callback);
          }
        }
        traverseVisible(callback) {
          if (this.visible === false)
            return;
          callback(this);
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].traverseVisible(callback);
          }
        }
        traverseAncestors(callback) {
          const parent = this.parent;
          if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
          }
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].updateMatrixWorld(force);
          }
        }
        updateWorldMatrix(updateParents, updateChildren) {
          const parent = this.parent;
          if (updateParents === true && parent !== null) {
            parent.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (updateChildren === true) {
            const children = this.children;
            for (let i2 = 0, l = children.length; i2 < l; i2++) {
              children[i2].updateWorldMatrix(false, true);
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          const output = {};
          if (isRootObject) {
            meta = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {}
            };
            output.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const object = {};
          object.uuid = this.uuid;
          object.type = this.type;
          if (this.name !== "")
            object.name = this.name;
          if (this.castShadow === true)
            object.castShadow = true;
          if (this.receiveShadow === true)
            object.receiveShadow = true;
          if (this.visible === false)
            object.visible = false;
          if (this.frustumCulled === false)
            object.frustumCulled = false;
          if (this.renderOrder !== 0)
            object.renderOrder = this.renderOrder;
          if (JSON.stringify(this.userData) !== "{}")
            object.userData = this.userData;
          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();
          if (this.matrixAutoUpdate === false)
            object.matrixAutoUpdate = false;
          if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null)
              object.instanceColor = this.instanceColor.toJSON();
          }
          function serialize(library, element) {
            if (library[element.uuid] === void 0) {
              library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                object.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                object.background = this.background.toJSON(meta).uuid;
              }
            }
            if (this.environment && this.environment.isTexture) {
              object.environment = this.environment.toJSON(meta).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== void 0 && parameters.shapes !== void 0) {
              const shapes = parameters.shapes;
              if (Array.isArray(shapes)) {
                for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
                  const shape = shapes[i2];
                  serialize(meta.shapes, shape);
                }
              } else {
                serialize(meta.shapes, shapes);
              }
            }
          }
          if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== void 0) {
              serialize(meta.skeletons, this.skeleton);
              object.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== void 0) {
            if (Array.isArray(this.material)) {
              const uuids = [];
              for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
                uuids.push(serialize(meta.materials, this.material[i2]));
              }
              object.material = uuids;
            } else {
              object.material = serialize(meta.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            object.children = [];
            for (let i2 = 0; i2 < this.children.length; i2++) {
              object.children.push(this.children[i2].toJSON(meta).object);
            }
          }
          if (this.animations.length > 0) {
            object.animations = [];
            for (let i2 = 0; i2 < this.animations.length; i2++) {
              const animation = this.animations[i2];
              object.animations.push(serialize(meta.animations, animation));
            }
          }
          if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            if (geometries.length > 0)
              output.geometries = geometries;
            if (materials.length > 0)
              output.materials = materials;
            if (textures.length > 0)
              output.textures = textures;
            if (images.length > 0)
              output.images = images;
            if (shapes.length > 0)
              output.shapes = shapes;
            if (skeletons.length > 0)
              output.skeletons = skeletons;
            if (animations.length > 0)
              output.animations = animations;
          }
          output.object = object;
          return output;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data = cache[key];
              delete data.metadata;
              values.push(data);
            }
            return values;
          }
        }
        clone(recursive) {
          return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
          this.name = source.name;
          this.up.copy(source.up);
          this.position.copy(source.position);
          this.rotation.order = source.rotation.order;
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);
          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
          this.layers.mask = source.layers.mask;
          this.visible = source.visible;
          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;
          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          if (recursive === true) {
            for (let i2 = 0; i2 < source.children.length; i2++) {
              const child = source.children[i2];
              this.add(child.clone());
            }
          }
          return this;
        }
      };
      Object3D2.DefaultUp = new Vector32(0, 1, 0);
      Object3D2.DefaultMatrixAutoUpdate = true;
      Object3D2.prototype.isObject3D = true;
      var _v0$12 = /* @__PURE__ */ new Vector32();
      var _v1$32 = /* @__PURE__ */ new Vector32();
      var _v2$22 = /* @__PURE__ */ new Vector32();
      var _v3$12 = /* @__PURE__ */ new Vector32();
      var _vab2 = /* @__PURE__ */ new Vector32();
      var _vac2 = /* @__PURE__ */ new Vector32();
      var _vbc2 = /* @__PURE__ */ new Vector32();
      var _vap2 = /* @__PURE__ */ new Vector32();
      var _vbp2 = /* @__PURE__ */ new Vector32();
      var _vcp2 = /* @__PURE__ */ new Vector32();
      var Triangle2 = class {
        constructor(a = new Vector32(), b = new Vector32(), c = new Vector32()) {
          this.a = a;
          this.b = b;
          this.c = c;
        }
        static getNormal(a, b, c, target) {
          target.subVectors(c, b);
          _v0$12.subVectors(a, b);
          target.cross(_v0$12);
          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
          }
          return target.set(0, 0, 0);
        }
        static getBarycoord(point, a, b, c, target) {
          _v0$12.subVectors(c, a);
          _v1$32.subVectors(b, a);
          _v2$22.subVectors(point, a);
          const dot00 = _v0$12.dot(_v0$12);
          const dot01 = _v0$12.dot(_v1$32);
          const dot02 = _v0$12.dot(_v2$22);
          const dot11 = _v1$32.dot(_v1$32);
          const dot12 = _v1$32.dot(_v2$22);
          const denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          const invDenom = 1 / denom;
          const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        }
        static containsPoint(point, a, b, c) {
          this.getBarycoord(point, a, b, c, _v3$12);
          return _v3$12.x >= 0 && _v3$12.y >= 0 && _v3$12.x + _v3$12.y <= 1;
        }
        static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          this.getBarycoord(point, p1, p2, p3, _v3$12);
          target.set(0, 0);
          target.addScaledVector(uv1, _v3$12.x);
          target.addScaledVector(uv2, _v3$12.y);
          target.addScaledVector(uv3, _v3$12.z);
          return target;
        }
        static isFrontFacing(a, b, c, direction) {
          _v0$12.subVectors(c, b);
          _v1$32.subVectors(a, b);
          return _v0$12.cross(_v1$32).dot(direction) < 0 ? true : false;
        }
        set(a, b, c) {
          this.a.copy(a);
          this.b.copy(b);
          this.c.copy(c);
          return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i2]);
          return this;
        }
        setFromAttributeAndIndices(attribute, i0, i1, i2) {
          this.a.fromBufferAttribute(attribute, i0);
          this.b.fromBufferAttribute(attribute, i1);
          this.c.fromBufferAttribute(attribute, i2);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(triangle) {
          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);
          return this;
        }
        getArea() {
          _v0$12.subVectors(this.c, this.b);
          _v1$32.subVectors(this.a, this.b);
          return _v0$12.cross(_v1$32).length() * 0.5;
        }
        getMidpoint(target) {
          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
          return Triangle2.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
          return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
          return Triangle2.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getUV(point, uv1, uv2, uv3, target) {
          return Triangle2.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        }
        containsPoint(point) {
          return Triangle2.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
          return Triangle2.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
          return box.intersectsTriangle(this);
        }
        closestPointToPoint(p2, target) {
          const a = this.a, b = this.b, c = this.c;
          let v, w;
          _vab2.subVectors(b, a);
          _vac2.subVectors(c, a);
          _vap2.subVectors(p2, a);
          const d1 = _vab2.dot(_vap2);
          const d2 = _vac2.dot(_vap2);
          if (d1 <= 0 && d2 <= 0) {
            return target.copy(a);
          }
          _vbp2.subVectors(p2, b);
          const d3 = _vab2.dot(_vbp2);
          const d4 = _vac2.dot(_vbp2);
          if (d3 >= 0 && d4 <= d3) {
            return target.copy(b);
          }
          const vc = d1 * d4 - d3 * d2;
          if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            return target.copy(a).addScaledVector(_vab2, v);
          }
          _vcp2.subVectors(p2, c);
          const d5 = _vab2.dot(_vcp2);
          const d6 = _vac2.dot(_vcp2);
          if (d6 >= 0 && d5 <= d6) {
            return target.copy(c);
          }
          const vb = d5 * d2 - d1 * d6;
          if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            return target.copy(a).addScaledVector(_vac2, w);
          }
          const va = d3 * d6 - d5 * d4;
          if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc2.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b).addScaledVector(_vbc2, w);
          }
          const denom = 1 / (va + vb + vc);
          v = vb * denom;
          w = vc * denom;
          return target.copy(a).addScaledVector(_vab2, v).addScaledVector(_vac2, w);
        }
        equals(triangle) {
          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
      };
      var materialId2 = 0;
      var Material2 = class extends EventDispatcher3 {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: materialId2++
          });
          this.uuid = generateUUID2();
          this.name = "";
          this.type = "Material";
          this.fog = true;
          this.blending = NormalBlending2;
          this.side = FrontSide2;
          this.vertexColors = false;
          this.opacity = 1;
          this.transparent = false;
          this.blendSrc = SrcAlphaFactor2;
          this.blendDst = OneMinusSrcAlphaFactor2;
          this.blendEquation = AddEquation2;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.depthFunc = LessEqualDepth2;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = AlwaysStencilFunc2;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = KeepStencilOp2;
          this.stencilZFail = KeepStencilOp2;
          this.stencilZPass = KeepStencilOp2;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
          this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(value) {
          if (this._alphaTest > 0 !== value > 0) {
            this.version++;
          }
          this._alphaTest = value;
        }
        onBuild() {
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(values) {
          if (values === void 0)
            return;
          for (const key in values) {
            const newValue = values[key];
            if (newValue === void 0) {
              console.warn("THREE.Material: '" + key + "' parameter is undefined.");
              continue;
            }
            if (key === "shading") {
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
              this.flatShading = newValue === FlatShading2 ? true : false;
              continue;
            }
            const currentValue = this[key];
            if (currentValue === void 0) {
              console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
              continue;
            }
            if (currentValue && currentValue.isColor) {
              currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
              currentValue.copy(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
        toJSON(meta) {
          const isRoot = meta === void 0 || typeof meta === "string";
          if (isRoot) {
            meta = {
              textures: {},
              images: {}
            };
          }
          const data = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (this.color && this.color.isColor)
            data.color = this.color.getHex();
          if (this.roughness !== void 0)
            data.roughness = this.roughness;
          if (this.metalness !== void 0)
            data.metalness = this.metalness;
          if (this.sheen !== void 0)
            data.sheen = this.sheen;
          if (this.sheenColor && this.sheenColor.isColor)
            data.sheenColor = this.sheenColor.getHex();
          if (this.sheenRoughness !== void 0)
            data.sheenRoughness = this.sheenRoughness;
          if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1)
            data.emissiveIntensity = this.emissiveIntensity;
          if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
          if (this.specularIntensity !== void 0)
            data.specularIntensity = this.specularIntensity;
          if (this.specularColor && this.specularColor.isColor)
            data.specularColor = this.specularColor.getHex();
          if (this.shininess !== void 0)
            data.shininess = this.shininess;
          if (this.clearcoat !== void 0)
            data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== void 0)
            data.clearcoatRoughness = this.clearcoatRoughness;
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture)
            data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
          if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
          if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
            data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
          if (this.specularColorMap && this.specularColorMap.isTexture)
            data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
          if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== void 0)
              data.combine = this.combine;
          }
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
          if (this.reflectivity !== void 0)
            data.reflectivity = this.reflectivity;
          if (this.refractionRatio !== void 0)
            data.refractionRatio = this.refractionRatio;
          if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
          }
          if (this.transmission !== void 0)
            data.transmission = this.transmission;
          if (this.transmissionMap && this.transmissionMap.isTexture)
            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
          if (this.thickness !== void 0)
            data.thickness = this.thickness;
          if (this.thicknessMap && this.thicknessMap.isTexture)
            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
          if (this.attenuationDistance !== void 0)
            data.attenuationDistance = this.attenuationDistance;
          if (this.attenuationColor !== void 0)
            data.attenuationColor = this.attenuationColor.getHex();
          if (this.size !== void 0)
            data.size = this.size;
          if (this.shadowSide !== null)
            data.shadowSide = this.shadowSide;
          if (this.sizeAttenuation !== void 0)
            data.sizeAttenuation = this.sizeAttenuation;
          if (this.blending !== NormalBlending2)
            data.blending = this.blending;
          if (this.side !== FrontSide2)
            data.side = this.side;
          if (this.vertexColors)
            data.vertexColors = true;
          if (this.opacity < 1)
            data.opacity = this.opacity;
          if (this.transparent === true)
            data.transparent = this.transparent;
          data.depthFunc = this.depthFunc;
          data.depthTest = this.depthTest;
          data.depthWrite = this.depthWrite;
          data.colorWrite = this.colorWrite;
          data.stencilWrite = this.stencilWrite;
          data.stencilWriteMask = this.stencilWriteMask;
          data.stencilFunc = this.stencilFunc;
          data.stencilRef = this.stencilRef;
          data.stencilFuncMask = this.stencilFuncMask;
          data.stencilFail = this.stencilFail;
          data.stencilZFail = this.stencilZFail;
          data.stencilZPass = this.stencilZPass;
          if (this.rotation && this.rotation !== 0)
            data.rotation = this.rotation;
          if (this.polygonOffset === true)
            data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0)
            data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0)
            data.polygonOffsetUnits = this.polygonOffsetUnits;
          if (this.linewidth && this.linewidth !== 1)
            data.linewidth = this.linewidth;
          if (this.dashSize !== void 0)
            data.dashSize = this.dashSize;
          if (this.gapSize !== void 0)
            data.gapSize = this.gapSize;
          if (this.scale !== void 0)
            data.scale = this.scale;
          if (this.dithering === true)
            data.dithering = true;
          if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
          if (this.alphaToCoverage === true)
            data.alphaToCoverage = this.alphaToCoverage;
          if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
          if (this.wireframe === true)
            data.wireframe = this.wireframe;
          if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== "round")
            data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== "round")
            data.wireframeLinejoin = this.wireframeLinejoin;
          if (this.flatShading === true)
            data.flatShading = this.flatShading;
          if (this.visible === false)
            data.visible = false;
          if (this.toneMapped === false)
            data.toneMapped = false;
          if (JSON.stringify(this.userData) !== "{}")
            data.userData = this.userData;
          function extractFromCache(cache) {
            const values = [];
            for (const key in cache) {
              const data2 = cache[key];
              delete data2.metadata;
              values.push(data2);
            }
            return values;
          }
          if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0)
              data.textures = textures;
            if (images.length > 0)
              data.images = images;
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.fog = source.fog;
          this.blending = source.blending;
          this.side = source.side;
          this.vertexColors = source.vertexColors;
          this.opacity = source.opacity;
          this.transparent = source.transparent;
          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;
          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;
          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;
          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;
          if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for (let i2 = 0; i2 !== n; ++i2) {
              dstPlanes[i2] = srcPlanes[i2].clone();
            }
          }
          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;
          this.shadowSide = source.shadowSide;
          this.colorWrite = source.colorWrite;
          this.precision = source.precision;
          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;
          this.dithering = source.dithering;
          this.alphaTest = source.alphaTest;
          this.alphaToCoverage = source.alphaToCoverage;
          this.premultipliedAlpha = source.premultipliedAlpha;
          this.visible = source.visible;
          this.toneMapped = source.toneMapped;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      };
      Material2.prototype.isMaterial = true;
      var MeshBasicMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "MeshBasicMaterial";
          this.color = new Color2(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation2;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshBasicMaterial2.prototype.isMeshBasicMaterial = true;
      var _vector$92 = /* @__PURE__ */ new Vector32();
      var _vector2$12 = /* @__PURE__ */ new Vector22();
      var BufferAttribute2 = class {
        constructor(array, itemSize, normalized) {
          if (Array.isArray(array)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.name = "";
          this.array = array;
          this.itemSize = itemSize;
          this.count = array !== void 0 ? array.length / itemSize : 0;
          this.normalized = normalized === true;
          this.usage = StaticDrawUsage2;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.itemSize;
          index2 *= attribute.itemSize;
          for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        copyArray(array) {
          this.array.set(array);
          return this;
        }
        copyColorsArray(colors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = colors.length; i2 < l; i2++) {
            let color = colors[i2];
            if (color === void 0) {
              console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
              color = new Color2();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
          }
          return this;
        }
        copyVector2sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
              vector = new Vector22();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
          }
          return this;
        }
        copyVector3sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
              vector = new Vector32();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
          }
          return this;
        }
        copyVector4sArray(vectors) {
          const array = this.array;
          let offset = 0;
          for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
            let vector = vectors[i2];
            if (vector === void 0) {
              console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
              vector = new Vector42();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
          }
          return this;
        }
        applyMatrix3(m) {
          if (this.itemSize === 2) {
            for (let i2 = 0, l = this.count; i2 < l; i2++) {
              _vector2$12.fromBufferAttribute(this, i2);
              _vector2$12.applyMatrix3(m);
              this.setXY(i2, _vector2$12.x, _vector2$12.y);
            }
          } else if (this.itemSize === 3) {
            for (let i2 = 0, l = this.count; i2 < l; i2++) {
              _vector$92.fromBufferAttribute(this, i2);
              _vector$92.applyMatrix3(m);
              this.setXYZ(i2, _vector$92.x, _vector$92.y, _vector$92.z);
            }
          }
          return this;
        }
        applyMatrix4(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$92.x = this.getX(i2);
            _vector$92.y = this.getY(i2);
            _vector$92.z = this.getZ(i2);
            _vector$92.applyMatrix4(m);
            this.setXYZ(i2, _vector$92.x, _vector$92.y, _vector$92.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$92.x = this.getX(i2);
            _vector$92.y = this.getY(i2);
            _vector$92.z = this.getZ(i2);
            _vector$92.applyNormalMatrix(m);
            this.setXYZ(i2, _vector$92.x, _vector$92.y, _vector$92.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$92.x = this.getX(i2);
            _vector$92.y = this.getY(i2);
            _vector$92.z = this.getZ(i2);
            _vector$92.transformDirection(m);
            this.setXYZ(i2, _vector$92.x, _vector$92.y, _vector$92.z);
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        getX(index) {
          return this.array[index * this.itemSize];
        }
        setX(index, x) {
          this.array[index * this.itemSize] = x;
          return this;
        }
        getY(index) {
          return this.array[index * this.itemSize + 1];
        }
        setY(index, y) {
          this.array[index * this.itemSize + 1] = y;
          return this;
        }
        getZ(index) {
          return this.array[index * this.itemSize + 2];
        }
        setZ(index, z) {
          this.array[index * this.itemSize + 2] = z;
          return this;
        }
        getW(index) {
          return this.array[index * this.itemSize + 3];
        }
        setW(index, w) {
          this.array[index * this.itemSize + 3] = w;
          return this;
        }
        setXY(index, x, y) {
          index *= this.itemSize;
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x, y, z) {
          index *= this.itemSize;
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x, y, z, w) {
          index *= this.itemSize;
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          this.array[index + 3] = w;
          return this;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
          };
          if (this.name !== "")
            data.name = this.name;
          if (this.usage !== StaticDrawUsage2)
            data.usage = this.usage;
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
            data.updateRange = this.updateRange;
          return data;
        }
      };
      BufferAttribute2.prototype.isBufferAttribute = true;
      var Int8BufferAttribute = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Int8Array(array), itemSize, normalized);
        }
      };
      var Uint8BufferAttribute = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Uint8Array(array), itemSize, normalized);
        }
      };
      var Uint8ClampedBufferAttribute = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Uint8ClampedArray(array), itemSize, normalized);
        }
      };
      var Int16BufferAttribute = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Int16Array(array), itemSize, normalized);
        }
      };
      var Uint16BufferAttribute2 = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      var Int32BufferAttribute = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Int32Array(array), itemSize, normalized);
        }
      };
      var Uint32BufferAttribute2 = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Uint32Array(array), itemSize, normalized);
        }
      };
      var Float16BufferAttribute2 = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      Float16BufferAttribute2.prototype.isFloat16BufferAttribute = true;
      var Float32BufferAttribute2 = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Float32Array(array), itemSize, normalized);
        }
      };
      var Float64BufferAttribute = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized) {
          super(new Float64Array(array), itemSize, normalized);
        }
      };
      var _id$12 = 0;
      var _m12 = /* @__PURE__ */ new Matrix42();
      var _obj2 = /* @__PURE__ */ new Object3D2();
      var _offset2 = /* @__PURE__ */ new Vector32();
      var _box$12 = /* @__PURE__ */ new Box32();
      var _boxMorphTargets2 = /* @__PURE__ */ new Box32();
      var _vector$82 = /* @__PURE__ */ new Vector32();
      var BufferGeometry2 = class extends EventDispatcher3 {
        constructor() {
          super();
          Object.defineProperty(this, "id", {
            value: _id$12++
          });
          this.uuid = generateUUID2();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = {
            start: 0,
            count: Infinity
          };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(index) {
          if (Array.isArray(index)) {
            this.index = new (arrayNeedsUint322(index) ? Uint32BufferAttribute2 : Uint16BufferAttribute2)(index, 1);
          } else {
            this.index = index;
          }
          return this;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        setAttribute(name, attribute) {
          this.attributes[name] = attribute;
          return this;
        }
        deleteAttribute(name) {
          delete this.attributes[name];
          return this;
        }
        hasAttribute(name) {
          return this.attributes[name] !== void 0;
        }
        addGroup(start, count, materialIndex = 0) {
          this.groups.push({
            start,
            count,
            materialIndex
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(start, count) {
          this.drawRange.start = start;
          this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
          const position = this.attributes.position;
          if (position !== void 0) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
          }
          const normal = this.attributes.normal;
          if (normal !== void 0) {
            const normalMatrix = new Matrix32().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
          }
          const tangent = this.attributes.tangent;
          if (tangent !== void 0) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(q) {
          _m12.makeRotationFromQuaternion(q);
          this.applyMatrix4(_m12);
          return this;
        }
        rotateX(angle) {
          _m12.makeRotationX(angle);
          this.applyMatrix4(_m12);
          return this;
        }
        rotateY(angle) {
          _m12.makeRotationY(angle);
          this.applyMatrix4(_m12);
          return this;
        }
        rotateZ(angle) {
          _m12.makeRotationZ(angle);
          this.applyMatrix4(_m12);
          return this;
        }
        translate(x, y, z) {
          _m12.makeTranslation(x, y, z);
          this.applyMatrix4(_m12);
          return this;
        }
        scale(x, y, z) {
          _m12.makeScale(x, y, z);
          this.applyMatrix4(_m12);
          return this;
        }
        lookAt(vector) {
          _obj2.lookAt(vector);
          _obj2.updateMatrix();
          this.applyMatrix4(_obj2.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(_offset2).negate();
          this.translate(_offset2.x, _offset2.y, _offset2.z);
          return this;
        }
        setFromPoints(points) {
          const position = [];
          for (let i2 = 0, l = points.length; i2 < l; i2++) {
            const point = points[i2];
            position.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute("position", new Float32BufferAttribute2(position, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new Box32();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector32(-Infinity, -Infinity, -Infinity), new Vector32(Infinity, Infinity, Infinity));
            return;
          }
          if (position !== void 0) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _box$12.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$82.addVectors(this.boundingBox.min, _box$12.min);
                  this.boundingBox.expandByPoint(_vector$82);
                  _vector$82.addVectors(this.boundingBox.max, _box$12.max);
                  this.boundingBox.expandByPoint(_vector$82);
                } else {
                  this.boundingBox.expandByPoint(_box$12.min);
                  this.boundingBox.expandByPoint(_box$12.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere2();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector32(), Infinity);
            return;
          }
          if (position) {
            const center = this.boundingSphere.center;
            _box$12.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                _boxMorphTargets2.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$82.addVectors(_box$12.min, _boxMorphTargets2.min);
                  _box$12.expandByPoint(_vector$82);
                  _vector$82.addVectors(_box$12.max, _boxMorphTargets2.max);
                  _box$12.expandByPoint(_vector$82);
                } else {
                  _box$12.expandByPoint(_boxMorphTargets2.min);
                  _box$12.expandByPoint(_boxMorphTargets2.max);
                }
              }
            }
            _box$12.getCenter(center);
            let maxRadiusSq = 0;
            for (let i2 = 0, il = position.count; i2 < il; i2++) {
              _vector$82.fromBufferAttribute(position, i2);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$82));
            }
            if (morphAttributesPosition) {
              for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
                const morphAttribute = morphAttributesPosition[i2];
                const morphTargetsRelative = this.morphTargetsRelative;
                for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                  _vector$82.fromBufferAttribute(morphAttribute, j);
                  if (morphTargetsRelative) {
                    _offset2.fromBufferAttribute(position, j);
                    _vector$82.add(_offset2);
                  }
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$82));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        }
        computeTangents() {
          const index = this.index;
          const attributes = this.attributes;
          if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const indices = index.array;
          const positions = attributes.position.array;
          const normals = attributes.normal.array;
          const uvs = attributes.uv.array;
          const nVertices = positions.length / 3;
          if (attributes.tangent === void 0) {
            this.setAttribute("tangent", new BufferAttribute2(new Float32Array(4 * nVertices), 4));
          }
          const tangents = attributes.tangent.array;
          const tan1 = [], tan2 = [];
          for (let i2 = 0; i2 < nVertices; i2++) {
            tan1[i2] = new Vector32();
            tan2[i2] = new Vector32();
          }
          const vA = new Vector32(), vB = new Vector32(), vC = new Vector32(), uvA = new Vector22(), uvB = new Vector22(), uvC = new Vector22(), sdir = new Vector32(), tdir = new Vector32();
          function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            if (!isFinite(r))
              return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
          }
          let groups = this.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.length
            }];
          }
          for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
            }
          }
          const tmp4 = new Vector32(), tmp22 = new Vector32();
          const n = new Vector32(), n2 = new Vector32();
          function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            tmp4.copy(t);
            tmp4.sub(n.multiplyScalar(n.dot(t))).normalize();
            tmp22.crossVectors(n2, t);
            const test = tmp22.dot(tan2[v]);
            const w = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp4.x;
            tangents[v * 4 + 1] = tmp4.y;
            tangents[v * 4 + 2] = tmp4.z;
            tangents[v * 4 + 3] = w;
          }
          for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for (let j = start, jl = start + count; j < jl; j += 3) {
              handleVertex(indices[j + 0]);
              handleVertex(indices[j + 1]);
              handleVertex(indices[j + 2]);
            }
          }
        }
        computeVertexNormals() {
          const index = this.index;
          const positionAttribute = this.getAttribute("position");
          if (positionAttribute !== void 0) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === void 0) {
              normalAttribute = new BufferAttribute2(new Float32Array(positionAttribute.count * 3), 3);
              this.setAttribute("normal", normalAttribute);
            } else {
              for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
                normalAttribute.setXYZ(i2, 0, 0, 0);
              }
            }
            const pA = new Vector32(), pB = new Vector32(), pC = new Vector32();
            const nA = new Vector32(), nB = new Vector32(), nC = new Vector32();
            const cb = new Vector32(), ab = new Vector32();
            if (index) {
              for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
                const vA = index.getX(i2 + 0);
                const vB = index.getX(i2 + 1);
                const vC = index.getX(i2 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
              }
            } else {
              for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
                pA.fromBufferAttribute(positionAttribute, i2 + 0);
                pB.fromBufferAttribute(positionAttribute, i2 + 1);
                pC.fromBufferAttribute(positionAttribute, i2 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
              }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
          }
        }
        merge(geometry, offset) {
          if (!(geometry && geometry.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
          }
          if (offset === void 0) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            if (geometry.attributes[key] === void 0)
              continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for (let i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
              attributeArray1[j] = attributeArray2[i2];
            }
          }
          return this;
        }
        normalizeNormals() {
          const normals = this.attributes.normal;
          for (let i2 = 0, il = normals.count; i2 < il; i2++) {
            _vector$82.fromBufferAttribute(normals, i2);
            _vector$82.normalize();
            normals.setXYZ(i2, _vector$82.x, _vector$82.y, _vector$82.z);
          }
        }
        toNonIndexed() {
          function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index = 0, index2 = 0;
            for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
              if (attribute.isInterleavedBufferAttribute) {
                index = indices2[i2] * attribute.data.stride + attribute.offset;
              } else {
                index = indices2[i2] * itemSize;
              }
              for (let j = 0; j < itemSize; j++) {
                array2[index2++] = array[index++];
              }
            }
            return new BufferAttribute2(array2, itemSize, normalized);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const geometry2 = new BufferGeometry2();
          const indices = this.index.array;
          const attributes = this.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
          }
          const morphAttributes = this.morphAttributes;
          for (const name in morphAttributes) {
            const morphArray = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
              const attribute = morphAttribute[i2];
              const newAttribute = convertBufferAttribute(attribute, indices);
              morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
          }
          geometry2.morphTargetsRelative = this.morphTargetsRelative;
          const groups = this.groups;
          for (let i2 = 0, l = groups.length; i2 < l; i2++) {
            const group = groups[i2];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
          }
          return geometry2;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          if (this.parameters !== void 0) {
            const parameters = this.parameters;
            for (const key in parameters) {
              if (parameters[key] !== void 0)
                data[key] = parameters[key];
            }
            return data;
          }
          data.data = {
            attributes: {}
          };
          const index = this.index;
          if (index !== null) {
            data.data.index = {
              type: index.array.constructor.name,
              array: Array.prototype.slice.call(index.array)
            };
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
          }
          const morphAttributes = {};
          let hasMorphAttributes = false;
          for (const key in this.morphAttributes) {
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
              const attribute = attributeArray[i2];
              array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
              morphAttributes[key] = array;
              hasMorphAttributes = true;
            }
          }
          if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const groups = this.groups;
          if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
          }
          const boundingSphere = this.boundingSphere;
          if (boundingSphere !== null) {
            data.data.boundingSphere = {
              center: boundingSphere.center.toArray(),
              radius: boundingSphere.radius
            };
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const data = {};
          this.name = source.name;
          const index = source.index;
          if (index !== null) {
            this.setIndex(index.clone(data));
          }
          const attributes = source.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
          }
          const morphAttributes = source.morphAttributes;
          for (const name in morphAttributes) {
            const array = [];
            const morphAttribute = morphAttributes[name];
            for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
              array.push(morphAttribute[i2].clone(data));
            }
            this.morphAttributes[name] = array;
          }
          this.morphTargetsRelative = source.morphTargetsRelative;
          const groups = source.groups;
          for (let i2 = 0, l = groups.length; i2 < l; i2++) {
            const group = groups[i2];
            this.addGroup(group.start, group.count, group.materialIndex);
          }
          const boundingBox = source.boundingBox;
          if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
          }
          const boundingSphere = source.boundingSphere;
          if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
          }
          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;
          this.userData = source.userData;
          if (source.parameters !== void 0)
            this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      };
      BufferGeometry2.prototype.isBufferGeometry = true;
      var _inverseMatrix$22 = /* @__PURE__ */ new Matrix42();
      var _ray$22 = /* @__PURE__ */ new Ray2();
      var _sphere$32 = /* @__PURE__ */ new Sphere2();
      var _vA$12 = /* @__PURE__ */ new Vector32();
      var _vB$12 = /* @__PURE__ */ new Vector32();
      var _vC$12 = /* @__PURE__ */ new Vector32();
      var _tempA2 = /* @__PURE__ */ new Vector32();
      var _tempB2 = /* @__PURE__ */ new Vector32();
      var _tempC2 = /* @__PURE__ */ new Vector32();
      var _morphA2 = /* @__PURE__ */ new Vector32();
      var _morphB2 = /* @__PURE__ */ new Vector32();
      var _morphC2 = /* @__PURE__ */ new Vector32();
      var _uvA$12 = /* @__PURE__ */ new Vector22();
      var _uvB$12 = /* @__PURE__ */ new Vector22();
      var _uvC$12 = /* @__PURE__ */ new Vector22();
      var _intersectionPoint2 = /* @__PURE__ */ new Vector32();
      var _intersectionPointWorld2 = /* @__PURE__ */ new Vector32();
      var Mesh2 = class extends Object3D2 {
        constructor(geometry = new BufferGeometry2(), material = new MeshBasicMaterial2()) {
          super();
          this.type = "Mesh";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          if (source.morphTargetInfluences !== void 0) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
          }
          if (source.morphTargetDictionary !== void 0) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
          }
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
        raycast(raycaster, intersects3) {
          const geometry = this.geometry;
          const material = this.material;
          const matrixWorld = this.matrixWorld;
          if (material === void 0)
            return;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$32.copy(geometry.boundingSphere);
          _sphere$32.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$32) === false)
            return;
          _inverseMatrix$22.copy(matrixWorld).invert();
          _ray$22.copy(raycaster.ray).applyMatrix4(_inverseMatrix$22);
          if (geometry.boundingBox !== null) {
            if (_ray$22.intersectsBox(geometry.boundingBox) === false)
              return;
          }
          let intersection;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
              if (Array.isArray(material)) {
                for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = index.getX(j);
                    const b = index.getX(j + 1);
                    const c = index.getX(j + 2);
                    intersection = checkBufferGeometryIntersection2(this, groupMaterial, raycaster, _ray$22, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects3.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for (let i2 = start, il = end; i2 < il; i2 += 3) {
                  const a = index.getX(i2);
                  const b = index.getX(i2 + 1);
                  const c = index.getX(i2 + 2);
                  intersection = checkBufferGeometryIntersection2(this, material, raycaster, _ray$22, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects3.push(intersection);
                  }
                }
              }
            } else if (position !== void 0) {
              if (Array.isArray(material)) {
                for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                  const group = groups[i2];
                  const groupMaterial = material[group.materialIndex];
                  const start = Math.max(group.start, drawRange.start);
                  const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                  for (let j = start, jl = end; j < jl; j += 3) {
                    const a = j;
                    const b = j + 1;
                    const c = j + 2;
                    intersection = checkBufferGeometryIntersection2(this, groupMaterial, raycaster, _ray$22, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                      intersection.faceIndex = Math.floor(j / 3);
                      intersection.face.materialIndex = group.materialIndex;
                      intersects3.push(intersection);
                    }
                  }
                }
              } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(position.count, drawRange.start + drawRange.count);
                for (let i2 = start, il = end; i2 < il; i2 += 3) {
                  const a = i2;
                  const b = i2 + 1;
                  const c = i2 + 2;
                  intersection = checkBufferGeometryIntersection2(this, material, raycaster, _ray$22, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(i2 / 3);
                    intersects3.push(intersection);
                  }
                }
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      };
      Mesh2.prototype.isMesh = true;
      function checkIntersection2(object, material, raycaster, ray, pA, pB, pC, point) {
        let intersect;
        if (material.side === BackSide2) {
          intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        } else {
          intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide3, point);
        }
        if (intersect === null)
          return null;
        _intersectionPointWorld2.copy(point);
        _intersectionPointWorld2.applyMatrix4(object.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld2);
        if (distance < raycaster.near || distance > raycaster.far)
          return null;
        return {
          distance,
          point: _intersectionPointWorld2.clone(),
          object
        };
      }
      function checkBufferGeometryIntersection2(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
        _vA$12.fromBufferAttribute(position, a);
        _vB$12.fromBufferAttribute(position, b);
        _vC$12.fromBufferAttribute(position, c);
        const morphInfluences = object.morphTargetInfluences;
        if (morphPosition && morphInfluences) {
          _morphA2.set(0, 0, 0);
          _morphB2.set(0, 0, 0);
          _morphC2.set(0, 0, 0);
          for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
            const influence = morphInfluences[i2];
            const morphAttribute = morphPosition[i2];
            if (influence === 0)
              continue;
            _tempA2.fromBufferAttribute(morphAttribute, a);
            _tempB2.fromBufferAttribute(morphAttribute, b);
            _tempC2.fromBufferAttribute(morphAttribute, c);
            if (morphTargetsRelative) {
              _morphA2.addScaledVector(_tempA2, influence);
              _morphB2.addScaledVector(_tempB2, influence);
              _morphC2.addScaledVector(_tempC2, influence);
            } else {
              _morphA2.addScaledVector(_tempA2.sub(_vA$12), influence);
              _morphB2.addScaledVector(_tempB2.sub(_vB$12), influence);
              _morphC2.addScaledVector(_tempC2.sub(_vC$12), influence);
            }
          }
          _vA$12.add(_morphA2);
          _vB$12.add(_morphB2);
          _vC$12.add(_morphC2);
        }
        if (object.isSkinnedMesh) {
          object.boneTransform(a, _vA$12);
          object.boneTransform(b, _vB$12);
          object.boneTransform(c, _vC$12);
        }
        const intersection = checkIntersection2(object, material, raycaster, ray, _vA$12, _vB$12, _vC$12, _intersectionPoint2);
        if (intersection) {
          if (uv) {
            _uvA$12.fromBufferAttribute(uv, a);
            _uvB$12.fromBufferAttribute(uv, b);
            _uvC$12.fromBufferAttribute(uv, c);
            intersection.uv = Triangle2.getUV(_intersectionPoint2, _vA$12, _vB$12, _vC$12, _uvA$12, _uvB$12, _uvC$12, new Vector22());
          }
          if (uv2) {
            _uvA$12.fromBufferAttribute(uv2, a);
            _uvB$12.fromBufferAttribute(uv2, b);
            _uvC$12.fromBufferAttribute(uv2, c);
            intersection.uv2 = Triangle2.getUV(_intersectionPoint2, _vA$12, _vB$12, _vC$12, _uvA$12, _uvB$12, _uvC$12, new Vector22());
          }
          const face = {
            a,
            b,
            c,
            normal: new Vector32(),
            materialIndex: 0
          };
          Triangle2.getNormal(_vA$12, _vB$12, _vC$12, face.normal);
          intersection.face = face;
        }
        return intersection;
      }
      var BoxGeometry2 = class extends BufferGeometry2 {
        constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width,
            height,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          };
          const scope = this;
          widthSegments = Math.floor(widthSegments);
          heightSegments = Math.floor(heightSegments);
          depthSegments = Math.floor(depthSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let numberOfVertices = 0;
          let groupStart = 0;
          buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
          buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
          buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
          buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
          buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
          buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
            const segmentWidth = width2 / gridX;
            const segmentHeight = height2 / gridY;
            const widthHalf = width2 / 2;
            const heightHalf = height2 / 2;
            const depthHalf = depth2 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector32();
            for (let iy = 0; iy < gridY1; iy++) {
              const y = iy * segmentHeight - heightHalf;
              for (let ix = 0; ix < gridX1; ix++) {
                const x = ix * segmentWidth - widthHalf;
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                vertices.push(vector.x, vector.y, vector.z);
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth2 > 0 ? 1 : -1;
                normals.push(vector.x, vector.y, vector.z);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                vertexCounter += 1;
              }
            }
            for (let iy = 0; iy < gridY; iy++) {
              for (let ix = 0; ix < gridX; ix++) {
                const a = numberOfVertices + ix + gridX1 * iy;
                const b = numberOfVertices + ix + gridX1 * (iy + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
          }
        }
        static fromJSON(data) {
          return new BoxGeometry2(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
      };
      function cloneUniforms2(src) {
        const dst = {};
        for (const u in src) {
          dst[u] = {};
          for (const p2 in src[u]) {
            const property = src[u][p2];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
              dst[u][p2] = property.clone();
            } else if (Array.isArray(property)) {
              dst[u][p2] = property.slice();
            } else {
              dst[u][p2] = property;
            }
          }
        }
        return dst;
      }
      function mergeUniforms2(uniforms) {
        const merged = {};
        for (let u = 0; u < uniforms.length; u++) {
          const tmp4 = cloneUniforms2(uniforms[u]);
          for (const p2 in tmp4) {
            merged[p2] = tmp4[p2];
          }
        }
        return merged;
      }
      var UniformsUtils2 = {
        clone: cloneUniforms2,
        merge: mergeUniforms2
      };
      var default_vertex2 = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
      var default_fragment2 = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      var ShaderMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.vertexShader = default_vertex2;
          this.fragmentShader = default_fragment2;
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
          };
          this.defaultAttributeValues = {
            "color": [1, 1, 1],
            "uv": [0, 0],
            "uv2": [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (parameters !== void 0) {
            if (parameters.attributes !== void 0) {
              console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
            }
            this.setValues(parameters);
          }
        }
        copy(source) {
          super.copy(source);
          this.fragmentShader = source.fragmentShader;
          this.vertexShader = source.vertexShader;
          this.uniforms = cloneUniforms2(source.uniforms);
          this.defines = Object.assign({}, source.defines);
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.lights = source.lights;
          this.clipping = source.clipping;
          this.extensions = Object.assign({}, source.extensions);
          this.glslVersion = source.glslVersion;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.glslVersion = this.glslVersion;
          data.uniforms = {};
          for (const name in this.uniforms) {
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) {
              data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
              };
            } else if (value && value.isColor) {
              data.uniforms[name] = {
                type: "c",
                value: value.getHex()
              };
            } else if (value && value.isVector2) {
              data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
              };
            } else if (value && value.isVector3) {
              data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
              };
            } else if (value && value.isVector4) {
              data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
              };
            } else if (value && value.isMatrix3) {
              data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
              };
            } else if (value && value.isMatrix4) {
              data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
              };
            } else {
              data.uniforms[name] = {
                value
              };
            }
          }
          if (Object.keys(this.defines).length > 0)
            data.defines = this.defines;
          data.vertexShader = this.vertexShader;
          data.fragmentShader = this.fragmentShader;
          const extensions = {};
          for (const key in this.extensions) {
            if (this.extensions[key] === true)
              extensions[key] = true;
          }
          if (Object.keys(extensions).length > 0)
            data.extensions = extensions;
          return data;
        }
      };
      ShaderMaterial2.prototype.isShaderMaterial = true;
      var Camera2 = class extends Object3D2 {
        constructor() {
          super();
          this.type = "Camera";
          this.matrixWorldInverse = new Matrix42();
          this.projectionMatrix = new Matrix42();
          this.projectionMatrixInverse = new Matrix42();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.matrixWorldInverse.copy(source.matrixWorldInverse);
          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
          return this;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(-e[8], -e[9], -e[10]).normalize();
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
          super.updateWorldMatrix(updateParents, updateChildren);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Camera2.prototype.isCamera = true;
      var PerspectiveCamera2 = class extends Camera2 {
        constructor(fov3 = 50, aspect3 = 1, near = 0.1, far = 2e3) {
          super();
          this.type = "PerspectiveCamera";
          this.fov = fov3;
          this.zoom = 1;
          this.near = near;
          this.far = far;
          this.focus = 10;
          this.aspect = aspect3;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.fov = source.fov;
          this.zoom = source.zoom;
          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;
          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;
          return this;
        }
        setFocalLength(focalLength) {
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
          this.fov = RAD2DEG3 * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();
        }
        getFocalLength() {
          const vExtentSlope = Math.tan(DEG2RAD3 * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
          return RAD2DEG3 * 2 * Math.atan(Math.tan(DEG2RAD3 * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const near = this.near;
          let top = near * Math.tan(DEG2RAD3 * 0.5 * this.fov) / this.zoom;
          let height = 2 * top;
          let width = this.aspect * height;
          let left = -0.5 * width;
          const view = this.view;
          if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
          }
          const skew = this.filmOffset;
          if (skew !== 0)
            left += near * skew / this.getFilmWidth();
          this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.fov = this.fov;
          data.object.zoom = this.zoom;
          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;
          data.object.aspect = this.aspect;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;
          return data;
        }
      };
      PerspectiveCamera2.prototype.isPerspectiveCamera = true;
      var fov2 = 90;
      var aspect2 = 1;
      var CubeCamera2 = class extends Object3D2 {
        constructor(near, far, renderTarget) {
          super();
          this.type = "CubeCamera";
          if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return;
          }
          this.renderTarget = renderTarget;
          const cameraPX = new PerspectiveCamera2(fov2, aspect2, near, far);
          cameraPX.layers = this.layers;
          cameraPX.up.set(0, -1, 0);
          cameraPX.lookAt(new Vector32(1, 0, 0));
          this.add(cameraPX);
          const cameraNX = new PerspectiveCamera2(fov2, aspect2, near, far);
          cameraNX.layers = this.layers;
          cameraNX.up.set(0, -1, 0);
          cameraNX.lookAt(new Vector32(-1, 0, 0));
          this.add(cameraNX);
          const cameraPY = new PerspectiveCamera2(fov2, aspect2, near, far);
          cameraPY.layers = this.layers;
          cameraPY.up.set(0, 0, 1);
          cameraPY.lookAt(new Vector32(0, 1, 0));
          this.add(cameraPY);
          const cameraNY = new PerspectiveCamera2(fov2, aspect2, near, far);
          cameraNY.layers = this.layers;
          cameraNY.up.set(0, 0, -1);
          cameraNY.lookAt(new Vector32(0, -1, 0));
          this.add(cameraNY);
          const cameraPZ = new PerspectiveCamera2(fov2, aspect2, near, far);
          cameraPZ.layers = this.layers;
          cameraPZ.up.set(0, -1, 0);
          cameraPZ.lookAt(new Vector32(0, 0, 1));
          this.add(cameraPZ);
          const cameraNZ = new PerspectiveCamera2(fov2, aspect2, near, far);
          cameraNZ.layers = this.layers;
          cameraNZ.up.set(0, -1, 0);
          cameraNZ.lookAt(new Vector32(0, 0, -1));
          this.add(cameraNZ);
        }
        update(renderer, scene) {
          if (this.parent === null)
            this.updateMatrixWorld();
          const renderTarget = this.renderTarget;
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
          const currentXrEnabled = renderer.xr.enabled;
          const currentRenderTarget = renderer.getRenderTarget();
          renderer.xr.enabled = false;
          const generateMipmaps = renderTarget.texture.generateMipmaps;
          renderTarget.texture.generateMipmaps = false;
          renderer.setRenderTarget(renderTarget, 0);
          renderer.render(scene, cameraPX);
          renderer.setRenderTarget(renderTarget, 1);
          renderer.render(scene, cameraNX);
          renderer.setRenderTarget(renderTarget, 2);
          renderer.render(scene, cameraPY);
          renderer.setRenderTarget(renderTarget, 3);
          renderer.render(scene, cameraNY);
          renderer.setRenderTarget(renderTarget, 4);
          renderer.render(scene, cameraPZ);
          renderTarget.texture.generateMipmaps = generateMipmaps;
          renderer.setRenderTarget(renderTarget, 5);
          renderer.render(scene, cameraNZ);
          renderer.setRenderTarget(currentRenderTarget);
          renderer.xr.enabled = currentXrEnabled;
          renderTarget.texture.needsPMREMUpdate = true;
        }
      };
      var CubeTexture2 = class extends Texture2 {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
          images = images !== void 0 ? images : [];
          mapping = mapping !== void 0 ? mapping : CubeReflectionMapping2;
          super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(value) {
          this.image = value;
        }
      };
      CubeTexture2.prototype.isCubeTexture = true;
      var WebGLCubeRenderTarget2 = class extends WebGLRenderTarget3 {
        constructor(size, options, dummy) {
          if (Number.isInteger(options)) {
            console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
            options = dummy;
          }
          super(size, size, options);
          options = options || {};
          this.texture = new CubeTexture2(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter2;
        }
        fromEquirectangularTexture(renderer, texture) {
          this.texture.type = texture.type;
          this.texture.format = RGBAFormat2;
          this.texture.encoding = texture.encoding;
          this.texture.generateMipmaps = texture.generateMipmaps;
          this.texture.minFilter = texture.minFilter;
          this.texture.magFilter = texture.magFilter;
          const shader = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          };
          const geometry = new BoxGeometry2(5, 5, 5);
          const material = new ShaderMaterial2({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms2(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide2,
            blending: NoBlending2
          });
          material.uniforms.tEquirect.value = texture;
          const mesh = new Mesh2(geometry, material);
          const currentMinFilter = texture.minFilter;
          if (texture.minFilter === LinearMipmapLinearFilter2)
            texture.minFilter = LinearFilter2;
          const camera = new CubeCamera2(1, 10, this);
          camera.update(renderer, mesh);
          texture.minFilter = currentMinFilter;
          mesh.geometry.dispose();
          mesh.material.dispose();
          return this;
        }
        clear(renderer, color, depth, stencil) {
          const currentRenderTarget = renderer.getRenderTarget();
          for (let i2 = 0; i2 < 6; i2++) {
            renderer.setRenderTarget(this, i2);
            renderer.clear(color, depth, stencil);
          }
          renderer.setRenderTarget(currentRenderTarget);
        }
      };
      WebGLCubeRenderTarget2.prototype.isWebGLCubeRenderTarget = true;
      var _vector12 = /* @__PURE__ */ new Vector32();
      var _vector22 = /* @__PURE__ */ new Vector32();
      var _normalMatrix2 = /* @__PURE__ */ new Matrix32();
      var Plane2 = class {
        constructor(normal = new Vector32(1, 0, 0), constant = 0) {
          this.normal = normal;
          this.constant = constant;
        }
        set(normal, constant) {
          this.normal.copy(normal);
          this.constant = constant;
          return this;
        }
        setComponents(x, y, z, w) {
          this.normal.set(x, y, z);
          this.constant = w;
          return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(a, b, c) {
          const normal = _vector12.subVectors(c, b).cross(_vector22.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        }
        copy(plane) {
          this.normal.copy(plane.normal);
          this.constant = plane.constant;
          return this;
        }
        normalize() {
          const inverseNormalLength = 1 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(point) {
          return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
          return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
          return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        }
        intersectLine(line, target) {
          const direction = line.delta(_vector12);
          const denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return target.copy(line.start);
            }
            return null;
          }
          const t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return null;
          }
          return target.copy(direction).multiplyScalar(t).add(line.start);
        }
        intersectsLine(line) {
          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);
          return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        }
        intersectsBox(box) {
          return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
          return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
          return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
          const normalMatrix = optionalNormalMatrix || _normalMatrix2.getNormalMatrix(matrix);
          const referencePoint = this.coplanarPoint(_vector12).applyMatrix4(matrix);
          const normal = this.normal.applyMatrix3(normalMatrix).normalize();
          this.constant = -referencePoint.dot(normal);
          return this;
        }
        translate(offset) {
          this.constant -= offset.dot(this.normal);
          return this;
        }
        equals(plane) {
          return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Plane2.prototype.isPlane = true;
      var _sphere$22 = /* @__PURE__ */ new Sphere2();
      var _vector$72 = /* @__PURE__ */ new Vector32();
      var Frustum2 = class {
        constructor(p0 = new Plane2(), p1 = new Plane2(), p2 = new Plane2(), p3 = new Plane2(), p4 = new Plane2(), p5 = new Plane2()) {
          this.planes = [p0, p1, p2, p3, p4, p5];
        }
        set(p0, p1, p2, p3, p4, p5) {
          const planes = this.planes;
          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p2);
          planes[3].copy(p3);
          planes[4].copy(p4);
          planes[5].copy(p5);
          return this;
        }
        copy(frustum) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            planes[i2].copy(frustum.planes[i2]);
          }
          return this;
        }
        setFromProjectionMatrix(m) {
          const planes = this.planes;
          const me = m.elements;
          const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
          const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
          const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
          const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
          planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
          return this;
        }
        intersectsObject(object) {
          const geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$22.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(_sphere$22);
        }
        intersectsSprite(sprite) {
          _sphere$22.center.set(0, 0, 0);
          _sphere$22.radius = 0.7071067811865476;
          _sphere$22.applyMatrix4(sprite.matrixWorld);
          return this.intersectsSphere(_sphere$22);
        }
        intersectsSphere(sphere) {
          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;
          for (let i2 = 0; i2 < 6; i2++) {
            const distance = planes[i2].distanceToPoint(center);
            if (distance < negRadius) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(box) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            const plane = planes[i2];
            _vector$72.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$72.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$72.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$72) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(point) {
          const planes = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            if (planes[i2].distanceToPoint(point) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      function WebGLAnimation2() {
        let context = null;
        let isAnimating = false;
        let animationLoop = null;
        let requestId = null;
        function onAnimationFrame(time, frame) {
          animationLoop(time, frame);
          requestId = context.requestAnimationFrame(onAnimationFrame);
        }
        return {
          start: function() {
            if (isAnimating === true)
              return;
            if (animationLoop === null)
              return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
          },
          stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
          },
          setAnimationLoop: function(callback) {
            animationLoop = callback;
          },
          setContext: function(value) {
            context = value;
          }
        };
      }
      function WebGLAttributes2(gl, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        const buffers = /* @__PURE__ */ new WeakMap();
        function createBuffer(attribute, bufferType) {
          const array = attribute.array;
          const usage = attribute.usage;
          const buffer = gl.createBuffer();
          gl.bindBuffer(bufferType, buffer);
          gl.bufferData(bufferType, array, usage);
          attribute.onUploadCallback();
          let type = gl.FLOAT;
          if (array instanceof Float32Array) {
            type = gl.FLOAT;
          } else if (array instanceof Float64Array) {
            console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
          } else if (array instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
              if (isWebGL2) {
                type = gl.HALF_FLOAT;
              } else {
                console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
              }
            } else {
              type = gl.UNSIGNED_SHORT;
            }
          } else if (array instanceof Int16Array) {
            type = gl.SHORT;
          } else if (array instanceof Uint32Array) {
            type = gl.UNSIGNED_INT;
          } else if (array instanceof Int32Array) {
            type = gl.INT;
          } else if (array instanceof Int8Array) {
            type = gl.BYTE;
          } else if (array instanceof Uint8Array) {
            type = gl.UNSIGNED_BYTE;
          } else if (array instanceof Uint8ClampedArray) {
            type = gl.UNSIGNED_BYTE;
          }
          return {
            buffer,
            type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
          };
        }
        function updateBuffer(buffer, attribute, bufferType) {
          const array = attribute.array;
          const updateRange = attribute.updateRange;
          gl.bindBuffer(bufferType, buffer);
          if (updateRange.count === -1) {
            gl.bufferSubData(bufferType, 0, array);
          } else {
            if (isWebGL2) {
              gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            } else {
              gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            }
            updateRange.count = -1;
          }
        }
        function get(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          return buffers.get(attribute);
        }
        function remove(attribute) {
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
          }
        }
        function update(attribute, bufferType) {
          if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) {
              buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
              });
            }
            return;
          }
          if (attribute.isInterleavedBufferAttribute)
            attribute = attribute.data;
          const data = buffers.get(attribute);
          if (data === void 0) {
            buffers.set(attribute, createBuffer(attribute, bufferType));
          } else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
          }
        }
        return {
          get,
          remove,
          update
        };
      }
      var PlaneGeometry2 = class extends BufferGeometry2 {
        constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width,
            height,
            widthSegments,
            heightSegments
          };
          const width_half = width / 2;
          const height_half = height / 2;
          const gridX = Math.floor(widthSegments);
          const gridY = Math.floor(heightSegments);
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          const segment_width = width / gridX;
          const segment_height = height / gridY;
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy < gridY1; iy++) {
            const y = iy * segment_height - height_half;
            for (let ix = 0; ix < gridX1; ix++) {
              const x = ix * segment_width - width_half;
              vertices.push(x, -y, 0);
              normals.push(0, 0, 1);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = ix + gridX1 * iy;
              const b = ix + gridX1 * (iy + 1);
              const c = ix + 1 + gridX1 * (iy + 1);
              const d = ix + 1 + gridX1 * iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new PlaneGeometry2(data.width, data.height, data.widthSegments, data.heightSegments);
        }
      };
      var alphamap_fragment2 = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
      var alphamap_pars_fragment2 = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var alphatest_fragment2 = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
      var alphatest_pars_fragment2 = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
      var aomap_fragment2 = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
      var aomap_pars_fragment2 = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
      var begin_vertex2 = "vec3 transformed = vec3( position );";
      var beginnormal_vertex2 = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
      var bsdfs2 = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
      var bumpmap_pars_fragment2 = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
      var clipping_planes_fragment2 = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
      var clipping_planes_pars_fragment2 = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
      var clipping_planes_pars_vertex2 = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
      var clipping_planes_vertex2 = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
      var color_fragment2 = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
      var color_pars_fragment2 = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_pars_vertex2 = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
      var color_vertex2 = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
      var common2 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
      var cube_uv_reflection_fragment2 = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		return texture2D( envMap, uv ).rgb;\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
      var defaultnormal_vertex2 = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
      var displacementmap_pars_vertex2 = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
      var displacementmap_vertex2 = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
      var emissivemap_fragment2 = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
      var emissivemap_pars_fragment2 = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
      var encodings_fragment2 = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
      var encodings_pars_fragment2 = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
      var envmap_fragment2 = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
      var envmap_common_pars_fragment2 = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
      var envmap_pars_fragment2 = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
      var envmap_pars_vertex2 = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
      var envmap_vertex2 = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
      var fog_vertex2 = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
      var fog_pars_vertex2 = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
      var fog_fragment2 = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
      var fog_pars_fragment2 = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
      var gradientmap_pars_fragment2 = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
      var lightmap_fragment2 = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
      var lightmap_pars_fragment2 = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
      var lights_lambert_vertex2 = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
      var lights_pars_begin2 = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
      var envmap_physical_pars_fragment2 = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
      var lights_toon_fragment2 = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
      var lights_toon_pars_fragment2 = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
      var lights_phong_fragment2 = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
      var lights_phong_pars_fragment2 = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
      var lights_physical_fragment2 = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
      var lights_physical_pars_fragment2 = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(		0, 1,		0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
      var lights_fragment_begin2 = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
      var lights_fragment_maps2 = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
      var lights_fragment_end2 = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
      var logdepthbuf_fragment2 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
      var logdepthbuf_pars_fragment2 = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
      var logdepthbuf_pars_vertex2 = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
      var logdepthbuf_vertex2 = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
      var map_fragment2 = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
      var map_pars_fragment2 = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
      var map_particle_fragment2 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
      var map_particle_pars_fragment2 = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      var metalnessmap_fragment2 = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
      var metalnessmap_pars_fragment2 = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
      var morphnormal_vertex2 = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
      var morphtarget_pars_vertex2 = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
      var morphtarget_vertex2 = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
      var normal_fragment_begin2 = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
      var normal_fragment_maps2 = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
      var normal_pars_fragment2 = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      var normal_pars_vertex2 = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      var normal_vertex2 = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
      var normalmap_pars_fragment2 = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
      var clearcoat_normal_fragment_begin2 = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
      var clearcoat_normal_fragment_maps2 = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
      var clearcoat_pars_fragment2 = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
      var output_fragment2 = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
      var packing2 = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
      var premultiplied_alpha_fragment2 = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
      var project_vertex2 = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
      var dithering_fragment2 = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
      var dithering_pars_fragment2 = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
      var roughnessmap_fragment2 = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
      var roughnessmap_pars_fragment2 = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
      var shadowmap_pars_fragment2 = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n							f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n							f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
      var shadowmap_pars_vertex2 = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
      var shadowmap_vertex2 = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
      var shadowmask_pars_fragment2 = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
      var skinbase_vertex2 = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      var skinning_pars_vertex2 = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
      var skinning_vertex2 = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
      var skinnormal_vertex2 = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
      var specularmap_fragment2 = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
      var specularmap_pars_fragment2 = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
      var tonemapping_fragment2 = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
      var tonemapping_pars_fragment2 = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,	1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
      var transmission_fragment2 = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
      var transmission_pars_fragment2 = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
      var uv_pars_fragment2 = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
      var uv_pars_vertex2 = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
      var uv_vertex2 = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
      var uv2_pars_fragment2 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
      var uv2_pars_vertex2 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
      var uv2_vertex2 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
      var worldpos_vertex2 = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
      var vertex$g2 = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
      var fragment$g2 = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var vertex$f2 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      var fragment$f2 = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var vertex$e2 = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
      var fragment$e2 = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
      var vertex$d2 = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
      var fragment$d2 = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
      var vertex$c2 = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
      var fragment$c2 = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      var vertex$b2 = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      var fragment$b2 = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      var vertex$a2 = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$a2 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$92 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$92 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$82 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
      var fragment$82 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$72 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
      var fragment$72 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
      var vertex$62 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$62 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$52 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
      var fragment$52 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$42 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$42 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      var vertex$32 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
      var fragment$32 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      var vertex$22 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      var fragment$22 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      var vertex$12 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      var fragment$12 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      var ShaderChunk2 = {
        alphamap_fragment: alphamap_fragment2,
        alphamap_pars_fragment: alphamap_pars_fragment2,
        alphatest_fragment: alphatest_fragment2,
        alphatest_pars_fragment: alphatest_pars_fragment2,
        aomap_fragment: aomap_fragment2,
        aomap_pars_fragment: aomap_pars_fragment2,
        begin_vertex: begin_vertex2,
        beginnormal_vertex: beginnormal_vertex2,
        bsdfs: bsdfs2,
        bumpmap_pars_fragment: bumpmap_pars_fragment2,
        clipping_planes_fragment: clipping_planes_fragment2,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment2,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex2,
        clipping_planes_vertex: clipping_planes_vertex2,
        color_fragment: color_fragment2,
        color_pars_fragment: color_pars_fragment2,
        color_pars_vertex: color_pars_vertex2,
        color_vertex: color_vertex2,
        common: common2,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment2,
        defaultnormal_vertex: defaultnormal_vertex2,
        displacementmap_pars_vertex: displacementmap_pars_vertex2,
        displacementmap_vertex: displacementmap_vertex2,
        emissivemap_fragment: emissivemap_fragment2,
        emissivemap_pars_fragment: emissivemap_pars_fragment2,
        encodings_fragment: encodings_fragment2,
        encodings_pars_fragment: encodings_pars_fragment2,
        envmap_fragment: envmap_fragment2,
        envmap_common_pars_fragment: envmap_common_pars_fragment2,
        envmap_pars_fragment: envmap_pars_fragment2,
        envmap_pars_vertex: envmap_pars_vertex2,
        envmap_physical_pars_fragment: envmap_physical_pars_fragment2,
        envmap_vertex: envmap_vertex2,
        fog_vertex: fog_vertex2,
        fog_pars_vertex: fog_pars_vertex2,
        fog_fragment: fog_fragment2,
        fog_pars_fragment: fog_pars_fragment2,
        gradientmap_pars_fragment: gradientmap_pars_fragment2,
        lightmap_fragment: lightmap_fragment2,
        lightmap_pars_fragment: lightmap_pars_fragment2,
        lights_lambert_vertex: lights_lambert_vertex2,
        lights_pars_begin: lights_pars_begin2,
        lights_toon_fragment: lights_toon_fragment2,
        lights_toon_pars_fragment: lights_toon_pars_fragment2,
        lights_phong_fragment: lights_phong_fragment2,
        lights_phong_pars_fragment: lights_phong_pars_fragment2,
        lights_physical_fragment: lights_physical_fragment2,
        lights_physical_pars_fragment: lights_physical_pars_fragment2,
        lights_fragment_begin: lights_fragment_begin2,
        lights_fragment_maps: lights_fragment_maps2,
        lights_fragment_end: lights_fragment_end2,
        logdepthbuf_fragment: logdepthbuf_fragment2,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment2,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex2,
        logdepthbuf_vertex: logdepthbuf_vertex2,
        map_fragment: map_fragment2,
        map_pars_fragment: map_pars_fragment2,
        map_particle_fragment: map_particle_fragment2,
        map_particle_pars_fragment: map_particle_pars_fragment2,
        metalnessmap_fragment: metalnessmap_fragment2,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment2,
        morphnormal_vertex: morphnormal_vertex2,
        morphtarget_pars_vertex: morphtarget_pars_vertex2,
        morphtarget_vertex: morphtarget_vertex2,
        normal_fragment_begin: normal_fragment_begin2,
        normal_fragment_maps: normal_fragment_maps2,
        normal_pars_fragment: normal_pars_fragment2,
        normal_pars_vertex: normal_pars_vertex2,
        normal_vertex: normal_vertex2,
        normalmap_pars_fragment: normalmap_pars_fragment2,
        clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin2,
        clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps2,
        clearcoat_pars_fragment: clearcoat_pars_fragment2,
        output_fragment: output_fragment2,
        packing: packing2,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment2,
        project_vertex: project_vertex2,
        dithering_fragment: dithering_fragment2,
        dithering_pars_fragment: dithering_pars_fragment2,
        roughnessmap_fragment: roughnessmap_fragment2,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment2,
        shadowmap_pars_fragment: shadowmap_pars_fragment2,
        shadowmap_pars_vertex: shadowmap_pars_vertex2,
        shadowmap_vertex: shadowmap_vertex2,
        shadowmask_pars_fragment: shadowmask_pars_fragment2,
        skinbase_vertex: skinbase_vertex2,
        skinning_pars_vertex: skinning_pars_vertex2,
        skinning_vertex: skinning_vertex2,
        skinnormal_vertex: skinnormal_vertex2,
        specularmap_fragment: specularmap_fragment2,
        specularmap_pars_fragment: specularmap_pars_fragment2,
        tonemapping_fragment: tonemapping_fragment2,
        tonemapping_pars_fragment: tonemapping_pars_fragment2,
        transmission_fragment: transmission_fragment2,
        transmission_pars_fragment: transmission_pars_fragment2,
        uv_pars_fragment: uv_pars_fragment2,
        uv_pars_vertex: uv_pars_vertex2,
        uv_vertex: uv_vertex2,
        uv2_pars_fragment: uv2_pars_fragment2,
        uv2_pars_vertex: uv2_pars_vertex2,
        uv2_vertex: uv2_vertex2,
        worldpos_vertex: worldpos_vertex2,
        background_vert: vertex$g2,
        background_frag: fragment$g2,
        cube_vert: vertex$f2,
        cube_frag: fragment$f2,
        depth_vert: vertex$e2,
        depth_frag: fragment$e2,
        distanceRGBA_vert: vertex$d2,
        distanceRGBA_frag: fragment$d2,
        equirect_vert: vertex$c2,
        equirect_frag: fragment$c2,
        linedashed_vert: vertex$b2,
        linedashed_frag: fragment$b2,
        meshbasic_vert: vertex$a2,
        meshbasic_frag: fragment$a2,
        meshlambert_vert: vertex$92,
        meshlambert_frag: fragment$92,
        meshmatcap_vert: vertex$82,
        meshmatcap_frag: fragment$82,
        meshnormal_vert: vertex$72,
        meshnormal_frag: fragment$72,
        meshphong_vert: vertex$62,
        meshphong_frag: fragment$62,
        meshphysical_vert: vertex$52,
        meshphysical_frag: fragment$52,
        meshtoon_vert: vertex$42,
        meshtoon_frag: fragment$42,
        points_vert: vertex$32,
        points_frag: fragment$32,
        shadow_vert: vertex$22,
        shadow_frag: fragment$22,
        sprite_vert: vertex$12,
        sprite_frag: fragment$12
      };
      var UniformsLib2 = {
        common: {
          diffuse: {
            value: new Color2(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          uvTransform: {
            value: new Matrix32()
          },
          uv2Transform: {
            value: new Matrix32()
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalScale: {
            value: new Vector22(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new Color2(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotShadowMap: {
            value: []
          },
          spotShadowMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new Color2(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Matrix32()
          }
        },
        sprite: {
          diffuse: {
            value: new Color2(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new Vector22(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Matrix32()
          }
        }
      };
      var ShaderLib2 = {
        basic: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.specularmap, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.fog]),
          vertexShader: ShaderChunk2.meshbasic_vert,
          fragmentShader: ShaderChunk2.meshbasic_frag
        },
        lambert: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.specularmap, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.fog, UniformsLib2.lights, {
            emissive: {
              value: new Color2(0)
            }
          }]),
          vertexShader: ShaderChunk2.meshlambert_vert,
          fragmentShader: ShaderChunk2.meshlambert_frag
        },
        phong: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.specularmap, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.fog, UniformsLib2.lights, {
            emissive: {
              value: new Color2(0)
            },
            specular: {
              value: new Color2(1118481)
            },
            shininess: {
              value: 30
            }
          }]),
          vertexShader: ShaderChunk2.meshphong_vert,
          fragmentShader: ShaderChunk2.meshphong_frag
        },
        standard: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.envmap, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.roughnessmap, UniformsLib2.metalnessmap, UniformsLib2.fog, UniformsLib2.lights, {
            emissive: {
              value: new Color2(0)
            },
            roughness: {
              value: 1
            },
            metalness: {
              value: 0
            },
            envMapIntensity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk2.meshphysical_vert,
          fragmentShader: ShaderChunk2.meshphysical_frag
        },
        toon: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.aomap, UniformsLib2.lightmap, UniformsLib2.emissivemap, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.gradientmap, UniformsLib2.fog, UniformsLib2.lights, {
            emissive: {
              value: new Color2(0)
            }
          }]),
          vertexShader: ShaderChunk2.meshtoon_vert,
          fragmentShader: ShaderChunk2.meshtoon_frag
        },
        matcap: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, UniformsLib2.fog, {
            matcap: {
              value: null
            }
          }]),
          vertexShader: ShaderChunk2.meshmatcap_vert,
          fragmentShader: ShaderChunk2.meshmatcap_frag
        },
        points: {
          uniforms: mergeUniforms2([UniformsLib2.points, UniformsLib2.fog]),
          vertexShader: ShaderChunk2.points_vert,
          fragmentShader: ShaderChunk2.points_frag
        },
        dashed: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.fog, {
            scale: {
              value: 1
            },
            dashSize: {
              value: 1
            },
            totalSize: {
              value: 2
            }
          }]),
          vertexShader: ShaderChunk2.linedashed_vert,
          fragmentShader: ShaderChunk2.linedashed_frag
        },
        depth: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.displacementmap]),
          vertexShader: ShaderChunk2.depth_vert,
          fragmentShader: ShaderChunk2.depth_frag
        },
        normal: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.bumpmap, UniformsLib2.normalmap, UniformsLib2.displacementmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk2.meshnormal_vert,
          fragmentShader: ShaderChunk2.meshnormal_frag
        },
        sprite: {
          uniforms: mergeUniforms2([UniformsLib2.sprite, UniformsLib2.fog]),
          vertexShader: ShaderChunk2.sprite_vert,
          fragmentShader: ShaderChunk2.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Matrix32()
            },
            t2D: {
              value: null
            }
          },
          vertexShader: ShaderChunk2.background_vert,
          fragmentShader: ShaderChunk2.background_frag
        },
        cube: {
          uniforms: mergeUniforms2([UniformsLib2.envmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk2.cube_vert,
          fragmentShader: ShaderChunk2.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: ShaderChunk2.equirect_vert,
          fragmentShader: ShaderChunk2.equirect_frag
        },
        distanceRGBA: {
          uniforms: mergeUniforms2([UniformsLib2.common, UniformsLib2.displacementmap, {
            referencePosition: {
              value: new Vector32()
            },
            nearDistance: {
              value: 1
            },
            farDistance: {
              value: 1e3
            }
          }]),
          vertexShader: ShaderChunk2.distanceRGBA_vert,
          fragmentShader: ShaderChunk2.distanceRGBA_frag
        },
        shadow: {
          uniforms: mergeUniforms2([UniformsLib2.lights, UniformsLib2.fog, {
            color: {
              value: new Color2(0)
            },
            opacity: {
              value: 1
            }
          }]),
          vertexShader: ShaderChunk2.shadow_vert,
          fragmentShader: ShaderChunk2.shadow_frag
        }
      };
      ShaderLib2.physical = {
        uniforms: mergeUniforms2([ShaderLib2.standard.uniforms, {
          clearcoat: {
            value: 0
          },
          clearcoatMap: {
            value: null
          },
          clearcoatRoughness: {
            value: 0
          },
          clearcoatRoughnessMap: {
            value: null
          },
          clearcoatNormalScale: {
            value: new Vector22(1, 1)
          },
          clearcoatNormalMap: {
            value: null
          },
          sheen: {
            value: 0
          },
          sheenColor: {
            value: new Color2(0)
          },
          sheenColorMap: {
            value: null
          },
          sheenRoughness: {
            value: 1
          },
          sheenRoughnessMap: {
            value: null
          },
          transmission: {
            value: 0
          },
          transmissionMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new Vector22()
          },
          transmissionSamplerMap: {
            value: null
          },
          thickness: {
            value: 0
          },
          thicknessMap: {
            value: null
          },
          attenuationDistance: {
            value: 0
          },
          attenuationColor: {
            value: new Color2(0)
          },
          specularIntensity: {
            value: 1
          },
          specularIntensityMap: {
            value: null
          },
          specularColor: {
            value: new Color2(1, 1, 1)
          },
          specularColorMap: {
            value: null
          }
        }]),
        vertexShader: ShaderChunk2.meshphysical_vert,
        fragmentShader: ShaderChunk2.meshphysical_frag
      };
      function WebGLBackground2(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
        const clearColor = new Color2(0);
        let clearAlpha = alpha === true ? 0 : 1;
        let planeMesh;
        let boxMesh;
        let currentBackground = null;
        let currentBackgroundVersion = 0;
        let currentTonemapping = null;
        function render6(renderList, scene) {
          let forceClear = false;
          let background = scene.isScene === true ? scene.background : null;
          if (background && background.isTexture) {
            background = cubemaps.get(background);
          }
          const xr = renderer.xr;
          const session = xr.getSession && xr.getSession();
          if (session && session.environmentBlendMode === "additive") {
            background = null;
          }
          if (background === null) {
            setClear(clearColor, clearAlpha);
          } else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
          }
          if (renderer.autoClear || forceClear) {
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
          }
          if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping2)) {
            if (boxMesh === void 0) {
              boxMesh = new Mesh2(new BoxGeometry2(1, 1, 1), new ShaderMaterial2({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms2(ShaderLib2.cube.uniforms),
                vertexShader: ShaderLib2.cube.vertexShader,
                fragmentShader: ShaderLib2.cube.fragmentShader,
                side: BackSide2,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              boxMesh.geometry.deleteAttribute("normal");
              boxMesh.geometry.deleteAttribute("uv");
              boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
                this.matrixWorld.copyPosition(camera.matrixWorld);
              };
              Object.defineProperty(boxMesh.material, "envMap", {
                get: function() {
                  return this.uniforms.envMap.value;
                }
              });
              objects.update(boxMesh);
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              boxMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
          } else if (background && background.isTexture) {
            if (planeMesh === void 0) {
              planeMesh = new Mesh2(new PlaneGeometry2(2, 2), new ShaderMaterial2({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms2(ShaderLib2.background.uniforms),
                vertexShader: ShaderLib2.background.vertexShader,
                fragmentShader: ShaderLib2.background.fragmentShader,
                side: FrontSide2,
                depthTest: false,
                depthWrite: false,
                fog: false
              }));
              planeMesh.geometry.deleteAttribute("normal");
              Object.defineProperty(planeMesh.material, "map", {
                get: function() {
                  return this.uniforms.t2D.value;
                }
              });
              objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) {
              background.updateMatrix();
            }
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
              planeMesh.material.needsUpdate = true;
              currentBackground = background;
              currentBackgroundVersion = background.version;
              currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
          }
        }
        function setClear(color, alpha2) {
          state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
        }
        return {
          getClearColor: function() {
            return clearColor;
          },
          setClearColor: function(color, alpha2 = 1) {
            clearColor.set(color);
            clearAlpha = alpha2;
            setClear(clearColor, clearAlpha);
          },
          getClearAlpha: function() {
            return clearAlpha;
          },
          setClearAlpha: function(alpha2) {
            clearAlpha = alpha2;
            setClear(clearColor, clearAlpha);
          },
          render: render6
        };
      }
      function WebGLBindingStates2(gl, extensions, attributes, capabilities) {
        const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
        const vaoAvailable = capabilities.isWebGL2 || extension !== null;
        const bindingStates = {};
        const defaultState = createBindingState(null);
        let currentState = defaultState;
        function setup(object, material, program, geometry, index) {
          let updateBuffers = false;
          if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
              currentState = state;
              bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index);
            if (updateBuffers)
              saveCache(geometry, index);
          } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
              currentState.geometry = geometry.id;
              currentState.program = program.id;
              currentState.wireframe = wireframe;
              updateBuffers = true;
            }
          }
          if (object.isInstancedMesh === true) {
            updateBuffers = true;
          }
          if (index !== null) {
            attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
          }
          if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) {
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
            }
          }
        }
        function createVertexArrayObject() {
          if (capabilities.isWebGL2)
            return gl.createVertexArray();
          return extension.createVertexArrayOES();
        }
        function bindVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl.bindVertexArray(vao);
          return extension.bindVertexArrayOES(vao);
        }
        function deleteVertexArrayObject(vao) {
          if (capabilities.isWebGL2)
            return gl.deleteVertexArray(vao);
          return extension.deleteVertexArrayOES(vao);
        }
        function getBindingState(geometry, program, material) {
          const wireframe = material.wireframe === true;
          let programMap = bindingStates[geometry.id];
          if (programMap === void 0) {
            programMap = {};
            bindingStates[geometry.id] = programMap;
          }
          let stateMap = programMap[program.id];
          if (stateMap === void 0) {
            stateMap = {};
            programMap[program.id] = stateMap;
          }
          let state = stateMap[wireframe];
          if (state === void 0) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
          }
          return state;
        }
        function createBindingState(vao) {
          const newAttributes = [];
          const enabledAttributes = [];
          const attributeDivisors = [];
          for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
            newAttributes[i2] = 0;
            enabledAttributes[i2] = 0;
            attributeDivisors[i2] = 0;
          }
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes,
            enabledAttributes,
            attributeDivisors,
            object: vao,
            attributes: {},
            index: null
          };
        }
        function needsUpdate(geometry, index) {
          const cachedAttributes = currentState.attributes;
          const geometryAttributes = geometry.attributes;
          let attributesNum = 0;
          for (const key in geometryAttributes) {
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === void 0)
              return true;
            if (cachedAttribute.attribute !== geometryAttribute)
              return true;
            if (cachedAttribute.data !== geometryAttribute.data)
              return true;
            attributesNum++;
          }
          if (currentState.attributesNum !== attributesNum)
            return true;
          if (currentState.index !== index)
            return true;
          return false;
        }
        function saveCache(geometry, index) {
          const cache = {};
          const attributes2 = geometry.attributes;
          let attributesNum = 0;
          for (const key in attributes2) {
            const attribute = attributes2[key];
            const data = {};
            data.attribute = attribute;
            if (attribute.data) {
              data.data = attribute.data;
            }
            cache[key] = data;
            attributesNum++;
          }
          currentState.attributes = cache;
          currentState.attributesNum = attributesNum;
          currentState.index = index;
        }
        function initAttributes() {
          const newAttributes = currentState.newAttributes;
          for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
            newAttributes[i2] = 0;
          }
        }
        function enableAttribute(attribute) {
          enableAttributeAndDivisor(attribute, 0);
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          const attributeDivisors = currentState.attributeDivisors;
          newAttributes[attribute] = 1;
          if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
          }
          if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
            extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
          }
        }
        function disableUnusedAttributes() {
          const newAttributes = currentState.newAttributes;
          const enabledAttributes = currentState.enabledAttributes;
          for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
            if (enabledAttributes[i2] !== newAttributes[i2]) {
              gl.disableVertexAttribArray(i2);
              enabledAttributes[i2] = 0;
            }
          }
        }
        function vertexAttribPointer(index, size, type, normalized, stride, offset) {
          if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
            gl.vertexAttribIPointer(index, size, type, stride, offset);
          } else {
            gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
          }
        }
        function setupVertexAttributes(object, material, program, geometry) {
          if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get("ANGLE_instanced_arrays") === null)
              return;
          }
          initAttributes();
          const geometryAttributes = geometry.attributes;
          const programAttributes = program.getAttributes();
          const materialDefaultAttributeValues = material.defaultAttributeValues;
          for (const name in programAttributes) {
            const programAttribute = programAttributes[name];
            if (programAttribute.location >= 0) {
              let geometryAttribute = geometryAttributes[name];
              if (geometryAttribute === void 0) {
                if (name === "instanceMatrix" && object.instanceMatrix)
                  geometryAttribute = object.instanceMatrix;
                if (name === "instanceColor" && object.instanceColor)
                  geometryAttribute = object.instanceColor;
              }
              if (geometryAttribute !== void 0) {
                const normalized = geometryAttribute.normalized;
                const size = geometryAttribute.itemSize;
                const attribute = attributes.get(geometryAttribute);
                if (attribute === void 0)
                  continue;
                const buffer = attribute.buffer;
                const type = attribute.type;
                const bytesPerElement = attribute.bytesPerElement;
                if (geometryAttribute.isInterleavedBufferAttribute) {
                  const data = geometryAttribute.data;
                  const stride = data.stride;
                  const offset = geometryAttribute.offset;
                  if (data && data.isInstancedInterleavedBuffer) {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
                    }
                    if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                      geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                    }
                  } else {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttribute(programAttribute.location + i2);
                    }
                  }
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i2) * bytesPerElement);
                  }
                } else {
                  if (geometryAttribute.isInstancedBufferAttribute) {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
                    }
                    if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                      geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                    }
                  } else {
                    for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                      enableAttribute(programAttribute.location + i2);
                    }
                  }
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                    vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
                  }
                }
              } else if (materialDefaultAttributeValues !== void 0) {
                const value = materialDefaultAttributeValues[name];
                if (value !== void 0) {
                  switch (value.length) {
                    case 2:
                      gl.vertexAttrib2fv(programAttribute.location, value);
                      break;
                    case 3:
                      gl.vertexAttrib3fv(programAttribute.location, value);
                      break;
                    case 4:
                      gl.vertexAttrib4fv(programAttribute.location, value);
                      break;
                    default:
                      gl.vertexAttrib1fv(programAttribute.location, value);
                  }
                }
              }
            }
          }
          disableUnusedAttributes();
        }
        function dispose() {
          reset();
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            for (const programId in programMap) {
              const stateMap = programMap[programId];
              for (const wireframe in stateMap) {
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
              }
              delete programMap[programId];
            }
            delete bindingStates[geometryId];
          }
        }
        function releaseStatesOfGeometry(geometry) {
          if (bindingStates[geometry.id] === void 0)
            return;
          const programMap = bindingStates[geometry.id];
          for (const programId in programMap) {
            const stateMap = programMap[programId];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[programId];
          }
          delete bindingStates[geometry.id];
        }
        function releaseStatesOfProgram(program) {
          for (const geometryId in bindingStates) {
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === void 0)
              continue;
            const stateMap = programMap[program.id];
            for (const wireframe in stateMap) {
              deleteVertexArrayObject(stateMap[wireframe].object);
              delete stateMap[wireframe];
            }
            delete programMap[program.id];
          }
        }
        function reset() {
          resetDefaultState();
          if (currentState === defaultState)
            return;
          currentState = defaultState;
          bindVertexArrayObject(currentState.object);
        }
        function resetDefaultState() {
          defaultState.geometry = null;
          defaultState.program = null;
          defaultState.wireframe = false;
        }
        return {
          setup,
          reset,
          resetDefaultState,
          dispose,
          releaseStatesOfGeometry,
          releaseStatesOfProgram,
          initAttributes,
          enableAttribute,
          disableUnusedAttributes
        };
      }
      function WebGLBufferRenderer2(gl, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        function render6(start, count) {
          gl.drawArrays(mode, start, count);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl;
            methodName = "drawArraysInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawArraysInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, start, count, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.render = render6;
        this.renderInstances = renderInstances;
      }
      function WebGLCapabilities2(gl, extensions, parameters) {
        let maxAnisotropy;
        function getMaxAnisotropy() {
          if (maxAnisotropy !== void 0)
            return maxAnisotropy;
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else {
            maxAnisotropy = 0;
          }
          return maxAnisotropy;
        }
        function getMaxPrecision(precision2) {
          if (precision2 === "highp") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
              return "highp";
            }
            precision2 = "mediump";
          }
          if (precision2 === "mediump") {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
              return "mediump";
            }
          }
          return "lowp";
        }
        const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
        let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
        const maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
          console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
          precision = maxPrecision;
        }
        const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
        const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        const vertexTextures = maxVertexTextures > 0;
        const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
        const floatVertexTextures = vertexTextures && floatFragmentTextures;
        const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
        return {
          isWebGL2,
          drawBuffers,
          getMaxAnisotropy,
          getMaxPrecision,
          precision,
          logarithmicDepthBuffer,
          maxTextures,
          maxVertexTextures,
          maxTextureSize,
          maxCubemapSize,
          maxAttributes,
          maxVertexUniforms,
          maxVaryings,
          maxFragmentUniforms,
          vertexTextures,
          floatFragmentTextures,
          floatVertexTextures,
          maxSamples
        };
      }
      function WebGLClipping2(properties) {
        const scope = this;
        let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
        const plane = new Plane2(), viewNormalMatrix = new Matrix32(), uniform = {
          value: null,
          needsUpdate: false
        };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function(planes, enableLocalClipping, camera) {
          const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
          localClippingEnabled = enableLocalClipping;
          globalState = projectPlanes(planes, camera, 0);
          numGlobalPlanes = planes.length;
          return enabled;
        };
        this.beginShadows = function() {
          renderingShadows = true;
          projectPlanes(null);
        };
        this.endShadows = function() {
          renderingShadows = false;
          resetGlobalState();
        };
        this.setState = function(material, camera, useCache) {
          const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
          const materialProperties = properties.get(material);
          if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            if (renderingShadows) {
              projectPlanes(null);
            } else {
              resetGlobalState();
            }
          } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray;
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for (let i2 = 0; i2 !== lGlobal; ++i2) {
              dstArray[i2] = globalState[i2];
            }
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
          }
        };
        function resetGlobalState() {
          if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
          }
          scope.numPlanes = numGlobalPlanes;
          scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
          const nPlanes = planes !== null ? planes.length : 0;
          let dstArray = null;
          if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
              const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
              viewNormalMatrix.getNormalMatrix(viewMatrix);
              if (dstArray === null || dstArray.length < flatSize) {
                dstArray = new Float32Array(flatSize);
              }
              for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
                plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
                plane.normal.toArray(dstArray, i4);
                dstArray[i4 + 3] = plane.constant;
              }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
          }
          scope.numPlanes = nPlanes;
          scope.numIntersection = 0;
          return dstArray;
        }
      }
      function WebGLCubeMaps2(renderer) {
        let cubemaps = /* @__PURE__ */ new WeakMap();
        function mapTextureMapping(texture, mapping) {
          if (mapping === EquirectangularReflectionMapping2) {
            texture.mapping = CubeReflectionMapping2;
          } else if (mapping === EquirectangularRefractionMapping2) {
            texture.mapping = CubeRefractionMapping2;
          }
          return texture;
        }
        function get(texture) {
          if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping2 || mapping === EquirectangularRefractionMapping2) {
              if (cubemaps.has(texture)) {
                const cubemap = cubemaps.get(texture).texture;
                return mapTextureMapping(cubemap, texture.mapping);
              } else {
                const image = texture.image;
                if (image && image.height > 0) {
                  const renderTarget = new WebGLCubeRenderTarget2(image.height / 2);
                  renderTarget.fromEquirectangularTexture(renderer, texture);
                  cubemaps.set(texture, renderTarget);
                  texture.addEventListener("dispose", onTextureDispose);
                  return mapTextureMapping(renderTarget.texture, texture.mapping);
                } else {
                  return null;
                }
              }
            }
          }
          return texture;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          const cubemap = cubemaps.get(texture);
          if (cubemap !== void 0) {
            cubemaps.delete(texture);
            cubemap.dispose();
          }
        }
        function dispose() {
          cubemaps = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      var OrthographicCamera2 = class extends Camera2 {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
          super();
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = left;
          this.right = right;
          this.top = top;
          this.bottom = bottom;
          this.near = near;
          this.far = far;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;
          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          return this;
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width;
          this.view.height = height;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;
          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;
          if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          return data;
        }
      };
      OrthographicCamera2.prototype.isOrthographicCamera = true;
      var RawShaderMaterial2 = class extends ShaderMaterial2 {
        constructor(parameters) {
          super(parameters);
          this.type = "RawShaderMaterial";
        }
      };
      RawShaderMaterial2.prototype.isRawShaderMaterial = true;
      var LOD_MIN2 = 4;
      var LOD_MAX2 = 8;
      var SIZE_MAX2 = Math.pow(2, LOD_MAX2);
      var EXTRA_LOD_SIGMA2 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      var TOTAL_LODS2 = LOD_MAX2 - LOD_MIN2 + 1 + EXTRA_LOD_SIGMA2.length;
      var MAX_SAMPLES2 = 20;
      var _flatCamera2 = /* @__PURE__ */ new OrthographicCamera2();
      var {
        _lodPlanes: _lodPlanes2,
        _sizeLods: _sizeLods2,
        _sigmas: _sigmas2
      } = /* @__PURE__ */ _createPlanes2();
      var _clearColor2 = /* @__PURE__ */ new Color2();
      var _oldTarget2 = null;
      var PHI2 = (1 + Math.sqrt(5)) / 2;
      var INV_PHI2 = 1 / PHI2;
      var _axisDirections2 = [/* @__PURE__ */ new Vector32(1, 1, 1), /* @__PURE__ */ new Vector32(-1, 1, 1), /* @__PURE__ */ new Vector32(1, 1, -1), /* @__PURE__ */ new Vector32(-1, 1, -1), /* @__PURE__ */ new Vector32(0, PHI2, INV_PHI2), /* @__PURE__ */ new Vector32(0, PHI2, -INV_PHI2), /* @__PURE__ */ new Vector32(INV_PHI2, 0, PHI2), /* @__PURE__ */ new Vector32(-INV_PHI2, 0, PHI2), /* @__PURE__ */ new Vector32(PHI2, INV_PHI2, 0), /* @__PURE__ */ new Vector32(-PHI2, INV_PHI2, 0)];
      var PMREMGenerator2 = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._pingPongRenderTarget = null;
          this._blurMaterial = _getBlurShader2(MAX_SAMPLES2);
          this._equirectShader = null;
          this._cubemapShader = null;
          this._compileMaterial(this._blurMaterial);
        }
        fromScene(scene, sigma = 0, near = 0.1, far = 100) {
          _oldTarget2 = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = this._allocateTargets();
          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {
            this._blur(cubeUVRenderTarget, 0, 0, sigma);
          }
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        fromEquirectangular(equirectangular, renderTarget = null) {
          return this._fromTexture(equirectangular, renderTarget);
        }
        fromCubemap(cubemap, renderTarget = null) {
          return this._fromTexture(cubemap, renderTarget);
        }
        compileCubemapShader() {
          if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader2();
            this._compileMaterial(this._cubemapShader);
          }
        }
        compileEquirectangularShader() {
          if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader2();
            this._compileMaterial(this._equirectShader);
          }
        }
        dispose() {
          this._blurMaterial.dispose();
          if (this._pingPongRenderTarget !== null)
            this._pingPongRenderTarget.dispose();
          if (this._cubemapShader !== null)
            this._cubemapShader.dispose();
          if (this._equirectShader !== null)
            this._equirectShader.dispose();
          for (let i2 = 0; i2 < _lodPlanes2.length; i2++) {
            _lodPlanes2[i2].dispose();
          }
        }
        _cleanup(outputTarget) {
          this._renderer.setRenderTarget(_oldTarget2);
          outputTarget.scissorTest = false;
          _setViewport2(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture, renderTarget) {
          _oldTarget2 = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = renderTarget || this._allocateTargets(texture);
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        _allocateTargets(texture) {
          const params = {
            magFilter: LinearFilter2,
            minFilter: LinearFilter2,
            generateMipmaps: false,
            type: HalfFloatType2,
            format: RGBAFormat2,
            encoding: LinearEncoding2,
            depthBuffer: false
          };
          const cubeUVRenderTarget = _createRenderTarget2(params);
          cubeUVRenderTarget.depthBuffer = texture ? false : true;
          if (this._pingPongRenderTarget === null) {
            this._pingPongRenderTarget = _createRenderTarget2(params);
          }
          return cubeUVRenderTarget;
        }
        _compileMaterial(material) {
          const tmpMesh = new Mesh2(_lodPlanes2[0], material);
          this._renderer.compile(tmpMesh, _flatCamera2);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
          const fov3 = 90;
          const aspect3 = 1;
          const cubeCamera = new PerspectiveCamera2(fov3, aspect3, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;
          const originalAutoClear = renderer.autoClear;
          const toneMapping = renderer.toneMapping;
          renderer.getClearColor(_clearColor2);
          renderer.toneMapping = NoToneMapping2;
          renderer.autoClear = false;
          const backgroundMaterial = new MeshBasicMaterial2({
            name: "PMREM.Background",
            side: BackSide2,
            depthWrite: false,
            depthTest: false
          });
          const backgroundBox = new Mesh2(new BoxGeometry2(), backgroundMaterial);
          let useSolidColor = false;
          const background = scene.background;
          if (background) {
            if (background.isColor) {
              backgroundMaterial.color.copy(background);
              scene.background = null;
              useSolidColor = true;
            }
          } else {
            backgroundMaterial.color.copy(_clearColor2);
            useSolidColor = true;
          }
          for (let i2 = 0; i2 < 6; i2++) {
            const col = i2 % 3;
            if (col === 0) {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(forwardSign[i2], 0, 0);
            } else if (col === 1) {
              cubeCamera.up.set(0, 0, upSign[i2]);
              cubeCamera.lookAt(0, forwardSign[i2], 0);
            } else {
              cubeCamera.up.set(0, upSign[i2], 0);
              cubeCamera.lookAt(0, 0, forwardSign[i2]);
            }
            _setViewport2(cubeUVRenderTarget, col * SIZE_MAX2, i2 > 2 ? SIZE_MAX2 : 0, SIZE_MAX2, SIZE_MAX2);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) {
              renderer.render(backgroundBox, cubeCamera);
            }
            renderer.render(scene, cubeCamera);
          }
          backgroundBox.geometry.dispose();
          backgroundBox.material.dispose();
          renderer.toneMapping = toneMapping;
          renderer.autoClear = originalAutoClear;
          scene.background = background;
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
          const renderer = this._renderer;
          const isCubeTexture = texture.mapping === CubeReflectionMapping2 || texture.mapping === CubeRefractionMapping2;
          if (isCubeTexture) {
            if (this._cubemapShader === null) {
              this._cubemapShader = _getCubemapShader2();
            }
            this._cubemapShader.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
          } else {
            if (this._equirectShader === null) {
              this._equirectShader = _getEquirectShader2();
            }
          }
          const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
          const mesh = new Mesh2(_lodPlanes2[0], material);
          const uniforms = material.uniforms;
          uniforms["envMap"].value = texture;
          if (!isCubeTexture) {
            uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
          }
          _setViewport2(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX2, 2 * SIZE_MAX2);
          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera2);
        }
        _applyPMREM(cubeUVRenderTarget) {
          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;
          for (let i2 = 1; i2 < TOTAL_LODS2; i2++) {
            const sigma = Math.sqrt(_sigmas2[i2] * _sigmas2[i2] - _sigmas2[i2 - 1] * _sigmas2[i2 - 1]);
            const poleAxis = _axisDirections2[(i2 - 1) % _axisDirections2.length];
            this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
          }
          renderer.autoClear = autoClear;
        }
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
          const pingPongRenderTarget = this._pingPongRenderTarget;
          this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
          this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;
          if (direction !== "latitudinal" && direction !== "longitudinal") {
            console.error("blur direction must be either latitudinal or longitudinal!");
          }
          const STANDARD_DEVIATIONS = 3;
          const blurMesh = new Mesh2(_lodPlanes2[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;
          const pixels = _sizeLods2[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES2 - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES2;
          if (samples > MAX_SAMPLES2) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES2}`);
          }
          const weights = [];
          let sum = 0;
          for (let i2 = 0; i2 < MAX_SAMPLES2; ++i2) {
            const x2 = i2 / sigmaPixels;
            const weight = Math.exp(-x2 * x2 / 2);
            weights.push(weight);
            if (i2 === 0) {
              sum += weight;
            } else if (i2 < samples) {
              sum += 2 * weight;
            }
          }
          for (let i2 = 0; i2 < weights.length; i2++) {
            weights[i2] = weights[i2] / sum;
          }
          blurUniforms["envMap"].value = targetIn.texture;
          blurUniforms["samples"].value = samples;
          blurUniforms["weights"].value = weights;
          blurUniforms["latitudinal"].value = direction === "latitudinal";
          if (poleAxis) {
            blurUniforms["poleAxis"].value = poleAxis;
          }
          blurUniforms["dTheta"].value = radiansPerPixel;
          blurUniforms["mipInt"].value = LOD_MAX2 - lodIn;
          const outputSize = _sizeLods2[lodOut];
          const x = 3 * Math.max(0, SIZE_MAX2 - 2 * outputSize);
          const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX2) + 2 * outputSize * (lodOut > LOD_MAX2 - LOD_MIN2 ? lodOut - LOD_MAX2 + LOD_MIN2 : 0);
          _setViewport2(targetOut, x, y, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera2);
        }
      };
      function _createPlanes2() {
        const _lodPlanes3 = [];
        const _sizeLods3 = [];
        const _sigmas3 = [];
        let lod = LOD_MAX2;
        for (let i2 = 0; i2 < TOTAL_LODS2; i2++) {
          const sizeLod = Math.pow(2, lod);
          _sizeLods3.push(sizeLod);
          let sigma = 1 / sizeLod;
          if (i2 > LOD_MAX2 - LOD_MIN2) {
            sigma = EXTRA_LOD_SIGMA2[i2 - LOD_MAX2 + LOD_MIN2 - 1];
          } else if (i2 === 0) {
            sigma = 0;
          }
          _sigmas3.push(sigma);
          const texelSize = 1 / (sizeLod - 1);
          const min = -texelSize / 2;
          const max = 1 + texelSize / 2;
          const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
          const cubeFaces = 6;
          const vertices = 6;
          const positionSize = 3;
          const uvSize = 2;
          const faceIndexSize = 1;
          const position = new Float32Array(positionSize * vertices * cubeFaces);
          const uv = new Float32Array(uvSize * vertices * cubeFaces);
          const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
          for (let face = 0; face < cubeFaces; face++) {
            const x = face % 3 * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [face, face, face, face, face, face];
            faceIndex.set(fill, faceIndexSize * vertices * face);
          }
          const planes = new BufferGeometry2();
          planes.setAttribute("position", new BufferAttribute2(position, positionSize));
          planes.setAttribute("uv", new BufferAttribute2(uv, uvSize));
          planes.setAttribute("faceIndex", new BufferAttribute2(faceIndex, faceIndexSize));
          _lodPlanes3.push(planes);
          if (lod > LOD_MIN2) {
            lod--;
          }
        }
        return {
          _lodPlanes: _lodPlanes3,
          _sizeLods: _sizeLods3,
          _sigmas: _sigmas3
        };
      }
      function _createRenderTarget2(params) {
        const cubeUVRenderTarget = new WebGLRenderTarget3(3 * SIZE_MAX2, 3 * SIZE_MAX2, params);
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping2;
        cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
      }
      function _setViewport2(target, x, y, width, height) {
        target.viewport.set(x, y, width, height);
        target.scissor.set(x, y, width, height);
      }
      function _getBlurShader2(maxSamples) {
        const weights = new Float32Array(maxSamples);
        const poleAxis = new Vector32(0, 1, 0);
        const shaderMaterial = new RawShaderMaterial2({
          name: "SphericalGaussianBlur",
          defines: {
            "n": maxSamples
          },
          uniforms: {
            "envMap": {
              value: null
            },
            "samples": {
              value: 1
            },
            "weights": {
              value: weights
            },
            "latitudinal": {
              value: false
            },
            "dTheta": {
              value: 0
            },
            "mipInt": {
              value: 0
            },
            "poleAxis": {
              value: poleAxis
            }
          },
          vertexShader: _getCommonVertexShader2(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: NoBlending2,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getEquirectShader2() {
        const texelSize = new Vector22(1, 1);
        const shaderMaterial = new RawShaderMaterial2({
          name: "EquirectangularToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            },
            "texelSize": {
              value: texelSize
            }
          },
          vertexShader: _getCommonVertexShader2(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = texture2D ( envMap, uv ).rgb;
				uv.x += texelSize.x;
				vec3 tr = texture2D ( envMap, uv ).rgb;
				uv.y += texelSize.y;
				vec3 br = texture2D ( envMap, uv ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = texture2D ( envMap, uv ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`,
          blending: NoBlending2,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getCubemapShader2() {
        const shaderMaterial = new RawShaderMaterial2({
          name: "CubemapToCubeUV",
          uniforms: {
            "envMap": {
              value: null
            },
            "flipEnvMap": {
              value: -1
            }
          },
          vertexShader: _getCommonVertexShader2(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: NoBlending2,
          depthTest: false,
          depthWrite: false
        });
        return shaderMaterial;
      }
      function _getCommonVertexShader2() {
        return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function WebGLCubeUVMaps2(renderer) {
        let cubeUVmaps = /* @__PURE__ */ new WeakMap();
        let pmremGenerator = null;
        function get(texture) {
          if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            const isEquirectMap = mapping === EquirectangularReflectionMapping2 || mapping === EquirectangularRefractionMapping2;
            const isCubeMap = mapping === CubeReflectionMapping2 || mapping === CubeRefractionMapping2;
            if (isEquirectMap || isCubeMap) {
              if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
                texture.needsPMREMUpdate = false;
                let renderTarget = cubeUVmaps.get(texture);
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator2(renderer);
                renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
                cubeUVmaps.set(texture, renderTarget);
                return renderTarget.texture;
              } else {
                if (cubeUVmaps.has(texture)) {
                  return cubeUVmaps.get(texture).texture;
                } else {
                  const image = texture.image;
                  if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                    if (pmremGenerator === null)
                      pmremGenerator = new PMREMGenerator2(renderer);
                    const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                    cubeUVmaps.set(texture, renderTarget);
                    texture.addEventListener("dispose", onTextureDispose);
                    return renderTarget.texture;
                  } else {
                    return null;
                  }
                }
              }
            }
          }
          return texture;
        }
        function isCubeTextureComplete(image) {
          let count = 0;
          const length = 6;
          for (let i2 = 0; i2 < length; i2++) {
            if (image[i2] !== void 0)
              count++;
          }
          return count === length;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          const cubemapUV = cubeUVmaps.get(texture);
          if (cubemapUV !== void 0) {
            cubeUVmaps.delete(texture);
            cubemapUV.dispose();
          }
        }
        function dispose() {
          cubeUVmaps = /* @__PURE__ */ new WeakMap();
          if (pmremGenerator !== null) {
            pmremGenerator.dispose();
            pmremGenerator = null;
          }
        }
        return {
          get,
          dispose
        };
      }
      function WebGLExtensions2(gl) {
        const extensions = {};
        function getExtension(name) {
          if (extensions[name] !== void 0) {
            return extensions[name];
          }
          let extension;
          switch (name) {
            case "WEBGL_depth_texture":
              extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              extension = gl.getExtension(name);
          }
          extensions[name] = extension;
          return extension;
        }
        return {
          has: function(name) {
            return getExtension(name) !== null;
          },
          init: function(capabilities) {
            if (capabilities.isWebGL2) {
              getExtension("EXT_color_buffer_float");
            } else {
              getExtension("WEBGL_depth_texture");
              getExtension("OES_texture_float");
              getExtension("OES_texture_half_float");
              getExtension("OES_texture_half_float_linear");
              getExtension("OES_standard_derivatives");
              getExtension("OES_element_index_uint");
              getExtension("OES_vertex_array_object");
              getExtension("ANGLE_instanced_arrays");
            }
            getExtension("OES_texture_float_linear");
            getExtension("EXT_color_buffer_half_float");
            getExtension("WEBGL_multisampled_render_to_texture");
          },
          get: function(name) {
            const extension = getExtension(name);
            if (extension === null) {
              console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
            }
            return extension;
          }
        };
      }
      function WebGLGeometries2(gl, attributes, info, bindingStates) {
        const geometries = {};
        const wireframeAttributes = /* @__PURE__ */ new WeakMap();
        function onGeometryDispose(event) {
          const geometry = event.target;
          if (geometry.index !== null) {
            attributes.remove(geometry.index);
          }
          for (const name in geometry.attributes) {
            attributes.remove(geometry.attributes[name]);
          }
          geometry.removeEventListener("dispose", onGeometryDispose);
          delete geometries[geometry.id];
          const attribute = wireframeAttributes.get(geometry);
          if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry);
          }
          bindingStates.releaseStatesOfGeometry(geometry);
          if (geometry.isInstancedBufferGeometry === true) {
            delete geometry._maxInstanceCount;
          }
          info.memory.geometries--;
        }
        function get(object, geometry) {
          if (geometries[geometry.id] === true)
            return geometry;
          geometry.addEventListener("dispose", onGeometryDispose);
          geometries[geometry.id] = true;
          info.memory.geometries++;
          return geometry;
        }
        function update(geometry) {
          const geometryAttributes = geometry.attributes;
          for (const name in geometryAttributes) {
            attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
          }
          const morphAttributes = geometry.morphAttributes;
          for (const name in morphAttributes) {
            const array = morphAttributes[name];
            for (let i2 = 0, l = array.length; i2 < l; i2++) {
              attributes.update(array[i2], gl.ARRAY_BUFFER);
            }
          }
        }
        function updateWireframeAttribute(geometry) {
          const indices = [];
          const geometryIndex = geometry.index;
          const geometryPosition = geometry.attributes.position;
          let version = 0;
          if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
              const a = array[i2 + 0];
              const b = array[i2 + 1];
              const c = array[i2 + 2];
              indices.push(a, b, b, c, c, a);
            }
          } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for (let i2 = 0, l = array.length / 3 - 1; i2 < l; i2 += 3) {
              const a = i2 + 0;
              const b = i2 + 1;
              const c = i2 + 2;
              indices.push(a, b, b, c, c, a);
            }
          }
          const attribute = new (arrayNeedsUint322(indices) ? Uint32BufferAttribute2 : Uint16BufferAttribute2)(indices, 1);
          attribute.version = version;
          const previousAttribute = wireframeAttributes.get(geometry);
          if (previousAttribute)
            attributes.remove(previousAttribute);
          wireframeAttributes.set(geometry, attribute);
        }
        function getWireframeAttribute(geometry) {
          const currentAttribute = wireframeAttributes.get(geometry);
          if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) {
              if (currentAttribute.version < geometryIndex.version) {
                updateWireframeAttribute(geometry);
              }
            }
          } else {
            updateWireframeAttribute(geometry);
          }
          return wireframeAttributes.get(geometry);
        }
        return {
          get,
          update,
          getWireframeAttribute
        };
      }
      function WebGLIndexedBufferRenderer2(gl, extensions, info, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        let mode;
        function setMode(value) {
          mode = value;
        }
        let type, bytesPerElement;
        function setIndex(value) {
          type = value.type;
          bytesPerElement = value.bytesPerElement;
        }
        function render6(start, count) {
          gl.drawElements(mode, count, type, start * bytesPerElement);
          info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
          if (primcount === 0)
            return;
          let extension, methodName;
          if (isWebGL2) {
            extension = gl;
            methodName = "drawElementsInstanced";
          } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawElementsInstancedANGLE";
            if (extension === null) {
              console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          extension[methodName](mode, count, type, start * bytesPerElement, primcount);
          info.update(count, mode, primcount);
        }
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render6;
        this.renderInstances = renderInstances;
      }
      function WebGLInfo2(gl) {
        const memory = {
          geometries: 0,
          textures: 0
        };
        const render6 = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function update(count, mode, instanceCount) {
          render6.calls++;
          switch (mode) {
            case gl.TRIANGLES:
              render6.triangles += instanceCount * (count / 3);
              break;
            case gl.LINES:
              render6.lines += instanceCount * (count / 2);
              break;
            case gl.LINE_STRIP:
              render6.lines += instanceCount * (count - 1);
              break;
            case gl.LINE_LOOP:
              render6.lines += instanceCount * count;
              break;
            case gl.POINTS:
              render6.points += instanceCount * count;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
              break;
          }
        }
        function reset() {
          render6.frame++;
          render6.calls = 0;
          render6.triangles = 0;
          render6.points = 0;
          render6.lines = 0;
        }
        return {
          memory,
          render: render6,
          programs: null,
          autoReset: true,
          reset,
          update
        };
      }
      var DataTexture2DArray2 = class extends Texture2 {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter2;
          this.minFilter = NearestFilter2;
          this.wrapR = ClampToEdgeWrapping2;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataTexture2DArray2.prototype.isDataTexture2DArray = true;
      function numericalSort2(a, b) {
        return a[0] - b[0];
      }
      function absNumericalSort2(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
      }
      function denormalize2(morph, attribute) {
        let denominator = 1;
        const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
        if (array instanceof Int8Array)
          denominator = 127;
        else if (array instanceof Int16Array)
          denominator = 32767;
        else if (array instanceof Int32Array)
          denominator = 2147483647;
        else
          console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
        morph.divideScalar(denominator);
      }
      function WebGLMorphtargets2(gl, capabilities, textures) {
        const influencesList = {};
        const morphInfluences = new Float32Array(8);
        const morphTextures = /* @__PURE__ */ new WeakMap();
        const morph = new Vector32();
        const workInfluences = [];
        for (let i2 = 0; i2 < 8; i2++) {
          workInfluences[i2] = [i2, 0];
        }
        function update(object, geometry, material, program) {
          const objectInfluences = object.morphTargetInfluences;
          if (capabilities.isWebGL2 === true) {
            const numberOfMorphTargets = geometry.morphAttributes.position.length;
            let entry = morphTextures.get(geometry);
            if (entry === void 0 || entry.count !== numberOfMorphTargets) {
              let disposeTexture = function() {
                texture.dispose();
                morphTextures.delete(geometry);
                geometry.removeEventListener("dispose", disposeTexture);
              };
              if (entry !== void 0)
                entry.texture.dispose();
              const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
              const morphTargets = geometry.morphAttributes.position;
              const morphNormals = geometry.morphAttributes.normal || [];
              const numberOfVertices = geometry.attributes.position.count;
              const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
              let width = numberOfVertices * numberOfVertexData;
              let height = 1;
              if (width > capabilities.maxTextureSize) {
                height = Math.ceil(width / capabilities.maxTextureSize);
                width = capabilities.maxTextureSize;
              }
              const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
              const texture = new DataTexture2DArray2(buffer, width, height, numberOfMorphTargets);
              texture.format = RGBAFormat2;
              texture.type = FloatType2;
              texture.needsUpdate = true;
              const vertexDataStride = numberOfVertexData * 4;
              for (let i2 = 0; i2 < numberOfMorphTargets; i2++) {
                const morphTarget = morphTargets[i2];
                const morphNormal = morphNormals[i2];
                const offset = width * height * 4 * i2;
                for (let j = 0; j < morphTarget.count; j++) {
                  morph.fromBufferAttribute(morphTarget, j);
                  if (morphTarget.normalized === true)
                    denormalize2(morph, morphTarget);
                  const stride = j * vertexDataStride;
                  buffer[offset + stride + 0] = morph.x;
                  buffer[offset + stride + 1] = morph.y;
                  buffer[offset + stride + 2] = morph.z;
                  buffer[offset + stride + 3] = 0;
                  if (hasMorphNormals === true) {
                    morph.fromBufferAttribute(morphNormal, j);
                    if (morphNormal.normalized === true)
                      denormalize2(morph, morphNormal);
                    buffer[offset + stride + 4] = morph.x;
                    buffer[offset + stride + 5] = morph.y;
                    buffer[offset + stride + 6] = morph.z;
                    buffer[offset + stride + 7] = 0;
                  }
                }
              }
              entry = {
                count: numberOfMorphTargets,
                texture,
                size: new Vector22(width, height)
              };
              morphTextures.set(geometry, entry);
              geometry.addEventListener("dispose", disposeTexture);
            }
            let morphInfluencesSum = 0;
            for (let i2 = 0; i2 < objectInfluences.length; i2++) {
              morphInfluencesSum += objectInfluences[i2];
            }
            const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
            program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
            program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
          } else {
            const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
            let influences = influencesList[geometry.id];
            if (influences === void 0 || influences.length !== length) {
              influences = [];
              for (let i2 = 0; i2 < length; i2++) {
                influences[i2] = [i2, 0];
              }
              influencesList[geometry.id] = influences;
            }
            for (let i2 = 0; i2 < length; i2++) {
              const influence = influences[i2];
              influence[0] = i2;
              influence[1] = objectInfluences[i2];
            }
            influences.sort(absNumericalSort2);
            for (let i2 = 0; i2 < 8; i2++) {
              if (i2 < length && influences[i2][1]) {
                workInfluences[i2][0] = influences[i2][0];
                workInfluences[i2][1] = influences[i2][1];
              } else {
                workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
                workInfluences[i2][1] = 0;
              }
            }
            workInfluences.sort(numericalSort2);
            const morphTargets = geometry.morphAttributes.position;
            const morphNormals = geometry.morphAttributes.normal;
            let morphInfluencesSum = 0;
            for (let i2 = 0; i2 < 8; i2++) {
              const influence = workInfluences[i2];
              const index = influence[0];
              const value = influence[1];
              if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
                  geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
                }
                if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
                  geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
                }
                morphInfluences[i2] = value;
                morphInfluencesSum += value;
              } else {
                if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
                  geometry.deleteAttribute("morphTarget" + i2);
                }
                if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
                  geometry.deleteAttribute("morphNormal" + i2);
                }
                morphInfluences[i2] = 0;
              }
            }
            const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
          }
        }
        return {
          update
        };
      }
      function WebGLObjects2(gl, geometries, attributes, info) {
        let updateMap = /* @__PURE__ */ new WeakMap();
        function update(object) {
          const frame = info.render.frame;
          const geometry = object.geometry;
          const buffergeometry = geometries.get(object, geometry);
          if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
          }
          if (object.isInstancedMesh) {
            if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
              object.addEventListener("dispose", onInstancedMeshDispose);
            }
            attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
            if (object.instanceColor !== null) {
              attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
            }
          }
          return buffergeometry;
        }
        function dispose() {
          updateMap = /* @__PURE__ */ new WeakMap();
        }
        function onInstancedMeshDispose(event) {
          const instancedMesh = event.target;
          instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
          attributes.remove(instancedMesh.instanceMatrix);
          if (instancedMesh.instanceColor !== null)
            attributes.remove(instancedMesh.instanceColor);
        }
        return {
          update,
          dispose
        };
      }
      var DataTexture3D2 = class extends Texture2 {
        constructor(data = null, width = 1, height = 1, depth = 1) {
          super(null);
          this.image = {
            data,
            width,
            height,
            depth
          };
          this.magFilter = NearestFilter2;
          this.minFilter = NearestFilter2;
          this.wrapR = ClampToEdgeWrapping2;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataTexture3D2.prototype.isDataTexture3D = true;
      var emptyTexture2 = new Texture2();
      var emptyTexture2dArray2 = new DataTexture2DArray2();
      var emptyTexture3d2 = new DataTexture3D2();
      var emptyCubeTexture2 = new CubeTexture2();
      var arrayCacheF322 = [];
      var arrayCacheI322 = [];
      var mat4array2 = new Float32Array(16);
      var mat3array2 = new Float32Array(9);
      var mat2array2 = new Float32Array(4);
      function flatten2(array, nBlocks, blockSize) {
        const firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0)
          return array;
        const n = nBlocks * blockSize;
        let r = arrayCacheF322[n];
        if (r === void 0) {
          r = new Float32Array(n);
          arrayCacheF322[n] = r;
        }
        if (nBlocks !== 0) {
          firstElem.toArray(r, 0);
          for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
            offset += blockSize;
            array[i2].toArray(r, offset);
          }
        }
        return r;
      }
      function arraysEqual2(a, b) {
        if (a.length !== b.length)
          return false;
        for (let i2 = 0, l = a.length; i2 < l; i2++) {
          if (a[i2] !== b[i2])
            return false;
        }
        return true;
      }
      function copyArray2(a, b) {
        for (let i2 = 0, l = b.length; i2 < l; i2++) {
          a[i2] = b[i2];
        }
      }
      function allocTexUnits2(textures, n) {
        let r = arrayCacheI322[n];
        if (r === void 0) {
          r = new Int32Array(n);
          arrayCacheI322[n] = r;
        }
        for (let i2 = 0; i2 !== n; ++i2) {
          r[i2] = textures.allocateTextureUnit();
        }
        return r;
      }
      function setValueV1f2(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1f(this.addr, v);
        cache[0] = v;
      }
      function setValueV2f2(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
          }
        } else {
          if (arraysEqual2(cache, v))
            return;
          gl.uniform2fv(this.addr, v);
          copyArray2(cache, v);
        }
      }
      function setValueV3f2(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
          }
        } else if (v.r !== void 0) {
          if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
          }
        } else {
          if (arraysEqual2(cache, v))
            return;
          gl.uniform3fv(this.addr, v);
          copyArray2(cache, v);
        }
      }
      function setValueV4f2(gl, v) {
        const cache = this.cache;
        if (v.x !== void 0) {
          if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
          }
        } else {
          if (arraysEqual2(cache, v))
            return;
          gl.uniform4fv(this.addr, v);
          copyArray2(cache, v);
        }
      }
      function setValueM22(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual2(cache, v))
            return;
          gl.uniformMatrix2fv(this.addr, false, v);
          copyArray2(cache, v);
        } else {
          if (arraysEqual2(cache, elements))
            return;
          mat2array2.set(elements);
          gl.uniformMatrix2fv(this.addr, false, mat2array2);
          copyArray2(cache, elements);
        }
      }
      function setValueM32(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual2(cache, v))
            return;
          gl.uniformMatrix3fv(this.addr, false, v);
          copyArray2(cache, v);
        } else {
          if (arraysEqual2(cache, elements))
            return;
          mat3array2.set(elements);
          gl.uniformMatrix3fv(this.addr, false, mat3array2);
          copyArray2(cache, elements);
        }
      }
      function setValueM42(gl, v) {
        const cache = this.cache;
        const elements = v.elements;
        if (elements === void 0) {
          if (arraysEqual2(cache, v))
            return;
          gl.uniformMatrix4fv(this.addr, false, v);
          copyArray2(cache, v);
        } else {
          if (arraysEqual2(cache, elements))
            return;
          mat4array2.set(elements);
          gl.uniformMatrix4fv(this.addr, false, mat4array2);
          copyArray2(cache, elements);
        }
      }
      function setValueV1i2(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1i(this.addr, v);
        cache[0] = v;
      }
      function setValueV2i2(gl, v) {
        const cache = this.cache;
        if (arraysEqual2(cache, v))
          return;
        gl.uniform2iv(this.addr, v);
        copyArray2(cache, v);
      }
      function setValueV3i2(gl, v) {
        const cache = this.cache;
        if (arraysEqual2(cache, v))
          return;
        gl.uniform3iv(this.addr, v);
        copyArray2(cache, v);
      }
      function setValueV4i2(gl, v) {
        const cache = this.cache;
        if (arraysEqual2(cache, v))
          return;
        gl.uniform4iv(this.addr, v);
        copyArray2(cache, v);
      }
      function setValueV1ui2(gl, v) {
        const cache = this.cache;
        if (cache[0] === v)
          return;
        gl.uniform1ui(this.addr, v);
        cache[0] = v;
      }
      function setValueV2ui2(gl, v) {
        const cache = this.cache;
        if (arraysEqual2(cache, v))
          return;
        gl.uniform2uiv(this.addr, v);
        copyArray2(cache, v);
      }
      function setValueV3ui2(gl, v) {
        const cache = this.cache;
        if (arraysEqual2(cache, v))
          return;
        gl.uniform3uiv(this.addr, v);
        copyArray2(cache, v);
      }
      function setValueV4ui2(gl, v) {
        const cache = this.cache;
        if (arraysEqual2(cache, v))
          return;
        gl.uniform4uiv(this.addr, v);
        copyArray2(cache, v);
      }
      function setValueT12(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.safeSetTexture2D(v || emptyTexture2, unit);
      }
      function setValueT3D12(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture3D(v || emptyTexture3d2, unit);
      }
      function setValueT62(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.safeSetTextureCube(v || emptyCubeTexture2, unit);
      }
      function setValueT2DArray12(gl, v, textures) {
        const cache = this.cache;
        const unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
          gl.uniform1i(this.addr, unit);
          cache[0] = unit;
        }
        textures.setTexture2DArray(v || emptyTexture2dArray2, unit);
      }
      function getSingularSetter2(type) {
        switch (type) {
          case 5126:
            return setValueV1f2;
          case 35664:
            return setValueV2f2;
          case 35665:
            return setValueV3f2;
          case 35666:
            return setValueV4f2;
          case 35674:
            return setValueM22;
          case 35675:
            return setValueM32;
          case 35676:
            return setValueM42;
          case 5124:
          case 35670:
            return setValueV1i2;
          case 35667:
          case 35671:
            return setValueV2i2;
          case 35668:
          case 35672:
            return setValueV3i2;
          case 35669:
          case 35673:
            return setValueV4i2;
          case 5125:
            return setValueV1ui2;
          case 36294:
            return setValueV2ui2;
          case 36295:
            return setValueV3ui2;
          case 36296:
            return setValueV4ui2;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT12;
          case 35679:
          case 36299:
          case 36307:
            return setValueT3D12;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT62;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return setValueT2DArray12;
        }
      }
      function setValueV1fArray2(gl, v) {
        gl.uniform1fv(this.addr, v);
      }
      function setValueV2fArray2(gl, v) {
        const data = flatten2(v, this.size, 2);
        gl.uniform2fv(this.addr, data);
      }
      function setValueV3fArray2(gl, v) {
        const data = flatten2(v, this.size, 3);
        gl.uniform3fv(this.addr, data);
      }
      function setValueV4fArray2(gl, v) {
        const data = flatten2(v, this.size, 4);
        gl.uniform4fv(this.addr, data);
      }
      function setValueM2Array2(gl, v) {
        const data = flatten2(v, this.size, 4);
        gl.uniformMatrix2fv(this.addr, false, data);
      }
      function setValueM3Array2(gl, v) {
        const data = flatten2(v, this.size, 9);
        gl.uniformMatrix3fv(this.addr, false, data);
      }
      function setValueM4Array2(gl, v) {
        const data = flatten2(v, this.size, 16);
        gl.uniformMatrix4fv(this.addr, false, data);
      }
      function setValueV1iArray2(gl, v) {
        gl.uniform1iv(this.addr, v);
      }
      function setValueV2iArray2(gl, v) {
        gl.uniform2iv(this.addr, v);
      }
      function setValueV3iArray2(gl, v) {
        gl.uniform3iv(this.addr, v);
      }
      function setValueV4iArray2(gl, v) {
        gl.uniform4iv(this.addr, v);
      }
      function setValueV1uiArray2(gl, v) {
        gl.uniform1uiv(this.addr, v);
      }
      function setValueV2uiArray2(gl, v) {
        gl.uniform2uiv(this.addr, v);
      }
      function setValueV3uiArray2(gl, v) {
        gl.uniform3uiv(this.addr, v);
      }
      function setValueV4uiArray2(gl, v) {
        gl.uniform4uiv(this.addr, v);
      }
      function setValueT1Array2(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits2(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.safeSetTexture2D(v[i2] || emptyTexture2, units[i2]);
        }
      }
      function setValueT3DArray2(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits2(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.setTexture3D(v[i2] || emptyTexture3d2, units[i2]);
        }
      }
      function setValueT6Array2(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits2(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.safeSetTextureCube(v[i2] || emptyCubeTexture2, units[i2]);
        }
      }
      function setValueT2DArrayArray2(gl, v, textures) {
        const n = v.length;
        const units = allocTexUnits2(textures, n);
        gl.uniform1iv(this.addr, units);
        for (let i2 = 0; i2 !== n; ++i2) {
          textures.setTexture2DArray(v[i2] || emptyTexture2dArray2, units[i2]);
        }
      }
      function getPureArraySetter2(type) {
        switch (type) {
          case 5126:
            return setValueV1fArray2;
          case 35664:
            return setValueV2fArray2;
          case 35665:
            return setValueV3fArray2;
          case 35666:
            return setValueV4fArray2;
          case 35674:
            return setValueM2Array2;
          case 35675:
            return setValueM3Array2;
          case 35676:
            return setValueM4Array2;
          case 5124:
          case 35670:
            return setValueV1iArray2;
          case 35667:
          case 35671:
            return setValueV2iArray2;
          case 35668:
          case 35672:
            return setValueV3iArray2;
          case 35669:
          case 35673:
            return setValueV4iArray2;
          case 5125:
            return setValueV1uiArray2;
          case 36294:
            return setValueV2uiArray2;
          case 36295:
            return setValueV3uiArray2;
          case 36296:
            return setValueV4uiArray2;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return setValueT1Array2;
          case 35679:
          case 36299:
          case 36307:
            return setValueT3DArray2;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return setValueT6Array2;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return setValueT2DArrayArray2;
        }
      }
      function SingleUniform2(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter2(activeInfo.type);
      }
      function PureArrayUniform2(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter2(activeInfo.type);
      }
      PureArrayUniform2.prototype.updateCache = function(data) {
        const cache = this.cache;
        if (data instanceof Float32Array && cache.length !== data.length) {
          this.cache = new Float32Array(data.length);
        }
        copyArray2(cache, data);
      };
      function StructuredUniform2(id) {
        this.id = id;
        this.seq = [];
        this.map = {};
      }
      StructuredUniform2.prototype.setValue = function(gl, value, textures) {
        const seq = this.seq;
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2];
          u.setValue(gl, value[u.id], textures);
        }
      };
      var RePathPart2 = /(\w+)(\])?(\[|\.)?/g;
      function addUniform2(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
      }
      function parseUniform2(activeInfo, addr, container) {
        const path = activeInfo.name, pathLength = path.length;
        RePathPart2.lastIndex = 0;
        while (true) {
          const match = RePathPart2.exec(path), matchEnd = RePathPart2.lastIndex;
          let id = match[1];
          const idIsIndex = match[2] === "]", subscript = match[3];
          if (idIsIndex)
            id = id | 0;
          if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
            addUniform2(container, subscript === void 0 ? new SingleUniform2(id, activeInfo, addr) : new PureArrayUniform2(id, activeInfo, addr));
            break;
          } else {
            const map = container.map;
            let next = map[id];
            if (next === void 0) {
              next = new StructuredUniform2(id);
              addUniform2(container, next);
            }
            container = next;
          }
        }
      }
      function WebGLUniforms2(gl, program) {
        this.seq = [];
        this.map = {};
        const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i2 = 0; i2 < n; ++i2) {
          const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
          parseUniform2(info, addr, this);
        }
      }
      WebGLUniforms2.prototype.setValue = function(gl, name, value, textures) {
        const u = this.map[name];
        if (u !== void 0)
          u.setValue(gl, value, textures);
      };
      WebGLUniforms2.prototype.setOptional = function(gl, object, name) {
        const v = object[name];
        if (v !== void 0)
          this.setValue(gl, name, v);
      };
      WebGLUniforms2.upload = function(gl, seq, values, textures) {
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2], v = values[u.id];
          if (v.needsUpdate !== false) {
            u.setValue(gl, v.value, textures);
          }
        }
      };
      WebGLUniforms2.seqWithValue = function(seq, values) {
        const r = [];
        for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
          const u = seq[i2];
          if (u.id in values)
            r.push(u);
        }
        return r;
      };
      function WebGLShader2(gl, type, string) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        return shader;
      }
      var programIdCount2 = 0;
      function addLineNumbers2(string) {
        const lines = string.split("\n");
        for (let i2 = 0; i2 < lines.length; i2++) {
          lines[i2] = i2 + 1 + ": " + lines[i2];
        }
        return lines.join("\n");
      }
      function getEncodingComponents2(encoding) {
        switch (encoding) {
          case LinearEncoding2:
            return ["Linear", "( value )"];
          case sRGBEncoding2:
            return ["sRGB", "( value )"];
          default:
            console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
            return ["Linear", "( value )"];
        }
      }
      function getShaderErrors2(gl, shader, type) {
        const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        const errors = gl.getShaderInfoLog(shader).trim();
        if (status && errors === "")
          return "";
        return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers2(gl.getShaderSource(shader));
      }
      function getTexelEncodingFunction2(functionName, encoding) {
        const components = getEncodingComponents2(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
      }
      function getToneMappingFunction2(functionName, toneMapping) {
        let toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping2:
            toneMappingName = "Linear";
            break;
          case ReinhardToneMapping2:
            toneMappingName = "Reinhard";
            break;
          case CineonToneMapping2:
            toneMappingName = "OptimizedCineon";
            break;
          case ACESFilmicToneMapping2:
            toneMappingName = "ACESFilmic";
            break;
          case CustomToneMapping2:
            toneMappingName = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
            toneMappingName = "Linear";
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
      }
      function generateExtensions2(parameters) {
        const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
        return chunks.filter(filterEmptyLine2).join("\n");
      }
      function generateDefines2(defines) {
        const chunks = [];
        for (const name in defines) {
          const value = defines[name];
          if (value === false)
            continue;
          chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
      }
      function fetchAttributeLocations2(gl, program) {
        const attributes = {};
        const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (let i2 = 0; i2 < n; i2++) {
          const info = gl.getActiveAttrib(program, i2);
          const name = info.name;
          let locationSize = 1;
          if (info.type === gl.FLOAT_MAT2)
            locationSize = 2;
          if (info.type === gl.FLOAT_MAT3)
            locationSize = 3;
          if (info.type === gl.FLOAT_MAT4)
            locationSize = 4;
          attributes[name] = {
            type: info.type,
            location: gl.getAttribLocation(program, name),
            locationSize
          };
        }
        return attributes;
      }
      function filterEmptyLine2(string) {
        return string !== "";
      }
      function replaceLightNums2(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
      }
      function replaceClippingPlaneNums2(string, parameters) {
        return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
      }
      var includePattern2 = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function resolveIncludes2(string) {
        return string.replace(includePattern2, includeReplacer2);
      }
      function includeReplacer2(match, include) {
        const string = ShaderChunk2[include];
        if (string === void 0) {
          throw new Error("Can not resolve #include <" + include + ">");
        }
        return resolveIncludes2(string);
      }
      var deprecatedUnrollLoopPattern2 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
      var unrollLoopPattern2 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function unrollLoops2(string) {
        return string.replace(unrollLoopPattern2, loopReplacer2).replace(deprecatedUnrollLoopPattern2, deprecatedLoopReplacer2);
      }
      function deprecatedLoopReplacer2(match, start, end, snippet) {
        console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
        return loopReplacer2(match, start, end, snippet);
      }
      function loopReplacer2(match, start, end, snippet) {
        let string = "";
        for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
          string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
        }
        return string;
      }
      function generatePrecision2(parameters) {
        let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
        if (parameters.precision === "highp") {
          precisionstring += "\n#define HIGH_PRECISION";
        } else if (parameters.precision === "mediump") {
          precisionstring += "\n#define MEDIUM_PRECISION";
        } else if (parameters.precision === "lowp") {
          precisionstring += "\n#define LOW_PRECISION";
        }
        return precisionstring;
      }
      function generateShadowMapTypeDefine2(parameters) {
        let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        if (parameters.shadowMapType === PCFShadowMap2) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
        } else if (parameters.shadowMapType === PCFSoftShadowMap2) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
        } else if (parameters.shadowMapType === VSMShadowMap2) {
          shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
        }
        return shadowMapTypeDefine;
      }
      function generateEnvMapTypeDefine2(parameters) {
        let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeReflectionMapping2:
            case CubeRefractionMapping2:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE";
              break;
            case CubeUVReflectionMapping2:
            case CubeUVRefractionMapping2:
              envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
              break;
          }
        }
        return envMapTypeDefine;
      }
      function generateEnvMapModeDefine2(parameters) {
        let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
        if (parameters.envMap) {
          switch (parameters.envMapMode) {
            case CubeRefractionMapping2:
            case CubeUVRefractionMapping2:
              envMapModeDefine = "ENVMAP_MODE_REFRACTION";
              break;
          }
        }
        return envMapModeDefine;
      }
      function generateEnvMapBlendingDefine2(parameters) {
        let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
        if (parameters.envMap) {
          switch (parameters.combine) {
            case MultiplyOperation2:
              envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case MixOperation2:
              envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
              break;
            case AddOperation2:
              envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
              break;
          }
        }
        return envMapBlendingDefine;
      }
      function WebGLProgram2(renderer, cacheKey, parameters, bindingStates) {
        const gl = renderer.getContext();
        const defines = parameters.defines;
        let vertexShader = parameters.vertexShader;
        let fragmentShader = parameters.fragmentShader;
        const shadowMapTypeDefine = generateShadowMapTypeDefine2(parameters);
        const envMapTypeDefine = generateEnvMapTypeDefine2(parameters);
        const envMapModeDefine = generateEnvMapModeDefine2(parameters);
        const envMapBlendingDefine = generateEnvMapBlendingDefine2(parameters);
        const customExtensions = parameters.isWebGL2 ? "" : generateExtensions2(parameters);
        const customDefines = generateDefines2(defines);
        const program = gl.createProgram();
        let prefixVertex, prefixFragment;
        let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
        if (parameters.isRawShaderMaterial) {
          prefixVertex = [customDefines].filter(filterEmptyLine2).join("\n");
          if (prefixVertex.length > 0) {
            prefixVertex += "\n";
          }
          prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine2).join("\n");
          if (prefixFragment.length > 0) {
            prefixFragment += "\n";
          }
        } else {
          prefixVertex = [generatePrecision2(parameters), "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.instancing ? "#define USE_INSTANCING" : "", parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "", parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.transmission ? "#define USE_TRANSMISSION" : "", parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "", parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine2).join("\n");
          prefixFragment = [
            customExtensions,
            generatePrecision2(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.matcap ? "#define USE_MATCAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapTypeDefine : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.envMap ? "#define " + envMapBlendingDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.alphaTest ? "#define USE_ALPHATEST" : "",
            parameters.sheen ? "#define USE_SHEEN" : "",
            parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            parameters.transmission ? "#define USE_TRANSMISSION" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
            parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            parameters.toneMapping !== NoToneMapping2 ? "#define TONE_MAPPING" : "",
            parameters.toneMapping !== NoToneMapping2 ? ShaderChunk2["tonemapping_pars_fragment"] : "",
            parameters.toneMapping !== NoToneMapping2 ? getToneMappingFunction2("toneMapping", parameters.toneMapping) : "",
            parameters.dithering ? "#define DITHERING" : "",
            parameters.transparent ? "" : "#define OPAQUE",
            ShaderChunk2["encodings_pars_fragment"],
            getTexelEncodingFunction2("linearToOutputTexel", parameters.outputEncoding),
            parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
            "\n"
          ].filter(filterEmptyLine2).join("\n");
        }
        vertexShader = resolveIncludes2(vertexShader);
        vertexShader = replaceLightNums2(vertexShader, parameters);
        vertexShader = replaceClippingPlaneNums2(vertexShader, parameters);
        fragmentShader = resolveIncludes2(fragmentShader);
        fragmentShader = replaceLightNums2(fragmentShader, parameters);
        fragmentShader = replaceClippingPlaneNums2(fragmentShader, parameters);
        vertexShader = unrollLoops2(vertexShader);
        fragmentShader = unrollLoops2(fragmentShader);
        if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
          versionString = "#version 300 es\n";
          prefixVertex = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex;
          prefixFragment = ["#define varying in", parameters.glslVersion === GLSL32 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", parameters.glslVersion === GLSL32 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment;
        }
        const vertexGlsl = versionString + prefixVertex + vertexShader;
        const fragmentGlsl = versionString + prefixFragment + fragmentShader;
        const glVertexShader = WebGLShader2(gl, gl.VERTEX_SHADER, vertexGlsl);
        const glFragmentShader = WebGLShader2(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (parameters.index0AttributeName !== void 0) {
          gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
        } else if (parameters.morphTargets === true) {
          gl.bindAttribLocation(program, 0, "position");
        }
        gl.linkProgram(program);
        if (renderer.debug.checkShaderErrors) {
          const programLog = gl.getProgramInfoLog(program).trim();
          const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
          const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
          let runnable = true;
          let haveDiagnostics = true;
          if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors2(gl, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors2(gl, glFragmentShader, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
          } else if (programLog !== "") {
            console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
          } else if (vertexLog === "" || fragmentLog === "") {
            haveDiagnostics = false;
          }
          if (haveDiagnostics) {
            this.diagnostics = {
              runnable,
              programLog,
              vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
              },
              fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
              }
            };
          }
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        let cachedUniforms;
        this.getUniforms = function() {
          if (cachedUniforms === void 0) {
            cachedUniforms = new WebGLUniforms2(gl, program);
          }
          return cachedUniforms;
        };
        let cachedAttributes;
        this.getAttributes = function() {
          if (cachedAttributes === void 0) {
            cachedAttributes = fetchAttributeLocations2(gl, program);
          }
          return cachedAttributes;
        };
        this.destroy = function() {
          bindingStates.releaseStatesOfProgram(this);
          gl.deleteProgram(program);
          this.program = void 0;
        };
        this.name = parameters.shaderName;
        this.id = programIdCount2++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      }
      var _id3 = 0;
      var WebGLShaderCache2 = class {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map();
          this.materialCache = /* @__PURE__ */ new Map();
        }
        update(material) {
          const vertexShader = material.vertexShader;
          const fragmentShader = material.fragmentShader;
          const vertexShaderStage = this._getShaderStage(vertexShader);
          const fragmentShaderStage = this._getShaderStage(fragmentShader);
          const materialShaders = this._getShaderCacheForMaterial(material);
          if (materialShaders.has(vertexShaderStage) === false) {
            materialShaders.add(vertexShaderStage);
            vertexShaderStage.usedTimes++;
          }
          if (materialShaders.has(fragmentShaderStage) === false) {
            materialShaders.add(fragmentShaderStage);
            fragmentShaderStage.usedTimes++;
          }
          return this;
        }
        remove(material) {
          const materialShaders = this.materialCache.get(material);
          for (const shaderStage of materialShaders) {
            shaderStage.usedTimes--;
            if (shaderStage.usedTimes === 0)
              this.shaderCache.delete(shaderStage);
          }
          this.materialCache.delete(material);
          return this;
        }
        getVertexShaderID(material) {
          return this._getShaderStage(material.vertexShader).id;
        }
        getFragmentShaderID(material) {
          return this._getShaderStage(material.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear();
          this.materialCache.clear();
        }
        _getShaderCacheForMaterial(material) {
          const cache = this.materialCache;
          if (cache.has(material) === false) {
            cache.set(material, /* @__PURE__ */ new Set());
          }
          return cache.get(material);
        }
        _getShaderStage(code) {
          const cache = this.shaderCache;
          if (cache.has(code) === false) {
            const stage = new WebGLShaderStage2();
            cache.set(code, stage);
          }
          return cache.get(code);
        }
      };
      var WebGLShaderStage2 = class {
        constructor() {
          this.id = _id3++;
          this.usedTimes = 0;
        }
      };
      function WebGLPrograms2(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
        const _programLayers = new Layers2();
        const _customShaders = new WebGLShaderCache2();
        const programs = [];
        const isWebGL2 = capabilities.isWebGL2;
        const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        const floatVertexTextures = capabilities.floatVertexTextures;
        const maxVertexUniforms = capabilities.maxVertexUniforms;
        const vertexTextures = capabilities.vertexTextures;
        let precision = capabilities.precision;
        const shaderIDs = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        function getMaxBones(object) {
          const skeleton = object.skeleton;
          const bones = skeleton.bones;
          if (floatVertexTextures) {
            return 1024;
          } else {
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
              console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
              return 0;
            }
            return maxBones;
          }
        }
        function getParameters(material, lights, shadows, scene, object) {
          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
          const shaderID = shaderIDs[material.type];
          const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
          if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) {
              console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
            }
          }
          let vertexShader, fragmentShader;
          let customVertexShaderID, customFragmentShaderID;
          if (shaderID) {
            const shader = ShaderLib2[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
          } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
            _customShaders.update(material);
            customVertexShaderID = _customShaders.getVertexShaderID(material);
            customFragmentShaderID = _customShaders.getFragmentShaderID(material);
          }
          const currentRenderTarget = renderer.getRenderTarget();
          const useAlphaTest = material.alphaTest > 0;
          const useClearcoat = material.clearcoat > 0;
          const parameters = {
            isWebGL2,
            shaderID,
            shaderName: material.type,
            vertexShader,
            fragmentShader,
            defines: material.defines,
            customVertexShaderID,
            customFragmentShaderID,
            isRawShaderMaterial: material.isRawShaderMaterial === true,
            glslVersion: material.glslVersion,
            precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding2,
            map: !!material.map,
            matcap: !!material.matcap,
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping2 || envMap.mapping === CubeUVRefractionMapping2),
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap2,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap2,
            decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding2,
            clearcoat: useClearcoat,
            clearcoatMap: useClearcoat && !!material.clearcoatMap,
            clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            specularIntensityMap: !!material.specularIntensityMap,
            specularColorMap: !!material.specularColorMap,
            transparent: material.transparent,
            alphaMap: !!material.alphaMap,
            alphaTest: useAlphaTest,
            gradientMap: !!material.gradientMap,
            sheen: material.sheen > 0,
            sheenColorMap: !!material.sheenColorMap,
            sheenRoughnessMap: !!material.sheenRoughnessMap,
            transmission: material.transmission > 0,
            transmissionMap: !!material.transmissionMap,
            thicknessMap: !!material.thicknessMap,
            combine: material.combine,
            vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
            vertexColors: material.vertexColors,
            vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: !!material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer,
            skinning: object.isSkinnedMesh === true && maxBones > 0,
            maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
            morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
            morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping2,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            doubleSided: material.side === DoubleSide3,
            flipSided: material.side === BackSide2,
            depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
            customProgramCacheKey: material.customProgramCacheKey()
          };
          return parameters;
        }
        function getProgramCacheKey(parameters) {
          const array = [];
          if (parameters.shaderID) {
            array.push(parameters.shaderID);
          } else {
            array.push(parameters.customVertexShaderID);
            array.push(parameters.customFragmentShaderID);
          }
          if (parameters.defines !== void 0) {
            for (const name in parameters.defines) {
              array.push(name);
              array.push(parameters.defines[name]);
            }
          }
          if (parameters.isRawShaderMaterial === false) {
            getProgramCacheKeyParameters(array, parameters);
            getProgramCacheKeyBooleans(array, parameters);
            array.push(renderer.outputEncoding);
          }
          array.push(parameters.customProgramCacheKey);
          return array.join();
        }
        function getProgramCacheKeyParameters(array, parameters) {
          array.push(parameters.precision);
          array.push(parameters.outputEncoding);
          array.push(parameters.envMapMode);
          array.push(parameters.combine);
          array.push(parameters.vertexUvs);
          array.push(parameters.fogExp2);
          array.push(parameters.sizeAttenuation);
          array.push(parameters.maxBones);
          array.push(parameters.morphTargetsCount);
          array.push(parameters.numDirLights);
          array.push(parameters.numPointLights);
          array.push(parameters.numSpotLights);
          array.push(parameters.numHemiLights);
          array.push(parameters.numRectAreaLights);
          array.push(parameters.numDirLightShadows);
          array.push(parameters.numPointLightShadows);
          array.push(parameters.numSpotLightShadows);
          array.push(parameters.shadowMapType);
          array.push(parameters.toneMapping);
          array.push(parameters.numClippingPlanes);
          array.push(parameters.numClipIntersection);
        }
        function getProgramCacheKeyBooleans(array, parameters) {
          _programLayers.disableAll();
          if (parameters.isWebGL2)
            _programLayers.enable(0);
          if (parameters.supportsVertexTextures)
            _programLayers.enable(1);
          if (parameters.instancing)
            _programLayers.enable(2);
          if (parameters.instancingColor)
            _programLayers.enable(3);
          if (parameters.map)
            _programLayers.enable(4);
          if (parameters.matcap)
            _programLayers.enable(5);
          if (parameters.envMap)
            _programLayers.enable(6);
          if (parameters.envMapCubeUV)
            _programLayers.enable(7);
          if (parameters.lightMap)
            _programLayers.enable(8);
          if (parameters.aoMap)
            _programLayers.enable(9);
          if (parameters.emissiveMap)
            _programLayers.enable(10);
          if (parameters.bumpMap)
            _programLayers.enable(11);
          if (parameters.normalMap)
            _programLayers.enable(12);
          if (parameters.objectSpaceNormalMap)
            _programLayers.enable(13);
          if (parameters.tangentSpaceNormalMap)
            _programLayers.enable(14);
          if (parameters.clearcoat)
            _programLayers.enable(15);
          if (parameters.clearcoatMap)
            _programLayers.enable(16);
          if (parameters.clearcoatRoughnessMap)
            _programLayers.enable(17);
          if (parameters.clearcoatNormalMap)
            _programLayers.enable(18);
          if (parameters.displacementMap)
            _programLayers.enable(19);
          if (parameters.specularMap)
            _programLayers.enable(20);
          if (parameters.roughnessMap)
            _programLayers.enable(21);
          if (parameters.metalnessMap)
            _programLayers.enable(22);
          if (parameters.gradientMap)
            _programLayers.enable(23);
          if (parameters.alphaMap)
            _programLayers.enable(24);
          if (parameters.alphaTest)
            _programLayers.enable(25);
          if (parameters.vertexColors)
            _programLayers.enable(26);
          if (parameters.vertexAlphas)
            _programLayers.enable(27);
          if (parameters.vertexUvs)
            _programLayers.enable(28);
          if (parameters.vertexTangents)
            _programLayers.enable(29);
          if (parameters.uvsVertexOnly)
            _programLayers.enable(30);
          if (parameters.fog)
            _programLayers.enable(31);
          array.push(_programLayers.mask);
          _programLayers.disableAll();
          if (parameters.useFog)
            _programLayers.enable(0);
          if (parameters.flatShading)
            _programLayers.enable(1);
          if (parameters.logarithmicDepthBuffer)
            _programLayers.enable(2);
          if (parameters.skinning)
            _programLayers.enable(3);
          if (parameters.useVertexTexture)
            _programLayers.enable(4);
          if (parameters.morphTargets)
            _programLayers.enable(5);
          if (parameters.morphNormals)
            _programLayers.enable(6);
          if (parameters.premultipliedAlpha)
            _programLayers.enable(7);
          if (parameters.shadowMapEnabled)
            _programLayers.enable(8);
          if (parameters.physicallyCorrectLights)
            _programLayers.enable(9);
          if (parameters.doubleSided)
            _programLayers.enable(10);
          if (parameters.flipSided)
            _programLayers.enable(11);
          if (parameters.depthPacking)
            _programLayers.enable(12);
          if (parameters.dithering)
            _programLayers.enable(13);
          if (parameters.specularIntensityMap)
            _programLayers.enable(14);
          if (parameters.specularColorMap)
            _programLayers.enable(15);
          if (parameters.transmission)
            _programLayers.enable(16);
          if (parameters.transmissionMap)
            _programLayers.enable(17);
          if (parameters.thicknessMap)
            _programLayers.enable(18);
          if (parameters.sheen)
            _programLayers.enable(19);
          if (parameters.sheenColorMap)
            _programLayers.enable(20);
          if (parameters.sheenRoughnessMap)
            _programLayers.enable(21);
          if (parameters.decodeVideoTexture)
            _programLayers.enable(22);
          if (parameters.transparent)
            _programLayers.enable(23);
          array.push(_programLayers.mask);
        }
        function getUniforms(material) {
          const shaderID = shaderIDs[material.type];
          let uniforms;
          if (shaderID) {
            const shader = ShaderLib2[shaderID];
            uniforms = UniformsUtils2.clone(shader.uniforms);
          } else {
            uniforms = material.uniforms;
          }
          return uniforms;
        }
        function acquireProgram(parameters, cacheKey) {
          let program;
          for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
            const preexistingProgram = programs[p2];
            if (preexistingProgram.cacheKey === cacheKey) {
              program = preexistingProgram;
              ++program.usedTimes;
              break;
            }
          }
          if (program === void 0) {
            program = new WebGLProgram2(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
          }
          return program;
        }
        function releaseProgram(program) {
          if (--program.usedTimes === 0) {
            const i2 = programs.indexOf(program);
            programs[i2] = programs[programs.length - 1];
            programs.pop();
            program.destroy();
          }
        }
        function releaseShaderCache(material) {
          _customShaders.remove(material);
        }
        function dispose() {
          _customShaders.dispose();
        }
        return {
          getParameters,
          getProgramCacheKey,
          getUniforms,
          acquireProgram,
          releaseProgram,
          releaseShaderCache,
          programs,
          dispose
        };
      }
      function WebGLProperties2() {
        let properties = /* @__PURE__ */ new WeakMap();
        function get(object) {
          let map = properties.get(object);
          if (map === void 0) {
            map = {};
            properties.set(object, map);
          }
          return map;
        }
        function remove(object) {
          properties.delete(object);
        }
        function update(object, key, value) {
          properties.get(object)[key] = value;
        }
        function dispose() {
          properties = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          remove,
          update,
          dispose
        };
      }
      function painterSortStable2(a, b) {
        if (a.groupOrder !== b.groupOrder) {
          return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
          return a.renderOrder - b.renderOrder;
        } else if (a.material.id !== b.material.id) {
          return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
          return a.z - b.z;
        } else {
          return a.id - b.id;
        }
      }
      function reversePainterSortStable2(a, b) {
        if (a.groupOrder !== b.groupOrder) {
          return a.groupOrder - b.groupOrder;
        } else if (a.renderOrder !== b.renderOrder) {
          return a.renderOrder - b.renderOrder;
        } else if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return a.id - b.id;
        }
      }
      function WebGLRenderList2() {
        const renderItems = [];
        let renderItemsIndex = 0;
        const opaque = [];
        const transmissive = [];
        const transparent = [];
        function init10() {
          renderItemsIndex = 0;
          opaque.length = 0;
          transmissive.length = 0;
          transparent.length = 0;
        }
        function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
          let renderItem = renderItems[renderItemsIndex];
          if (renderItem === void 0) {
            renderItem = {
              id: object.id,
              object,
              geometry,
              material,
              groupOrder,
              renderOrder: object.renderOrder,
              z,
              group
            };
            renderItems[renderItemsIndex] = renderItem;
          } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z;
            renderItem.group = group;
          }
          renderItemsIndex++;
          return renderItem;
        }
        function push(object, geometry, material, groupOrder, z, group) {
          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
          if (material.transmission > 0) {
            transmissive.push(renderItem);
          } else if (material.transparent === true) {
            transparent.push(renderItem);
          } else {
            opaque.push(renderItem);
          }
        }
        function unshift(object, geometry, material, groupOrder, z, group) {
          const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
          if (material.transmission > 0) {
            transmissive.unshift(renderItem);
          } else if (material.transparent === true) {
            transparent.unshift(renderItem);
          } else {
            opaque.unshift(renderItem);
          }
        }
        function sort(customOpaqueSort, customTransparentSort) {
          if (opaque.length > 1)
            opaque.sort(customOpaqueSort || painterSortStable2);
          if (transmissive.length > 1)
            transmissive.sort(customTransparentSort || reversePainterSortStable2);
          if (transparent.length > 1)
            transparent.sort(customTransparentSort || reversePainterSortStable2);
        }
        function finish() {
          for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
            const renderItem = renderItems[i2];
            if (renderItem.id === null)
              break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.group = null;
          }
        }
        return {
          opaque,
          transmissive,
          transparent,
          init: init10,
          push,
          unshift,
          finish,
          sort
        };
      }
      function WebGLRenderLists2() {
        let lists = /* @__PURE__ */ new WeakMap();
        function get(scene, renderCallDepth) {
          let list;
          if (lists.has(scene) === false) {
            list = new WebGLRenderList2();
            lists.set(scene, [list]);
          } else {
            if (renderCallDepth >= lists.get(scene).length) {
              list = new WebGLRenderList2();
              lists.get(scene).push(list);
            } else {
              list = lists.get(scene)[renderCallDepth];
            }
          }
          return list;
        }
        function dispose() {
          lists = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      function UniformsCache2() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  direction: new Vector32(),
                  color: new Color2()
                };
                break;
              case "SpotLight":
                uniforms = {
                  position: new Vector32(),
                  direction: new Vector32(),
                  color: new Color2(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                uniforms = {
                  position: new Vector32(),
                  color: new Color2(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                uniforms = {
                  direction: new Vector32(),
                  skyColor: new Color2(),
                  groundColor: new Color2()
                };
                break;
              case "RectAreaLight":
                uniforms = {
                  color: new Color2(),
                  position: new Vector32(),
                  halfWidth: new Vector32(),
                  halfHeight: new Vector32()
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      function ShadowUniformsCache2() {
        const lights = {};
        return {
          get: function(light) {
            if (lights[light.id] !== void 0) {
              return lights[light.id];
            }
            let uniforms;
            switch (light.type) {
              case "DirectionalLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector22()
                };
                break;
              case "SpotLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector22()
                };
                break;
              case "PointLight":
                uniforms = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Vector22(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
          }
        };
      }
      var nextVersion2 = 0;
      function shadowCastingLightsFirst2(lightA, lightB) {
        return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
      }
      function WebGLLights2(extensions, capabilities) {
        const cache = new UniformsCache2();
        const shadowCache = ShadowUniformsCache2();
        const state = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: []
        };
        for (let i2 = 0; i2 < 9; i2++)
          state.probe.push(new Vector32());
        const vector3 = new Vector32();
        const matrix4 = new Matrix42();
        const matrix42 = new Matrix42();
        function setup(lights, physicallyCorrectLights) {
          let r = 0, g = 0, b = 0;
          for (let i2 = 0; i2 < 9; i2++)
            state.probe[i2].set(0, 0, 0);
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          let numDirectionalShadows = 0;
          let numPointShadows = 0;
          let numSpotShadows = 0;
          lights.sort(shadowCastingLightsFirst2);
          const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
          for (let i2 = 0, l = lights.length; i2 < l; i2++) {
            const light = lights[i2];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
              r += color.r * intensity * scaleFactor;
              g += color.g * intensity * scaleFactor;
              b += color.b * intensity * scaleFactor;
            } else if (light.isLightProbe) {
              for (let j = 0; j < 9; j++) {
                state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
              }
            } else if (light.isDirectionalLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state.directionalShadow[directionalLength] = shadowUniforms;
                state.directionalShadowMap[directionalLength] = shadowMap;
                state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                numDirectionalShadows++;
              }
              state.directional[directionalLength] = uniforms;
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = cache.get(light);
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
              uniforms.distance = distance;
              uniforms.coneCos = Math.cos(light.angle);
              uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                state.spotShadow[spotLength] = shadowUniforms;
                state.spotShadowMap[spotLength] = shadowMap;
                state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                numSpotShadows++;
              }
              state.spot[spotLength] = uniforms;
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(color).multiplyScalar(intensity);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              state.rectArea[rectAreaLength] = uniforms;
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = cache.get(light);
              uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
              uniforms.distance = light.distance;
              uniforms.decay = light.decay;
              if (light.castShadow) {
                const shadow = light.shadow;
                const shadowUniforms = shadowCache.get(light);
                shadowUniforms.shadowBias = shadow.bias;
                shadowUniforms.shadowNormalBias = shadow.normalBias;
                shadowUniforms.shadowRadius = shadow.radius;
                shadowUniforms.shadowMapSize = shadow.mapSize;
                shadowUniforms.shadowCameraNear = shadow.camera.near;
                shadowUniforms.shadowCameraFar = shadow.camera.far;
                state.pointShadow[pointLength] = shadowUniforms;
                state.pointShadowMap[pointLength] = shadowMap;
                state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                numPointShadows++;
              }
              state.point[pointLength] = uniforms;
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = cache.get(light);
              uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
              uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
              state.hemi[hemiLength] = uniforms;
              hemiLength++;
            }
          }
          if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
              state.rectAreaLTC1 = UniformsLib2.LTC_FLOAT_1;
              state.rectAreaLTC2 = UniformsLib2.LTC_FLOAT_2;
            } else {
              if (extensions.has("OES_texture_float_linear") === true) {
                state.rectAreaLTC1 = UniformsLib2.LTC_FLOAT_1;
                state.rectAreaLTC2 = UniformsLib2.LTC_FLOAT_2;
              } else if (extensions.has("OES_texture_half_float_linear") === true) {
                state.rectAreaLTC1 = UniformsLib2.LTC_HALF_1;
                state.rectAreaLTC2 = UniformsLib2.LTC_HALF_2;
              } else {
                console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
              }
            }
          }
          state.ambient[0] = r;
          state.ambient[1] = g;
          state.ambient[2] = b;
          const hash = state.hash;
          if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion2++;
          }
        }
        function setupView(lights, camera) {
          let directionalLength = 0;
          let pointLength = 0;
          let spotLength = 0;
          let rectAreaLength = 0;
          let hemiLength = 0;
          const viewMatrix = camera.matrixWorldInverse;
          for (let i2 = 0, l = lights.length; i2 < l; i2++) {
            const light = lights[i2];
            if (light.isDirectionalLight) {
              const uniforms = state.directional[directionalLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              directionalLength++;
            } else if (light.isSpotLight) {
              const uniforms = state.spot[spotLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              vector3.setFromMatrixPosition(light.target.matrixWorld);
              uniforms.direction.sub(vector3);
              uniforms.direction.transformDirection(viewMatrix);
              spotLength++;
            } else if (light.isRectAreaLight) {
              const uniforms = state.rectArea[rectAreaLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              matrix42.identity();
              matrix4.copy(light.matrixWorld);
              matrix4.premultiply(viewMatrix);
              matrix42.extractRotation(matrix4);
              uniforms.halfWidth.set(light.width * 0.5, 0, 0);
              uniforms.halfHeight.set(0, light.height * 0.5, 0);
              uniforms.halfWidth.applyMatrix4(matrix42);
              uniforms.halfHeight.applyMatrix4(matrix42);
              rectAreaLength++;
            } else if (light.isPointLight) {
              const uniforms = state.point[pointLength];
              uniforms.position.setFromMatrixPosition(light.matrixWorld);
              uniforms.position.applyMatrix4(viewMatrix);
              pointLength++;
            } else if (light.isHemisphereLight) {
              const uniforms = state.hemi[hemiLength];
              uniforms.direction.setFromMatrixPosition(light.matrixWorld);
              uniforms.direction.transformDirection(viewMatrix);
              uniforms.direction.normalize();
              hemiLength++;
            }
          }
        }
        return {
          setup,
          setupView,
          state
        };
      }
      function WebGLRenderState2(extensions, capabilities) {
        const lights = new WebGLLights2(extensions, capabilities);
        const lightsArray = [];
        const shadowsArray = [];
        function init10() {
          lightsArray.length = 0;
          shadowsArray.length = 0;
        }
        function pushLight(light) {
          lightsArray.push(light);
        }
        function pushShadow(shadowLight) {
          shadowsArray.push(shadowLight);
        }
        function setupLights(physicallyCorrectLights) {
          lights.setup(lightsArray, physicallyCorrectLights);
        }
        function setupLightsView(camera) {
          lights.setupView(lightsArray, camera);
        }
        const state = {
          lightsArray,
          shadowsArray,
          lights
        };
        return {
          init: init10,
          state,
          setupLights,
          setupLightsView,
          pushLight,
          pushShadow
        };
      }
      function WebGLRenderStates2(extensions, capabilities) {
        let renderStates = /* @__PURE__ */ new WeakMap();
        function get(scene, renderCallDepth = 0) {
          let renderState;
          if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState2(extensions, capabilities);
            renderStates.set(scene, [renderState]);
          } else {
            if (renderCallDepth >= renderStates.get(scene).length) {
              renderState = new WebGLRenderState2(extensions, capabilities);
              renderStates.get(scene).push(renderState);
            } else {
              renderState = renderStates.get(scene)[renderCallDepth];
            }
          }
          return renderState;
        }
        function dispose() {
          renderStates = /* @__PURE__ */ new WeakMap();
        }
        return {
          get,
          dispose
        };
      }
      var MeshDepthMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "MeshDepthMaterial";
          this.depthPacking = BasicDepthPacking2;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.depthPacking = source.depthPacking;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          return this;
        }
      };
      MeshDepthMaterial2.prototype.isMeshDepthMaterial = true;
      var MeshDistanceMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new Vector32();
          this.nearDistance = 1;
          this.farDistance = 1e3;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.fog = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.referencePosition.copy(source.referencePosition);
          this.nearDistance = source.nearDistance;
          this.farDistance = source.farDistance;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          return this;
        }
      };
      MeshDistanceMaterial2.prototype.isMeshDistanceMaterial = true;
      var vertex2 = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
      var fragment2 = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      function WebGLShadowMap2(_renderer, _objects, _capabilities) {
        let _frustum = new Frustum2();
        const _shadowMapSize = new Vector22(), _viewportSize = new Vector22(), _viewport = new Vector42(), _depthMaterial = new MeshDepthMaterial2({
          depthPacking: RGBADepthPacking2
        }), _distanceMaterial = new MeshDistanceMaterial2(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
        const shadowSide = {
          0: BackSide2,
          1: FrontSide2,
          2: DoubleSide3
        };
        const shadowMaterialVertical = new ShaderMaterial2({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new Vector22()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: vertex2,
          fragmentShader: fragment2
        });
        const shadowMaterialHorizontal = shadowMaterialVertical.clone();
        shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
        const fullScreenTri = new BufferGeometry2();
        fullScreenTri.setAttribute("position", new BufferAttribute2(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const fullScreenMesh = new Mesh2(fullScreenTri, shadowMaterialVertical);
        const scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap2;
        this.render = function(lights, scene, camera) {
          if (scope.enabled === false)
            return;
          if (scope.autoUpdate === false && scope.needsUpdate === false)
            return;
          if (lights.length === 0)
            return;
          const currentRenderTarget = _renderer.getRenderTarget();
          const activeCubeFace = _renderer.getActiveCubeFace();
          const activeMipmapLevel = _renderer.getActiveMipmapLevel();
          const _state = _renderer.state;
          _state.setBlending(NoBlending2);
          _state.buffers.color.setClear(1, 1, 1, 1);
          _state.buffers.depth.setTest(true);
          _state.setScissorTest(false);
          for (let i2 = 0, il = lights.length; i2 < il; i2++) {
            const light = lights[i2];
            const shadow = light.shadow;
            if (shadow === void 0) {
              console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
              continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false)
              continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
              if (_shadowMapSize.x > _maxTextureSize) {
                _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                shadow.mapSize.x = _viewportSize.x;
              }
              if (_shadowMapSize.y > _maxTextureSize) {
                _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                shadow.mapSize.y = _viewportSize.y;
              }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap2) {
              const pars = {
                minFilter: LinearFilter2,
                magFilter: LinearFilter2,
                format: RGBAFormat2
              };
              shadow.map = new WebGLRenderTarget3(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.mapPass = new WebGLRenderTarget3(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
              const pars = {
                minFilter: NearestFilter2,
                magFilter: NearestFilter2,
                format: RGBAFormat2
              };
              shadow.map = new WebGLRenderTarget3(_shadowMapSize.x, _shadowMapSize.y, pars);
              shadow.map.texture.name = light.name + ".shadowMap";
              shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for (let vp = 0; vp < viewportCount; vp++) {
              const viewport = shadow.getViewport(vp);
              _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
              _state.viewport(_viewport);
              shadow.updateMatrices(light, vp);
              _frustum = shadow.getFrustum();
              renderObject(scene, camera, shadow.camera, light, this.type);
            }
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap2) {
              VSMPass(shadow, camera);
            }
            shadow.needsUpdate = false;
          }
          scope.needsUpdate = false;
          _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
        };
        function VSMPass(shadow, camera) {
          const geometry = _objects.update(fullScreenMesh);
          if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
            shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialVertical.needsUpdate = true;
            shadowMaterialHorizontal.needsUpdate = true;
          }
          shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
          shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialVertical.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.mapPass);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
          shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
          shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
          shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
          _renderer.setRenderTarget(shadow.map);
          _renderer.clear();
          _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
        }
        function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
          let result = null;
          const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
          if (customMaterial !== void 0) {
            result = customMaterial;
          } else {
            result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
          }
          if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === void 0) {
              materialsForVariant = {};
              _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === void 0) {
              cachedMaterial = result.clone();
              materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
          }
          result.visible = material.visible;
          result.wireframe = material.wireframe;
          if (type === VSMShadowMap2) {
            result.side = material.shadowSide !== null ? material.shadowSide : material.side;
          } else {
            result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
          }
          result.alphaMap = material.alphaMap;
          result.alphaTest = material.alphaTest;
          result.clipShadows = material.clipShadows;
          result.clippingPlanes = material.clippingPlanes;
          result.clipIntersection = material.clipIntersection;
          result.displacementMap = material.displacementMap;
          result.displacementScale = material.displacementScale;
          result.displacementBias = material.displacementBias;
          result.wireframeLinewidth = material.wireframeLinewidth;
          result.linewidth = material.linewidth;
          if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
          }
          return result;
        }
        function renderObject(object, camera, shadowCamera, light, type) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap2) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
              object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              const geometry = _objects.update(object);
              const material = object.material;
              if (Array.isArray(material)) {
                const groups = geometry.groups;
                for (let k = 0, kl = groups.length; k < kl; k++) {
                  const group = groups[k];
                  const groupMaterial = material[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                  }
                }
              } else if (material.visible) {
                const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
              }
            }
          }
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            renderObject(children[i2], camera, shadowCamera, light, type);
          }
        }
      }
      function WebGLState2(gl, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function ColorBuffer() {
          let locked = false;
          const color = new Vector42();
          let currentColorMask = null;
          const currentColorClear = new Vector42(0, 0, 0, 0);
          return {
            setMask: function(colorMask) {
              if (currentColorMask !== colorMask && !locked) {
                gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                currentColorMask = colorMask;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(r, g, b, a, premultipliedAlpha) {
              if (premultipliedAlpha === true) {
                r *= a;
                g *= a;
                b *= a;
              }
              color.set(r, g, b, a);
              if (currentColorClear.equals(color) === false) {
                gl.clearColor(r, g, b, a);
                currentColorClear.copy(color);
              }
            },
            reset: function() {
              locked = false;
              currentColorMask = null;
              currentColorClear.set(-1, 0, 0, 0);
            }
          };
        }
        function DepthBuffer() {
          let locked = false;
          let currentDepthMask = null;
          let currentDepthFunc = null;
          let currentDepthClear = null;
          return {
            setTest: function(depthTest) {
              if (depthTest) {
                enable(gl.DEPTH_TEST);
              } else {
                disable(gl.DEPTH_TEST);
              }
            },
            setMask: function(depthMask) {
              if (currentDepthMask !== depthMask && !locked) {
                gl.depthMask(depthMask);
                currentDepthMask = depthMask;
              }
            },
            setFunc: function(depthFunc) {
              if (currentDepthFunc !== depthFunc) {
                if (depthFunc) {
                  switch (depthFunc) {
                    case NeverDepth2:
                      gl.depthFunc(gl.NEVER);
                      break;
                    case AlwaysDepth2:
                      gl.depthFunc(gl.ALWAYS);
                      break;
                    case LessDepth2:
                      gl.depthFunc(gl.LESS);
                      break;
                    case LessEqualDepth2:
                      gl.depthFunc(gl.LEQUAL);
                      break;
                    case EqualDepth2:
                      gl.depthFunc(gl.EQUAL);
                      break;
                    case GreaterEqualDepth2:
                      gl.depthFunc(gl.GEQUAL);
                      break;
                    case GreaterDepth2:
                      gl.depthFunc(gl.GREATER);
                      break;
                    case NotEqualDepth2:
                      gl.depthFunc(gl.NOTEQUAL);
                      break;
                    default:
                      gl.depthFunc(gl.LEQUAL);
                  }
                } else {
                  gl.depthFunc(gl.LEQUAL);
                }
                currentDepthFunc = depthFunc;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(depth) {
              if (currentDepthClear !== depth) {
                gl.clearDepth(depth);
                currentDepthClear = depth;
              }
            },
            reset: function() {
              locked = false;
              currentDepthMask = null;
              currentDepthFunc = null;
              currentDepthClear = null;
            }
          };
        }
        function StencilBuffer() {
          let locked = false;
          let currentStencilMask = null;
          let currentStencilFunc = null;
          let currentStencilRef = null;
          let currentStencilFuncMask = null;
          let currentStencilFail = null;
          let currentStencilZFail = null;
          let currentStencilZPass = null;
          let currentStencilClear = null;
          return {
            setTest: function(stencilTest) {
              if (!locked) {
                if (stencilTest) {
                  enable(gl.STENCIL_TEST);
                } else {
                  disable(gl.STENCIL_TEST);
                }
              }
            },
            setMask: function(stencilMask) {
              if (currentStencilMask !== stencilMask && !locked) {
                gl.stencilMask(stencilMask);
                currentStencilMask = stencilMask;
              }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
              if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                currentStencilFunc = stencilFunc;
                currentStencilRef = stencilRef;
                currentStencilFuncMask = stencilMask;
              }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
              if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                currentStencilFail = stencilFail;
                currentStencilZFail = stencilZFail;
                currentStencilZPass = stencilZPass;
              }
            },
            setLocked: function(lock) {
              locked = lock;
            },
            setClear: function(stencil) {
              if (currentStencilClear !== stencil) {
                gl.clearStencil(stencil);
                currentStencilClear = stencil;
              }
            },
            reset: function() {
              locked = false;
              currentStencilMask = null;
              currentStencilFunc = null;
              currentStencilRef = null;
              currentStencilFuncMask = null;
              currentStencilFail = null;
              currentStencilZFail = null;
              currentStencilZPass = null;
              currentStencilClear = null;
            }
          };
        }
        const colorBuffer = new ColorBuffer();
        const depthBuffer = new DepthBuffer();
        const stencilBuffer = new StencilBuffer();
        let enabledCapabilities = {};
        let currentBoundFramebuffers = {};
        let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
        let defaultDrawbuffers = [];
        let currentProgram = null;
        let currentBlendingEnabled = false;
        let currentBlending = null;
        let currentBlendEquation = null;
        let currentBlendSrc = null;
        let currentBlendDst = null;
        let currentBlendEquationAlpha = null;
        let currentBlendSrcAlpha = null;
        let currentBlendDstAlpha = null;
        let currentPremultipledAlpha = false;
        let currentFlipSided = null;
        let currentCullFace = null;
        let currentLineWidth = null;
        let currentPolygonOffsetFactor = null;
        let currentPolygonOffsetUnits = null;
        const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let lineWidthAvailable = false;
        let version = 0;
        const glVersion = gl.getParameter(gl.VERSION);
        if (glVersion.indexOf("WebGL") !== -1) {
          version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 1;
        } else if (glVersion.indexOf("OpenGL ES") !== -1) {
          version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
          lineWidthAvailable = version >= 2;
        }
        let currentTextureSlot = null;
        let currentBoundTextures = {};
        const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
        const viewportParam = gl.getParameter(gl.VIEWPORT);
        const currentScissor = new Vector42().fromArray(scissorParam);
        const currentViewport = new Vector42().fromArray(viewportParam);
        function createTexture(type, target, count) {
          const data = new Uint8Array(4);
          const texture = gl.createTexture();
          gl.bindTexture(type, texture);
          gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          for (let i2 = 0; i2 < count; i2++) {
            gl.texImage2D(target + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
          }
          return texture;
        }
        const emptyTextures = {};
        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(gl.DEPTH_TEST);
        depthBuffer.setFunc(LessEqualDepth2);
        setFlipSided(false);
        setCullFace(CullFaceBack2);
        enable(gl.CULL_FACE);
        setBlending(NoBlending2);
        function enable(id) {
          if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
          }
        }
        function disable(id) {
          if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
          }
        }
        function bindFramebuffer(target, framebuffer) {
          if (currentBoundFramebuffers[target] !== framebuffer) {
            gl.bindFramebuffer(target, framebuffer);
            currentBoundFramebuffers[target] = framebuffer;
            if (isWebGL2) {
              if (target === gl.DRAW_FRAMEBUFFER) {
                currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
              }
              if (target === gl.FRAMEBUFFER) {
                currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
              }
            }
            return true;
          }
          return false;
        }
        function drawBuffers(renderTarget, framebuffer) {
          let drawBuffers2 = defaultDrawbuffers;
          let needsUpdate = false;
          if (renderTarget) {
            drawBuffers2 = currentDrawbuffers.get(framebuffer);
            if (drawBuffers2 === void 0) {
              drawBuffers2 = [];
              currentDrawbuffers.set(framebuffer, drawBuffers2);
            }
            if (renderTarget.isWebGLMultipleRenderTargets) {
              const textures = renderTarget.texture;
              if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
                for (let i2 = 0, il = textures.length; i2 < il; i2++) {
                  drawBuffers2[i2] = gl.COLOR_ATTACHMENT0 + i2;
                }
                drawBuffers2.length = textures.length;
                needsUpdate = true;
              }
            } else {
              if (drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
                drawBuffers2[0] = gl.COLOR_ATTACHMENT0;
                needsUpdate = true;
              }
            }
          } else {
            if (drawBuffers2[0] !== gl.BACK) {
              drawBuffers2[0] = gl.BACK;
              needsUpdate = true;
            }
          }
          if (needsUpdate) {
            if (capabilities.isWebGL2) {
              gl.drawBuffers(drawBuffers2);
            } else {
              extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
            }
          }
        }
        function useProgram(program) {
          if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
          }
          return false;
        }
        const equationToGL = {
          [AddEquation2]: gl.FUNC_ADD,
          [SubtractEquation2]: gl.FUNC_SUBTRACT,
          [ReverseSubtractEquation2]: gl.FUNC_REVERSE_SUBTRACT
        };
        if (isWebGL2) {
          equationToGL[MinEquation2] = gl.MIN;
          equationToGL[MaxEquation2] = gl.MAX;
        } else {
          const extension = extensions.get("EXT_blend_minmax");
          if (extension !== null) {
            equationToGL[MinEquation2] = extension.MIN_EXT;
            equationToGL[MaxEquation2] = extension.MAX_EXT;
          }
        }
        const factorToGL = {
          [ZeroFactor2]: gl.ZERO,
          [OneFactor2]: gl.ONE,
          [SrcColorFactor2]: gl.SRC_COLOR,
          [SrcAlphaFactor2]: gl.SRC_ALPHA,
          [SrcAlphaSaturateFactor2]: gl.SRC_ALPHA_SATURATE,
          [DstColorFactor2]: gl.DST_COLOR,
          [DstAlphaFactor2]: gl.DST_ALPHA,
          [OneMinusSrcColorFactor2]: gl.ONE_MINUS_SRC_COLOR,
          [OneMinusSrcAlphaFactor2]: gl.ONE_MINUS_SRC_ALPHA,
          [OneMinusDstColorFactor2]: gl.ONE_MINUS_DST_COLOR,
          [OneMinusDstAlphaFactor2]: gl.ONE_MINUS_DST_ALPHA
        };
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
          if (blending === NoBlending2) {
            if (currentBlendingEnabled === true) {
              disable(gl.BLEND);
              currentBlendingEnabled = false;
            }
            return;
          }
          if (currentBlendingEnabled === false) {
            enable(gl.BLEND);
            currentBlendingEnabled = true;
          }
          if (blending !== CustomBlending2) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
              if (currentBlendEquation !== AddEquation2 || currentBlendEquationAlpha !== AddEquation2) {
                gl.blendEquation(gl.FUNC_ADD);
                currentBlendEquation = AddEquation2;
                currentBlendEquationAlpha = AddEquation2;
              }
              if (premultipliedAlpha) {
                switch (blending) {
                  case NormalBlending2:
                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending2:
                    gl.blendFunc(gl.ONE, gl.ONE);
                    break;
                  case SubtractiveBlending2:
                    gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                    break;
                  case MultiplyBlending2:
                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              } else {
                switch (blending) {
                  case NormalBlending2:
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    break;
                  case AdditiveBlending2:
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                    break;
                  case SubtractiveBlending2:
                    gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                    break;
                  case MultiplyBlending2:
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", blending);
                    break;
                }
              }
              currentBlendSrc = null;
              currentBlendDst = null;
              currentBlendSrcAlpha = null;
              currentBlendDstAlpha = null;
              currentBlending = blending;
              currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
          }
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
          currentBlending = blending;
          currentPremultipledAlpha = null;
        }
        function setMaterial(material, frontFaceCW) {
          material.side === DoubleSide3 ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
          let flipSided = material.side === BackSide2;
          if (frontFaceCW)
            flipSided = !flipSided;
          setFlipSided(flipSided);
          material.blending === NormalBlending2 && material.transparent === false ? setBlending(NoBlending2) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
          depthBuffer.setFunc(material.depthFunc);
          depthBuffer.setTest(material.depthTest);
          depthBuffer.setMask(material.depthWrite);
          colorBuffer.setMask(material.colorWrite);
          const stencilWrite = material.stencilWrite;
          stencilBuffer.setTest(stencilWrite);
          if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
          }
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
          material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function setFlipSided(flipSided) {
          if (currentFlipSided !== flipSided) {
            if (flipSided) {
              gl.frontFace(gl.CW);
            } else {
              gl.frontFace(gl.CCW);
            }
            currentFlipSided = flipSided;
          }
        }
        function setCullFace(cullFace) {
          if (cullFace !== CullFaceNone2) {
            enable(gl.CULL_FACE);
            if (cullFace !== currentCullFace) {
              if (cullFace === CullFaceBack2) {
                gl.cullFace(gl.BACK);
              } else if (cullFace === CullFaceFront2) {
                gl.cullFace(gl.FRONT);
              } else {
                gl.cullFace(gl.FRONT_AND_BACK);
              }
            }
          } else {
            disable(gl.CULL_FACE);
          }
          currentCullFace = cullFace;
        }
        function setLineWidth(width) {
          if (width !== currentLineWidth) {
            if (lineWidthAvailable)
              gl.lineWidth(width);
            currentLineWidth = width;
          }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
          if (polygonOffset) {
            enable(gl.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
              gl.polygonOffset(factor, units);
              currentPolygonOffsetFactor = factor;
              currentPolygonOffsetUnits = units;
            }
          } else {
            disable(gl.POLYGON_OFFSET_FILL);
          }
        }
        function setScissorTest(scissorTest) {
          if (scissorTest) {
            enable(gl.SCISSOR_TEST);
          } else {
            disable(gl.SCISSOR_TEST);
          }
        }
        function activeTexture(webglSlot) {
          if (webglSlot === void 0)
            webglSlot = gl.TEXTURE0 + maxTextures - 1;
          if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
          }
        }
        function bindTexture(webglType, webglTexture) {
          if (currentTextureSlot === null) {
            activeTexture();
          }
          let boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture === void 0) {
            boundTexture = {
              type: void 0,
              texture: void 0
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
          }
          if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
          }
        }
        function unbindTexture() {
          const boundTexture = currentBoundTextures[currentTextureSlot];
          if (boundTexture !== void 0 && boundTexture.type !== void 0) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = void 0;
            boundTexture.texture = void 0;
          }
        }
        function compressedTexImage2D() {
          try {
            gl.compressedTexImage2D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texSubImage2D() {
          try {
            gl.texSubImage2D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texSubImage3D() {
          try {
            gl.texSubImage3D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function compressedTexSubImage2D() {
          try {
            gl.compressedTexSubImage2D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texStorage2D() {
          try {
            gl.texStorage2D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texStorage3D() {
          try {
            gl.texStorage3D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texImage2D() {
          try {
            gl.texImage2D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function texImage3D() {
          try {
            gl.texImage3D.apply(gl, arguments);
          } catch (error) {
            console.error("THREE.WebGLState:", error);
          }
        }
        function scissor(scissor2) {
          if (currentScissor.equals(scissor2) === false) {
            gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
            currentScissor.copy(scissor2);
          }
        }
        function viewport(viewport2) {
          if (currentViewport.equals(viewport2) === false) {
            gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
            currentViewport.copy(viewport2);
          }
        }
        function reset() {
          gl.disable(gl.BLEND);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.POLYGON_OFFSET_FILL);
          gl.disable(gl.SCISSOR_TEST);
          gl.disable(gl.STENCIL_TEST);
          gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFunc(gl.ONE, gl.ZERO);
          gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
          gl.colorMask(true, true, true, true);
          gl.clearColor(0, 0, 0, 0);
          gl.depthMask(true);
          gl.depthFunc(gl.LESS);
          gl.clearDepth(1);
          gl.stencilMask(4294967295);
          gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.clearStencil(0);
          gl.cullFace(gl.BACK);
          gl.frontFace(gl.CCW);
          gl.polygonOffset(0, 0);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          if (isWebGL2 === true) {
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
          }
          gl.useProgram(null);
          gl.lineWidth(1);
          gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          enabledCapabilities = {};
          currentTextureSlot = null;
          currentBoundTextures = {};
          currentBoundFramebuffers = {};
          currentDrawbuffers = /* @__PURE__ */ new WeakMap();
          defaultDrawbuffers = [];
          currentProgram = null;
          currentBlendingEnabled = false;
          currentBlending = null;
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentPremultipledAlpha = false;
          currentFlipSided = null;
          currentCullFace = null;
          currentLineWidth = null;
          currentPolygonOffsetFactor = null;
          currentPolygonOffsetUnits = null;
          currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
          currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
          colorBuffer.reset();
          depthBuffer.reset();
          stencilBuffer.reset();
        }
        return {
          buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
          },
          enable,
          disable,
          bindFramebuffer,
          drawBuffers,
          useProgram,
          setBlending,
          setMaterial,
          setFlipSided,
          setCullFace,
          setLineWidth,
          setPolygonOffset,
          setScissorTest,
          activeTexture,
          bindTexture,
          unbindTexture,
          compressedTexImage2D,
          texImage2D,
          texImage3D,
          texStorage2D,
          texStorage3D,
          texSubImage2D,
          texSubImage3D,
          compressedTexSubImage2D,
          scissor,
          viewport,
          reset
        };
      }
      function WebGLTextures2(_gl, extensions, state, properties, capabilities, utils, info) {
        const isWebGL2 = capabilities.isWebGL2;
        const maxTextures = capabilities.maxTextures;
        const maxCubemapSize = capabilities.maxCubemapSize;
        const maxTextureSize = capabilities.maxTextureSize;
        const maxSamples = capabilities.maxSamples;
        const hasMultisampledRenderToTexture = extensions.has("WEBGL_multisampled_render_to_texture");
        const MultisampledRenderToTextureExtension = hasMultisampledRenderToTexture ? extensions.get("WEBGL_multisampled_render_to_texture") : void 0;
        const _videoTextures = /* @__PURE__ */ new WeakMap();
        let _canvas3;
        let useOffscreenCanvas = false;
        try {
          useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch (err) {
        }
        function createCanvas(width, height) {
          return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS2("canvas");
        }
        function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
          let scale = 1;
          if (image.width > maxSize || image.height > maxSize) {
            scale = maxSize / Math.max(image.width, image.height);
          }
          if (scale < 1 || needsPowerOfTwo === true) {
            if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
              const floor2 = needsPowerOfTwo ? floorPowerOfTwo2 : Math.floor;
              const width = floor2(scale * image.width);
              const height = floor2(scale * image.height);
              if (_canvas3 === void 0)
                _canvas3 = createCanvas(width, height);
              const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas3;
              canvas.width = width;
              canvas.height = height;
              const context = canvas.getContext("2d");
              context.drawImage(image, 0, 0, width, height);
              console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
              return canvas;
            } else {
              if ("data" in image) {
                console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
              }
              return image;
            }
          }
          return image;
        }
        function isPowerOfTwo$1(image) {
          return isPowerOfTwo2(image.width) && isPowerOfTwo2(image.height);
        }
        function textureNeedsPowerOfTwo(texture) {
          if (isWebGL2)
            return false;
          return texture.wrapS !== ClampToEdgeWrapping2 || texture.wrapT !== ClampToEdgeWrapping2 || texture.minFilter !== NearestFilter2 && texture.minFilter !== LinearFilter2;
        }
        function textureNeedsGenerateMipmaps(texture, supportsMips) {
          return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter2 && texture.minFilter !== LinearFilter2;
        }
        function generateMipmap(target) {
          _gl.generateMipmap(target);
        }
        function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
          if (isWebGL2 === false)
            return glFormat;
          if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== void 0)
              return _gl[internalFormatName];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
          }
          let internalFormat = glFormat;
          if (glFormat === _gl.RED) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.R32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.R16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.R8;
          }
          if (glFormat === _gl.RG) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RG32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RG16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = _gl.RG8;
          }
          if (glFormat === _gl.RGBA) {
            if (glType === _gl.FLOAT)
              internalFormat = _gl.RGBA32F;
            if (glType === _gl.HALF_FLOAT)
              internalFormat = _gl.RGBA16F;
            if (glType === _gl.UNSIGNED_BYTE)
              internalFormat = encoding === sRGBEncoding2 && isVideoTexture === false ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
            if (glType === _gl.UNSIGNED_SHORT_4_4_4_4)
              internalFormat = _gl.RGBA4;
            if (glType === _gl.UNSIGNED_SHORT_5_5_5_1)
              internalFormat = _gl.RGB5_A1;
          }
          if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
            extensions.get("EXT_color_buffer_float");
          }
          return internalFormat;
        }
        function getMipLevels(texture, image, supportsMips) {
          if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter2 && texture.minFilter !== LinearFilter2) {
            return Math.log2(Math.max(image.width, image.height)) + 1;
          } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
            return texture.mipmaps.length;
          } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
            return image.mipmaps.length;
          } else {
            return 1;
          }
        }
        function filterFallback(f) {
          if (f === NearestFilter2 || f === NearestMipmapNearestFilter2 || f === NearestMipmapLinearFilter2) {
            return _gl.NEAREST;
          }
          return _gl.LINEAR;
        }
        function onTextureDispose(event) {
          const texture = event.target;
          texture.removeEventListener("dispose", onTextureDispose);
          deallocateTexture(texture);
          if (texture.isVideoTexture) {
            _videoTextures.delete(texture);
          }
          info.memory.textures--;
        }
        function onRenderTargetDispose(event) {
          const renderTarget = event.target;
          renderTarget.removeEventListener("dispose", onRenderTargetDispose);
          deallocateRenderTarget(renderTarget);
        }
        function deallocateTexture(texture) {
          const textureProperties = properties.get(texture);
          if (textureProperties.__webglInit === void 0)
            return;
          _gl.deleteTexture(textureProperties.__webglTexture);
          properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          if (!renderTarget)
            return;
          if (textureProperties.__webglTexture !== void 0) {
            _gl.deleteTexture(textureProperties.__webglTexture);
            info.memory.textures--;
          }
          if (renderTarget.depthTexture) {
            renderTarget.depthTexture.dispose();
          }
          if (renderTarget.isWebGLCubeRenderTarget) {
            for (let i2 = 0; i2 < 6; i2++) {
              _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
              if (renderTargetProperties.__webglDepthbuffer)
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
            }
          } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer)
              _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer)
              _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
          }
          if (renderTarget.isWebGLMultipleRenderTargets) {
            for (let i2 = 0, il = texture.length; i2 < il; i2++) {
              const attachmentProperties = properties.get(texture[i2]);
              if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
              }
              properties.remove(texture[i2]);
            }
          }
          properties.remove(texture);
          properties.remove(renderTarget);
        }
        let textureUnits = 0;
        function resetTextureUnits() {
          textureUnits = 0;
        }
        function allocateTextureUnit() {
          const textureUnit = textureUnits;
          if (textureUnit >= maxTextures) {
            console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
          }
          textureUnits += 1;
          return textureUnit;
        }
        function setTexture2D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.isVideoTexture)
            updateVideoTexture(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === void 0) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            } else if (image.complete === false) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            } else {
              uploadTexture(textureProperties, texture, slot);
              return;
            }
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTexture2DArray(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
        }
        function setTexture3D(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
          const textureProperties = properties.get(texture);
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
          }
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        }
        const wrappingToGL = {
          [RepeatWrapping2]: _gl.REPEAT,
          [ClampToEdgeWrapping2]: _gl.CLAMP_TO_EDGE,
          [MirroredRepeatWrapping2]: _gl.MIRRORED_REPEAT
        };
        const filterToGL = {
          [NearestFilter2]: _gl.NEAREST,
          [NearestMipmapNearestFilter2]: _gl.NEAREST_MIPMAP_NEAREST,
          [NearestMipmapLinearFilter2]: _gl.NEAREST_MIPMAP_LINEAR,
          [LinearFilter2]: _gl.LINEAR,
          [LinearMipmapNearestFilter2]: _gl.LINEAR_MIPMAP_NEAREST,
          [LinearMipmapLinearFilter2]: _gl.LINEAR_MIPMAP_LINEAR
        };
        function setTextureParameters(textureType, texture, supportsMips) {
          if (supportsMips) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
          } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
              _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
            }
            if (texture.wrapS !== ClampToEdgeWrapping2 || texture.wrapT !== ClampToEdgeWrapping2) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter2 && texture.minFilter !== LinearFilter2) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
            }
          }
          if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            if (texture.type === FloatType2 && extensions.has("OES_texture_float_linear") === false)
              return;
            if (isWebGL2 === false && texture.type === HalfFloatType2 && extensions.has("OES_texture_half_float_linear") === false)
              return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
              _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
              properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
          }
        }
        function initTexture(textureProperties, texture) {
          if (textureProperties.__webglInit === void 0) {
            textureProperties.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
        function uploadTexture(textureProperties, texture, slot) {
          let textureType = _gl.TEXTURE_2D;
          if (texture.isDataTexture2DArray)
            textureType = _gl.TEXTURE_2D_ARRAY;
          if (texture.isDataTexture3D)
            textureType = _gl.TEXTURE_3D;
          initTexture(textureProperties, texture);
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(textureType, textureProperties.__webglTexture);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
          _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
          const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
          let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
          image = verifyColorSpace(texture, image);
          const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
          let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
          setTextureParameters(textureType, texture, supportsMips);
          let mipmap;
          const mipmaps = texture.mipmaps;
          const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
          const allocateMemory = textureProperties.__version === void 0;
          const levels = getMipLevels(texture, image, supportsMips);
          if (texture.isDepthTexture) {
            glInternalFormat = _gl.DEPTH_COMPONENT;
            if (isWebGL2) {
              if (texture.type === FloatType2) {
                glInternalFormat = _gl.DEPTH_COMPONENT32F;
              } else if (texture.type === UnsignedIntType2) {
                glInternalFormat = _gl.DEPTH_COMPONENT24;
              } else if (texture.type === UnsignedInt248Type2) {
                glInternalFormat = _gl.DEPTH24_STENCIL8;
              } else {
                glInternalFormat = _gl.DEPTH_COMPONENT16;
              }
            } else {
              if (texture.type === FloatType2) {
                console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
              }
            }
            if (texture.format === DepthFormat2 && glInternalFormat === _gl.DEPTH_COMPONENT) {
              if (texture.type !== UnsignedShortType2 && texture.type !== UnsignedIntType2) {
                console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                texture.type = UnsignedShortType2;
                glType = utils.convert(texture.type);
              }
            }
            if (texture.format === DepthStencilFormat2 && glInternalFormat === _gl.DEPTH_COMPONENT) {
              glInternalFormat = _gl.DEPTH_STENCIL;
              if (texture.type !== UnsignedInt248Type2) {
                console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                texture.type = UnsignedInt248Type2;
                glType = utils.convert(texture.type);
              }
            }
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
          } else if (texture.isDataTexture) {
            if (mipmaps.length > 0 && supportsMips) {
              if (useTexStorage && allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
              }
              for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
                mipmap = mipmaps[i2];
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
              texture.generateMipmaps = false;
            } else {
              if (useTexStorage) {
                if (allocateMemory) {
                  state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                }
                state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
              }
            }
          } else if (texture.isCompressedTexture) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
              mipmap = mipmaps[i2];
              if (texture.format !== RGBAFormat2) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  } else {
                    state.compressedTexImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          } else if (texture.isDataTexture2DArray) {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
              }
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            } else {
              state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            }
          } else if (texture.isDataTexture3D) {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
              }
              state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            } else {
              state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            }
          } else if (texture.isFramebufferTexture) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
          } else {
            if (mipmaps.length > 0 && supportsMips) {
              if (useTexStorage && allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
              }
              for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
                mipmap = mipmaps[i2];
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, glFormat, glType, mipmap);
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
                }
              }
              texture.generateMipmaps = false;
            } else {
              if (useTexStorage) {
                if (allocateMemory) {
                  state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                }
                state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
              }
            }
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(textureType);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        }
        function uploadCubeTexture(textureProperties, texture, slot) {
          if (texture.image.length !== 6)
            return;
          initTexture(textureProperties, texture);
          state.activeTexture(_gl.TEXTURE0 + slot);
          state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
          _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
          const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
          const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
          const cubeImage = [];
          for (let i2 = 0; i2 < 6; i2++) {
            if (!isCompressed && !isDataTexture) {
              cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
            } else {
              cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
            }
            cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
          }
          const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
          const allocateMemory = textureProperties.__version === void 0;
          let levels = getMipLevels(texture, image, supportsMips);
          setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
          let mipmaps;
          if (isCompressed) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
            }
            for (let i2 = 0; i2 < 6; i2++) {
              mipmaps = cubeImage[i2].mipmaps;
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                if (texture.format !== RGBAFormat2) {
                  if (glFormat !== null) {
                    if (useTexStorage) {
                      state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                    } else {
                      state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    }
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                  }
                } else {
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                  } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
              }
            }
          } else {
            mipmaps = texture.mipmaps;
            if (useTexStorage && allocateMemory) {
              if (mipmaps.length > 0)
                levels++;
              state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
            }
            for (let i2 = 0; i2 < 6; i2++) {
              if (isDataTexture) {
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
                }
                for (let j = 0; j < mipmaps.length; j++) {
                  const mipmap = mipmaps[j];
                  const mipmapImage = mipmap.image[i2].image;
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                  } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                  }
                }
              } else {
                if (useTexStorage) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
                }
                for (let j = 0; j < mipmaps.length; j++) {
                  const mipmap = mipmaps[j];
                  if (useTexStorage) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
                  } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
                  }
                }
              }
            }
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(_gl.TEXTURE_CUBE_MAP);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
          const glFormat = utils.convert(texture.format, texture.encoding);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const renderTargetProperties = properties.get(renderTarget);
          if (!renderTargetProperties.__hasExternalTextures) {
            if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
              state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
            } else {
              state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            }
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (renderTarget.useRenderToTexture) {
            MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
          } else {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = _gl.DEPTH_COMPONENT16;
            if (isMultisample || renderTarget.useRenderToTexture) {
              const depthTexture = renderTarget.depthTexture;
              if (depthTexture && depthTexture.isDepthTexture) {
                if (depthTexture.type === FloatType2) {
                  glInternalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (depthTexture.type === UnsignedIntType2) {
                  glInternalFormat = _gl.DEPTH_COMPONENT24;
                }
              }
              const samples = getRenderTargetSamples(renderTarget);
              if (renderTarget.useRenderToTexture) {
                MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              } else {
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
              }
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            const samples = getRenderTargetSamples(renderTarget);
            if (isMultisample && renderTarget.useRenderbuffer) {
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            }
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
          } else {
            const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
            const glFormat = utils.convert(texture.format, texture.encoding);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
            const samples = getRenderTargetSamples(renderTarget);
            if (isMultisample && renderTarget.useRenderbuffer) {
              _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else {
              _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            }
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
          const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
          if (isCube)
            throw new Error("Depth Texture with cube render targets is not supported");
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          }
          if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
          }
          setTexture2D(renderTarget.depthTexture, 0);
          const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
          const samples = getRenderTargetSamples(renderTarget);
          if (renderTarget.depthTexture.format === DepthFormat2) {
            if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
            } else {
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
          } else if (renderTarget.depthTexture.format === DepthStencilFormat2) {
            if (renderTarget.useRenderToTexture) {
              MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
            } else {
              _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
          } else {
            throw new Error("Unknown depthTexture format");
          }
        }
        function setupDepthRenderbuffer(renderTarget) {
          const renderTargetProperties = properties.get(renderTarget);
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
            if (isCube)
              throw new Error("target.depthTexture not supported in Cube render targets");
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
          } else {
            if (isCube) {
              renderTargetProperties.__webglDepthbuffer = [];
              for (let i2 = 0; i2 < 6; i2++) {
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i2]);
                renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
              }
            } else {
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
            }
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function rebindTextures(renderTarget, colorTexture, depthTexture) {
          const renderTargetProperties = properties.get(renderTarget);
          if (colorTexture !== void 0) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
          }
          if (depthTexture !== void 0) {
            setupDepthRenderbuffer(renderTarget);
          }
        }
        function setupRenderTarget(renderTarget) {
          const texture = renderTarget.texture;
          const renderTargetProperties = properties.get(renderTarget);
          const textureProperties = properties.get(texture);
          renderTarget.addEventListener("dispose", onRenderTargetDispose);
          if (renderTarget.isWebGLMultipleRenderTargets !== true) {
            if (textureProperties.__webglTexture === void 0) {
              textureProperties.__webglTexture = _gl.createTexture();
            }
            textureProperties.__version = texture.version;
            info.memory.textures++;
          }
          const isCube = renderTarget.isWebGLCubeRenderTarget === true;
          const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
          const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for (let i2 = 0; i2 < 6; i2++) {
              renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
            }
          } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultipleRenderTargets) {
              if (capabilities.drawBuffers) {
                const textures = renderTarget.texture;
                for (let i2 = 0, il = textures.length; i2 < il; i2++) {
                  const attachmentProperties = properties.get(textures[i2]);
                  if (attachmentProperties.__webglTexture === void 0) {
                    attachmentProperties.__webglTexture = _gl.createTexture();
                    info.memory.textures++;
                  }
                }
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
              }
            } else if (renderTarget.useRenderbuffer) {
              if (isWebGL2) {
                renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                const glFormat = utils.convert(texture.format, texture.encoding);
                const glType = utils.convert(texture.type);
                const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                if (renderTarget.depthBuffer) {
                  renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                  setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                }
                state.bindFramebuffer(_gl.FRAMEBUFFER, null);
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
              }
            }
          }
          if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
            for (let i2 = 0; i2 < 6; i2++) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2);
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            state.unbindTexture();
          } else if (isMultipleRenderTargets) {
            const textures = renderTarget.texture;
            for (let i2 = 0, il = textures.length; i2 < il; i2++) {
              const attachment = textures[i2];
              const attachmentProperties = properties.get(attachment);
              state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
              setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D);
              if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
                generateMipmap(_gl.TEXTURE_2D);
              }
            }
            state.unbindTexture();
          } else {
            let glTextureType = _gl.TEXTURE_2D;
            if (isRenderTarget3D) {
              if (isWebGL2) {
                const isTexture3D = texture.isDataTexture3D;
                glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
              } else {
                console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
              }
            }
            state.bindTexture(glTextureType, textureProperties.__webglTexture);
            setTextureParameters(glTextureType, texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              generateMipmap(glTextureType);
            }
            state.unbindTexture();
          }
          if (renderTarget.depthBuffer) {
            setupDepthRenderbuffer(renderTarget);
          }
        }
        function updateRenderTargetMipmap(renderTarget) {
          const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
          const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const texture = textures[i2];
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
              const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
              const webglTexture = properties.get(texture).__webglTexture;
              state.bindTexture(target, webglTexture);
              generateMipmap(target);
              state.unbindTexture();
            }
          }
        }
        function updateMultisampleRenderTarget(renderTarget) {
          if (renderTarget.useRenderbuffer) {
            if (isWebGL2) {
              const width = renderTarget.width;
              const height = renderTarget.height;
              let mask = _gl.COLOR_BUFFER_BIT;
              const invalidationArray = [_gl.COLOR_ATTACHMENT0];
              const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
              if (renderTarget.depthBuffer) {
                invalidationArray.push(depthStyle);
              }
              if (!renderTarget.ignoreDepthForMultisampleCopy) {
                if (renderTarget.depthBuffer)
                  mask |= _gl.DEPTH_BUFFER_BIT;
                if (renderTarget.stencilBuffer)
                  mask |= _gl.STENCIL_BUFFER_BIT;
              }
              const renderTargetProperties = properties.get(renderTarget);
              state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              if (renderTarget.ignoreDepthForMultisampleCopy) {
                _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
                _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
              }
              _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
              _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
              state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
              state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            } else {
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            }
          }
        }
        function getRenderTargetSamples(renderTarget) {
          return isWebGL2 && (renderTarget.useRenderbuffer || renderTarget.useRenderToTexture) ? Math.min(maxSamples, renderTarget.samples) : 0;
        }
        function updateVideoTexture(texture) {
          const frame = info.render.frame;
          if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
          }
        }
        function verifyColorSpace(texture, image) {
          const encoding = texture.encoding;
          const format = texture.format;
          const type = texture.type;
          if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat2)
            return image;
          if (encoding !== LinearEncoding2) {
            if (encoding === sRGBEncoding2) {
              if (isWebGL2 === false) {
                if (extensions.has("EXT_sRGB") === true && format === RGBAFormat2) {
                  texture.format = _SRGBAFormat2;
                  texture.minFilter = LinearFilter2;
                  texture.generateMipmaps = false;
                } else {
                  image = ImageUtils2.sRGBToLinear(image);
                }
              } else {
                if (format !== RGBAFormat2 || type !== UnsignedByteType2) {
                  console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
                }
              }
            } else {
              console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
            }
          }
          return image;
        }
        let warnedTexture2D = false;
        let warnedTextureCube = false;
        function safeSetTexture2D(texture, slot) {
          if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
              console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
              warnedTexture2D = true;
            }
            texture = texture.texture;
          }
          setTexture2D(texture, slot);
        }
        function safeSetTextureCube(texture, slot) {
          if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
              console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
              warnedTextureCube = true;
            }
            texture = texture.texture;
          }
          setTextureCube(texture, slot);
        }
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.rebindTextures = rebindTextures;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
        this.setupDepthRenderbuffer = setupDepthRenderbuffer;
        this.setupFrameBufferTexture = setupFrameBufferTexture;
        this.safeSetTexture2D = safeSetTexture2D;
        this.safeSetTextureCube = safeSetTextureCube;
      }
      function WebGLUtils2(gl, extensions, capabilities) {
        const isWebGL2 = capabilities.isWebGL2;
        function convert(p2, encoding = null) {
          let extension;
          if (p2 === UnsignedByteType2)
            return gl.UNSIGNED_BYTE;
          if (p2 === UnsignedShort4444Type2)
            return gl.UNSIGNED_SHORT_4_4_4_4;
          if (p2 === UnsignedShort5551Type2)
            return gl.UNSIGNED_SHORT_5_5_5_1;
          if (p2 === ByteType2)
            return gl.BYTE;
          if (p2 === ShortType2)
            return gl.SHORT;
          if (p2 === UnsignedShortType2)
            return gl.UNSIGNED_SHORT;
          if (p2 === IntType2)
            return gl.INT;
          if (p2 === UnsignedIntType2)
            return gl.UNSIGNED_INT;
          if (p2 === FloatType2)
            return gl.FLOAT;
          if (p2 === HalfFloatType2) {
            if (isWebGL2)
              return gl.HALF_FLOAT;
            extension = extensions.get("OES_texture_half_float");
            if (extension !== null) {
              return extension.HALF_FLOAT_OES;
            } else {
              return null;
            }
          }
          if (p2 === AlphaFormat2)
            return gl.ALPHA;
          if (p2 === RGBAFormat2)
            return gl.RGBA;
          if (p2 === LuminanceFormat2)
            return gl.LUMINANCE;
          if (p2 === LuminanceAlphaFormat2)
            return gl.LUMINANCE_ALPHA;
          if (p2 === DepthFormat2)
            return gl.DEPTH_COMPONENT;
          if (p2 === DepthStencilFormat2)
            return gl.DEPTH_STENCIL;
          if (p2 === RedFormat2)
            return gl.RED;
          if (p2 === RGBFormat2) {
            console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
            return gl.RGBA;
          }
          if (p2 === _SRGBAFormat2) {
            extension = extensions.get("EXT_sRGB");
            if (extension !== null) {
              return extension.SRGB_ALPHA_EXT;
            } else {
              return null;
            }
          }
          if (p2 === RedIntegerFormat2)
            return gl.RED_INTEGER;
          if (p2 === RGFormat2)
            return gl.RG;
          if (p2 === RGIntegerFormat2)
            return gl.RG_INTEGER;
          if (p2 === RGBAIntegerFormat2)
            return gl.RGBA_INTEGER;
          if (p2 === RGB_S3TC_DXT1_Format2 || p2 === RGBA_S3TC_DXT1_Format2 || p2 === RGBA_S3TC_DXT3_Format2 || p2 === RGBA_S3TC_DXT5_Format2) {
            if (encoding === sRGBEncoding2) {
              extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
              if (extension !== null) {
                if (p2 === RGB_S3TC_DXT1_Format2)
                  return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (p2 === RGBA_S3TC_DXT1_Format2)
                  return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (p2 === RGBA_S3TC_DXT3_Format2)
                  return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (p2 === RGBA_S3TC_DXT5_Format2)
                  return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                return null;
              }
            } else {
              extension = extensions.get("WEBGL_compressed_texture_s3tc");
              if (extension !== null) {
                if (p2 === RGB_S3TC_DXT1_Format2)
                  return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p2 === RGBA_S3TC_DXT1_Format2)
                  return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p2 === RGBA_S3TC_DXT3_Format2)
                  return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p2 === RGBA_S3TC_DXT5_Format2)
                  return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              } else {
                return null;
              }
            }
          }
          if (p2 === RGB_PVRTC_4BPPV1_Format2 || p2 === RGB_PVRTC_2BPPV1_Format2 || p2 === RGBA_PVRTC_4BPPV1_Format2 || p2 === RGBA_PVRTC_2BPPV1_Format2) {
            extension = extensions.get("WEBGL_compressed_texture_pvrtc");
            if (extension !== null) {
              if (p2 === RGB_PVRTC_4BPPV1_Format2)
                return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (p2 === RGB_PVRTC_2BPPV1_Format2)
                return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (p2 === RGBA_PVRTC_4BPPV1_Format2)
                return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (p2 === RGBA_PVRTC_2BPPV1_Format2)
                return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else {
              return null;
            }
          }
          if (p2 === RGB_ETC1_Format2) {
            extension = extensions.get("WEBGL_compressed_texture_etc1");
            if (extension !== null) {
              return extension.COMPRESSED_RGB_ETC1_WEBGL;
            } else {
              return null;
            }
          }
          if (p2 === RGB_ETC2_Format2 || p2 === RGBA_ETC2_EAC_Format2) {
            extension = extensions.get("WEBGL_compressed_texture_etc");
            if (extension !== null) {
              if (p2 === RGB_ETC2_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
              if (p2 === RGBA_ETC2_EAC_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
            } else {
              return null;
            }
          }
          if (p2 === RGBA_ASTC_4x4_Format2 || p2 === RGBA_ASTC_5x4_Format2 || p2 === RGBA_ASTC_5x5_Format2 || p2 === RGBA_ASTC_6x5_Format2 || p2 === RGBA_ASTC_6x6_Format2 || p2 === RGBA_ASTC_8x5_Format2 || p2 === RGBA_ASTC_8x6_Format2 || p2 === RGBA_ASTC_8x8_Format2 || p2 === RGBA_ASTC_10x5_Format2 || p2 === RGBA_ASTC_10x6_Format2 || p2 === RGBA_ASTC_10x8_Format2 || p2 === RGBA_ASTC_10x10_Format2 || p2 === RGBA_ASTC_12x10_Format2 || p2 === RGBA_ASTC_12x12_Format2) {
            extension = extensions.get("WEBGL_compressed_texture_astc");
            if (extension !== null) {
              if (p2 === RGBA_ASTC_4x4_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (p2 === RGBA_ASTC_5x4_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (p2 === RGBA_ASTC_5x5_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (p2 === RGBA_ASTC_6x5_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (p2 === RGBA_ASTC_6x6_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (p2 === RGBA_ASTC_8x5_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (p2 === RGBA_ASTC_8x6_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (p2 === RGBA_ASTC_8x8_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (p2 === RGBA_ASTC_10x5_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (p2 === RGBA_ASTC_10x6_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (p2 === RGBA_ASTC_10x8_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (p2 === RGBA_ASTC_10x10_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (p2 === RGBA_ASTC_12x10_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (p2 === RGBA_ASTC_12x12_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else {
              return null;
            }
          }
          if (p2 === RGBA_BPTC_Format2) {
            extension = extensions.get("EXT_texture_compression_bptc");
            if (extension !== null) {
              if (p2 === RGBA_BPTC_Format2)
                return encoding === sRGBEncoding2 ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            } else {
              return null;
            }
          }
          if (p2 === UnsignedInt248Type2) {
            if (isWebGL2)
              return gl.UNSIGNED_INT_24_8;
            extension = extensions.get("WEBGL_depth_texture");
            if (extension !== null) {
              return extension.UNSIGNED_INT_24_8_WEBGL;
            } else {
              return null;
            }
          }
        }
        return {
          convert
        };
      }
      var ArrayCamera2 = class extends PerspectiveCamera2 {
        constructor(array = []) {
          super();
          this.cameras = array;
        }
      };
      ArrayCamera2.prototype.isArrayCamera = true;
      var Group2 = class extends Object3D2 {
        constructor() {
          super();
          this.type = "Group";
        }
      };
      Group2.prototype.isGroup = true;
      var _moveEvent2 = {
        type: "move"
      };
      var WebXRController2 = class {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Group2();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = {
              pinching: false
            };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Group2();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector32();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector32();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Group2();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector32();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector32();
          }
          return this._grip;
        }
        dispatchEvent(event) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(event);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(event);
          }
          return this;
        }
        disconnect(inputSource) {
          this.dispatchEvent({
            type: "disconnected",
            data: inputSource
          });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(inputSource, frame, referenceSpace) {
          let inputPose = null;
          let gripPose = null;
          let handPose = null;
          const targetRay = this._targetRay;
          const grip = this._grip;
          const hand = this._hand;
          if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                if (inputPose.linearVelocity) {
                  targetRay.hasLinearVelocity = true;
                  targetRay.linearVelocity.copy(inputPose.linearVelocity);
                } else {
                  targetRay.hasLinearVelocity = false;
                }
                if (inputPose.angularVelocity) {
                  targetRay.hasAngularVelocity = true;
                  targetRay.angularVelocity.copy(inputPose.angularVelocity);
                } else {
                  targetRay.hasAngularVelocity = false;
                }
                this.dispatchEvent(_moveEvent2);
              }
            }
            if (hand && inputSource.hand) {
              handPose = true;
              for (const inputjoint of inputSource.hand.values()) {
                const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                if (hand.joints[inputjoint.jointName] === void 0) {
                  const joint2 = new Group2();
                  joint2.matrixAutoUpdate = false;
                  joint2.visible = false;
                  hand.joints[inputjoint.jointName] = joint2;
                  hand.add(joint2);
                }
                const joint = hand.joints[inputjoint.jointName];
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
              }
              const indexTip = hand.joints["index-finger-tip"];
              const thumbTip = hand.joints["thumb-tip"];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            } else {
              if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                  grip.matrix.fromArray(gripPose.transform.matrix);
                  grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                  if (gripPose.linearVelocity) {
                    grip.hasLinearVelocity = true;
                    grip.linearVelocity.copy(gripPose.linearVelocity);
                  } else {
                    grip.hasLinearVelocity = false;
                  }
                  if (gripPose.angularVelocity) {
                    grip.hasAngularVelocity = true;
                    grip.angularVelocity.copy(gripPose.angularVelocity);
                  } else {
                    grip.hasAngularVelocity = false;
                  }
                }
              }
            }
          }
          if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
          }
          if (grip !== null) {
            grip.visible = gripPose !== null;
          }
          if (hand !== null) {
            hand.visible = handPose !== null;
          }
          return this;
        }
      };
      var DepthTexture2 = class extends Texture2 {
        constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
          format = format !== void 0 ? format : DepthFormat2;
          if (format !== DepthFormat2 && format !== DepthStencilFormat2) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (type === void 0 && format === DepthFormat2)
            type = UnsignedShortType2;
          if (type === void 0 && format === DepthStencilFormat2)
            type = UnsignedInt248Type2;
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.image = {
            width,
            height
          };
          this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter2;
          this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter2;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      DepthTexture2.prototype.isDepthTexture = true;
      var WebXRManager2 = class extends EventDispatcher3 {
        constructor(renderer, gl) {
          super();
          const scope = this;
          let session = null;
          let framebufferScaleFactor = 1;
          let referenceSpace = null;
          let referenceSpaceType = "local-floor";
          const hasMultisampledRenderToTexture = renderer.extensions.has("WEBGL_multisampled_render_to_texture");
          let pose = null;
          let glBinding = null;
          let glProjLayer = null;
          let glBaseLayer = null;
          let isMultisample = false;
          let xrFrame = null;
          const attributes = gl.getContextAttributes();
          let initialRenderTarget = null;
          let newRenderTarget = null;
          const controllers = [];
          const inputSourcesMap = /* @__PURE__ */ new Map();
          const cameraL = new PerspectiveCamera2();
          cameraL.layers.enable(1);
          cameraL.viewport = new Vector42();
          const cameraR = new PerspectiveCamera2();
          cameraR.layers.enable(2);
          cameraR.viewport = new Vector42();
          const cameras = [cameraL, cameraR];
          const cameraVR = new ArrayCamera2();
          cameraVR.layers.enable(1);
          cameraVR.layers.enable(2);
          let _currentDepthNear = null;
          let _currentDepthFar = null;
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController2();
              controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
          };
          this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController2();
              controllers[index] = controller;
            }
            return controller.getGripSpace();
          };
          this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController2();
              controllers[index] = controller;
            }
            return controller.getHandSpace();
          };
          function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller) {
              controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
              });
            }
          }
          function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
              controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            renderer.setRenderTarget(initialRenderTarget);
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            newRenderTarget = null;
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function() {
            return referenceSpace;
          };
          this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
          };
          this.getBinding = function() {
            return glBinding;
          };
          this.getFrame = function() {
            return xrFrame;
          };
          this.getSession = function() {
            return session;
          };
          this.setSession = async function(value) {
            session = value;
            if (session !== null) {
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              if (attributes.xrCompatible !== true) {
                await gl.makeXRCompatible();
              }
              if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
                const layerInit = {
                  antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({
                  baseLayer: glBaseLayer
                });
                newRenderTarget = new WebGLRenderTarget3(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                  format: RGBAFormat2,
                  type: UnsignedByteType2,
                  encoding: renderer.outputEncoding
                });
              } else {
                isMultisample = attributes.antialias;
                let depthFormat = null;
                let depthType = null;
                let glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                  depthFormat = attributes.stencil ? DepthStencilFormat2 : DepthFormat2;
                  depthType = attributes.stencil ? UnsignedInt248Type2 : UnsignedShortType2;
                }
                const projectionlayerInit = {
                  colorFormat: renderer.outputEncoding === sRGBEncoding2 ? gl.SRGB8_ALPHA8 : gl.RGBA8,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({
                  layers: [glProjLayer]
                });
                if (isMultisample) {
                  newRenderTarget = new WebGLMultisampleRenderTarget2(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                    format: RGBAFormat2,
                    type: UnsignedByteType2,
                    depthTexture: new DepthTexture2(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    ignoreDepth: glProjLayer.ignoreDepthValues,
                    useRenderToTexture: hasMultisampledRenderToTexture,
                    encoding: renderer.outputEncoding
                  });
                } else {
                  newRenderTarget = new WebGLRenderTarget3(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                    format: RGBAFormat2,
                    type: UnsignedByteType2,
                    depthTexture: new DepthTexture2(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    ignoreDepth: glProjLayer.ignoreDepthValues,
                    encoding: renderer.outputEncoding
                  });
                }
              }
              newRenderTarget.isXRRenderTarget = true;
              this.setFoveation(1);
              referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({
                type: "sessionstart"
              });
            }
          };
          function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              inputSourcesMap.set(inputSources[i2], controllers[i2]);
            }
            for (let i2 = 0; i2 < event.removed.length; i2++) {
              const inputSource = event.removed[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "disconnected",
                  data: inputSource
                });
                inputSourcesMap.delete(inputSource);
              }
            }
            for (let i2 = 0; i2 < event.added.length; i2++) {
              const inputSource = event.added[i2];
              const controller = inputSourcesMap.get(inputSource);
              if (controller) {
                controller.dispatchEvent({
                  type: "connected",
                  data: inputSource
                });
              }
            }
          }
          const cameraLPos = new Vector32();
          const cameraRPos = new Vector32();
          function setProjectionFromUnion(camera, cameraL2, cameraR2) {
            cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL2.projectionMatrix.elements;
            const projR = cameraR2.projectionMatrix.elements;
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          }
          function updateCamera(camera, parent) {
            if (parent === null) {
              camera.matrixWorld.copy(camera.matrix);
            } else {
              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          }
          this.updateCamera = function(camera) {
            if (session === null)
              return;
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
              session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
              });
              _currentDepthNear = cameraVR.near;
              _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras2 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for (let i2 = 0; i2 < cameras2.length; i2++) {
              updateCamera(cameras2[i2], parent);
            }
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for (let i2 = 0, l = children.length; i2 < l; i2++) {
              children[i2].updateMatrixWorld(true);
            }
            if (cameras2.length === 2) {
              setProjectionFromUnion(cameraVR, cameraL, cameraR);
            } else {
              cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
          };
          this.getCamera = function() {
            return cameraVR;
          };
          this.getFoveation = function() {
            if (glProjLayer !== null) {
              return glProjLayer.fixedFoveation;
            }
            if (glBaseLayer !== null) {
              return glBaseLayer.fixedFoveation;
            }
            return void 0;
          };
          this.setFoveation = function(foveation) {
            if (glProjLayer !== null) {
              glProjLayer.fixedFoveation = foveation;
            }
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
              glBaseLayer.fixedFoveation = foveation;
            }
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
              const views = pose.views;
              if (glBaseLayer !== null) {
                renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                renderer.setRenderTarget(newRenderTarget);
              }
              let cameraVRNeedsUpdate = false;
              if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
              }
              for (let i2 = 0; i2 < views.length; i2++) {
                const view = views[i2];
                let viewport = null;
                if (glBaseLayer !== null) {
                  viewport = glBaseLayer.getViewport(view);
                } else {
                  const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                  viewport = glSubImage.viewport;
                  if (i2 === 0) {
                    renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
                    renderer.setRenderTarget(newRenderTarget);
                  }
                }
                const camera = cameras[i2];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i2 === 0) {
                  cameraVR.matrix.copy(camera.matrix);
                }
                if (cameraVRNeedsUpdate === true) {
                  cameraVR.cameras.push(camera);
                }
              }
            }
            const inputSources = session.inputSources;
            for (let i2 = 0; i2 < controllers.length; i2++) {
              const controller = controllers[i2];
              const inputSource = inputSources[i2];
              controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time, frame);
            xrFrame = null;
          }
          const animation = new WebGLAnimation2();
          animation.setAnimationLoop(onAnimationFrame);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
          };
          this.dispose = function() {
          };
        }
      };
      function WebGLMaterials2(properties) {
        function refreshFogUniforms(uniforms, fog) {
          uniforms.fogColor.value.copy(fog.color);
          if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
          } else if (fog.isFogExp2) {
            uniforms.fogDensity.value = fog.density;
          }
        }
        function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
          if (material.isMeshBasicMaterial) {
            refreshUniformsCommon(uniforms, material);
          } else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
          } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
          } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
          } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) {
              refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
            } else {
              refreshUniformsStandard(uniforms, material);
            }
          } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
          } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
          } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
          } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
          } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) {
              refreshUniformsDash(uniforms, material);
            }
          } else if (material.isPointsMaterial) {
            refreshUniformsPoints(uniforms, material, pixelRatio, height);
          } else if (material.isSpriteMaterial) {
            refreshUniformsSprites(uniforms, material);
          } else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
          } else if (material.isShaderMaterial) {
            material.uniformsNeedUpdate = false;
          }
        }
        function refreshUniformsCommon(uniforms, material) {
          uniforms.opacity.value = material.opacity;
          if (material.color) {
            uniforms.diffuse.value.copy(material.color);
          }
          if (material.emissive) {
            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
          }
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          if (material.specularMap) {
            uniforms.specularMap.value = material.specularMap;
          }
          if (material.alphaTest > 0) {
            uniforms.alphaTest.value = material.alphaTest;
          }
          const envMap = properties.get(material).envMap;
          if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.ior.value = material.ior;
            uniforms.refractionRatio.value = material.refractionRatio;
          }
          if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
          }
          if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.specularMap) {
            uvScaleMap = material.specularMap;
          } else if (material.displacementMap) {
            uvScaleMap = material.displacementMap;
          } else if (material.normalMap) {
            uvScaleMap = material.normalMap;
          } else if (material.bumpMap) {
            uvScaleMap = material.bumpMap;
          } else if (material.roughnessMap) {
            uvScaleMap = material.roughnessMap;
          } else if (material.metalnessMap) {
            uvScaleMap = material.metalnessMap;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          } else if (material.emissiveMap) {
            uvScaleMap = material.emissiveMap;
          } else if (material.clearcoatMap) {
            uvScaleMap = material.clearcoatMap;
          } else if (material.clearcoatNormalMap) {
            uvScaleMap = material.clearcoatNormalMap;
          } else if (material.clearcoatRoughnessMap) {
            uvScaleMap = material.clearcoatRoughnessMap;
          } else if (material.specularIntensityMap) {
            uvScaleMap = material.specularIntensityMap;
          } else if (material.specularColorMap) {
            uvScaleMap = material.specularColorMap;
          } else if (material.transmissionMap) {
            uvScaleMap = material.transmissionMap;
          } else if (material.thicknessMap) {
            uvScaleMap = material.thicknessMap;
          } else if (material.sheenColorMap) {
            uvScaleMap = material.sheenColorMap;
          } else if (material.sheenRoughnessMap) {
            uvScaleMap = material.sheenRoughnessMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.isWebGLRenderTarget) {
              uvScaleMap = uvScaleMap.texture;
            }
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
          let uv2ScaleMap;
          if (material.aoMap) {
            uv2ScaleMap = material.aoMap;
          } else if (material.lightMap) {
            uv2ScaleMap = material.lightMap;
          }
          if (uv2ScaleMap !== void 0) {
            if (uv2ScaleMap.isWebGLRenderTarget) {
              uv2ScaleMap = uv2ScaleMap.texture;
            }
            if (uv2ScaleMap.matrixAutoUpdate === true) {
              uv2ScaleMap.updateMatrix();
            }
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
          }
        }
        function refreshUniformsLine(uniforms, material) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
          uniforms.dashSize.value = material.dashSize;
          uniforms.totalSize.value = material.dashSize + material.gapSize;
          uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.size.value = material.size * pixelRatio;
          uniforms.scale.value = height * 0.5;
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          if (material.alphaTest > 0) {
            uniforms.alphaTest.value = material.alphaTest;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsSprites(uniforms, material) {
          uniforms.diffuse.value.copy(material.color);
          uniforms.opacity.value = material.opacity;
          uniforms.rotation.value = material.rotation;
          if (material.map) {
            uniforms.map.value = material.map;
          }
          if (material.alphaMap) {
            uniforms.alphaMap.value = material.alphaMap;
          }
          if (material.alphaTest > 0) {
            uniforms.alphaTest.value = material.alphaTest;
          }
          let uvScaleMap;
          if (material.map) {
            uvScaleMap = material.map;
          } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
          }
          if (uvScaleMap !== void 0) {
            if (uvScaleMap.matrixAutoUpdate === true) {
              uvScaleMap.updateMatrix();
            }
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
          }
        }
        function refreshUniformsLambert(uniforms, material) {
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
        }
        function refreshUniformsPhong(uniforms, material) {
          uniforms.specular.value.copy(material.specular);
          uniforms.shininess.value = Math.max(material.shininess, 1e-4);
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide2)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide2)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsToon(uniforms, material) {
          if (material.gradientMap) {
            uniforms.gradientMap.value = material.gradientMap;
          }
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide2)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide2)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsStandard(uniforms, material) {
          uniforms.roughness.value = material.roughness;
          uniforms.metalness.value = material.metalness;
          if (material.roughnessMap) {
            uniforms.roughnessMap.value = material.roughnessMap;
          }
          if (material.metalnessMap) {
            uniforms.metalnessMap.value = material.metalnessMap;
          }
          if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide2)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide2)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
          const envMap = properties.get(material).envMap;
          if (envMap) {
            uniforms.envMapIntensity.value = material.envMapIntensity;
          }
        }
        function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
          refreshUniformsStandard(uniforms, material);
          uniforms.ior.value = material.ior;
          if (material.sheen > 0) {
            uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
            uniforms.sheenRoughness.value = material.sheenRoughness;
            if (material.sheenColorMap) {
              uniforms.sheenColorMap.value = material.sheenColorMap;
            }
            if (material.sheenRoughnessMap) {
              uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
            }
          }
          if (material.clearcoat > 0) {
            uniforms.clearcoat.value = material.clearcoat;
            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
            if (material.clearcoatMap) {
              uniforms.clearcoatMap.value = material.clearcoatMap;
            }
            if (material.clearcoatRoughnessMap) {
              uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
            }
            if (material.clearcoatNormalMap) {
              uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
              uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
              if (material.side === BackSide2) {
                uniforms.clearcoatNormalScale.value.negate();
              }
            }
          }
          if (material.transmission > 0) {
            uniforms.transmission.value = material.transmission;
            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
            if (material.transmissionMap) {
              uniforms.transmissionMap.value = material.transmissionMap;
            }
            uniforms.thickness.value = material.thickness;
            if (material.thicknessMap) {
              uniforms.thicknessMap.value = material.thicknessMap;
            }
            uniforms.attenuationDistance.value = material.attenuationDistance;
            uniforms.attenuationColor.value.copy(material.attenuationColor);
          }
          uniforms.specularIntensity.value = material.specularIntensity;
          uniforms.specularColor.value.copy(material.specularColor);
          if (material.specularIntensityMap) {
            uniforms.specularIntensityMap.value = material.specularIntensityMap;
          }
          if (material.specularColorMap) {
            uniforms.specularColorMap.value = material.specularColorMap;
          }
        }
        function refreshUniformsMatcap(uniforms, material) {
          if (material.matcap) {
            uniforms.matcap.value = material.matcap;
          }
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide2)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide2)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsDepth(uniforms, material) {
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        function refreshUniformsDistance(uniforms, material) {
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
          uniforms.referencePosition.value.copy(material.referencePosition);
          uniforms.nearDistance.value = material.nearDistance;
          uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
          if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide2)
              uniforms.bumpScale.value *= -1;
          }
          if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide2)
              uniforms.normalScale.value.negate();
          }
          if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
          }
        }
        return {
          refreshFogUniforms,
          refreshMaterialUniforms
        };
      }
      function createCanvasElement2() {
        const canvas = createElementNS2("canvas");
        canvas.style.display = "block";
        return canvas;
      }
      function WebGLRenderer2(parameters = {}) {
        const _canvas3 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement2(), _context3 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
        let currentRenderList = null;
        let currentRenderState = null;
        const renderListStack = [];
        const renderStateStack = [];
        this.domElement = _canvas3;
        this.debug = {
          checkShaderErrors: true
        };
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.outputEncoding = LinearEncoding2;
        this.physicallyCorrectLights = false;
        this.toneMapping = NoToneMapping2;
        this.toneMappingExposure = 1;
        const _this = this;
        let _isContextLost = false;
        let _currentActiveCubeFace = 0;
        let _currentActiveMipmapLevel = 0;
        let _currentRenderTarget = null;
        let _currentMaterialId = -1;
        let _currentCamera = null;
        const _currentViewport = new Vector42();
        const _currentScissor = new Vector42();
        let _currentScissorTest = null;
        let _width2 = _canvas3.width;
        let _height2 = _canvas3.height;
        let _pixelRatio = 1;
        let _opaqueSort = null;
        let _transparentSort = null;
        const _viewport = new Vector42(0, 0, _width2, _height2);
        const _scissor = new Vector42(0, 0, _width2, _height2);
        let _scissorTest = false;
        const _frustum = new Frustum2();
        let _clippingEnabled = false;
        let _localClippingEnabled = false;
        let _transmissionRenderTarget = null;
        const _projScreenMatrix3 = new Matrix42();
        const _vector3 = new Vector32();
        const _emptyScene = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: true
        };
        function getTargetPixelRatio() {
          return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        let _gl = _context3;
        function getContext(contextNames, contextAttributes) {
          for (let i2 = 0; i2 < contextNames.length; i2++) {
            const contextName = contextNames[i2];
            const context = _canvas3.getContext(contextName, contextAttributes);
            if (context !== null)
              return context;
          }
          return null;
        }
        try {
          const contextAttributes = {
            alpha: true,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
          };
          if ("setAttribute" in _canvas3)
            _canvas3.setAttribute("data-engine", `three.js r${REVISION2}`);
          _canvas3.addEventListener("webglcontextlost", onContextLost, false);
          _canvas3.addEventListener("webglcontextrestored", onContextRestore, false);
          if (_gl === null) {
            const contextNames = ["webgl2", "webgl", "experimental-webgl"];
            if (_this.isWebGL1Renderer === true) {
              contextNames.shift();
            }
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
              if (getContext(contextNames)) {
                throw new Error("Error creating WebGL context with your selected attributes.");
              } else {
                throw new Error("Error creating WebGL context.");
              }
            }
          }
          if (_gl.getShaderPrecisionFormat === void 0) {
            _gl.getShaderPrecisionFormat = function() {
              return {
                "rangeMin": 1,
                "rangeMax": 1,
                "precision": 1
              };
            };
          }
        } catch (error) {
          console.error("THREE.WebGLRenderer: " + error.message);
          throw error;
        }
        let extensions, capabilities, state, info;
        let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
        let programCache, materials, renderLists, renderStates, clipping, shadowMap;
        let background, morphtargets, bufferRenderer, indexedBufferRenderer;
        let utils, bindingStates;
        function initGLContext() {
          extensions = new WebGLExtensions2(_gl);
          capabilities = new WebGLCapabilities2(_gl, extensions, parameters);
          extensions.init(capabilities);
          utils = new WebGLUtils2(_gl, extensions, capabilities);
          state = new WebGLState2(_gl, extensions, capabilities);
          info = new WebGLInfo2(_gl);
          properties = new WebGLProperties2();
          textures = new WebGLTextures2(_gl, extensions, state, properties, capabilities, utils, info);
          cubemaps = new WebGLCubeMaps2(_this);
          cubeuvmaps = new WebGLCubeUVMaps2(_this);
          attributes = new WebGLAttributes2(_gl, capabilities);
          bindingStates = new WebGLBindingStates2(_gl, extensions, attributes, capabilities);
          geometries = new WebGLGeometries2(_gl, attributes, info, bindingStates);
          objects = new WebGLObjects2(_gl, geometries, attributes, info);
          morphtargets = new WebGLMorphtargets2(_gl, capabilities, textures);
          clipping = new WebGLClipping2(properties);
          programCache = new WebGLPrograms2(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
          materials = new WebGLMaterials2(properties);
          renderLists = new WebGLRenderLists2();
          renderStates = new WebGLRenderStates2(extensions, capabilities);
          background = new WebGLBackground2(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
          shadowMap = new WebGLShadowMap2(_this, objects, capabilities);
          bufferRenderer = new WebGLBufferRenderer2(_gl, extensions, info, capabilities);
          indexedBufferRenderer = new WebGLIndexedBufferRenderer2(_gl, extensions, info, capabilities);
          info.programs = programCache.programs;
          _this.capabilities = capabilities;
          _this.extensions = extensions;
          _this.properties = properties;
          _this.renderLists = renderLists;
          _this.shadowMap = shadowMap;
          _this.state = state;
          _this.info = info;
        }
        initGLContext();
        const xr = new WebXRManager2(_this, _gl);
        this.xr = xr;
        this.getContext = function() {
          return _gl;
        };
        this.getContextAttributes = function() {
          return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.loseContext();
        };
        this.forceContextRestore = function() {
          const extension = extensions.get("WEBGL_lose_context");
          if (extension)
            extension.restoreContext();
        };
        this.getPixelRatio = function() {
          return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
          if (value === void 0)
            return;
          _pixelRatio = value;
          this.setSize(_width2, _height2, false);
        };
        this.getSize = function(target) {
          return target.set(_width2, _height2);
        };
        this.setSize = function(width, height, updateStyle) {
          if (xr.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
          }
          _width2 = width;
          _height2 = height;
          _canvas3.width = Math.floor(width * _pixelRatio);
          _canvas3.height = Math.floor(height * _pixelRatio);
          if (updateStyle !== false) {
            _canvas3.style.width = width + "px";
            _canvas3.style.height = height + "px";
          }
          this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function(target) {
          return target.set(_width2 * _pixelRatio, _height2 * _pixelRatio).floor();
        };
        this.setDrawingBufferSize = function(width, height, pixelRatio) {
          _width2 = width;
          _height2 = height;
          _pixelRatio = pixelRatio;
          _canvas3.width = Math.floor(width * pixelRatio);
          _canvas3.height = Math.floor(height * pixelRatio);
          this.setViewport(0, 0, width, height);
        };
        this.getCurrentViewport = function(target) {
          return target.copy(_currentViewport);
        };
        this.getViewport = function(target) {
          return target.copy(_viewport);
        };
        this.setViewport = function(x, y, width, height) {
          if (x.isVector4) {
            _viewport.set(x.x, x.y, x.z, x.w);
          } else {
            _viewport.set(x, y, width, height);
          }
          state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissor = function(target) {
          return target.copy(_scissor);
        };
        this.setScissor = function(x, y, width, height) {
          if (x.isVector4) {
            _scissor.set(x.x, x.y, x.z, x.w);
          } else {
            _scissor.set(x, y, width, height);
          }
          state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissorTest = function() {
          return _scissorTest;
        };
        this.setScissorTest = function(boolean) {
          state.setScissorTest(_scissorTest = boolean);
        };
        this.setOpaqueSort = function(method) {
          _opaqueSort = method;
        };
        this.setTransparentSort = function(method) {
          _transparentSort = method;
        };
        this.getClearColor = function(target) {
          return target.copy(background.getClearColor());
        };
        this.setClearColor = function() {
          background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function() {
          return background.getClearAlpha();
        };
        this.setClearAlpha = function() {
          background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function(color, depth, stencil) {
          let bits = 0;
          if (color === void 0 || color)
            bits |= _gl.COLOR_BUFFER_BIT;
          if (depth === void 0 || depth)
            bits |= _gl.DEPTH_BUFFER_BIT;
          if (stencil === void 0 || stencil)
            bits |= _gl.STENCIL_BUFFER_BIT;
          _gl.clear(bits);
        };
        this.clearColor = function() {
          this.clear(true, false, false);
        };
        this.clearDepth = function() {
          this.clear(false, true, false);
        };
        this.clearStencil = function() {
          this.clear(false, false, true);
        };
        this.dispose = function() {
          _canvas3.removeEventListener("webglcontextlost", onContextLost, false);
          _canvas3.removeEventListener("webglcontextrestored", onContextRestore, false);
          renderLists.dispose();
          renderStates.dispose();
          properties.dispose();
          cubemaps.dispose();
          cubeuvmaps.dispose();
          objects.dispose();
          bindingStates.dispose();
          programCache.dispose();
          xr.dispose();
          xr.removeEventListener("sessionstart", onXRSessionStart);
          xr.removeEventListener("sessionend", onXRSessionEnd);
          if (_transmissionRenderTarget) {
            _transmissionRenderTarget.dispose();
            _transmissionRenderTarget = null;
          }
          animation.stop();
        };
        function onContextLost(event) {
          event.preventDefault();
          console.log("THREE.WebGLRenderer: Context Lost.");
          _isContextLost = true;
        }
        function onContextRestore() {
          console.log("THREE.WebGLRenderer: Context Restored.");
          _isContextLost = false;
          const infoAutoReset = info.autoReset;
          const shadowMapEnabled = shadowMap.enabled;
          const shadowMapAutoUpdate = shadowMap.autoUpdate;
          const shadowMapNeedsUpdate = shadowMap.needsUpdate;
          const shadowMapType = shadowMap.type;
          initGLContext();
          info.autoReset = infoAutoReset;
          shadowMap.enabled = shadowMapEnabled;
          shadowMap.autoUpdate = shadowMapAutoUpdate;
          shadowMap.needsUpdate = shadowMapNeedsUpdate;
          shadowMap.type = shadowMapType;
        }
        function onMaterialDispose(event) {
          const material = event.target;
          material.removeEventListener("dispose", onMaterialDispose);
          deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
          releaseMaterialProgramReferences(material);
          properties.remove(material);
        }
        function releaseMaterialProgramReferences(material) {
          const programs = properties.get(material).programs;
          if (programs !== void 0) {
            programs.forEach(function(program) {
              programCache.releaseProgram(program);
            });
            if (material.isShaderMaterial) {
              programCache.releaseShaderCache(material);
            }
          }
        }
        this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
          if (scene === null)
            scene = _emptyScene;
          const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
          const program = setProgram(camera, scene, geometry, material, object);
          state.setMaterial(material, frontFaceCW);
          let index = geometry.index;
          const position = geometry.attributes.position;
          if (index === null) {
            if (position === void 0 || position.count === 0)
              return;
          } else if (index.count === 0) {
            return;
          }
          let rangeFactor = 1;
          if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
          }
          bindingStates.setup(object, material, program, geometry, index);
          let attribute;
          let renderer = bufferRenderer;
          if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
          }
          const dataCount = index !== null ? index.count : position.count;
          const rangeStart = geometry.drawRange.start * rangeFactor;
          const rangeCount = geometry.drawRange.count * rangeFactor;
          const groupStart = group !== null ? group.start * rangeFactor : 0;
          const groupCount = group !== null ? group.count * rangeFactor : Infinity;
          const drawStart = Math.max(rangeStart, groupStart);
          const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
          const drawCount = Math.max(0, drawEnd - drawStart + 1);
          if (drawCount === 0)
            return;
          if (object.isMesh) {
            if (material.wireframe === true) {
              state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
              renderer.setMode(_gl.LINES);
            } else {
              renderer.setMode(_gl.TRIANGLES);
            }
          } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === void 0)
              lineWidth = 1;
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) {
              renderer.setMode(_gl.LINES);
            } else if (object.isLineLoop) {
              renderer.setMode(_gl.LINE_LOOP);
            } else {
              renderer.setMode(_gl.LINE_STRIP);
            }
          } else if (object.isPoints) {
            renderer.setMode(_gl.POINTS);
          } else if (object.isSprite) {
            renderer.setMode(_gl.TRIANGLES);
          }
          if (object.isInstancedMesh) {
            renderer.renderInstances(drawStart, drawCount, object.count);
          } else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
          } else {
            renderer.render(drawStart, drawCount);
          }
        };
        this.compile = function(scene, camera) {
          currentRenderState = renderStates.get(scene);
          currentRenderState.init();
          renderStateStack.push(currentRenderState);
          scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            }
          });
          currentRenderState.setupLights(_this.physicallyCorrectLights);
          scene.traverse(function(object) {
            const material = object.material;
            if (material) {
              if (Array.isArray(material)) {
                for (let i2 = 0; i2 < material.length; i2++) {
                  const material2 = material[i2];
                  getProgram(material2, scene, object);
                }
              } else {
                getProgram(material, scene, object);
              }
            }
          });
          renderStateStack.pop();
          currentRenderState = null;
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time) {
          if (onAnimationFrameCallback)
            onAnimationFrameCallback(time);
        }
        function onXRSessionStart() {
          animation.stop();
        }
        function onXRSessionEnd() {
          animation.start();
        }
        const animation = new WebGLAnimation2();
        animation.setAnimationLoop(onAnimationFrame);
        if (typeof window !== "undefined")
          animation.setContext(window);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
          xr.setAnimationLoop(callback);
          callback === null ? animation.stop() : animation.start();
        };
        xr.addEventListener("sessionstart", onXRSessionStart);
        xr.addEventListener("sessionend", onXRSessionEnd);
        this.render = function(scene, camera) {
          if (camera !== void 0 && camera.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
          }
          if (_isContextLost === true)
            return;
          if (scene.autoUpdate === true)
            scene.updateMatrixWorld();
          if (camera.parent === null)
            camera.updateMatrixWorld();
          if (xr.enabled === true && xr.isPresenting === true) {
            if (xr.cameraAutoUpdate === true)
              xr.updateCamera(camera);
            camera = xr.getCamera();
          }
          if (scene.isScene === true)
            scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
          currentRenderState = renderStates.get(scene, renderStateStack.length);
          currentRenderState.init();
          renderStateStack.push(currentRenderState);
          _projScreenMatrix3.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          _frustum.setFromProjectionMatrix(_projScreenMatrix3);
          _localClippingEnabled = this.localClippingEnabled;
          _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
          currentRenderList = renderLists.get(scene, renderListStack.length);
          currentRenderList.init();
          renderListStack.push(currentRenderList);
          projectObject(scene, camera, 0, _this.sortObjects);
          currentRenderList.finish();
          if (_this.sortObjects === true) {
            currentRenderList.sort(_opaqueSort, _transparentSort);
          }
          if (_clippingEnabled === true)
            clipping.beginShadows();
          const shadowsArray = currentRenderState.state.shadowsArray;
          shadowMap.render(shadowsArray, scene, camera);
          if (_clippingEnabled === true)
            clipping.endShadows();
          if (this.info.autoReset === true)
            this.info.reset();
          background.render(currentRenderList, scene);
          currentRenderState.setupLights(_this.physicallyCorrectLights);
          if (camera.isArrayCamera) {
            const cameras = camera.cameras;
            for (let i2 = 0, l = cameras.length; i2 < l; i2++) {
              const camera2 = cameras[i2];
              renderScene(currentRenderList, scene, camera2, camera2.viewport);
            }
          } else {
            renderScene(currentRenderList, scene, camera);
          }
          if (_currentRenderTarget !== null) {
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
            textures.updateRenderTargetMipmap(_currentRenderTarget);
          }
          if (scene.isScene === true)
            scene.onAfterRender(_this, scene, camera);
          state.buffers.depth.setTest(true);
          state.buffers.depth.setMask(true);
          state.buffers.color.setMask(true);
          state.setPolygonOffset(false);
          bindingStates.resetDefaultState();
          _currentMaterialId = -1;
          _currentCamera = null;
          renderStateStack.pop();
          if (renderStateStack.length > 0) {
            currentRenderState = renderStateStack[renderStateStack.length - 1];
          } else {
            currentRenderState = null;
          }
          renderListStack.pop();
          if (renderListStack.length > 0) {
            currentRenderList = renderListStack[renderListStack.length - 1];
          } else {
            currentRenderList = null;
          }
        };
        function projectObject(object, camera, groupOrder, sortObjects) {
          if (object.visible === false)
            return;
          const visible = object.layers.test(camera.layers);
          if (visible) {
            if (object.isGroup) {
              groupOrder = object.renderOrder;
            } else if (object.isLOD) {
              if (object.autoUpdate === true)
                object.update(camera);
            } else if (object.isLight) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            } else if (object.isSprite) {
              if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix3);
                }
                const geometry = objects.update(object);
                const material = object.material;
                if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
              }
            } else if (object.isMesh || object.isLine || object.isPoints) {
              if (object.isSkinnedMesh) {
                if (object.skeleton.frame !== info.render.frame) {
                  object.skeleton.update();
                  object.skeleton.frame = info.render.frame;
                }
              }
              if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                if (sortObjects) {
                  _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix3);
                }
                const geometry = objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                  const groups = geometry.groups;
                  for (let i2 = 0, l = groups.length; i2 < l; i2++) {
                    const group = groups[i2];
                    const groupMaterial = material[group.materialIndex];
                    if (groupMaterial && groupMaterial.visible) {
                      currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                    }
                  }
                } else if (material.visible) {
                  currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
              }
            }
          }
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            projectObject(children[i2], camera, groupOrder, sortObjects);
          }
        }
        function renderScene(currentRenderList2, scene, camera, viewport) {
          const opaqueObjects = currentRenderList2.opaque;
          const transmissiveObjects = currentRenderList2.transmissive;
          const transparentObjects = currentRenderList2.transparent;
          currentRenderState.setupLightsView(camera);
          if (transmissiveObjects.length > 0)
            renderTransmissionPass(opaqueObjects, scene, camera);
          if (viewport)
            state.viewport(_currentViewport.copy(viewport));
          if (opaqueObjects.length > 0)
            renderObjects(opaqueObjects, scene, camera);
          if (transmissiveObjects.length > 0)
            renderObjects(transmissiveObjects, scene, camera);
          if (transparentObjects.length > 0)
            renderObjects(transparentObjects, scene, camera);
        }
        function renderTransmissionPass(opaqueObjects, scene, camera) {
          if (_transmissionRenderTarget === null) {
            const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
            const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget2 : WebGLRenderTarget3;
            _transmissionRenderTarget = new renderTargetType(1024, 1024, {
              generateMipmaps: true,
              type: utils.convert(HalfFloatType2) !== null ? HalfFloatType2 : UnsignedByteType2,
              minFilter: LinearMipmapLinearFilter2,
              magFilter: NearestFilter2,
              wrapS: ClampToEdgeWrapping2,
              wrapT: ClampToEdgeWrapping2,
              useRenderToTexture: extensions.has("WEBGL_multisampled_render_to_texture")
            });
          }
          const currentRenderTarget = _this.getRenderTarget();
          _this.setRenderTarget(_transmissionRenderTarget);
          _this.clear();
          const currentToneMapping = _this.toneMapping;
          _this.toneMapping = NoToneMapping2;
          renderObjects(opaqueObjects, scene, camera);
          _this.toneMapping = currentToneMapping;
          textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
          textures.updateRenderTargetMipmap(_transmissionRenderTarget);
          _this.setRenderTarget(currentRenderTarget);
        }
        function renderObjects(renderList, scene, camera) {
          const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
          for (let i2 = 0, l = renderList.length; i2 < l; i2++) {
            const renderItem = renderList[i2];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (object.layers.test(camera.layers)) {
              renderObject(object, scene, camera, geometry, material, group);
            }
          }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
          object.onBeforeRender(_this, scene, camera, geometry, material, group);
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          material.onBeforeRender(_this, scene, camera, geometry, object, group);
          if (material.transparent === true && material.side === DoubleSide3) {
            material.side = BackSide2;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = FrontSide2;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = DoubleSide3;
          } else {
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          }
          object.onAfterRender(_this, scene, camera, geometry, material, group);
        }
        function getProgram(material, scene, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          const shadowsArray = currentRenderState.state.shadowsArray;
          const lightsStateVersion = lights.state.version;
          const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
          const programCacheKey = programCache.getProgramCacheKey(parameters2);
          let programs = materialProperties.programs;
          materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
          materialProperties.fog = scene.fog;
          materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
          if (programs === void 0) {
            material.addEventListener("dispose", onMaterialDispose);
            programs = /* @__PURE__ */ new Map();
            materialProperties.programs = programs;
          }
          let program = programs.get(programCacheKey);
          if (program !== void 0) {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
              updateCommonMaterialProperties(material, parameters2);
              return program;
            }
          } else {
            parameters2.uniforms = programCache.getUniforms(material);
            material.onBuild(object, parameters2, _this);
            material.onBeforeCompile(parameters2, _this);
            program = programCache.acquireProgram(parameters2, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters2.uniforms;
          }
          const uniforms = materialProperties.uniforms;
          if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            uniforms.clippingPlanes = clipping.uniform;
          }
          updateCommonMaterialProperties(material, parameters2);
          materialProperties.needsLights = materialNeedsLights(material);
          materialProperties.lightsStateVersion = lightsStateVersion;
          if (materialProperties.needsLights) {
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
          }
          const progUniforms = program.getUniforms();
          const uniformsList = WebGLUniforms2.seqWithValue(progUniforms.seq, uniforms);
          materialProperties.currentProgram = program;
          materialProperties.uniformsList = uniformsList;
          return program;
        }
        function updateCommonMaterialProperties(material, parameters2) {
          const materialProperties = properties.get(material);
          materialProperties.outputEncoding = parameters2.outputEncoding;
          materialProperties.instancing = parameters2.instancing;
          materialProperties.skinning = parameters2.skinning;
          materialProperties.morphTargets = parameters2.morphTargets;
          materialProperties.morphNormals = parameters2.morphNormals;
          materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
          materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
          materialProperties.numIntersection = parameters2.numClipIntersection;
          materialProperties.vertexAlphas = parameters2.vertexAlphas;
          materialProperties.vertexTangents = parameters2.vertexTangents;
          materialProperties.toneMapping = parameters2.toneMapping;
        }
        function setProgram(camera, scene, geometry, material, object) {
          if (scene.isScene !== true)
            scene = _emptyScene;
          textures.resetTextureUnits();
          const fog = scene.fog;
          const environment = material.isMeshStandardMaterial ? scene.environment : null;
          const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding2;
          const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
          const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
          const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
          const morphTargets = !!geometry.morphAttributes.position;
          const morphNormals = !!geometry.morphAttributes.normal;
          const morphTargetsCount = !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
          const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping2;
          const materialProperties = properties.get(material);
          const lights = currentRenderState.state.lights;
          if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
              const useCache = camera === _currentCamera && material.id === _currentMaterialId;
              clipping.setState(material, camera, useCache);
            }
          }
          let needsProgramChange = false;
          if (material.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
              needsProgramChange = true;
            } else if (materialProperties.outputEncoding !== encoding) {
              needsProgramChange = true;
            } else if (object.isInstancedMesh && materialProperties.instancing === false) {
              needsProgramChange = true;
            } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
              needsProgramChange = true;
            } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
              needsProgramChange = true;
            } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
              needsProgramChange = true;
            } else if (materialProperties.envMap !== envMap) {
              needsProgramChange = true;
            } else if (material.fog && materialProperties.fog !== fog) {
              needsProgramChange = true;
            } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
              needsProgramChange = true;
            } else if (materialProperties.vertexAlphas !== vertexAlphas) {
              needsProgramChange = true;
            } else if (materialProperties.vertexTangents !== vertexTangents) {
              needsProgramChange = true;
            } else if (materialProperties.morphTargets !== morphTargets) {
              needsProgramChange = true;
            } else if (materialProperties.morphNormals !== morphNormals) {
              needsProgramChange = true;
            } else if (materialProperties.toneMapping !== toneMapping) {
              needsProgramChange = true;
            } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
              needsProgramChange = true;
            }
          } else {
            needsProgramChange = true;
            materialProperties.__version = material.version;
          }
          let program = materialProperties.currentProgram;
          if (needsProgramChange === true) {
            program = getProgram(material, scene, object);
          }
          let refreshProgram = false;
          let refreshMaterial = false;
          let refreshLights = false;
          const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
          if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
          }
          if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
          }
          if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) {
              p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
            }
            if (_currentCamera !== camera) {
              _currentCamera = camera;
              refreshMaterial = true;
              refreshLights = true;
            }
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
              const uCamPos = p_uniforms.map.cameraPosition;
              if (uCamPos !== void 0) {
                uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
              }
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
              p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
              p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
          }
          if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            const skeleton = object.skeleton;
            if (skeleton) {
              if (capabilities.floatVertexTextures) {
                if (skeleton.boneTexture === null)
                  skeleton.computeBoneTexture();
                p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
                p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
              } else {
                p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
              }
            }
          }
          if (!!geometry && (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0)) {
            morphtargets.update(object, geometry, material, program);
          }
          if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
          }
          if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            if (materialProperties.needsLights) {
              markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            if (fog && material.fog) {
              materials.refreshFogUniforms(m_uniforms, fog);
            }
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height2, _transmissionRenderTarget);
            WebGLUniforms2.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
          }
          if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms2.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
          }
          if (material.isSpriteMaterial) {
            p_uniforms.setValue(_gl, "center", object.center);
          }
          p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
          p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
          p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
          return program;
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
          uniforms.ambientLightColor.needsUpdate = value;
          uniforms.lightProbe.needsUpdate = value;
          uniforms.directionalLights.needsUpdate = value;
          uniforms.directionalLightShadows.needsUpdate = value;
          uniforms.pointLights.needsUpdate = value;
          uniforms.pointLightShadows.needsUpdate = value;
          uniforms.spotLights.needsUpdate = value;
          uniforms.spotLightShadows.needsUpdate = value;
          uniforms.rectAreaLights.needsUpdate = value;
          uniforms.hemisphereLights.needsUpdate = value;
        }
        function materialNeedsLights(material) {
          return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
        }
        this.getActiveCubeFace = function() {
          return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function() {
          return _currentActiveMipmapLevel;
        };
        this.getRenderTarget = function() {
          return _currentRenderTarget;
        };
        this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
          properties.get(renderTarget.texture).__webglTexture = colorTexture;
          properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__hasExternalTextures = true;
          if (renderTargetProperties.__hasExternalTextures) {
            renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
            if (!renderTargetProperties.__autoAllocateDepthBuffer) {
              if (renderTarget.useRenderToTexture) {
                console.warn("render-to-texture extension was disabled because an external texture was provided");
                renderTarget.useRenderToTexture = false;
                renderTarget.useRenderbuffer = true;
              }
            }
          }
        };
        this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
          const renderTargetProperties = properties.get(renderTarget);
          renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
          renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
        };
        this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
          _currentRenderTarget = renderTarget;
          _currentActiveCubeFace = activeCubeFace;
          _currentActiveMipmapLevel = activeMipmapLevel;
          let useDefaultFramebuffer = true;
          if (renderTarget) {
            const renderTargetProperties = properties.get(renderTarget);
            if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, null);
              useDefaultFramebuffer = false;
            } else if (renderTargetProperties.__webglFramebuffer === void 0) {
              textures.setupRenderTarget(renderTarget);
            } else if (renderTargetProperties.__hasExternalTextures) {
              textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
            }
          }
          let framebuffer = null;
          let isCube = false;
          let isRenderTarget3D = false;
          if (renderTarget) {
            const texture = renderTarget.texture;
            if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
              isRenderTarget3D = true;
            }
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
              framebuffer = __webglFramebuffer[activeCubeFace];
              isCube = true;
            } else if (renderTarget.useRenderbuffer) {
              framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            } else {
              framebuffer = __webglFramebuffer;
            }
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
          } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
          }
          const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
            state.drawBuffers(renderTarget, framebuffer);
          }
          state.viewport(_currentViewport);
          state.scissor(_currentScissor);
          state.setScissorTest(_currentScissorTest);
          if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
          } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
          }
          _currentMaterialId = -1;
        };
        this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
          if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
          }
          let framebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
            framebuffer = framebuffer[activeCubeFaceIndex];
          }
          if (framebuffer) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            try {
              const texture = renderTarget.texture;
              const textureFormat = texture.format;
              const textureType = texture.type;
              if (textureFormat !== RGBAFormat2 && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                return;
              }
              const halfFloatSupportedByExt = textureType === HalfFloatType2 && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
              if (textureType !== UnsignedByteType2 && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType2 && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                return;
              }
              if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
                  _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                }
              } else {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
              }
            } finally {
              const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
            }
          }
        };
        this.copyFramebufferToTexture = function(position, texture, level = 0) {
          if (texture.isFramebufferTexture !== true) {
            console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
            return;
          }
          const levelScale = Math.pow(2, -level);
          const width = Math.floor(texture.image.width * levelScale);
          const height = Math.floor(texture.image.height * levelScale);
          textures.setTexture2D(texture, 0);
          _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
          state.unbindTexture();
        };
        this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
          const width = srcTexture.image.width;
          const height = srcTexture.image.height;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          textures.setTexture2D(dstTexture, 0);
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
            } else {
              _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
            }
          }
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(_gl.TEXTURE_2D);
          state.unbindTexture();
        };
        this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
          if (_this.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return;
          }
          const width = sourceBox.max.x - sourceBox.min.x + 1;
          const height = sourceBox.max.y - sourceBox.min.y + 1;
          const depth = sourceBox.max.z - sourceBox.min.z + 1;
          const glFormat = utils.convert(dstTexture.format);
          const glType = utils.convert(dstTexture.type);
          let glTarget;
          if (dstTexture.isDataTexture3D) {
            textures.setTexture3D(dstTexture, 0);
            glTarget = _gl.TEXTURE_3D;
          } else if (dstTexture.isDataTexture2DArray) {
            textures.setTexture2DArray(dstTexture, 0);
            glTarget = _gl.TEXTURE_2D_ARRAY;
          } else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return;
          }
          _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
          _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
          _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
          const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
          const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
          const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
          const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
          const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
          const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
          if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
            _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
              _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
            } else {
              _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
            }
          }
          _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
          _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
          _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
          _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
          _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
          if (level === 0 && dstTexture.generateMipmaps)
            _gl.generateMipmap(glTarget);
          state.unbindTexture();
        };
        this.initTexture = function(texture) {
          textures.setTexture2D(texture, 0);
          state.unbindTexture();
        };
        this.resetState = function() {
          _currentActiveCubeFace = 0;
          _currentActiveMipmapLevel = 0;
          _currentRenderTarget = null;
          state.reset();
          bindingStates.reset();
        };
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
      }
      WebGLRenderer2.prototype.isWebGLRenderer = true;
      var WebGL1Renderer2 = class extends WebGLRenderer2 {
      };
      WebGL1Renderer2.prototype.isWebGL1Renderer = true;
      var FogExp22 = class {
        constructor(color, density = 25e-5) {
          this.name = "";
          this.color = new Color2(color);
          this.density = density;
        }
        clone() {
          return new FogExp22(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      };
      FogExp22.prototype.isFogExp2 = true;
      var Fog2 = class {
        constructor(color, near = 1, far = 1e3) {
          this.name = "";
          this.color = new Color2(color);
          this.near = near;
          this.far = far;
        }
        clone() {
          return new Fog2(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      };
      Fog2.prototype.isFog = true;
      var Scene2 = class extends Object3D2 {
        constructor() {
          super();
          this.type = "Scene";
          this.background = null;
          this.environment = null;
          this.fog = null;
          this.overrideMaterial = null;
          this.autoUpdate = true;
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
              detail: this
            }));
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.background !== null)
            this.background = source.background.clone();
          if (source.environment !== null)
            this.environment = source.environment.clone();
          if (source.fog !== null)
            this.fog = source.fog.clone();
          if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
          this.autoUpdate = source.autoUpdate;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.fog !== null)
            data.object.fog = this.fog.toJSON();
          return data;
        }
      };
      Scene2.prototype.isScene = true;
      var InterleavedBuffer2 = class {
        constructor(array, stride) {
          this.array = array;
          this.stride = stride;
          this.count = array !== void 0 ? array.length / stride : 0;
          this.usage = StaticDrawUsage2;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
          this.uuid = generateUUID2();
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.stride;
          index2 *= attribute.stride;
          for (let i2 = 0, l = this.stride; i2 < l; i2++) {
            this.array[index1 + i2] = attribute.array[index2 + i2];
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        clone(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID2();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
          }
          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
          const ib = new this.constructor(array, this.stride);
          ib.setUsage(this.usage);
          return ib;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        toJSON(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID2();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
          }
          return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      };
      InterleavedBuffer2.prototype.isInterleavedBuffer = true;
      var _vector$62 = /* @__PURE__ */ new Vector32();
      var InterleavedBufferAttribute2 = class {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
          this.name = "";
          this.data = interleavedBuffer;
          this.itemSize = itemSize;
          this.offset = offset;
          this.normalized = normalized === true;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(value) {
          this.data.needsUpdate = value;
        }
        applyMatrix4(m) {
          for (let i2 = 0, l = this.data.count; i2 < l; i2++) {
            _vector$62.x = this.getX(i2);
            _vector$62.y = this.getY(i2);
            _vector$62.z = this.getZ(i2);
            _vector$62.applyMatrix4(m);
            this.setXYZ(i2, _vector$62.x, _vector$62.y, _vector$62.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$62.x = this.getX(i2);
            _vector$62.y = this.getY(i2);
            _vector$62.z = this.getZ(i2);
            _vector$62.applyNormalMatrix(m);
            this.setXYZ(i2, _vector$62.x, _vector$62.y, _vector$62.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$62.x = this.getX(i2);
            _vector$62.y = this.getY(i2);
            _vector$62.z = this.getZ(i2);
            _vector$62.transformDirection(m);
            this.setXYZ(i2, _vector$62.x, _vector$62.y, _vector$62.z);
          }
          return this;
        }
        setX(index, x) {
          this.data.array[index * this.data.stride + this.offset] = x;
          return this;
        }
        setY(index, y) {
          this.data.array[index * this.data.stride + this.offset + 1] = y;
          return this;
        }
        setZ(index, z) {
          this.data.array[index * this.data.stride + this.offset + 2] = z;
          return this;
        }
        setW(index, w) {
          this.data.array[index * this.data.stride + this.offset + 3] = w;
          return this;
        }
        getX(index) {
          return this.data.array[index * this.data.stride + this.offset];
        }
        getY(index) {
          return this.data.array[index * this.data.stride + this.offset + 1];
        }
        getZ(index) {
          return this.data.array[index * this.data.stride + this.offset + 2];
        }
        getW(index) {
          return this.data.array[index * this.data.stride + this.offset + 3];
        }
        setXY(index, x, y) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x, y, z) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x, y, z, w) {
          index = index * this.data.stride + this.offset;
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          this.data.array[index + 3] = w;
          return this;
        }
        clone(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return new BufferAttribute2(new this.array.constructor(array), this.itemSize, this.normalized);
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new InterleavedBufferAttribute2(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
          }
        }
        toJSON(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for (let i2 = 0; i2 < this.count; i2++) {
              const index = i2 * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array,
              normalized: this.normalized
            };
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
              isInterleavedBufferAttribute: true,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized
            };
          }
        }
      };
      InterleavedBufferAttribute2.prototype.isInterleavedBufferAttribute = true;
      var SpriteMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "SpriteMaterial";
          this.color = new Color2(16777215);
          this.map = null;
          this.alphaMap = null;
          this.rotation = 0;
          this.sizeAttenuation = true;
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.rotation = source.rotation;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      };
      SpriteMaterial2.prototype.isSpriteMaterial = true;
      var _geometry2;
      var _intersectPoint2 = /* @__PURE__ */ new Vector32();
      var _worldScale2 = /* @__PURE__ */ new Vector32();
      var _mvPosition2 = /* @__PURE__ */ new Vector32();
      var _alignedPosition2 = /* @__PURE__ */ new Vector22();
      var _rotatedPosition2 = /* @__PURE__ */ new Vector22();
      var _viewWorldMatrix2 = /* @__PURE__ */ new Matrix42();
      var _vA2 = /* @__PURE__ */ new Vector32();
      var _vB2 = /* @__PURE__ */ new Vector32();
      var _vC2 = /* @__PURE__ */ new Vector32();
      var _uvA2 = /* @__PURE__ */ new Vector22();
      var _uvB2 = /* @__PURE__ */ new Vector22();
      var _uvC2 = /* @__PURE__ */ new Vector22();
      var Sprite2 = class extends Object3D2 {
        constructor(material) {
          super();
          this.type = "Sprite";
          if (_geometry2 === void 0) {
            _geometry2 = new BufferGeometry2();
            const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
            const interleavedBuffer = new InterleavedBuffer2(float32Array, 5);
            _geometry2.setIndex([0, 1, 2, 0, 2, 3]);
            _geometry2.setAttribute("position", new InterleavedBufferAttribute2(interleavedBuffer, 3, 0, false));
            _geometry2.setAttribute("uv", new InterleavedBufferAttribute2(interleavedBuffer, 2, 3, false));
          }
          this.geometry = _geometry2;
          this.material = material !== void 0 ? material : new SpriteMaterial2();
          this.center = new Vector22(0.5, 0.5);
        }
        raycast(raycaster, intersects3) {
          if (raycaster.camera === null) {
            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
          }
          _worldScale2.setFromMatrixScale(this.matrixWorld);
          _viewWorldMatrix2.copy(raycaster.camera.matrixWorld);
          this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
          _mvPosition2.setFromMatrixPosition(this.modelViewMatrix);
          if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
            _worldScale2.multiplyScalar(-_mvPosition2.z);
          }
          const rotation = this.material.rotation;
          let sin, cos;
          if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
          }
          const center = this.center;
          transformVertex2(_vA2.set(-0.5, -0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
          transformVertex2(_vB2.set(0.5, -0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
          transformVertex2(_vC2.set(0.5, 0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
          _uvA2.set(0, 0);
          _uvB2.set(1, 0);
          _uvC2.set(1, 1);
          let intersect = raycaster.ray.intersectTriangle(_vA2, _vB2, _vC2, false, _intersectPoint2);
          if (intersect === null) {
            transformVertex2(_vB2.set(-0.5, 0.5, 0), _mvPosition2, center, _worldScale2, sin, cos);
            _uvB2.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA2, _vC2, _vB2, false, _intersectPoint2);
            if (intersect === null) {
              return;
            }
          }
          const distance = raycaster.ray.origin.distanceTo(_intersectPoint2);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects3.push({
            distance,
            point: _intersectPoint2.clone(),
            uv: Triangle2.getUV(_intersectPoint2, _vA2, _vB2, _vC2, _uvA2, _uvB2, _uvC2, new Vector22()),
            face: null,
            object: this
          });
        }
        copy(source) {
          super.copy(source);
          if (source.center !== void 0)
            this.center.copy(source.center);
          this.material = source.material;
          return this;
        }
      };
      Sprite2.prototype.isSprite = true;
      function transformVertex2(vertexPosition, mvPosition, center, scale, sin, cos) {
        _alignedPosition2.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
        if (sin !== void 0) {
          _rotatedPosition2.x = cos * _alignedPosition2.x - sin * _alignedPosition2.y;
          _rotatedPosition2.y = sin * _alignedPosition2.x + cos * _alignedPosition2.y;
        } else {
          _rotatedPosition2.copy(_alignedPosition2);
        }
        vertexPosition.copy(mvPosition);
        vertexPosition.x += _rotatedPosition2.x;
        vertexPosition.y += _rotatedPosition2.y;
        vertexPosition.applyMatrix4(_viewWorldMatrix2);
      }
      var _v1$2 = /* @__PURE__ */ new Vector32();
      var _v2$1 = /* @__PURE__ */ new Vector32();
      var LOD = class extends Object3D2 {
        constructor() {
          super();
          this._currentLevel = 0;
          this.type = "LOD";
          Object.defineProperties(this, {
            levels: {
              enumerable: true,
              value: []
            },
            isLOD: {
              value: true
            }
          });
          this.autoUpdate = true;
        }
        copy(source) {
          super.copy(source, false);
          const levels = source.levels;
          for (let i2 = 0, l = levels.length; i2 < l; i2++) {
            const level = levels[i2];
            this.addLevel(level.object.clone(), level.distance);
          }
          this.autoUpdate = source.autoUpdate;
          return this;
        }
        addLevel(object, distance = 0) {
          distance = Math.abs(distance);
          const levels = this.levels;
          let l;
          for (l = 0; l < levels.length; l++) {
            if (distance < levels[l].distance) {
              break;
            }
          }
          levels.splice(l, 0, {
            distance,
            object
          });
          this.add(object);
          return this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(distance) {
          const levels = this.levels;
          if (levels.length > 0) {
            let i2, l;
            for (i2 = 1, l = levels.length; i2 < l; i2++) {
              if (distance < levels[i2].distance) {
                break;
              }
            }
            return levels[i2 - 1].object;
          }
          return null;
        }
        raycast(raycaster, intersects3) {
          const levels = this.levels;
          if (levels.length > 0) {
            _v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects3);
          }
        }
        update(camera) {
          const levels = this.levels;
          if (levels.length > 1) {
            _v1$2.setFromMatrixPosition(camera.matrixWorld);
            _v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i2, l;
            for (i2 = 1, l = levels.length; i2 < l; i2++) {
              if (distance >= levels[i2].distance) {
                levels[i2 - 1].object.visible = false;
                levels[i2].object.visible = true;
              } else {
                break;
              }
            }
            this._currentLevel = i2 - 1;
            for (; i2 < l; i2++) {
              levels[i2].object.visible = false;
            }
          }
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.autoUpdate === false)
            data.object.autoUpdate = false;
          data.object.levels = [];
          const levels = this.levels;
          for (let i2 = 0, l = levels.length; i2 < l; i2++) {
            const level = levels[i2];
            data.object.levels.push({
              object: level.object.uuid,
              distance: level.distance
            });
          }
          return data;
        }
      };
      var _basePosition2 = /* @__PURE__ */ new Vector32();
      var _skinIndex2 = /* @__PURE__ */ new Vector42();
      var _skinWeight2 = /* @__PURE__ */ new Vector42();
      var _vector$52 = /* @__PURE__ */ new Vector32();
      var _matrix2 = /* @__PURE__ */ new Matrix42();
      var SkinnedMesh2 = class extends Mesh2 {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "SkinnedMesh";
          this.bindMode = "attached";
          this.bindMatrix = new Matrix42();
          this.bindMatrixInverse = new Matrix42();
        }
        copy(source) {
          super.copy(source);
          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);
          this.skeleton = source.skeleton;
          return this;
        }
        bind(skeleton, bindMatrix) {
          this.skeleton = skeleton;
          if (bindMatrix === void 0) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
          }
          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const vector = new Vector42();
          const skinWeight = this.geometry.attributes.skinWeight;
          for (let i2 = 0, l = skinWeight.count; i2 < l; i2++) {
            vector.x = skinWeight.getX(i2);
            vector.y = skinWeight.getY(i2);
            vector.z = skinWeight.getZ(i2);
            vector.w = skinWeight.getW(i2);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) {
              vector.multiplyScalar(scale);
            } else {
              vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
          }
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.bindMode === "attached") {
            this.bindMatrixInverse.copy(this.matrixWorld).invert();
          } else if (this.bindMode === "detached") {
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
          } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
        }
        boneTransform(index, target) {
          const skeleton = this.skeleton;
          const geometry = this.geometry;
          _skinIndex2.fromBufferAttribute(geometry.attributes.skinIndex, index);
          _skinWeight2.fromBufferAttribute(geometry.attributes.skinWeight, index);
          _basePosition2.copy(target).applyMatrix4(this.bindMatrix);
          target.set(0, 0, 0);
          for (let i2 = 0; i2 < 4; i2++) {
            const weight = _skinWeight2.getComponent(i2);
            if (weight !== 0) {
              const boneIndex = _skinIndex2.getComponent(i2);
              _matrix2.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              target.addScaledVector(_vector$52.copy(_basePosition2).applyMatrix4(_matrix2), weight);
            }
          }
          return target.applyMatrix4(this.bindMatrixInverse);
        }
      };
      SkinnedMesh2.prototype.isSkinnedMesh = true;
      var Bone2 = class extends Object3D2 {
        constructor() {
          super();
          this.type = "Bone";
        }
      };
      Bone2.prototype.isBone = true;
      var DataTexture2 = class extends Texture2 {
        constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter2, minFilter = NearestFilter2, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.image = {
            data,
            width,
            height
          };
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      DataTexture2.prototype.isDataTexture = true;
      var _offsetMatrix2 = /* @__PURE__ */ new Matrix42();
      var _identityMatrix4 = /* @__PURE__ */ new Matrix42();
      var Skeleton2 = class {
        constructor(bones = [], boneInverses = []) {
          this.uuid = generateUUID2();
          this.bones = bones.slice(0);
          this.boneInverses = boneInverses;
          this.boneMatrices = null;
          this.boneTexture = null;
          this.boneTextureSize = 0;
          this.frame = -1;
          this.init();
        }
        init() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          this.boneMatrices = new Float32Array(bones.length * 16);
          if (boneInverses.length === 0) {
            this.calculateInverses();
          } else {
            if (bones.length !== boneInverses.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
              this.boneInverses = [];
              for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
                this.boneInverses.push(new Matrix42());
              }
            }
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const inverse = new Matrix42();
            if (this.bones[i2]) {
              inverse.copy(this.bones[i2].matrixWorld).invert();
            }
            this.boneInverses.push(inverse);
          }
        }
        pose() {
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              bone.matrixWorld.copy(this.boneInverses[i2]).invert();
            }
          }
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone) {
              if (bone.parent && bone.parent.isBone) {
                bone.matrix.copy(bone.parent.matrixWorld).invert();
                bone.matrix.multiply(bone.matrixWorld);
              } else {
                bone.matrix.copy(bone.matrixWorld);
              }
              bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
          }
        }
        update() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;
          for (let i2 = 0, il = bones.length; i2 < il; i2++) {
            const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix4;
            _offsetMatrix2.multiplyMatrices(matrix, boneInverses[i2]);
            _offsetMatrix2.toArray(boneMatrices, i2 * 16);
          }
          if (boneTexture !== null) {
            boneTexture.needsUpdate = true;
          }
        }
        clone() {
          return new Skeleton2(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let size = Math.sqrt(this.bones.length * 4);
          size = ceilPowerOfTwo2(size);
          size = Math.max(size, 4);
          const boneMatrices = new Float32Array(size * size * 4);
          boneMatrices.set(this.boneMatrices);
          const boneTexture = new DataTexture2(boneMatrices, size, size, RGBAFormat2, FloatType2);
          boneTexture.needsUpdate = true;
          this.boneMatrices = boneMatrices;
          this.boneTexture = boneTexture;
          this.boneTextureSize = size;
          return this;
        }
        getBoneByName(name) {
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            const bone = this.bones[i2];
            if (bone.name === name) {
              return bone;
            }
          }
          return void 0;
        }
        dispose() {
          if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
          }
        }
        fromJSON(json, bones) {
          this.uuid = json.uuid;
          for (let i2 = 0, l = json.bones.length; i2 < l; i2++) {
            const uuid = json.bones[i2];
            let bone = bones[uuid];
            if (bone === void 0) {
              console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
              bone = new Bone2();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix42().fromArray(json.boneInverses[i2]));
          }
          this.init();
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          data.uuid = this.uuid;
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          for (let i2 = 0, l = bones.length; i2 < l; i2++) {
            const bone = bones[i2];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i2];
            data.boneInverses.push(boneInverse.toArray());
          }
          return data;
        }
      };
      var InstancedBufferAttribute2 = class extends BufferAttribute2 {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
          if (typeof normalized === "number") {
            meshPerAttribute = normalized;
            normalized = false;
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
          }
          super(array, itemSize, normalized);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.meshPerAttribute = this.meshPerAttribute;
          data.isInstancedBufferAttribute = true;
          return data;
        }
      };
      InstancedBufferAttribute2.prototype.isInstancedBufferAttribute = true;
      var _instanceLocalMatrix2 = /* @__PURE__ */ new Matrix42();
      var _instanceWorldMatrix2 = /* @__PURE__ */ new Matrix42();
      var _instanceIntersects2 = [];
      var _mesh2 = /* @__PURE__ */ new Mesh2();
      var InstancedMesh2 = class extends Mesh2 {
        constructor(geometry, material, count) {
          super(geometry, material);
          this.instanceMatrix = new InstancedBufferAttribute2(new Float32Array(count * 16), 16);
          this.instanceColor = null;
          this.count = count;
          this.frustumCulled = false;
        }
        copy(source) {
          super.copy(source);
          this.instanceMatrix.copy(source.instanceMatrix);
          if (source.instanceColor !== null)
            this.instanceColor = source.instanceColor.clone();
          this.count = source.count;
          return this;
        }
        getColorAt(index, color) {
          color.fromArray(this.instanceColor.array, index * 3);
        }
        getMatrixAt(index, matrix) {
          matrix.fromArray(this.instanceMatrix.array, index * 16);
        }
        raycast(raycaster, intersects3) {
          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;
          _mesh2.geometry = this.geometry;
          _mesh2.material = this.material;
          if (_mesh2.material === void 0)
            return;
          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
            this.getMatrixAt(instanceId, _instanceLocalMatrix2);
            _instanceWorldMatrix2.multiplyMatrices(matrixWorld, _instanceLocalMatrix2);
            _mesh2.matrixWorld = _instanceWorldMatrix2;
            _mesh2.raycast(raycaster, _instanceIntersects2);
            for (let i2 = 0, l = _instanceIntersects2.length; i2 < l; i2++) {
              const intersect = _instanceIntersects2[i2];
              intersect.instanceId = instanceId;
              intersect.object = this;
              intersects3.push(intersect);
            }
            _instanceIntersects2.length = 0;
          }
        }
        setColorAt(index, color) {
          if (this.instanceColor === null) {
            this.instanceColor = new InstancedBufferAttribute2(new Float32Array(this.instanceMatrix.count * 3), 3);
          }
          color.toArray(this.instanceColor.array, index * 3);
        }
        setMatrixAt(index, matrix) {
          matrix.toArray(this.instanceMatrix.array, index * 16);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      };
      InstancedMesh2.prototype.isInstancedMesh = true;
      var LineBasicMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "LineBasicMaterial";
          this.color = new Color2(16777215);
          this.linewidth = 1;
          this.linecap = "round";
          this.linejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.linewidth = source.linewidth;
          this.linecap = source.linecap;
          this.linejoin = source.linejoin;
          return this;
        }
      };
      LineBasicMaterial2.prototype.isLineBasicMaterial = true;
      var _start$12 = /* @__PURE__ */ new Vector32();
      var _end$12 = /* @__PURE__ */ new Vector32();
      var _inverseMatrix$12 = /* @__PURE__ */ new Matrix42();
      var _ray$12 = /* @__PURE__ */ new Ray2();
      var _sphere$12 = /* @__PURE__ */ new Sphere2();
      var Line2 = class extends Object3D2 {
        constructor(geometry = new BufferGeometry2(), material = new LineBasicMaterial2()) {
          super();
          this.type = "Line";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [0];
              for (let i2 = 1, l = positionAttribute.count; i2 < l; i2++) {
                _start$12.fromBufferAttribute(positionAttribute, i2 - 1);
                _end$12.fromBufferAttribute(positionAttribute, i2);
                lineDistances[i2] = lineDistances[i2 - 1];
                lineDistances[i2] += _start$12.distanceTo(_end$12);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
            } else {
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
        raycast(raycaster, intersects3) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$12.copy(geometry.boundingSphere);
          _sphere$12.applyMatrix4(matrixWorld);
          _sphere$12.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere$12) === false)
            return;
          _inverseMatrix$12.copy(matrixWorld).invert();
          _ray$12.copy(raycaster.ray).applyMatrix4(_inverseMatrix$12);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const vStart = new Vector32();
          const vEnd = new Vector32();
          const interSegment = new Vector32();
          const interRay = new Vector32();
          const step = this.isLineSegments ? 2 : 1;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
                const a = index.getX(i2);
                const b = index.getX(i2 + 1);
                vStart.fromBufferAttribute(positionAttribute, a);
                vEnd.fromBufferAttribute(positionAttribute, b);
                const distSq = _ray$12.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects3.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
                vStart.fromBufferAttribute(positionAttribute, i2);
                vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
                const distSq = _ray$12.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq)
                  continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects3.push({
                  distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i2,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      };
      Line2.prototype.isLine = true;
      var _start2 = /* @__PURE__ */ new Vector32();
      var _end2 = /* @__PURE__ */ new Vector32();
      var LineSegments2 = class extends Line2 {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineSegments";
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
              const positionAttribute = geometry.attributes.position;
              const lineDistances = [];
              for (let i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2) {
                _start2.fromBufferAttribute(positionAttribute, i2);
                _end2.fromBufferAttribute(positionAttribute, i2 + 1);
                lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
                lineDistances[i2 + 1] = lineDistances[i2] + _start2.distanceTo(_end2);
              }
              geometry.setAttribute("lineDistance", new Float32BufferAttribute2(lineDistances, 1));
            } else {
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            }
          } else if (geometry.isGeometry) {
            console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          return this;
        }
      };
      LineSegments2.prototype.isLineSegments = true;
      var LineLoop2 = class extends Line2 {
        constructor(geometry, material) {
          super(geometry, material);
          this.type = "LineLoop";
        }
      };
      LineLoop2.prototype.isLineLoop = true;
      var PointsMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "PointsMaterial";
          this.color = new Color2(16777215);
          this.map = null;
          this.alphaMap = null;
          this.size = 1;
          this.sizeAttenuation = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.size = source.size;
          this.sizeAttenuation = source.sizeAttenuation;
          return this;
        }
      };
      PointsMaterial2.prototype.isPointsMaterial = true;
      var _inverseMatrix2 = /* @__PURE__ */ new Matrix42();
      var _ray2 = /* @__PURE__ */ new Ray2();
      var _sphere2 = /* @__PURE__ */ new Sphere2();
      var _position$22 = /* @__PURE__ */ new Vector32();
      var Points2 = class extends Object3D2 {
        constructor(geometry = new BufferGeometry2(), material = new PointsMaterial2()) {
          super();
          this.type = "Points";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source) {
          super.copy(source);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        raycast(raycaster, intersects3) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere2.copy(geometry.boundingSphere);
          _sphere2.applyMatrix4(matrixWorld);
          _sphere2.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere2) === false)
            return;
          _inverseMatrix2.copy(matrixWorld).invert();
          _ray2.copy(raycaster.ray).applyMatrix4(_inverseMatrix2);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2++) {
                const a = index.getX(i2);
                _position$22.fromBufferAttribute(positionAttribute, a);
                testPoint2(_position$22, a, localThresholdSq, matrixWorld, raycaster, intersects3, this);
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
              for (let i2 = start, l = end; i2 < l; i2++) {
                _position$22.fromBufferAttribute(positionAttribute, i2);
                testPoint2(_position$22, i2, localThresholdSq, matrixWorld, raycaster, intersects3, this);
              }
            }
          } else {
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
              const morphAttribute = morphAttributes[keys[0]];
              if (morphAttribute !== void 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                  const name = morphAttribute[m].name || String(m);
                  this.morphTargetInfluences.push(0);
                  this.morphTargetDictionary[name] = m;
                }
              }
            }
          } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== void 0 && morphTargets.length > 0) {
              console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
            }
          }
        }
      };
      Points2.prototype.isPoints = true;
      function testPoint2(point, index, localThresholdSq, matrixWorld, raycaster, intersects3, object) {
        const rayPointDistanceSq = _ray2.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          const intersectPoint = new Vector32();
          _ray2.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects3.push({
            distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index,
            face: null,
            object
          });
        }
      }
      var VideoTexture2 = class extends Texture2 {
        constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
          super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter2;
          this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter2;
          this.generateMipmaps = false;
          const scope = this;
          function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
          }
          if ("requestVideoFrameCallback" in video) {
            video.requestVideoFrameCallback(updateVideo);
          }
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const video = this.image;
          const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
          if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
            this.needsUpdate = true;
          }
        }
      };
      VideoTexture2.prototype.isVideoTexture = true;
      var FramebufferTexture2 = class extends Texture2 {
        constructor(width, height, format) {
          super({
            width,
            height
          });
          this.format = format;
          this.magFilter = NearestFilter2;
          this.minFilter = NearestFilter2;
          this.generateMipmaps = false;
          this.needsUpdate = true;
        }
      };
      FramebufferTexture2.prototype.isFramebufferTexture = true;
      var CompressedTexture2 = class extends Texture2 {
        constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
          this.image = {
            width,
            height
          };
          this.mipmaps = mipmaps;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      CompressedTexture2.prototype.isCompressedTexture = true;
      var CanvasTexture2 = class extends Texture2 {
        constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
          super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
          this.needsUpdate = true;
        }
      };
      CanvasTexture2.prototype.isCanvasTexture = true;
      var CircleGeometry = class extends BufferGeometry2 {
        constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CircleGeometry";
          this.parameters = {
            radius,
            segments,
            thetaStart,
            thetaLength
          };
          segments = Math.max(3, segments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex3 = new Vector32();
          const uv = new Vector22();
          vertices.push(0, 0, 0);
          normals.push(0, 0, 1);
          uvs.push(0.5, 0.5);
          for (let s = 0, i2 = 3; s <= segments; s++, i2 += 3) {
            const segment = thetaStart + s / segments * thetaLength;
            vertex3.x = radius * Math.cos(segment);
            vertex3.y = radius * Math.sin(segment);
            vertices.push(vertex3.x, vertex3.y, vertex3.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i2] / radius + 1) / 2;
            uv.y = (vertices[i2 + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          for (let i2 = 1; i2 <= segments; i2++) {
            indices.push(i2, i2 + 1, 0);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
        }
      };
      var CylinderGeometry = class extends BufferGeometry2 {
        constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CylinderGeometry";
          this.parameters = {
            radiusTop,
            radiusBottom,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
          const scope = this;
          radialSegments = Math.floor(radialSegments);
          heightSegments = Math.floor(heightSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let index = 0;
          const indexArray = [];
          const halfHeight = height / 2;
          let groupStart = 0;
          generateTorso();
          if (openEnded === false) {
            if (radiusTop > 0)
              generateCap(true);
            if (radiusBottom > 0)
              generateCap(false);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function generateTorso() {
            const normal = new Vector32();
            const vertex3 = new Vector32();
            let groupCount = 0;
            const slope = (radiusBottom - radiusTop) / height;
            for (let y = 0; y <= heightSegments; y++) {
              const indexRow = [];
              const v = y / heightSegments;
              const radius = v * (radiusBottom - radiusTop) + radiusTop;
              for (let x = 0; x <= radialSegments; x++) {
                const u = x / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                vertex3.x = radius * sinTheta;
                vertex3.y = -v * height + halfHeight;
                vertex3.z = radius * cosTheta;
                vertices.push(vertex3.x, vertex3.y, vertex3.z);
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, 1 - v);
                indexRow.push(index++);
              }
              indexArray.push(indexRow);
            }
            for (let x = 0; x < radialSegments; x++) {
              for (let y = 0; y < heightSegments; y++) {
                const a = indexArray[y][x];
                const b = indexArray[y + 1][x];
                const c = indexArray[y + 1][x + 1];
                const d = indexArray[y][x + 1];
                indices.push(a, b, d);
                indices.push(b, c, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
          }
          function generateCap(top) {
            const centerIndexStart = index;
            const uv = new Vector22();
            const vertex3 = new Vector32();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign3 = top === true ? 1 : -1;
            for (let x = 1; x <= radialSegments; x++) {
              vertices.push(0, halfHeight * sign3, 0);
              normals.push(0, sign3, 0);
              uvs.push(0.5, 0.5);
              index++;
            }
            const centerIndexEnd = index;
            for (let x = 0; x <= radialSegments; x++) {
              const u = x / radialSegments;
              const theta = u * thetaLength + thetaStart;
              const cosTheta = Math.cos(theta);
              const sinTheta = Math.sin(theta);
              vertex3.x = radius * sinTheta;
              vertex3.y = halfHeight * sign3;
              vertex3.z = radius * cosTheta;
              vertices.push(vertex3.x, vertex3.y, vertex3.z);
              normals.push(0, sign3, 0);
              uv.x = cosTheta * 0.5 + 0.5;
              uv.y = sinTheta * 0.5 * sign3 + 0.5;
              uvs.push(uv.x, uv.y);
              index++;
            }
            for (let x = 0; x < radialSegments; x++) {
              const c = centerIndexStart + x;
              const i2 = centerIndexEnd + x;
              if (top === true) {
                indices.push(i2, i2 + 1, c);
              } else {
                indices.push(i2 + 1, i2, c);
              }
              groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
          }
        }
        static fromJSON(data) {
          return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      };
      var ConeGeometry = class extends CylinderGeometry {
        constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
          this.type = "ConeGeometry";
          this.parameters = {
            radius,
            height,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
        }
        static fromJSON(data) {
          return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      };
      var PolyhedronGeometry = class extends BufferGeometry2 {
        constructor(vertices = [], indices = [], radius = 1, detail = 0) {
          super();
          this.type = "PolyhedronGeometry";
          this.parameters = {
            vertices,
            indices,
            radius,
            detail
          };
          const vertexBuffer = [];
          const uvBuffer = [];
          subdivide(detail);
          applyRadius(radius);
          generateUVs();
          this.setAttribute("position", new Float32BufferAttribute2(vertexBuffer, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(vertexBuffer.slice(), 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvBuffer, 2));
          if (detail === 0) {
            this.computeVertexNormals();
          } else {
            this.normalizeNormals();
          }
          function subdivide(detail2) {
            const a = new Vector32();
            const b = new Vector32();
            const c = new Vector32();
            for (let i2 = 0; i2 < indices.length; i2 += 3) {
              getVertexByIndex(indices[i2 + 0], a);
              getVertexByIndex(indices[i2 + 1], b);
              getVertexByIndex(indices[i2 + 2], c);
              subdivideFace(a, b, c, detail2);
            }
          }
          function subdivideFace(a, b, c, detail2) {
            const cols = detail2 + 1;
            const v = [];
            for (let i2 = 0; i2 <= cols; i2++) {
              v[i2] = [];
              const aj = a.clone().lerp(c, i2 / cols);
              const bj = b.clone().lerp(c, i2 / cols);
              const rows = cols - i2;
              for (let j = 0; j <= rows; j++) {
                if (j === 0 && i2 === cols) {
                  v[i2][j] = aj;
                } else {
                  v[i2][j] = aj.clone().lerp(bj, j / rows);
                }
              }
            }
            for (let i2 = 0; i2 < cols; i2++) {
              for (let j = 0; j < 2 * (cols - i2) - 1; j++) {
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                  pushVertex(v[i2][k + 1]);
                  pushVertex(v[i2 + 1][k]);
                  pushVertex(v[i2][k]);
                } else {
                  pushVertex(v[i2][k + 1]);
                  pushVertex(v[i2 + 1][k + 1]);
                  pushVertex(v[i2 + 1][k]);
                }
              }
            }
          }
          function applyRadius(radius2) {
            const vertex3 = new Vector32();
            for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
              vertex3.x = vertexBuffer[i2 + 0];
              vertex3.y = vertexBuffer[i2 + 1];
              vertex3.z = vertexBuffer[i2 + 2];
              vertex3.normalize().multiplyScalar(radius2);
              vertexBuffer[i2 + 0] = vertex3.x;
              vertexBuffer[i2 + 1] = vertex3.y;
              vertexBuffer[i2 + 2] = vertex3.z;
            }
          }
          function generateUVs() {
            const vertex3 = new Vector32();
            for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
              vertex3.x = vertexBuffer[i2 + 0];
              vertex3.y = vertexBuffer[i2 + 1];
              vertex3.z = vertexBuffer[i2 + 2];
              const u = azimuth(vertex3) / 2 / Math.PI + 0.5;
              const v = inclination(vertex3) / Math.PI + 0.5;
              uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
          }
          function correctSeam() {
            for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
              const x0 = uvBuffer[i2 + 0];
              const x1 = uvBuffer[i2 + 2];
              const x2 = uvBuffer[i2 + 4];
              const max = Math.max(x0, x1, x2);
              const min = Math.min(x0, x1, x2);
              if (max > 0.9 && min < 0.1) {
                if (x0 < 0.2)
                  uvBuffer[i2 + 0] += 1;
                if (x1 < 0.2)
                  uvBuffer[i2 + 2] += 1;
                if (x2 < 0.2)
                  uvBuffer[i2 + 4] += 1;
              }
            }
          }
          function pushVertex(vertex3) {
            vertexBuffer.push(vertex3.x, vertex3.y, vertex3.z);
          }
          function getVertexByIndex(index, vertex3) {
            const stride = index * 3;
            vertex3.x = vertices[stride + 0];
            vertex3.y = vertices[stride + 1];
            vertex3.z = vertices[stride + 2];
          }
          function correctUVs() {
            const a = new Vector32();
            const b = new Vector32();
            const c = new Vector32();
            const centroid = new Vector32();
            const uvA = new Vector22();
            const uvB = new Vector22();
            const uvC = new Vector22();
            for (let i2 = 0, j = 0; i2 < vertexBuffer.length; i2 += 9, j += 6) {
              a.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
              b.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
              c.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
              uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
              uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
              uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
              centroid.copy(a).add(b).add(c).divideScalar(3);
              const azi = azimuth(centroid);
              correctUV(uvA, j + 0, a, azi);
              correctUV(uvB, j + 2, b, azi);
              correctUV(uvC, j + 4, c, azi);
            }
          }
          function correctUV(uv, stride, vector, azimuth2) {
            if (azimuth2 < 0 && uv.x === 1) {
              uvBuffer[stride] = uv.x - 1;
            }
            if (vector.x === 0 && vector.z === 0) {
              uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
            }
          }
          function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
          }
          function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
          }
        }
        static fromJSON(data) {
          return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
        }
      };
      var DodecahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t = (1 + Math.sqrt(5)) / 2;
          const r = 1 / t;
          const vertices = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            0,
            -t,
            0,
            -r,
            t,
            0,
            -r,
            -t,
            0,
            r,
            t,
            0,
            r
          ];
          const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
          super(vertices, indices, radius, detail);
          this.type = "DodecahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new DodecahedronGeometry(data.radius, data.detail);
        }
      };
      var _v02 = new Vector32();
      var _v1$12 = new Vector32();
      var _normal2 = new Vector32();
      var _triangle2 = new Triangle2();
      var EdgesGeometry = class extends BufferGeometry2 {
        constructor(geometry = null, thresholdAngle = 1) {
          super();
          this.type = "EdgesGeometry";
          this.parameters = {
            geometry,
            thresholdAngle
          };
          if (geometry !== null) {
            const precisionPoints = 4;
            const precision = Math.pow(10, precisionPoints);
            const thresholdDot = Math.cos(DEG2RAD3 * thresholdAngle);
            const indexAttr = geometry.getIndex();
            const positionAttr = geometry.getAttribute("position");
            const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
            const indexArr = [0, 0, 0];
            const vertKeys = ["a", "b", "c"];
            const hashes = new Array(3);
            const edgeData = {};
            const vertices = [];
            for (let i2 = 0; i2 < indexCount; i2 += 3) {
              if (indexAttr) {
                indexArr[0] = indexAttr.getX(i2);
                indexArr[1] = indexAttr.getX(i2 + 1);
                indexArr[2] = indexAttr.getX(i2 + 2);
              } else {
                indexArr[0] = i2;
                indexArr[1] = i2 + 1;
                indexArr[2] = i2 + 2;
              }
              const {
                a,
                b,
                c
              } = _triangle2;
              a.fromBufferAttribute(positionAttr, indexArr[0]);
              b.fromBufferAttribute(positionAttr, indexArr[1]);
              c.fromBufferAttribute(positionAttr, indexArr[2]);
              _triangle2.getNormal(_normal2);
              hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
              hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
              hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
              if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                continue;
              }
              for (let j = 0; j < 3; j++) {
                const jNext = (j + 1) % 3;
                const vecHash0 = hashes[j];
                const vecHash1 = hashes[jNext];
                const v0 = _triangle2[vertKeys[j]];
                const v1 = _triangle2[vertKeys[jNext]];
                const hash = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                  if (_normal2.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                    vertices.push(v0.x, v0.y, v0.z);
                    vertices.push(v1.x, v1.y, v1.z);
                  }
                  edgeData[reverseHash] = null;
                } else if (!(hash in edgeData)) {
                  edgeData[hash] = {
                    index0: indexArr[j],
                    index1: indexArr[jNext],
                    normal: _normal2.clone()
                  };
                }
              }
            }
            for (const key in edgeData) {
              if (edgeData[key]) {
                const {
                  index0,
                  index1
                } = edgeData[key];
                _v02.fromBufferAttribute(positionAttr, index0);
                _v1$12.fromBufferAttribute(positionAttr, index1);
                vertices.push(_v02.x, _v02.y, _v02.z);
                vertices.push(_v1$12.x, _v1$12.y, _v1$12.z);
              }
            }
            this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          }
        }
      };
      var Curve2 = class {
        constructor() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
          return null;
        }
        getPointAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getPoint(t, optionalTarget);
        }
        getPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPoint(d / divisions));
          }
          return points;
        }
        getSpacedPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPointAt(d / divisions));
          }
          return points;
        }
        getLength() {
          const lengths = this.getLengths();
          return lengths[lengths.length - 1];
        }
        getLengths(divisions = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          const cache = [];
          let current, last = this.getPoint(0);
          let sum = 0;
          cache.push(0);
          for (let p2 = 1; p2 <= divisions; p2++) {
            current = this.getPoint(p2 / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
          }
          this.cacheArcLengths = cache;
          return cache;
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.getLengths();
        }
        getUtoTmapping(u, distance) {
          const arcLengths = this.getLengths();
          let i2 = 0;
          const il = arcLengths.length;
          let targetArcLength;
          if (distance) {
            targetArcLength = distance;
          } else {
            targetArcLength = u * arcLengths[il - 1];
          }
          let low = 0, high = il - 1, comparison;
          while (low <= high) {
            i2 = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i2] - targetArcLength;
            if (comparison < 0) {
              low = i2 + 1;
            } else if (comparison > 0) {
              high = i2 - 1;
            } else {
              high = i2;
              break;
            }
          }
          i2 = high;
          if (arcLengths[i2] === targetArcLength) {
            return i2 / (il - 1);
          }
          const lengthBefore = arcLengths[i2];
          const lengthAfter = arcLengths[i2 + 1];
          const segmentLength = lengthAfter - lengthBefore;
          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          const t = (i2 + segmentFraction) / (il - 1);
          return t;
        }
        getTangent(t, optionalTarget) {
          const delta = 1e-4;
          let t1 = t - delta;
          let t2 = t + delta;
          if (t1 < 0)
            t1 = 0;
          if (t2 > 1)
            t2 = 1;
          const pt1 = this.getPoint(t1);
          const pt2 = this.getPoint(t2);
          const tangent = optionalTarget || (pt1.isVector2 ? new Vector22() : new Vector32());
          tangent.copy(pt2).sub(pt1).normalize();
          return tangent;
        }
        getTangentAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getTangent(t, optionalTarget);
        }
        computeFrenetFrames(segments, closed) {
          const normal = new Vector32();
          const tangents = [];
          const normals = [];
          const binormals = [];
          const vec = new Vector32();
          const mat = new Matrix42();
          for (let i2 = 0; i2 <= segments; i2++) {
            const u = i2 / segments;
            tangents[i2] = this.getTangentAt(u, new Vector32());
          }
          normals[0] = new Vector32();
          binormals[0] = new Vector32();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);
          if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
          }
          if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
          }
          if (tz <= min) {
            normal.set(0, 0, 1);
          }
          vec.crossVectors(tangents[0], normal).normalize();
          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2] = normals[i2 - 1].clone();
            binormals[i2] = binormals[i2 - 1].clone();
            vec.crossVectors(tangents[i2 - 1], tangents[i2]);
            if (vec.length() > Number.EPSILON) {
              vec.normalize();
              const theta = Math.acos(clamp4(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
              normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
          if (closed === true) {
            let theta = Math.acos(clamp4(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
              theta = -theta;
            }
            for (let i2 = 1; i2 <= segments; i2++) {
              normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
              binormals[i2].crossVectors(tangents[i2], normals[i2]);
            }
          }
          return {
            tangents,
            normals,
            binormals
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.arcLengthDivisions = source.arcLengthDivisions;
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;
          return data;
        }
        fromJSON(json) {
          this.arcLengthDivisions = json.arcLengthDivisions;
          return this;
        }
      };
      var EllipseCurve2 = class extends Curve2 {
        constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
          super();
          this.type = "EllipseCurve";
          this.aX = aX;
          this.aY = aY;
          this.xRadius = xRadius;
          this.yRadius = yRadius;
          this.aStartAngle = aStartAngle;
          this.aEndAngle = aEndAngle;
          this.aClockwise = aClockwise;
          this.aRotation = aRotation;
        }
        getPoint(t, optionalTarget) {
          const point = optionalTarget || new Vector22();
          const twoPi = Math.PI * 2;
          let deltaAngle = this.aEndAngle - this.aStartAngle;
          const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
          while (deltaAngle < 0)
            deltaAngle += twoPi;
          while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
          if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
              deltaAngle = 0;
            } else {
              deltaAngle = twoPi;
            }
          }
          if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
              deltaAngle = -twoPi;
            } else {
              deltaAngle = deltaAngle - twoPi;
            }
          }
          const angle = this.aStartAngle + t * deltaAngle;
          let x = this.aX + this.xRadius * Math.cos(angle);
          let y = this.aY + this.yRadius * Math.sin(angle);
          if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x - this.aX;
            const ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
          }
          return point.set(x, y);
        }
        copy(source) {
          super.copy(source);
          this.aX = source.aX;
          this.aY = source.aY;
          this.xRadius = source.xRadius;
          this.yRadius = source.yRadius;
          this.aStartAngle = source.aStartAngle;
          this.aEndAngle = source.aEndAngle;
          this.aClockwise = source.aClockwise;
          this.aRotation = source.aRotation;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.aX = this.aX;
          data.aY = this.aY;
          data.xRadius = this.xRadius;
          data.yRadius = this.yRadius;
          data.aStartAngle = this.aStartAngle;
          data.aEndAngle = this.aEndAngle;
          data.aClockwise = this.aClockwise;
          data.aRotation = this.aRotation;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.aX = json.aX;
          this.aY = json.aY;
          this.xRadius = json.xRadius;
          this.yRadius = json.yRadius;
          this.aStartAngle = json.aStartAngle;
          this.aEndAngle = json.aEndAngle;
          this.aClockwise = json.aClockwise;
          this.aRotation = json.aRotation;
          return this;
        }
      };
      EllipseCurve2.prototype.isEllipseCurve = true;
      var ArcCurve2 = class extends EllipseCurve2 {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          this.type = "ArcCurve";
        }
      };
      ArcCurve2.prototype.isArcCurve = true;
      function CubicPoly2() {
        let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        function init10(x0, x1, t0, t1) {
          c0 = x0;
          c1 = t0;
          c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
          c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
          initCatmullRom: function(x0, x1, x2, x3, tension) {
            init10(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
          },
          initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            t1 *= dt1;
            t2 *= dt1;
            init10(x1, x2, t1, t2);
          },
          calc: function(t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return c0 + c1 * t + c2 * t2 + c3 * t3;
          }
        };
      }
      var tmp3 = new Vector32();
      var px2 = new CubicPoly2();
      var py2 = new CubicPoly2();
      var pz2 = new CubicPoly2();
      var CatmullRomCurve32 = class extends Curve2 {
        constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
          super();
          this.type = "CatmullRomCurve3";
          this.points = points;
          this.closed = closed;
          this.curveType = curveType;
          this.tension = tension;
        }
        getPoint(t, optionalTarget = new Vector32()) {
          const point = optionalTarget;
          const points = this.points;
          const l = points.length;
          const p2 = (l - (this.closed ? 0 : 1)) * t;
          let intPoint = Math.floor(p2);
          let weight = p2 - intPoint;
          if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
          } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
          }
          let p0, p3;
          if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
          } else {
            tmp3.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp3;
          }
          const p1 = points[intPoint % l];
          const p22 = points[(intPoint + 1) % l];
          if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
          } else {
            tmp3.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp3;
          }
          if (this.curveType === "centripetal" || this.curveType === "chordal") {
            const pow = this.curveType === "chordal" ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
            let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
            if (dt1 < 1e-4)
              dt1 = 1;
            if (dt0 < 1e-4)
              dt0 = dt1;
            if (dt2 < 1e-4)
              dt2 = dt1;
            px2.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
            py2.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
            pz2.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
          } else if (this.curveType === "catmullrom") {
            px2.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
            py2.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
            pz2.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
          }
          point.set(px2.calc(weight), py2.calc(weight), pz2.calc(weight));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          this.closed = source.closed;
          this.curveType = source.curveType;
          this.tension = source.tension;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          data.closed = this.closed;
          data.curveType = this.curveType;
          data.tension = this.tension;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector32().fromArray(point));
          }
          this.closed = json.closed;
          this.curveType = json.curveType;
          this.tension = json.tension;
          return this;
        }
      };
      CatmullRomCurve32.prototype.isCatmullRomCurve3 = true;
      function CatmullRom2(t, p0, p1, p2, p3) {
        const v0 = (p2 - p0) * 0.5;
        const v1 = (p3 - p1) * 0.5;
        const t2 = t * t;
        const t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
      function QuadraticBezierP02(t, p2) {
        const k = 1 - t;
        return k * k * p2;
      }
      function QuadraticBezierP12(t, p2) {
        return 2 * (1 - t) * t * p2;
      }
      function QuadraticBezierP22(t, p2) {
        return t * t * p2;
      }
      function QuadraticBezier2(t, p0, p1, p2) {
        return QuadraticBezierP02(t, p0) + QuadraticBezierP12(t, p1) + QuadraticBezierP22(t, p2);
      }
      function CubicBezierP02(t, p2) {
        const k = 1 - t;
        return k * k * k * p2;
      }
      function CubicBezierP12(t, p2) {
        const k = 1 - t;
        return 3 * k * k * t * p2;
      }
      function CubicBezierP22(t, p2) {
        return 3 * (1 - t) * t * t * p2;
      }
      function CubicBezierP32(t, p2) {
        return t * t * t * p2;
      }
      function CubicBezier2(t, p0, p1, p2, p3) {
        return CubicBezierP02(t, p0) + CubicBezierP12(t, p1) + CubicBezierP22(t, p2) + CubicBezierP32(t, p3);
      }
      var CubicBezierCurve2 = class extends Curve2 {
        constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22(), v3 = new Vector22()) {
          super();
          this.type = "CubicBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier2(t, v0.x, v1.x, v2.x, v3.x), CubicBezier2(t, v0.y, v1.y, v2.y, v3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      CubicBezierCurve2.prototype.isCubicBezierCurve = true;
      var CubicBezierCurve32 = class extends Curve2 {
        constructor(v0 = new Vector32(), v1 = new Vector32(), v2 = new Vector32(), v3 = new Vector32()) {
          super();
          this.type = "CubicBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector32()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(CubicBezier2(t, v0.x, v1.x, v2.x, v3.x), CubicBezier2(t, v0.y, v1.y, v2.y, v3.y), CubicBezier2(t, v0.z, v1.z, v2.z, v3.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      CubicBezierCurve32.prototype.isCubicBezierCurve3 = true;
      var LineCurve2 = class extends Curve2 {
        constructor(v1 = new Vector22(), v2 = new Vector22()) {
          super();
          this.type = "LineCurve";
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        getTangent(t, optionalTarget) {
          const tangent = optionalTarget || new Vector22();
          tangent.copy(this.v2).sub(this.v1).normalize();
          return tangent;
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      LineCurve2.prototype.isLineCurve = true;
      var LineCurve32 = class extends Curve2 {
        constructor(v1 = new Vector32(), v2 = new Vector32()) {
          super();
          this.type = "LineCurve3";
          this.isLineCurve3 = true;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector32()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      var QuadraticBezierCurve2 = class extends Curve2 {
        constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22()) {
          super();
          this.type = "QuadraticBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier2(t, v0.x, v1.x, v2.x), QuadraticBezier2(t, v0.y, v1.y, v2.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve2.prototype.isQuadraticBezierCurve = true;
      var QuadraticBezierCurve32 = class extends Curve2 {
        constructor(v0 = new Vector32(), v1 = new Vector32(), v2 = new Vector32()) {
          super();
          this.type = "QuadraticBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector32()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(QuadraticBezier2(t, v0.x, v1.x, v2.x), QuadraticBezier2(t, v0.y, v1.y, v2.y), QuadraticBezier2(t, v0.z, v1.z, v2.z));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve32.prototype.isQuadraticBezierCurve3 = true;
      var SplineCurve2 = class extends Curve2 {
        constructor(points = []) {
          super();
          this.type = "SplineCurve";
          this.points = points;
        }
        getPoint(t, optionalTarget = new Vector22()) {
          const point = optionalTarget;
          const points = this.points;
          const p2 = (points.length - 1) * t;
          const intPoint = Math.floor(p2);
          const weight = p2 - intPoint;
          const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
          const p1 = points[intPoint];
          const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
          const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
          point.set(CatmullRom2(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom2(weight, p0.y, p1.y, p22.y, p3.y));
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
            const point = source.points[i2];
            this.points.push(point.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
            const point = this.points[i2];
            data.points.push(point.toArray());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
            const point = json.points[i2];
            this.points.push(new Vector22().fromArray(point));
          }
          return this;
        }
      };
      SplineCurve2.prototype.isSplineCurve = true;
      var Curves2 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcCurve: ArcCurve2,
        CatmullRomCurve3: CatmullRomCurve32,
        CubicBezierCurve: CubicBezierCurve2,
        CubicBezierCurve3: CubicBezierCurve32,
        EllipseCurve: EllipseCurve2,
        LineCurve: LineCurve2,
        LineCurve3: LineCurve32,
        QuadraticBezierCurve: QuadraticBezierCurve2,
        QuadraticBezierCurve3: QuadraticBezierCurve32,
        SplineCurve: SplineCurve2
      });
      var CurvePath2 = class extends Curve2 {
        constructor() {
          super();
          this.type = "CurvePath";
          this.curves = [];
          this.autoClose = false;
        }
        add(curve) {
          this.curves.push(curve);
        }
        closePath() {
          const startPoint = this.curves[0].getPoint(0);
          const endPoint = this.curves[this.curves.length - 1].getPoint(1);
          if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve2(endPoint, startPoint));
          }
        }
        getPoint(t, optionalTarget) {
          const d = t * this.getLength();
          const curveLengths = this.getCurveLengths();
          let i2 = 0;
          while (i2 < curveLengths.length) {
            if (curveLengths[i2] >= d) {
              const diff = curveLengths[i2] - d;
              const curve = this.curves[i2];
              const segmentLength = curve.getLength();
              const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
              return curve.getPointAt(u, optionalTarget);
            }
            i2++;
          }
          return null;
        }
        getLength() {
          const lens = this.getCurveLengths();
          return lens[lens.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.cacheLengths = null;
          this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
          }
          const lengths = [];
          let sums = 0;
          for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
            sums += this.curves[i2].getLength();
            lengths.push(sums);
          }
          this.cacheLengths = lengths;
          return lengths;
        }
        getSpacedPoints(divisions = 40) {
          const points = [];
          for (let i2 = 0; i2 <= divisions; i2++) {
            points.push(this.getPoint(i2 / divisions));
          }
          if (this.autoClose) {
            points.push(points[0]);
          }
          return points;
        }
        getPoints(divisions = 12) {
          const points = [];
          let last;
          for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
            const curve = curves[i2];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for (let j = 0; j < pts.length; j++) {
              const point = pts[j];
              if (last && last.equals(point))
                continue;
              points.push(point);
              last = point;
            }
          }
          if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
          }
          return points;
        }
        copy(source) {
          super.copy(source);
          this.curves = [];
          for (let i2 = 0, l = source.curves.length; i2 < l; i2++) {
            const curve = source.curves[i2];
            this.curves.push(curve.clone());
          }
          this.autoClose = source.autoClose;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.autoClose = this.autoClose;
          data.curves = [];
          for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
            const curve = this.curves[i2];
            data.curves.push(curve.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.autoClose = json.autoClose;
          this.curves = [];
          for (let i2 = 0, l = json.curves.length; i2 < l; i2++) {
            const curve = json.curves[i2];
            this.curves.push(new Curves2[curve.type]().fromJSON(curve));
          }
          return this;
        }
      };
      var Path2 = class extends CurvePath2 {
        constructor(points) {
          super();
          this.type = "Path";
          this.currentPoint = new Vector22();
          if (points) {
            this.setFromPoints(points);
          }
        }
        setFromPoints(points) {
          this.moveTo(points[0].x, points[0].y);
          for (let i2 = 1, l = points.length; i2 < l; i2++) {
            this.lineTo(points[i2].x, points[i2].y);
          }
          return this;
        }
        moveTo(x, y) {
          this.currentPoint.set(x, y);
          return this;
        }
        lineTo(x, y) {
          const curve = new LineCurve2(this.currentPoint.clone(), new Vector22(x, y));
          this.curves.push(curve);
          this.currentPoint.set(x, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          const curve = new QuadraticBezierCurve2(this.currentPoint.clone(), new Vector22(aCPx, aCPy), new Vector22(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          const curve = new CubicBezierCurve2(this.currentPoint.clone(), new Vector22(aCP1x, aCP1y), new Vector22(aCP2x, aCP2y), new Vector22(aX, aY));
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        splineThru(pts) {
          const npts = [this.currentPoint.clone()].concat(pts);
          const curve = new SplineCurve2(npts);
          this.curves.push(curve);
          this.currentPoint.copy(pts[pts.length - 1]);
          return this;
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          return this;
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const curve = new EllipseCurve2(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
              this.lineTo(firstPoint.x, firstPoint.y);
            }
          }
          this.curves.push(curve);
          const lastPoint = curve.getPoint(1);
          this.currentPoint.copy(lastPoint);
          return this;
        }
        copy(source) {
          super.copy(source);
          this.currentPoint.copy(source.currentPoint);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.currentPoint = this.currentPoint.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.currentPoint.fromArray(json.currentPoint);
          return this;
        }
      };
      var Shape2 = class extends Path2 {
        constructor(points) {
          super(points);
          this.uuid = generateUUID2();
          this.type = "Shape";
          this.holes = [];
        }
        getPointsHoles(divisions) {
          const holesPts = [];
          for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
            holesPts[i2] = this.holes[i2].getPoints(divisions);
          }
          return holesPts;
        }
        extractPoints(divisions) {
          return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
          };
        }
        copy(source) {
          super.copy(source);
          this.holes = [];
          for (let i2 = 0, l = source.holes.length; i2 < l; i2++) {
            const hole = source.holes[i2];
            this.holes.push(hole.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.uuid = this.uuid;
          data.holes = [];
          for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
            const hole = this.holes[i2];
            data.holes.push(hole.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.uuid = json.uuid;
          this.holes = [];
          for (let i2 = 0, l = json.holes.length; i2 < l; i2++) {
            const hole = json.holes[i2];
            this.holes.push(new Path2().fromJSON(hole));
          }
          return this;
        }
      };
      var Earcut2 = {
        triangulate: function(data, holeIndices, dim = 2) {
          const hasHoles = holeIndices && holeIndices.length;
          const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
          let outerNode = linkedList2(data, 0, outerLen, dim, true);
          const triangles = [];
          if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
          let minX, minY, maxX, maxY, x, y, invSize;
          if (hasHoles)
            outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
          if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i2 = dim; i2 < outerLen; i2 += dim) {
              x = data[i2];
              y = data[i2 + 1];
              if (x < minX)
                minX = x;
              if (y < minY)
                minY = y;
              if (x > maxX)
                maxX = x;
              if (y > maxY)
                maxY = y;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
          }
          earcutLinked2(outerNode, triangles, dim, minX, minY, invSize);
          return triangles;
        }
      };
      function linkedList2(data, start, end, dim, clockwise) {
        let i2, last;
        if (clockwise === signedArea2(data, start, end, dim) > 0) {
          for (i2 = start; i2 < end; i2 += dim)
            last = insertNode2(i2, data[i2], data[i2 + 1], last);
        } else {
          for (i2 = end - dim; i2 >= start; i2 -= dim)
            last = insertNode2(i2, data[i2], data[i2 + 1], last);
        }
        if (last && equals2(last, last.next)) {
          removeNode2(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints2(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        let p2 = start, again;
        do {
          again = false;
          if (!p2.steiner && (equals2(p2, p2.next) || area2(p2.prev, p2, p2.next) === 0)) {
            removeNode2(p2);
            p2 = end = p2.prev;
            if (p2 === p2.next)
              break;
            again = true;
          } else {
            p2 = p2.next;
          }
        } while (again || p2 !== end);
        return end;
      }
      function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve2(ear, minX, minY, invSize);
        let stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode2(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
              earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut2(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar2(ear) {
        const a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        let p2 = ear.next.next;
        while (p2 !== ear.prev) {
          if (pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.next;
        }
        return true;
      }
      function isEarHashed2(ear, minX, minY, invSize) {
        const a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        const minZ = zOrder2(minTX, minTY, minX, minY, invSize), maxZ = zOrder2(maxTX, maxTY, minX, minY, invSize);
        let p2 = ear.prevZ, n = ear.nextZ;
        while (p2 && p2.z >= minZ && n && n.z <= maxZ) {
          if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
          if (n !== ear.prev && n !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p2 && p2.z >= minZ) {
          if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections2(start, triangles, dim) {
        let p2 = start;
        do {
          const a = p2.prev, b = p2.next.next;
          if (!equals2(a, b) && intersects2(a, p2, p2.next, b) && locallyInside2(a, b) && locallyInside2(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p2.i / dim);
            triangles.push(b.i / dim);
            removeNode2(p2);
            removeNode2(p2.next);
            p2 = start = b;
          }
          p2 = p2.next;
        } while (p2 !== start);
        return filterPoints2(p2);
      }
      function splitEarcut2(start, triangles, dim, minX, minY, invSize) {
        let a = start;
        do {
          let b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal2(a, b)) {
              let c = splitPolygon2(a, b);
              a = filterPoints2(a, a.next);
              c = filterPoints2(c, c.next);
              earcutLinked2(a, triangles, dim, minX, minY, invSize);
              earcutLinked2(c, triangles, dim, minX, minY, invSize);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles2(data, holeIndices, outerNode, dim) {
        const queue = [];
        let i2, len, start, end, list;
        for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          start = holeIndices[i2] * dim;
          end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          list = linkedList2(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost2(list));
        }
        queue.sort(compareX2);
        for (i2 = 0; i2 < queue.length; i2++) {
          eliminateHole2(queue[i2], outerNode);
          outerNode = filterPoints2(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX2(a, b) {
        return a.x - b.x;
      }
      function eliminateHole2(hole, outerNode) {
        outerNode = findHoleBridge2(hole, outerNode);
        if (outerNode) {
          const b = splitPolygon2(outerNode, hole);
          filterPoints2(outerNode, outerNode.next);
          filterPoints2(b, b.next);
        }
      }
      function findHoleBridge2(hole, outerNode) {
        let p2 = outerNode;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity, m;
        do {
          if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
            const x = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
            if (x <= hx && x > qx) {
              qx = x;
              if (x === hx) {
                if (hy === p2.y)
                  return p2;
                if (hy === p2.next.y)
                  return p2.next;
              }
              m = p2.x < p2.next.x ? p2 : p2.next;
            }
          }
          p2 = p2.next;
        } while (p2 !== outerNode);
        if (!m)
          return null;
        if (hx === qx)
          return m;
        const stop = m, mx = m.x, my = m.y;
        let tanMin = Infinity, tan;
        p2 = m;
        do {
          if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
            tan = Math.abs(hy - p2.y) / (hx - p2.x);
            if (locallyInside2(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector2(m, p2)))) {
              m = p2;
              tanMin = tan;
            }
          }
          p2 = p2.next;
        } while (p2 !== stop);
        return m;
      }
      function sectorContainsSector2(m, p2) {
        return area2(m.prev, m, p2.prev) < 0 && area2(p2.next, m, m.next) < 0;
      }
      function indexCurve2(start, minX, minY, invSize) {
        let p2 = start;
        do {
          if (p2.z === null)
            p2.z = zOrder2(p2.x, p2.y, minX, minY, invSize);
          p2.prevZ = p2.prev;
          p2.nextZ = p2.next;
          p2 = p2.next;
        } while (p2 !== start);
        p2.prevZ.nextZ = null;
        p2.prevZ = null;
        sortLinked2(p2);
      }
      function sortLinked2(list) {
        let i2, p2, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p2 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p2) {
            numMerges++;
            q = p2;
            pSize = 0;
            for (i2 = 0; i2 < inSize; i2++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
                e = p2;
                p2 = p2.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p2 = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder2(x, y, minX, minY, invSize) {
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      }
      function getLeftmost2(start) {
        let p2 = start, leftmost = start;
        do {
          if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
            leftmost = p2;
          p2 = p2.next;
        } while (p2 !== start);
        return leftmost;
      }
      function pointInTriangle2(ax, ay, bx, by, cx, cy, px3, py3) {
        return (cx - px3) * (ay - py3) - (ax - px3) * (cy - py3) >= 0 && (ax - px3) * (by - py3) - (bx - px3) * (ay - py3) >= 0 && (bx - px3) * (cy - py3) - (cx - px3) * (by - py3) >= 0;
      }
      function isValidDiagonal2(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon2(a, b) && (locallyInside2(a, b) && locallyInside2(b, a) && middleInside2(a, b) && (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || equals2(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
      }
      function area2(p2, q, r) {
        return (q.y - p2.y) * (r.x - q.x) - (q.x - p2.x) * (r.y - q.y);
      }
      function equals2(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects2(p1, q1, p2, q2) {
        const o1 = sign2(area2(p1, q1, p2));
        const o2 = sign2(area2(p1, q1, q2));
        const o3 = sign2(area2(p2, q2, p1));
        const o4 = sign2(area2(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment2(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment2(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment2(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment2(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment2(p2, q, r) {
        return q.x <= Math.max(p2.x, r.x) && q.x >= Math.min(p2.x, r.x) && q.y <= Math.max(p2.y, r.y) && q.y >= Math.min(p2.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon2(a, b) {
        let p2 = a;
        do {
          if (p2.i !== a.i && p2.next.i !== a.i && p2.i !== b.i && p2.next.i !== b.i && intersects2(p2, p2.next, a, b))
            return true;
          p2 = p2.next;
        } while (p2 !== a);
        return false;
      }
      function locallyInside2(a, b) {
        return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
      }
      function middleInside2(a, b) {
        let p2 = a, inside = false;
        const px3 = (a.x + b.x) / 2, py3 = (a.y + b.y) / 2;
        do {
          if (p2.y > py3 !== p2.next.y > py3 && p2.next.y !== p2.y && px3 < (p2.next.x - p2.x) * (py3 - p2.y) / (p2.next.y - p2.y) + p2.x)
            inside = !inside;
          p2 = p2.next;
        } while (p2 !== a);
        return inside;
      }
      function splitPolygon2(a, b) {
        const a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode2(i2, x, y, last) {
        const p2 = new Node2(i2, x, y);
        if (!last) {
          p2.prev = p2;
          p2.next = p2;
        } else {
          p2.next = last.next;
          p2.prev = last;
          last.next.prev = p2;
          last.next = p2;
        }
        return p2;
      }
      function removeNode2(p2) {
        p2.next.prev = p2.prev;
        p2.prev.next = p2.next;
        if (p2.prevZ)
          p2.prevZ.nextZ = p2.nextZ;
        if (p2.nextZ)
          p2.nextZ.prevZ = p2.prevZ;
      }
      function Node2(i2, x, y) {
        this.i = i2;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      function signedArea2(data, start, end, dim) {
        let sum = 0;
        for (let i2 = start, j = end - dim; i2 < end; i2 += dim) {
          sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
          j = i2;
        }
        return sum;
      }
      var ShapeUtils2 = class {
        static area(contour) {
          const n = contour.length;
          let a = 0;
          for (let p2 = n - 1, q = 0; q < n; p2 = q++) {
            a += contour[p2].x * contour[q].y - contour[q].x * contour[p2].y;
          }
          return a * 0.5;
        }
        static isClockWise(pts) {
          return ShapeUtils2.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
          const vertices = [];
          const holeIndices = [];
          const faces = [];
          removeDupEndPts2(contour);
          addContour2(vertices, contour);
          let holeIndex = contour.length;
          holes.forEach(removeDupEndPts2);
          for (let i2 = 0; i2 < holes.length; i2++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i2].length;
            addContour2(vertices, holes[i2]);
          }
          const triangles = Earcut2.triangulate(vertices, holeIndices);
          for (let i2 = 0; i2 < triangles.length; i2 += 3) {
            faces.push(triangles.slice(i2, i2 + 3));
          }
          return faces;
        }
      };
      function removeDupEndPts2(points) {
        const l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) {
          points.pop();
        }
      }
      function addContour2(vertices, contour) {
        for (let i2 = 0; i2 < contour.length; i2++) {
          vertices.push(contour[i2].x);
          vertices.push(contour[i2].y);
        }
      }
      var ExtrudeGeometry2 = class extends BufferGeometry2 {
        constructor(shapes = new Shape2([new Vector22(0.5, 0.5), new Vector22(-0.5, 0.5), new Vector22(-0.5, -0.5), new Vector22(0.5, -0.5)]), options = {}) {
          super();
          this.type = "ExtrudeGeometry";
          this.parameters = {
            shapes,
            options
          };
          shapes = Array.isArray(shapes) ? shapes : [shapes];
          const scope = this;
          const verticesArray = [];
          const uvArray = [];
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            addShape(shape);
          }
          this.setAttribute("position", new Float32BufferAttribute2(verticesArray, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvArray, 2));
          this.computeVertexNormals();
          function addShape(shape) {
            const placeholder = [];
            const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
            const steps = options.steps !== void 0 ? options.steps : 1;
            let depth = options.depth !== void 0 ? options.depth : 1;
            let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
            let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
            let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator2;
            if (options.amount !== void 0) {
              console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
              depth = options.amount;
            }
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
              extrudePts = extrudePath.getSpacedPoints(steps);
              extrudeByPath = true;
              bevelEnabled = false;
              splineTube = extrudePath.computeFrenetFrames(steps, false);
              binormal = new Vector32();
              normal = new Vector32();
              position2 = new Vector32();
            }
            if (!bevelEnabled) {
              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
              bevelOffset = 0;
            }
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils2.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                if (ShapeUtils2.isClockWise(ahole)) {
                  holes[h] = ahole.reverse();
                }
              }
            }
            const faces = ShapeUtils2.triangulateShape(vertices, holes);
            const contour = vertices;
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
              if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
              return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
              let v_trans_x, v_trans_y, shrink_by;
              const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
              const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
              const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
              const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
              if (Math.abs(collinear0) > Number.EPSILON) {
                const v_prev_len = Math.sqrt(v_prev_lensq);
                const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                  return new Vector22(v_trans_x, v_trans_y);
                } else {
                  shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
              } else {
                let direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                  if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                      direction_eq = true;
                    }
                  }
                }
                if (direction_eq) {
                  v_trans_x = -v_prev_y;
                  v_trans_y = v_prev_x;
                  shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                  v_trans_x = v_prev_x;
                  v_trans_y = v_prev_y;
                  shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
              }
              return new Vector22(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = [];
              for (let i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
                if (j === il)
                  j = 0;
                if (k === il)
                  k = 0;
                oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
              }
              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (let b = 0; b < bevelSegments; b++) {
              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il = contour.length; i2 < il; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
                v(vert.x, vert.y, -z);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                  v(vert.x, vert.y, -z);
                }
              }
            }
            const bs = bevelSize + bevelOffset;
            for (let i2 = 0; i2 < vlen; i2++) {
              const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
              if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
              } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
            for (let s = 1; s <= steps; s++) {
              for (let i2 = 0; i2 < vlen; i2++) {
                const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
                if (!extrudeByPath) {
                  v(vert.x, vert.y, depth / steps * s);
                } else {
                  normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                  position2.copy(extrudePts[s]).add(normal).add(binormal);
                  v(position2.x, position2.y, position2.z);
                }
              }
            }
            for (let b = bevelSegments - 1; b >= 0; b--) {
              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i2 = 0, il = contour.length; i2 < il; i2++) {
                const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
                v(vert.x, vert.y, depth + z);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                  const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                  if (!extrudeByPath) {
                    v(vert.x, vert.y, depth + z);
                  } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                  }
                }
              }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
              const start = verticesArray.length / 3;
              if (bevelEnabled) {
                let layer = 0;
                let offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
              } else {
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[2], face[1], face[0]);
                }
                for (let i2 = 0; i2 < flen; i2++) {
                  const face = faces[i2];
                  f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            function buildSideFaces() {
              const start = verticesArray.length / 3;
              let layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
              }
              scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour2, layeroffset) {
              let i2 = contour2.length;
              while (--i2 >= 0) {
                const j = i2;
                let k = i2 - 1;
                if (k < 0)
                  k = contour2.length - 1;
                for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
                  const slen1 = vlen * s;
                  const slen2 = vlen * (s + 1);
                  const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                  f4(a, b, c, d);
                }
              }
            }
            function v(x, y, z) {
              placeholder.push(x);
              placeholder.push(y);
              placeholder.push(z);
            }
            function f3(a, b, c) {
              addVertex(a);
              addVertex(b);
              addVertex(c);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
              addVertex(a);
              addVertex(b);
              addVertex(d);
              addVertex(b);
              addVertex(c);
              addVertex(d);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[3]);
              addUV(uvs[1]);
              addUV(uvs[2]);
              addUV(uvs[3]);
            }
            function addVertex(index) {
              verticesArray.push(placeholder[index * 3 + 0]);
              verticesArray.push(placeholder[index * 3 + 1]);
              verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
              uvArray.push(vector2.x);
              uvArray.push(vector2.y);
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          const options = this.parameters.options;
          return toJSON$12(shapes, options, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          const extrudePath = data.options.extrudePath;
          if (extrudePath !== void 0) {
            data.options.extrudePath = new Curves2[extrudePath.type]().fromJSON(extrudePath);
          }
          return new ExtrudeGeometry2(geometryShapes, data.options);
        }
      };
      var WorldUVGenerator2 = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          return [new Vector22(a_x, a_y), new Vector22(b_x, b_y), new Vector22(c_x, c_y)];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const a_z = vertices[indexA * 3 + 2];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const b_z = vertices[indexB * 3 + 2];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          const c_z = vertices[indexC * 3 + 2];
          const d_x = vertices[indexD * 3];
          const d_y = vertices[indexD * 3 + 1];
          const d_z = vertices[indexD * 3 + 2];
          if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [new Vector22(a_x, 1 - a_z), new Vector22(b_x, 1 - b_z), new Vector22(c_x, 1 - c_z), new Vector22(d_x, 1 - d_z)];
          } else {
            return [new Vector22(a_y, 1 - a_z), new Vector22(b_y, 1 - b_z), new Vector22(c_y, 1 - c_z), new Vector22(d_y, 1 - d_z)];
          }
        }
      };
      function toJSON$12(shapes, options, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        if (options.extrudePath !== void 0)
          data.options.extrudePath = options.extrudePath.toJSON();
        return data;
      }
      var IcosahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t = (1 + Math.sqrt(5)) / 2;
          const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
          const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
          super(vertices, indices, radius, detail);
          this.type = "IcosahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new IcosahedronGeometry(data.radius, data.detail);
        }
      };
      var LatheGeometry = class extends BufferGeometry2 {
        constructor(points = [new Vector22(0, 0.5), new Vector22(0.5, 0), new Vector22(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
          super();
          this.type = "LatheGeometry";
          this.parameters = {
            points,
            segments,
            phiStart,
            phiLength
          };
          segments = Math.floor(segments);
          phiLength = clamp4(phiLength, 0, Math.PI * 2);
          const indices = [];
          const vertices = [];
          const uvs = [];
          const initNormals = [];
          const normals = [];
          const inverseSegments = 1 / segments;
          const vertex3 = new Vector32();
          const uv = new Vector22();
          const normal = new Vector32();
          const curNormal = new Vector32();
          const prevNormal = new Vector32();
          let dx = 0;
          let dy = 0;
          for (let j = 0; j <= points.length - 1; j++) {
            switch (j) {
              case 0:
                dx = points[j + 1].x - points[j].x;
                dy = points[j + 1].y - points[j].y;
                normal.x = dy * 1;
                normal.y = -dx;
                normal.z = dy * 0;
                prevNormal.copy(normal);
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                break;
              case points.length - 1:
                initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                break;
              default:
                dx = points[j + 1].x - points[j].x;
                dy = points[j + 1].y - points[j].y;
                normal.x = dy * 1;
                normal.y = -dx;
                normal.z = dy * 0;
                curNormal.copy(normal);
                normal.x += prevNormal.x;
                normal.y += prevNormal.y;
                normal.z += prevNormal.z;
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                prevNormal.copy(curNormal);
            }
          }
          for (let i2 = 0; i2 <= segments; i2++) {
            const phi = phiStart + i2 * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for (let j = 0; j <= points.length - 1; j++) {
              vertex3.x = points[j].x * sin;
              vertex3.y = points[j].y;
              vertex3.z = points[j].x * cos;
              vertices.push(vertex3.x, vertex3.y, vertex3.z);
              uv.x = i2 / segments;
              uv.y = j / (points.length - 1);
              uvs.push(uv.x, uv.y);
              const x = initNormals[3 * j + 0] * sin;
              const y = initNormals[3 * j + 1];
              const z = initNormals[3 * j + 0] * cos;
              normals.push(x, y, z);
            }
          }
          for (let i2 = 0; i2 < segments; i2++) {
            for (let j = 0; j < points.length - 1; j++) {
              const base = j + i2 * points.length;
              const a = base;
              const b = base + points.length;
              const c = base + points.length + 1;
              const d = base + 1;
              indices.push(a, b, d);
              indices.push(c, d, b);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
        }
        static fromJSON(data) {
          return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
        }
      };
      var OctahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
          const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
          super(vertices, indices, radius, detail);
          this.type = "OctahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new OctahedronGeometry(data.radius, data.detail);
        }
      };
      var RingGeometry = class extends BufferGeometry2 {
        constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "RingGeometry";
          this.parameters = {
            innerRadius,
            outerRadius,
            thetaSegments,
            phiSegments,
            thetaStart,
            thetaLength
          };
          thetaSegments = Math.max(3, thetaSegments);
          phiSegments = Math.max(1, phiSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let radius = innerRadius;
          const radiusStep = (outerRadius - innerRadius) / phiSegments;
          const vertex3 = new Vector32();
          const uv = new Vector22();
          for (let j = 0; j <= phiSegments; j++) {
            for (let i2 = 0; i2 <= thetaSegments; i2++) {
              const segment = thetaStart + i2 / thetaSegments * thetaLength;
              vertex3.x = radius * Math.cos(segment);
              vertex3.y = radius * Math.sin(segment);
              vertices.push(vertex3.x, vertex3.y, vertex3.z);
              normals.push(0, 0, 1);
              uv.x = (vertex3.x / outerRadius + 1) / 2;
              uv.y = (vertex3.y / outerRadius + 1) / 2;
              uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
          }
          for (let j = 0; j < phiSegments; j++) {
            const thetaSegmentLevel = j * (thetaSegments + 1);
            for (let i2 = 0; i2 < thetaSegments; i2++) {
              const segment = i2 + thetaSegmentLevel;
              const a = segment;
              const b = segment + thetaSegments + 1;
              const c = segment + thetaSegments + 2;
              const d = segment + 1;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
        }
      };
      var ShapeGeometry2 = class extends BufferGeometry2 {
        constructor(shapes = new Shape2([new Vector22(0, 0.5), new Vector22(-0.5, -0.5), new Vector22(0.5, -0.5)]), curveSegments = 12) {
          super();
          this.type = "ShapeGeometry";
          this.parameters = {
            shapes,
            curveSegments
          };
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let groupStart = 0;
          let groupCount = 0;
          if (Array.isArray(shapes) === false) {
            addShape(shapes);
          } else {
            for (let i2 = 0; i2 < shapes.length; i2++) {
              addShape(shapes[i2]);
              this.addGroup(groupStart, groupCount, i2);
              groupStart += groupCount;
              groupCount = 0;
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            if (ShapeUtils2.isClockWise(shapeVertices) === false) {
              shapeVertices = shapeVertices.reverse();
            }
            for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
              const shapeHole = shapeHoles[i2];
              if (ShapeUtils2.isClockWise(shapeHole) === true) {
                shapeHoles[i2] = shapeHole.reverse();
              }
            }
            const faces = ShapeUtils2.triangulateShape(shapeVertices, shapeHoles);
            for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
              const shapeHole = shapeHoles[i2];
              shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (let i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
              const vertex3 = shapeVertices[i2];
              vertices.push(vertex3.x, vertex3.y, 0);
              normals.push(0, 0, 1);
              uvs.push(vertex3.x, vertex3.y);
            }
            for (let i2 = 0, l = faces.length; i2 < l; i2++) {
              const face = faces[i2];
              const a = face[0] + indexOffset;
              const b = face[1] + indexOffset;
              const c = face[2] + indexOffset;
              indices.push(a, b, c);
              groupCount += 3;
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          return toJSON2(shapes, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          return new ShapeGeometry2(geometryShapes, data.curveSegments);
        }
      };
      function toJSON2(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            data.shapes.push(shape.uuid);
          }
        } else {
          data.shapes.push(shapes.uuid);
        }
        return data;
      }
      var SphereGeometry = class extends BufferGeometry2 {
        constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
          super();
          this.type = "SphereGeometry";
          this.parameters = {
            radius,
            widthSegments,
            heightSegments,
            phiStart,
            phiLength,
            thetaStart,
            thetaLength
          };
          widthSegments = Math.max(3, Math.floor(widthSegments));
          heightSegments = Math.max(2, Math.floor(heightSegments));
          const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
          let index = 0;
          const grid = [];
          const vertex3 = new Vector32();
          const normal = new Vector32();
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy <= heightSegments; iy++) {
            const verticesRow = [];
            const v = iy / heightSegments;
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
              uOffset = 0.5 / widthSegments;
            } else if (iy == heightSegments && thetaEnd == Math.PI) {
              uOffset = -0.5 / widthSegments;
            }
            for (let ix = 0; ix <= widthSegments; ix++) {
              const u = ix / widthSegments;
              vertex3.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertex3.y = radius * Math.cos(thetaStart + v * thetaLength);
              vertex3.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertices.push(vertex3.x, vertex3.y, vertex3.z);
              normal.copy(vertex3).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u + uOffset, 1 - v);
              verticesRow.push(index++);
            }
            grid.push(verticesRow);
          }
          for (let iy = 0; iy < heightSegments; iy++) {
            for (let ix = 0; ix < widthSegments; ix++) {
              const a = grid[iy][ix + 1];
              const b = grid[iy][ix];
              const c = grid[iy + 1][ix];
              const d = grid[iy + 1][ix + 1];
              if (iy !== 0 || thetaStart > 0)
                indices.push(a, b, d);
              if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
        }
      };
      var TetrahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
          const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
          super(vertices, indices, radius, detail);
          this.type = "TetrahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new TetrahedronGeometry(data.radius, data.detail);
        }
      };
      var TorusGeometry = class extends BufferGeometry2 {
        constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
          super();
          this.type = "TorusGeometry";
          this.parameters = {
            radius,
            tube,
            radialSegments,
            tubularSegments,
            arc
          };
          radialSegments = Math.floor(radialSegments);
          tubularSegments = Math.floor(tubularSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const center = new Vector32();
          const vertex3 = new Vector32();
          const normal = new Vector32();
          for (let j = 0; j <= radialSegments; j++) {
            for (let i2 = 0; i2 <= tubularSegments; i2++) {
              const u = i2 / tubularSegments * arc;
              const v = j / radialSegments * Math.PI * 2;
              vertex3.x = (radius + tube * Math.cos(v)) * Math.cos(u);
              vertex3.y = (radius + tube * Math.cos(v)) * Math.sin(u);
              vertex3.z = tube * Math.sin(v);
              vertices.push(vertex3.x, vertex3.y, vertex3.z);
              center.x = radius * Math.cos(u);
              center.y = radius * Math.sin(u);
              normal.subVectors(vertex3, center).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i2 / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= radialSegments; j++) {
            for (let i2 = 1; i2 <= tubularSegments; i2++) {
              const a = (tubularSegments + 1) * j + i2 - 1;
              const b = (tubularSegments + 1) * (j - 1) + i2 - 1;
              const c = (tubularSegments + 1) * (j - 1) + i2;
              const d = (tubularSegments + 1) * j + i2;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
        }
        static fromJSON(data) {
          return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
        }
      };
      var TorusKnotGeometry = class extends BufferGeometry2 {
        constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p2 = 2, q = 3) {
          super();
          this.type = "TorusKnotGeometry";
          this.parameters = {
            radius,
            tube,
            tubularSegments,
            radialSegments,
            p: p2,
            q
          };
          tubularSegments = Math.floor(tubularSegments);
          radialSegments = Math.floor(radialSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex3 = new Vector32();
          const normal = new Vector32();
          const P1 = new Vector32();
          const P2 = new Vector32();
          const B = new Vector32();
          const T = new Vector32();
          const N = new Vector32();
          for (let i2 = 0; i2 <= tubularSegments; ++i2) {
            const u = i2 / tubularSegments * p2 * Math.PI * 2;
            calculatePositionOnCurve(u, p2, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p2, q, radius, P2);
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            B.normalize();
            N.normalize();
            for (let j = 0; j <= radialSegments; ++j) {
              const v = j / radialSegments * Math.PI * 2;
              const cx = -tube * Math.cos(v);
              const cy = tube * Math.sin(v);
              vertex3.x = P1.x + (cx * N.x + cy * B.x);
              vertex3.y = P1.y + (cx * N.y + cy * B.y);
              vertex3.z = P1.z + (cx * N.z + cy * B.z);
              vertices.push(vertex3.x, vertex3.y, vertex3.z);
              normal.subVectors(vertex3, P1).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i2 / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= tubularSegments; j++) {
            for (let i2 = 1; i2 <= radialSegments; i2++) {
              const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
              const b = (radialSegments + 1) * j + (i2 - 1);
              const c = (radialSegments + 1) * j + i2;
              const d = (radialSegments + 1) * (j - 1) + i2;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function calculatePositionOnCurve(u, p3, q2, radius2, position) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q2 / p3 * u;
            const cs = Math.cos(quOverP);
            position.x = radius2 * (2 + cs) * 0.5 * cu;
            position.y = radius2 * (2 + cs) * su * 0.5;
            position.z = radius2 * Math.sin(quOverP) * 0.5;
          }
        }
        static fromJSON(data) {
          return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
        }
      };
      var TubeGeometry = class extends BufferGeometry2 {
        constructor(path = new QuadraticBezierCurve32(new Vector32(-1, -1, 0), new Vector32(-1, 1, 0), new Vector32(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
          super();
          this.type = "TubeGeometry";
          this.parameters = {
            path,
            tubularSegments,
            radius,
            radialSegments,
            closed
          };
          const frames = path.computeFrenetFrames(tubularSegments, closed);
          this.tangents = frames.tangents;
          this.normals = frames.normals;
          this.binormals = frames.binormals;
          const vertex3 = new Vector32();
          const normal = new Vector32();
          const uv = new Vector22();
          let P = new Vector32();
          const vertices = [];
          const normals = [];
          const uvs = [];
          const indices = [];
          generateBufferData();
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
          function generateBufferData() {
            for (let i2 = 0; i2 < tubularSegments; i2++) {
              generateSegment(i2);
            }
            generateSegment(closed === false ? tubularSegments : 0);
            generateUVs();
            generateIndices();
          }
          function generateSegment(i2) {
            P = path.getPointAt(i2 / tubularSegments, P);
            const N = frames.normals[i2];
            const B = frames.binormals[i2];
            for (let j = 0; j <= radialSegments; j++) {
              const v = j / radialSegments * Math.PI * 2;
              const sin = Math.sin(v);
              const cos = -Math.cos(v);
              normal.x = cos * N.x + sin * B.x;
              normal.y = cos * N.y + sin * B.y;
              normal.z = cos * N.z + sin * B.z;
              normal.normalize();
              normals.push(normal.x, normal.y, normal.z);
              vertex3.x = P.x + radius * normal.x;
              vertex3.y = P.y + radius * normal.y;
              vertex3.z = P.z + radius * normal.z;
              vertices.push(vertex3.x, vertex3.y, vertex3.z);
            }
          }
          function generateIndices() {
            for (let j = 1; j <= tubularSegments; j++) {
              for (let i2 = 1; i2 <= radialSegments; i2++) {
                const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
                const b = (radialSegments + 1) * j + (i2 - 1);
                const c = (radialSegments + 1) * j + i2;
                const d = (radialSegments + 1) * (j - 1) + i2;
                indices.push(a, b, d);
                indices.push(b, c, d);
              }
            }
          }
          function generateUVs() {
            for (let i2 = 0; i2 <= tubularSegments; i2++) {
              for (let j = 0; j <= radialSegments; j++) {
                uv.x = i2 / tubularSegments;
                uv.y = j / radialSegments;
                uvs.push(uv.x, uv.y);
              }
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          data.path = this.parameters.path.toJSON();
          return data;
        }
        static fromJSON(data) {
          return new TubeGeometry(new Curves2[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
        }
      };
      var WireframeGeometry = class extends BufferGeometry2 {
        constructor(geometry = null) {
          super();
          this.type = "WireframeGeometry";
          this.parameters = {
            geometry
          };
          if (geometry !== null) {
            const vertices = [];
            const edges = /* @__PURE__ */ new Set();
            const start = new Vector32();
            const end = new Vector32();
            if (geometry.index !== null) {
              const position = geometry.attributes.position;
              const indices = geometry.index;
              let groups = geometry.groups;
              if (groups.length === 0) {
                groups = [{
                  start: 0,
                  count: indices.count,
                  materialIndex: 0
                }];
              }
              for (let o = 0, ol = groups.length; o < ol; ++o) {
                const group = groups[o];
                const groupStart = group.start;
                const groupCount = group.count;
                for (let i2 = groupStart, l = groupStart + groupCount; i2 < l; i2 += 3) {
                  for (let j = 0; j < 3; j++) {
                    const index1 = indices.getX(i2 + j);
                    const index2 = indices.getX(i2 + (j + 1) % 3);
                    start.fromBufferAttribute(position, index1);
                    end.fromBufferAttribute(position, index2);
                    if (isUniqueEdge(start, end, edges) === true) {
                      vertices.push(start.x, start.y, start.z);
                      vertices.push(end.x, end.y, end.z);
                    }
                  }
                }
              }
            } else {
              const position = geometry.attributes.position;
              for (let i2 = 0, l = position.count / 3; i2 < l; i2++) {
                for (let j = 0; j < 3; j++) {
                  const index1 = 3 * i2 + j;
                  const index2 = 3 * i2 + (j + 1) % 3;
                  start.fromBufferAttribute(position, index1);
                  end.fromBufferAttribute(position, index2);
                  if (isUniqueEdge(start, end, edges) === true) {
                    vertices.push(start.x, start.y, start.z);
                    vertices.push(end.x, end.y, end.z);
                  }
                }
              }
            }
            this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          }
        }
      };
      function isUniqueEdge(start, end, edges) {
        const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
        const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
        if (edges.has(hash1) === true || edges.has(hash2) === true) {
          return false;
        } else {
          edges.add(hash1, hash2);
          return true;
        }
      }
      var Geometries = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BoxGeometry: BoxGeometry2,
        BoxBufferGeometry: BoxGeometry2,
        CircleGeometry,
        CircleBufferGeometry: CircleGeometry,
        ConeGeometry,
        ConeBufferGeometry: ConeGeometry,
        CylinderGeometry,
        CylinderBufferGeometry: CylinderGeometry,
        DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronGeometry,
        EdgesGeometry,
        ExtrudeGeometry: ExtrudeGeometry2,
        ExtrudeBufferGeometry: ExtrudeGeometry2,
        IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronGeometry,
        LatheGeometry,
        LatheBufferGeometry: LatheGeometry,
        OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronGeometry,
        PlaneGeometry: PlaneGeometry2,
        PlaneBufferGeometry: PlaneGeometry2,
        PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronGeometry,
        RingGeometry,
        RingBufferGeometry: RingGeometry,
        ShapeGeometry: ShapeGeometry2,
        ShapeBufferGeometry: ShapeGeometry2,
        SphereGeometry,
        SphereBufferGeometry: SphereGeometry,
        TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronGeometry,
        TorusGeometry,
        TorusBufferGeometry: TorusGeometry,
        TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotGeometry,
        TubeGeometry,
        TubeBufferGeometry: TubeGeometry,
        WireframeGeometry
      });
      var ShadowMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "ShadowMaterial";
          this.color = new Color2(0);
          this.transparent = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          return this;
        }
      };
      ShadowMaterial2.prototype.isShadowMaterial = true;
      var MeshStandardMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": ""
          };
          this.type = "MeshStandardMaterial";
          this.color = new Color2(16777215);
          this.roughness = 1;
          this.metalness = 0;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color2(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap2;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.roughnessMap = null;
          this.metalnessMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.envMapIntensity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": ""
          };
          this.color.copy(source.color);
          this.roughness = source.roughness;
          this.metalness = source.metalness;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.roughnessMap = source.roughnessMap;
          this.metalnessMap = source.metalnessMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.envMapIntensity = source.envMapIntensity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshStandardMaterial2.prototype.isMeshStandardMaterial = true;
      var MeshPhysicalMaterial2 = class extends MeshStandardMaterial2 {
        constructor(parameters) {
          super();
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.type = "MeshPhysicalMaterial";
          this.clearcoatMap = null;
          this.clearcoatRoughness = 0;
          this.clearcoatRoughnessMap = null;
          this.clearcoatNormalScale = new Vector22(1, 1);
          this.clearcoatNormalMap = null;
          this.ior = 1.5;
          Object.defineProperty(this, "reflectivity", {
            get: function() {
              return clamp4(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
              this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
          });
          this.sheenColor = new Color2(0);
          this.sheenColorMap = null;
          this.sheenRoughness = 1;
          this.sheenRoughnessMap = null;
          this.transmissionMap = null;
          this.thickness = 0;
          this.thicknessMap = null;
          this.attenuationDistance = 0;
          this.attenuationColor = new Color2(1, 1, 1);
          this.specularIntensity = 1;
          this.specularIntensityMap = null;
          this.specularColor = new Color2(1, 1, 1);
          this.specularColorMap = null;
          this._sheen = 0;
          this._clearcoat = 0;
          this._transmission = 0;
          this.setValues(parameters);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(value) {
          if (this._sheen > 0 !== value > 0) {
            this.version++;
          }
          this._sheen = value;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(value) {
          if (this._clearcoat > 0 !== value > 0) {
            this.version++;
          }
          this._clearcoat = value;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(value) {
          if (this._transmission > 0 !== value > 0) {
            this.version++;
          }
          this._transmission = value;
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.clearcoat = source.clearcoat;
          this.clearcoatMap = source.clearcoatMap;
          this.clearcoatRoughness = source.clearcoatRoughness;
          this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
          this.clearcoatNormalMap = source.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
          this.ior = source.ior;
          this.sheen = source.sheen;
          this.sheenColor.copy(source.sheenColor);
          this.sheenColorMap = source.sheenColorMap;
          this.sheenRoughness = source.sheenRoughness;
          this.sheenRoughnessMap = source.sheenRoughnessMap;
          this.transmission = source.transmission;
          this.transmissionMap = source.transmissionMap;
          this.thickness = source.thickness;
          this.thicknessMap = source.thicknessMap;
          this.attenuationDistance = source.attenuationDistance;
          this.attenuationColor.copy(source.attenuationColor);
          this.specularIntensity = source.specularIntensity;
          this.specularIntensityMap = source.specularIntensityMap;
          this.specularColor.copy(source.specularColor);
          this.specularColorMap = source.specularColorMap;
          return this;
        }
      };
      MeshPhysicalMaterial2.prototype.isMeshPhysicalMaterial = true;
      var MeshPhongMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "MeshPhongMaterial";
          this.color = new Color2(16777215);
          this.specular = new Color2(1118481);
          this.shininess = 30;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color2(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap2;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation2;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.specular.copy(source.specular);
          this.shininess = source.shininess;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshPhongMaterial2.prototype.isMeshPhongMaterial = true;
      var MeshToonMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.defines = {
            "TOON": ""
          };
          this.type = "MeshToonMaterial";
          this.color = new Color2(16777215);
          this.map = null;
          this.gradientMap = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color2(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap2;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.gradientMap = source.gradientMap;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshToonMaterial2.prototype.isMeshToonMaterial = true;
      var MeshNormalMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "MeshNormalMaterial";
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap2;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshNormalMaterial2.prototype.isMeshNormalMaterial = true;
      var MeshLambertMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.type = "MeshLambertMaterial";
          this.color = new Color2(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color2(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation2;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          return this;
        }
      };
      MeshLambertMaterial2.prototype.isMeshLambertMaterial = true;
      var MeshMatcapMaterial2 = class extends Material2 {
        constructor(parameters) {
          super();
          this.defines = {
            "MATCAP": ""
          };
          this.type = "MeshMatcapMaterial";
          this.color = new Color2(16777215);
          this.matcap = null;
          this.map = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap2;
          this.normalScale = new Vector22(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "MATCAP": ""
          };
          this.color.copy(source.color);
          this.matcap = source.matcap;
          this.map = source.map;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshMatcapMaterial2.prototype.isMeshMatcapMaterial = true;
      var LineDashedMaterial2 = class extends LineBasicMaterial2 {
        constructor(parameters) {
          super();
          this.type = "LineDashedMaterial";
          this.scale = 1;
          this.dashSize = 3;
          this.gapSize = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.scale = source.scale;
          this.dashSize = source.dashSize;
          this.gapSize = source.gapSize;
          return this;
        }
      };
      LineDashedMaterial2.prototype.isLineDashedMaterial = true;
      var Materials = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ShadowMaterial: ShadowMaterial2,
        SpriteMaterial: SpriteMaterial2,
        RawShaderMaterial: RawShaderMaterial2,
        ShaderMaterial: ShaderMaterial2,
        PointsMaterial: PointsMaterial2,
        MeshPhysicalMaterial: MeshPhysicalMaterial2,
        MeshStandardMaterial: MeshStandardMaterial2,
        MeshPhongMaterial: MeshPhongMaterial2,
        MeshToonMaterial: MeshToonMaterial2,
        MeshNormalMaterial: MeshNormalMaterial2,
        MeshLambertMaterial: MeshLambertMaterial2,
        MeshDepthMaterial: MeshDepthMaterial2,
        MeshDistanceMaterial: MeshDistanceMaterial2,
        MeshBasicMaterial: MeshBasicMaterial2,
        MeshMatcapMaterial: MeshMatcapMaterial2,
        LineDashedMaterial: LineDashedMaterial2,
        LineBasicMaterial: LineBasicMaterial2,
        Material: Material2
      });
      var AnimationUtils2 = {
        arraySlice: function(array, from, to) {
          if (AnimationUtils2.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
          }
          return array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
          if (!array || !forceClone && array.constructor === type)
            return array;
          if (typeof type.BYTES_PER_ELEMENT === "number") {
            return new type(array);
          }
          return Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
          return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
          function compareTime(i2, j) {
            return times[i2] - times[j];
          }
          const n = times.length;
          const result = new Array(n);
          for (let i2 = 0; i2 !== n; ++i2)
            result[i2] = i2;
          result.sort(compareTime);
          return result;
        },
        sortedArray: function(values, stride, order) {
          const nValues = values.length;
          const result = new values.constructor(nValues);
          for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
            const srcOffset = order[i2] * stride;
            for (let j = 0; j !== stride; ++j) {
              result[dstOffset++] = values[srcOffset + j];
            }
          }
          return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
          let i2 = 1, key = jsonKeys[0];
          while (key !== void 0 && key[valuePropertyName] === void 0) {
            key = jsonKeys[i2++];
          }
          if (key === void 0)
            return;
          let value = key[valuePropertyName];
          if (value === void 0)
            return;
          if (Array.isArray(value)) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push.apply(values, value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else if (value.toArray !== void 0) {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                value.toArray(values, values.length);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          } else {
            do {
              value = key[valuePropertyName];
              if (value !== void 0) {
                times.push(key.time);
                values.push(value);
              }
              key = jsonKeys[i2++];
            } while (key !== void 0);
          }
        },
        subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
          const clip = sourceClip.clone();
          clip.name = name;
          const tracks = [];
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            const track = clip.tracks[i2];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for (let j = 0; j < track.times.length; ++j) {
              const frame = track.times[j] * fps;
              if (frame < startFrame || frame >= endFrame)
                continue;
              times.push(track.times[j]);
              for (let k = 0; k < valueSize; ++k) {
                values.push(track.values[j * valueSize + k]);
              }
            }
            if (times.length === 0)
              continue;
            track.times = AnimationUtils2.convertArray(times, track.times.constructor);
            track.values = AnimationUtils2.convertArray(values, track.values.constructor);
            tracks.push(track);
          }
          clip.tracks = tracks;
          let minStartTime = Infinity;
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            if (minStartTime > clip.tracks[i2].times[0]) {
              minStartTime = clip.tracks[i2].times[0];
            }
          }
          for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
            clip.tracks[i2].shift(-1 * minStartTime);
          }
          clip.resetDuration();
          return clip;
        },
        makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
          if (fps <= 0)
            fps = 30;
          const numTracks = referenceClip.tracks.length;
          const referenceTime = referenceFrame / fps;
          for (let i2 = 0; i2 < numTracks; ++i2) {
            const referenceTrack = referenceClip.tracks[i2];
            const referenceTrackType = referenceTrack.ValueTypeName;
            if (referenceTrackType === "bool" || referenceTrackType === "string")
              continue;
            const targetTrack = targetClip.tracks.find(function(track) {
              return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === void 0)
              continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              referenceOffset = referenceValueSize / 3;
            }
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
              targetOffset = targetValueSize / 3;
            }
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            if (referenceTime <= referenceTrack.times[0]) {
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils2.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
              const startIndex = lastIndex * referenceValueSize + referenceOffset;
              const endIndex = startIndex + referenceValueSize - referenceOffset;
              referenceValue = AnimationUtils2.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
              const interpolant = referenceTrack.createInterpolant();
              const startIndex = referenceOffset;
              const endIndex = referenceValueSize - referenceOffset;
              interpolant.evaluate(referenceTime);
              referenceValue = AnimationUtils2.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            if (referenceTrackType === "quaternion") {
              const referenceQuat = new Quaternion2().fromArray(referenceValue).normalize().conjugate();
              referenceQuat.toArray(referenceValue);
            }
            const numTimes = targetTrack.times.length;
            for (let j = 0; j < numTimes; ++j) {
              const valueStart = j * targetValueSize + targetOffset;
              if (referenceTrackType === "quaternion") {
                Quaternion2.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
              } else {
                const valueEnd = targetValueSize - targetOffset * 2;
                for (let k = 0; k < valueEnd; ++k) {
                  targetTrack.values[valueStart + k] -= referenceValue[k];
                }
              }
            }
          }
          targetClip.blendMode = AdditiveAnimationBlendMode2;
          return targetClip;
        }
      };
      var Interpolant2 = class {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          this.parameterPositions = parameterPositions;
          this._cachedIndex = 0;
          this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
          this.sampleValues = sampleValues;
          this.valueSize = sampleSize;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(t) {
          const pp = this.parameterPositions;
          let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
          validate_interval: {
            seek: {
              let right;
              linear_scan: {
                forward_scan:
                  if (!(t < t1)) {
                    for (let giveUpAt = i1 + 2; ; ) {
                      if (t1 === void 0) {
                        if (t < t0)
                          break forward_scan;
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t, t0);
                      }
                      if (i1 === giveUpAt)
                        break;
                      t0 = t1;
                      t1 = pp[++i1];
                      if (t < t1) {
                        break seek;
                      }
                    }
                    right = pp.length;
                    break linear_scan;
                  }
                if (!(t >= t0)) {
                  const t1global = pp[1];
                  if (t < t1global) {
                    i1 = 2;
                    t0 = t1global;
                  }
                  for (let giveUpAt = i1 - 2; ; ) {
                    if (t0 === void 0) {
                      this._cachedIndex = 0;
                      return this.beforeStart_(0, t, t1);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t1 = t0;
                    t0 = pp[--i1 - 1];
                    if (t >= t0) {
                      break seek;
                    }
                  }
                  right = i1;
                  i1 = 0;
                  break linear_scan;
                }
                break validate_interval;
              }
              while (i1 < right) {
                const mid = i1 + right >>> 1;
                if (t < pp[mid]) {
                  right = mid;
                } else {
                  i1 = mid + 1;
                }
              }
              t1 = pp[i1];
              t0 = pp[i1 - 1];
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (t1 === void 0) {
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t0, t);
              }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
          }
          return this.interpolate_(i1, t0, t, t1);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset + i2];
          }
          return result;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      };
      Interpolant2.prototype.beforeStart_ = Interpolant2.prototype.copySampleValue_;
      Interpolant2.prototype.afterEnd_ = Interpolant2.prototype.copySampleValue_;
      var CubicInterpolant2 = class extends Interpolant2 {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding2,
            endingEnd: ZeroCurvatureEnding2
          };
        }
        intervalChanged_(i1, t0, t1) {
          const pp = this.parameterPositions;
          let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
          if (tPrev === void 0) {
            switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding2:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
              case WrapAroundEnding2:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
              default:
                iPrev = i1;
                tPrev = t1;
            }
          }
          if (tNext === void 0) {
            switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding2:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
              case WrapAroundEnding2:
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
              default:
                iNext = i1 - 1;
                tNext = t0;
            }
          }
          const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
          const sP = -wP * ppp + 2 * wP * pp - wP * p2;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
          const sN = wN * ppp - wN * pp;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
          }
          return result;
        }
      };
      var LinearInterpolant2 = class extends Interpolant2 {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
          for (let i2 = 0; i2 !== stride; ++i2) {
            result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
          }
          return result;
        }
      };
      var DiscreteInterpolant2 = class extends Interpolant2 {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1) {
          return this.copySampleValue_(i1 - 1);
        }
      };
      var KeyframeTrack2 = class {
        constructor(name, times, values, interpolation) {
          if (name === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (times === void 0 || times.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
          this.name = name;
          this.times = AnimationUtils2.convertArray(times, this.TimeBufferType);
          this.values = AnimationUtils2.convertArray(values, this.ValueBufferType);
          this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        static toJSON(track) {
          const trackType = track.constructor;
          let json;
          if (trackType.toJSON !== this.toJSON) {
            json = trackType.toJSON(track);
          } else {
            json = {
              "name": track.name,
              "times": AnimationUtils2.convertArray(track.times, Array),
              "values": AnimationUtils2.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
              json.interpolation = interpolation;
            }
          }
          json.type = track.ValueTypeName;
          return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
          return new DiscreteInterpolant2(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
          return new LinearInterpolant2(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
          return new CubicInterpolant2(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
          let factoryMethod;
          switch (interpolation) {
            case InterpolateDiscrete2:
              factoryMethod = this.InterpolantFactoryMethodDiscrete;
              break;
            case InterpolateLinear2:
              factoryMethod = this.InterpolantFactoryMethodLinear;
              break;
            case InterpolateSmooth2:
              factoryMethod = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (factoryMethod === void 0) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (interpolation !== this.DefaultInterpolation) {
                this.setInterpolation(this.DefaultInterpolation);
              } else {
                throw new Error(message);
              }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
          }
          this.createInterpolant = factoryMethod;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return InterpolateDiscrete2;
            case this.InterpolantFactoryMethodLinear:
              return InterpolateLinear2;
            case this.InterpolantFactoryMethodSmooth:
              return InterpolateSmooth2;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(timeOffset) {
          if (timeOffset !== 0) {
            const times = this.times;
            for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
              times[i2] += timeOffset;
            }
          }
          return this;
        }
        scale(timeScale) {
          if (timeScale !== 1) {
            const times = this.times;
            for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
              times[i2] *= timeScale;
            }
          }
          return this;
        }
        trim(startTime, endTime) {
          const times = this.times, nKeys = times.length;
          let from = 0, to = nKeys - 1;
          while (from !== nKeys && times[from] < startTime) {
            ++from;
          }
          while (to !== -1 && times[to] > endTime) {
            --to;
          }
          ++to;
          if (from !== 0 || to !== nKeys) {
            if (from >= to) {
              to = Math.max(to, 1);
              from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils2.arraySlice(times, from, to);
            this.values = AnimationUtils2.arraySlice(this.values, from * stride, to * stride);
          }
          return this;
        }
        validate() {
          let valid = true;
          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
          }
          const times = this.times, values = this.values, nKeys = times.length;
          if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
          }
          let prevTime = null;
          for (let i2 = 0; i2 !== nKeys; i2++) {
            const currTime = times[i2];
            if (typeof currTime === "number" && isNaN(currTime)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
              valid = false;
              break;
            }
            if (prevTime !== null && prevTime > currTime) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
              valid = false;
              break;
            }
            prevTime = currTime;
          }
          if (values !== void 0) {
            if (AnimationUtils2.isTypedArray(values)) {
              for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
                const value = values[i2];
                if (isNaN(value)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                  valid = false;
                  break;
                }
              }
            }
          }
          return valid;
        }
        optimize() {
          const times = AnimationUtils2.arraySlice(this.times), values = AnimationUtils2.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth2, lastIndex = times.length - 1;
          let writeIndex = 1;
          for (let i2 = 1; i2 < lastIndex; ++i2) {
            let keep = false;
            const time = times[i2];
            const timeNext = times[i2 + 1];
            if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
              if (!smoothInterpolation) {
                const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (let j = 0; j !== stride; ++j) {
                  const value = values[offset + j];
                  if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                    keep = true;
                    break;
                  }
                }
              } else {
                keep = true;
              }
            }
            if (keep) {
              if (i2 !== writeIndex) {
                times[writeIndex] = times[i2];
                const readOffset = i2 * stride, writeOffset = writeIndex * stride;
                for (let j = 0; j !== stride; ++j) {
                  values[writeOffset + j] = values[readOffset + j];
                }
              }
              ++writeIndex;
            }
          }
          if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
            ++writeIndex;
          }
          if (writeIndex !== times.length) {
            this.times = AnimationUtils2.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils2.arraySlice(values, 0, writeIndex * stride);
          } else {
            this.times = times;
            this.values = values;
          }
          return this;
        }
        clone() {
          const times = AnimationUtils2.arraySlice(this.times, 0);
          const values = AnimationUtils2.arraySlice(this.values, 0);
          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values);
          track.createInterpolant = this.createInterpolant;
          return track;
        }
      };
      KeyframeTrack2.prototype.TimeBufferType = Float32Array;
      KeyframeTrack2.prototype.ValueBufferType = Float32Array;
      KeyframeTrack2.prototype.DefaultInterpolation = InterpolateLinear2;
      var BooleanKeyframeTrack2 = class extends KeyframeTrack2 {
      };
      BooleanKeyframeTrack2.prototype.ValueTypeName = "bool";
      BooleanKeyframeTrack2.prototype.ValueBufferType = Array;
      BooleanKeyframeTrack2.prototype.DefaultInterpolation = InterpolateDiscrete2;
      BooleanKeyframeTrack2.prototype.InterpolantFactoryMethodLinear = void 0;
      BooleanKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void 0;
      var ColorKeyframeTrack2 = class extends KeyframeTrack2 {
      };
      ColorKeyframeTrack2.prototype.ValueTypeName = "color";
      var NumberKeyframeTrack2 = class extends KeyframeTrack2 {
      };
      NumberKeyframeTrack2.prototype.ValueTypeName = "number";
      var QuaternionLinearInterpolant2 = class extends Interpolant2 {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
          let offset = i1 * stride;
          for (let end = offset + stride; offset !== end; offset += 4) {
            Quaternion2.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
          }
          return result;
        }
      };
      var QuaternionKeyframeTrack2 = class extends KeyframeTrack2 {
        InterpolantFactoryMethodLinear(result) {
          return new QuaternionLinearInterpolant2(this.times, this.values, this.getValueSize(), result);
        }
      };
      QuaternionKeyframeTrack2.prototype.ValueTypeName = "quaternion";
      QuaternionKeyframeTrack2.prototype.DefaultInterpolation = InterpolateLinear2;
      QuaternionKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void 0;
      var StringKeyframeTrack2 = class extends KeyframeTrack2 {
      };
      StringKeyframeTrack2.prototype.ValueTypeName = "string";
      StringKeyframeTrack2.prototype.ValueBufferType = Array;
      StringKeyframeTrack2.prototype.DefaultInterpolation = InterpolateDiscrete2;
      StringKeyframeTrack2.prototype.InterpolantFactoryMethodLinear = void 0;
      StringKeyframeTrack2.prototype.InterpolantFactoryMethodSmooth = void 0;
      var VectorKeyframeTrack2 = class extends KeyframeTrack2 {
      };
      VectorKeyframeTrack2.prototype.ValueTypeName = "vector";
      var AnimationClip2 = class {
        constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode2) {
          this.name = name;
          this.tracks = tracks;
          this.duration = duration;
          this.blendMode = blendMode;
          this.uuid = generateUUID2();
          if (this.duration < 0) {
            this.resetDuration();
          }
        }
        static parse(json) {
          const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
          for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
            tracks.push(parseKeyframeTrack2(jsonTracks[i2]).scale(frameTime));
          }
          const clip = new this(json.name, json.duration, tracks, json.blendMode);
          clip.uuid = json.uuid;
          return clip;
        }
        static toJSON(clip) {
          const tracks = [], clipTracks = clip.tracks;
          const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
          };
          for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
            tracks.push(KeyframeTrack2.toJSON(clipTracks[i2]));
          }
          return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];
          for (let i2 = 0; i2 < numMorphTargets; i2++) {
            let times = [];
            let values = [];
            times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils2.getKeyframeOrder(times);
            times = AnimationUtils2.sortedArray(times, 1, order);
            values = AnimationUtils2.sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
              times.push(numMorphTargets);
              values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack2(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
          }
          return new this(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
          let clipArray = objectOrClipArray;
          if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
          }
          for (let i2 = 0; i2 < clipArray.length; i2++) {
            if (clipArray[i2].name === name) {
              return clipArray[i2];
            }
          }
          return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
          const animationToMorphTargets = {};
          const pattern = /^([\w-]*?)([\d]+)$/;
          for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
            const morphTarget = morphTargets[i2];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
              const name = parts[1];
              let animationMorphTargets = animationToMorphTargets[name];
              if (!animationMorphTargets) {
                animationToMorphTargets[name] = animationMorphTargets = [];
              }
              animationMorphTargets.push(morphTarget);
            }
          }
          const clips = [];
          for (const name in animationToMorphTargets) {
            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
          }
          return clips;
        }
        static parseAnimation(animation, bones) {
          if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
          }
          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
              const times = [];
              const values = [];
              AnimationUtils2.flattenJSON(animationKeys, times, values, propertyName);
              if (times.length !== 0) {
                destTracks.push(new trackType(trackName, times, values));
              }
            }
          };
          const tracks = [];
          const clipName = animation.name || "default";
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;
          let duration = animation.length || -1;
          const hierarchyTracks = animation.hierarchy || [];
          for (let h = 0; h < hierarchyTracks.length; h++) {
            const animationKeys = hierarchyTracks[h].keys;
            if (!animationKeys || animationKeys.length === 0)
              continue;
            if (animationKeys[0].morphTargets) {
              const morphTargetNames = {};
              let k;
              for (k = 0; k < animationKeys.length; k++) {
                if (animationKeys[k].morphTargets) {
                  for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                    morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                  }
                }
              }
              for (const morphTargetName in morphTargetNames) {
                const times = [];
                const values = [];
                for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                  const animationKey = animationKeys[k];
                  times.push(animationKey.time);
                  values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                }
                tracks.push(new NumberKeyframeTrack2(".morphTargetInfluence[" + morphTargetName + "]", times, values));
              }
              duration = morphTargetNames.length * (fps || 1);
            } else {
              const boneName = ".bones[" + bones[h].name + "]";
              addNonemptyTrack(VectorKeyframeTrack2, boneName + ".position", animationKeys, "pos", tracks);
              addNonemptyTrack(QuaternionKeyframeTrack2, boneName + ".quaternion", animationKeys, "rot", tracks);
              addNonemptyTrack(VectorKeyframeTrack2, boneName + ".scale", animationKeys, "scl", tracks);
            }
          }
          if (tracks.length === 0) {
            return null;
          }
          const clip = new this(clipName, duration, tracks, blendMode);
          return clip;
        }
        resetDuration() {
          const tracks = this.tracks;
          let duration = 0;
          for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
            const track = this.tracks[i2];
            duration = Math.max(duration, track.times[track.times.length - 1]);
          }
          this.duration = duration;
          return this;
        }
        trim() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].trim(0, this.duration);
          }
          return this;
        }
        validate() {
          let valid = true;
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            valid = valid && this.tracks[i2].validate();
          }
          return valid;
        }
        optimize() {
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            this.tracks[i2].optimize();
          }
          return this;
        }
        clone() {
          const tracks = [];
          for (let i2 = 0; i2 < this.tracks.length; i2++) {
            tracks.push(this.tracks[i2].clone());
          }
          return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      };
      function getTrackTypeForValueTypeName2(typeName) {
        switch (typeName.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return NumberKeyframeTrack2;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return VectorKeyframeTrack2;
          case "color":
            return ColorKeyframeTrack2;
          case "quaternion":
            return QuaternionKeyframeTrack2;
          case "bool":
          case "boolean":
            return BooleanKeyframeTrack2;
          case "string":
            return StringKeyframeTrack2;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
      }
      function parseKeyframeTrack2(json) {
        if (json.type === void 0) {
          throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        }
        const trackType = getTrackTypeForValueTypeName2(json.type);
        if (json.times === void 0) {
          const times = [], values = [];
          AnimationUtils2.flattenJSON(json.keys, times, values, "value");
          json.times = times;
          json.values = values;
        }
        if (trackType.parse !== void 0) {
          return trackType.parse(json);
        } else {
          return new trackType(json.name, json.times, json.values, json.interpolation);
        }
      }
      var Cache2 = {
        enabled: false,
        files: {},
        add: function(key, file) {
          if (this.enabled === false)
            return;
          this.files[key] = file;
        },
        get: function(key) {
          if (this.enabled === false)
            return;
          return this.files[key];
        },
        remove: function(key) {
          delete this.files[key];
        },
        clear: function() {
          this.files = {};
        }
      };
      var LoadingManager2 = class {
        constructor(onLoad, onProgress, onError) {
          const scope = this;
          let isLoading = false;
          let itemsLoaded = 0;
          let itemsTotal = 0;
          let urlModifier = void 0;
          const handlers = [];
          this.onStart = void 0;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== void 0) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== void 0) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== void 0) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function(url) {
            if (scope.onError !== void 0) {
              scope.onError(url);
            }
          };
          this.resolveURL = function(url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
          };
          this.addHandler = function(regex, loader4) {
            handlers.push(regex, loader4);
            return this;
          };
          this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) {
              handlers.splice(index, 2);
            }
            return this;
          };
          this.getHandler = function(file) {
            for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {
              const regex = handlers[i2];
              const loader4 = handlers[i2 + 1];
              if (regex.global)
                regex.lastIndex = 0;
              if (regex.test(file)) {
                return loader4;
              }
            }
            return null;
          };
        }
      };
      var DefaultLoadingManager2 = new LoadingManager2();
      var Loader2 = class {
        constructor(manager) {
          this.manager = manager !== void 0 ? manager : DefaultLoadingManager2;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {
        }
        loadAsync(url, onProgress) {
          const scope = this;
          return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
          });
        }
        parse() {
        }
        setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        }
        setWithCredentials(value) {
          this.withCredentials = value;
          return this;
        }
        setPath(path) {
          this.path = path;
          return this;
        }
        setResourcePath(resourcePath) {
          this.resourcePath = resourcePath;
          return this;
        }
        setRequestHeader(requestHeader) {
          this.requestHeader = requestHeader;
          return this;
        }
      };
      var loading2 = {};
      var FileLoader2 = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const cached = Cache2.get(url);
          if (cached !== void 0) {
            this.manager.itemStart(url);
            setTimeout(() => {
              if (onLoad)
                onLoad(cached);
              this.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          if (loading2[url] !== void 0) {
            loading2[url].push({
              onLoad,
              onProgress,
              onError
            });
            return;
          }
          loading2[url] = [];
          loading2[url].push({
            onLoad,
            onProgress,
            onError
          });
          const req = new Request(url, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          });
          const mimeType = this.mimeType;
          const responseType = this.responseType;
          fetch(req).then((response) => {
            if (response.status === 200 || response.status === 0) {
              if (response.status === 0) {
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              }
              if (typeof ReadableStream === "undefined" || response.body.getReader === void 0) {
                return response;
              }
              const callbacks = loading2[url];
              const reader = response.body.getReader();
              const contentLength = response.headers.get("Content-Length");
              const total = contentLength ? parseInt(contentLength) : 0;
              const lengthComputable = total !== 0;
              let loaded = 0;
              const stream = new ReadableStream({
                start(controller) {
                  readData();
                  function readData() {
                    reader.read().then(({
                      done,
                      value
                    }) => {
                      if (done) {
                        controller.close();
                      } else {
                        loaded += value.byteLength;
                        const event = new ProgressEvent("progress", {
                          lengthComputable,
                          loaded,
                          total
                        });
                        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                          const callback = callbacks[i2];
                          if (callback.onProgress)
                            callback.onProgress(event);
                        }
                        controller.enqueue(value);
                        readData();
                      }
                    });
                  }
                }
              });
              return new Response(stream);
            } else {
              throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
            }
          }).then((response) => {
            switch (responseType) {
              case "arraybuffer":
                return response.arrayBuffer();
              case "blob":
                return response.blob();
              case "document":
                return response.text().then((text) => {
                  const parser = new DOMParser();
                  return parser.parseFromString(text, mimeType);
                });
              case "json":
                return response.json();
              default:
                if (mimeType === void 0) {
                  return response.text();
                } else {
                  const re = /charset="?([^;"\s]*)"?/i;
                  const exec = re.exec(mimeType);
                  const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
                  const decoder = new TextDecoder(label);
                  return response.arrayBuffer().then((ab) => decoder.decode(ab));
                }
            }
          }).then((data) => {
            Cache2.add(url, data);
            const callbacks = loading2[url];
            delete loading2[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onLoad)
                callback.onLoad(data);
            }
          }).catch((err) => {
            const callbacks = loading2[url];
            if (callbacks === void 0) {
              this.manager.itemError(url);
              throw err;
            }
            delete loading2[url];
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onError)
                callback.onError(err);
            }
            this.manager.itemError(url);
          }).finally(() => {
            this.manager.itemEnd(url);
          });
          this.manager.itemStart(url);
        }
        setResponseType(value) {
          this.responseType = value;
          return this;
        }
        setMimeType(value) {
          this.mimeType = value;
          return this;
        }
      };
      var AnimationLoader = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader4 = new FileLoader2(this.manager);
          loader4.setPath(this.path);
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(this.withCredentials);
          loader4.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const animations = [];
          for (let i2 = 0; i2 < json.length; i2++) {
            const clip = AnimationClip2.parse(json[i2]);
            animations.push(clip);
          }
          return animations;
        }
      };
      var CompressedTextureLoader2 = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const images = [];
          const texture = new CompressedTexture2();
          const loader4 = new FileLoader2(this.manager);
          loader4.setPath(this.path);
          loader4.setResponseType("arraybuffer");
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(scope.withCredentials);
          let loaded = 0;
          function loadTexture(i2) {
            loader4.load(url[i2], function(buffer) {
              const texDatas = scope.parse(buffer, true);
              images[i2] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = LinearFilter2;
                texture.image = images;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          }
          if (Array.isArray(url)) {
            for (let i2 = 0, il = url.length; i2 < il; ++i2) {
              loadTexture(i2);
            }
          } else {
            loader4.load(url, function(buffer) {
              const texDatas = scope.parse(buffer, true);
              if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for (let f = 0; f < faces; f++) {
                  images[f] = {
                    mipmaps: []
                  };
                  for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                    images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
                    images[f].format = texDatas.format;
                    images[f].width = texDatas.width;
                    images[f].height = texDatas.height;
                  }
                }
                texture.image = images;
              } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
              }
              if (texDatas.mipmapCount === 1) {
                texture.minFilter = LinearFilter2;
              }
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }, onProgress, onError);
          }
          return texture;
        }
      };
      var ImageLoader2 = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache2.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const image = createElementNS2("img");
          function onImageLoad() {
            removeEventListeners();
            Cache2.add(url, this);
            if (onLoad)
              onLoad(this);
            scope.manager.itemEnd(url);
          }
          function onImageError(event) {
            removeEventListeners();
            if (onError)
              onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
          function removeEventListeners() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
          }
          image.addEventListener("load", onImageLoad, false);
          image.addEventListener("error", onImageError, false);
          if (url.substr(0, 5) !== "data:") {
            if (this.crossOrigin !== void 0)
              image.crossOrigin = this.crossOrigin;
          }
          scope.manager.itemStart(url);
          image.src = url;
          return image;
        }
      };
      var CubeTextureLoader2 = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(urls, onLoad, onProgress, onError) {
          const texture = new CubeTexture2();
          const loader4 = new ImageLoader2(this.manager);
          loader4.setCrossOrigin(this.crossOrigin);
          loader4.setPath(this.path);
          let loaded = 0;
          function loadTexture(i2) {
            loader4.load(urls[i2], function(image) {
              texture.images[i2] = image;
              loaded++;
              if (loaded === 6) {
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, void 0, onError);
          }
          for (let i2 = 0; i2 < urls.length; ++i2) {
            loadTexture(i2);
          }
          return texture;
        }
      };
      var DataTextureLoader = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const texture = new DataTexture2();
          const loader4 = new FileLoader2(this.manager);
          loader4.setResponseType("arraybuffer");
          loader4.setRequestHeader(this.requestHeader);
          loader4.setPath(this.path);
          loader4.setWithCredentials(scope.withCredentials);
          loader4.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData)
              return;
            if (texData.image !== void 0) {
              texture.image = texData.image;
            } else if (texData.data !== void 0) {
              texture.image.width = texData.width;
              texture.image.height = texData.height;
              texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping2;
            texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping2;
            texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter2;
            texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter2;
            texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
            if (texData.encoding !== void 0) {
              texture.encoding = texData.encoding;
            }
            if (texData.flipY !== void 0) {
              texture.flipY = texData.flipY;
            }
            if (texData.format !== void 0) {
              texture.format = texData.format;
            }
            if (texData.type !== void 0) {
              texture.type = texData.type;
            }
            if (texData.mipmaps !== void 0) {
              texture.mipmaps = texData.mipmaps;
              texture.minFilter = LinearMipmapLinearFilter2;
            }
            if (texData.mipmapCount === 1) {
              texture.minFilter = LinearFilter2;
            }
            if (texData.generateMipmaps !== void 0) {
              texture.generateMipmaps = texData.generateMipmaps;
            }
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture, texData);
          }, onProgress, onError);
          return texture;
        }
      };
      var TextureLoader2 = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture2();
          const loader4 = new ImageLoader2(this.manager);
          loader4.setCrossOrigin(this.crossOrigin);
          loader4.setPath(this.path);
          loader4.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== void 0) {
              onLoad(texture);
            }
          }, onProgress, onError);
          return texture;
        }
      };
      var Light2 = class extends Object3D2 {
        constructor(color, intensity = 1) {
          super();
          this.type = "Light";
          this.color = new Color2(color);
          this.intensity = intensity;
        }
        dispose() {
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.intensity = source.intensity;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;
          if (this.groundColor !== void 0)
            data.object.groundColor = this.groundColor.getHex();
          if (this.distance !== void 0)
            data.object.distance = this.distance;
          if (this.angle !== void 0)
            data.object.angle = this.angle;
          if (this.decay !== void 0)
            data.object.decay = this.decay;
          if (this.penumbra !== void 0)
            data.object.penumbra = this.penumbra;
          if (this.shadow !== void 0)
            data.object.shadow = this.shadow.toJSON();
          return data;
        }
      };
      Light2.prototype.isLight = true;
      var HemisphereLight2 = class extends Light2 {
        constructor(skyColor, groundColor, intensity) {
          super(skyColor, intensity);
          this.type = "HemisphereLight";
          this.position.copy(Object3D2.DefaultUp);
          this.updateMatrix();
          this.groundColor = new Color2(groundColor);
        }
        copy(source) {
          Light2.prototype.copy.call(this, source);
          this.groundColor.copy(source.groundColor);
          return this;
        }
      };
      HemisphereLight2.prototype.isHemisphereLight = true;
      var _projScreenMatrix$12 = /* @__PURE__ */ new Matrix42();
      var _lightPositionWorld$12 = /* @__PURE__ */ new Vector32();
      var _lookTarget$12 = /* @__PURE__ */ new Vector32();
      var LightShadow2 = class {
        constructor(camera) {
          this.camera = camera;
          this.bias = 0;
          this.normalBias = 0;
          this.radius = 1;
          this.blurSamples = 8;
          this.mapSize = new Vector22(512, 512);
          this.map = null;
          this.mapPass = null;
          this.matrix = new Matrix42();
          this.autoUpdate = true;
          this.needsUpdate = false;
          this._frustum = new Frustum2();
          this._frameExtents = new Vector22(1, 1);
          this._viewportCount = 1;
          this._viewports = [new Vector42(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(light) {
          const shadowCamera = this.camera;
          const shadowMatrix = this.matrix;
          _lightPositionWorld$12.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld$12);
          _lookTarget$12.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget$12);
          shadowCamera.updateMatrixWorld();
          _projScreenMatrix$12.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix$12);
          shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        }
        getViewport(viewportIndex) {
          return this._viewports[viewportIndex];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          if (this.map) {
            this.map.dispose();
          }
          if (this.mapPass) {
            this.mapPass.dispose();
          }
        }
        copy(source) {
          this.camera = source.camera.clone();
          this.bias = source.bias;
          this.radius = source.radius;
          this.mapSize.copy(source.mapSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const object = {};
          if (this.bias !== 0)
            object.bias = this.bias;
          if (this.normalBias !== 0)
            object.normalBias = this.normalBias;
          if (this.radius !== 1)
            object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;
          return object;
        }
      };
      var SpotLightShadow2 = class extends LightShadow2 {
        constructor() {
          super(new PerspectiveCamera2(50, 1, 0.5, 500));
          this.focus = 1;
        }
        updateMatrices(light) {
          const camera = this.camera;
          const fov3 = RAD2DEG3 * 2 * light.angle * this.focus;
          const aspect3 = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;
          if (fov3 !== camera.fov || aspect3 !== camera.aspect || far !== camera.far) {
            camera.fov = fov3;
            camera.aspect = aspect3;
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          super.updateMatrices(light);
        }
        copy(source) {
          super.copy(source);
          this.focus = source.focus;
          return this;
        }
      };
      SpotLightShadow2.prototype.isSpotLightShadow = true;
      var SpotLight2 = class extends Light2 {
        constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
          super(color, intensity);
          this.type = "SpotLight";
          this.position.copy(Object3D2.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D2();
          this.distance = distance;
          this.angle = angle;
          this.penumbra = penumbra;
          this.decay = decay;
          this.shadow = new SpotLightShadow2();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(power) {
          this.intensity = power / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      SpotLight2.prototype.isSpotLight = true;
      var _projScreenMatrix2 = /* @__PURE__ */ new Matrix42();
      var _lightPositionWorld2 = /* @__PURE__ */ new Vector32();
      var _lookTarget2 = /* @__PURE__ */ new Vector32();
      var PointLightShadow2 = class extends LightShadow2 {
        constructor() {
          super(new PerspectiveCamera2(90, 1, 0.5, 500));
          this._frameExtents = new Vector22(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            new Vector42(2, 1, 1, 1),
            new Vector42(0, 1, 1, 1),
            new Vector42(3, 1, 1, 1),
            new Vector42(1, 1, 1, 1),
            new Vector42(3, 0, 1, 1),
            new Vector42(1, 0, 1, 1)
          ];
          this._cubeDirections = [new Vector32(1, 0, 0), new Vector32(-1, 0, 0), new Vector32(0, 0, 1), new Vector32(0, 0, -1), new Vector32(0, 1, 0), new Vector32(0, -1, 0)];
          this._cubeUps = [new Vector32(0, 1, 0), new Vector32(0, 1, 0), new Vector32(0, 1, 0), new Vector32(0, 1, 0), new Vector32(0, 0, 1), new Vector32(0, 0, -1)];
        }
        updateMatrices(light, viewportIndex = 0) {
          const camera = this.camera;
          const shadowMatrix = this.matrix;
          const far = light.distance || camera.far;
          if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          _lightPositionWorld2.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(_lightPositionWorld2);
          _lookTarget2.copy(camera.position);
          _lookTarget2.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(_lookTarget2);
          camera.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld2.x, -_lightPositionWorld2.y, -_lightPositionWorld2.z);
          _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix2);
        }
      };
      PointLightShadow2.prototype.isPointLightShadow = true;
      var PointLight2 = class extends Light2 {
        constructor(color, intensity, distance = 0, decay = 1) {
          super(color, intensity);
          this.type = "PointLight";
          this.distance = distance;
          this.decay = decay;
          this.shadow = new PointLightShadow2();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(power) {
          this.intensity = power / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.distance = source.distance;
          this.decay = source.decay;
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      PointLight2.prototype.isPointLight = true;
      var DirectionalLightShadow2 = class extends LightShadow2 {
        constructor() {
          super(new OrthographicCamera2(-5, 5, 5, -5, 0.5, 500));
        }
      };
      DirectionalLightShadow2.prototype.isDirectionalLightShadow = true;
      var DirectionalLight2 = class extends Light2 {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "DirectionalLight";
          this.position.copy(Object3D2.DefaultUp);
          this.updateMatrix();
          this.target = new Object3D2();
          this.shadow = new DirectionalLightShadow2();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      DirectionalLight2.prototype.isDirectionalLight = true;
      var AmbientLight2 = class extends Light2 {
        constructor(color, intensity) {
          super(color, intensity);
          this.type = "AmbientLight";
        }
      };
      AmbientLight2.prototype.isAmbientLight = true;
      var RectAreaLight2 = class extends Light2 {
        constructor(color, intensity, width = 10, height = 10) {
          super(color, intensity);
          this.type = "RectAreaLight";
          this.width = width;
          this.height = height;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(power) {
          this.intensity = power / (this.width * this.height * Math.PI);
        }
        copy(source) {
          super.copy(source);
          this.width = source.width;
          this.height = source.height;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.width = this.width;
          data.object.height = this.height;
          return data;
        }
      };
      RectAreaLight2.prototype.isRectAreaLight = true;
      var SphericalHarmonics32 = class {
        constructor() {
          this.coefficients = [];
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients.push(new Vector32());
          }
        }
        set(coefficients) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].copy(coefficients[i2]);
          }
          return this;
        }
        zero() {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].set(0, 0, 0);
          }
          return this;
        }
        getAt(normal, target) {
          const x = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.282095);
          target.addScaledVector(coeff[1], 0.488603 * y);
          target.addScaledVector(coeff[2], 0.488603 * z);
          target.addScaledVector(coeff[3], 0.488603 * x);
          target.addScaledVector(coeff[4], 1.092548 * (x * y));
          target.addScaledVector(coeff[5], 1.092548 * (y * z));
          target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
          target.addScaledVector(coeff[7], 1.092548 * (x * z));
          target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
          return target;
        }
        getIrradianceAt(normal, target) {
          const x = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.886227);
          target.addScaledVector(coeff[1], 2 * 0.511664 * y);
          target.addScaledVector(coeff[2], 2 * 0.511664 * z);
          target.addScaledVector(coeff[3], 2 * 0.511664 * x);
          target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
          target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
          target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
          target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
          target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
          return target;
        }
        add(sh) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].add(sh.coefficients[i2]);
          }
          return this;
        }
        addScaledSH(sh, s) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].addScaledVector(sh.coefficients[i2], s);
          }
          return this;
        }
        scale(s) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].multiplyScalar(s);
          }
          return this;
        }
        lerp(sh, alpha) {
          for (let i2 = 0; i2 < 9; i2++) {
            this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
          }
          return this;
        }
        equals(sh) {
          for (let i2 = 0; i2 < 9; i2++) {
            if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
              return false;
            }
          }
          return true;
        }
        copy(sh) {
          return this.set(sh.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(array, offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].fromArray(array, offset + i2 * 3);
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const coefficients = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++) {
            coefficients[i2].toArray(array, offset + i2 * 3);
          }
          return array;
        }
        static getBasisAt(normal, shBasis) {
          const x = normal.x, y = normal.y, z = normal.z;
          shBasis[0] = 0.282095;
          shBasis[1] = 0.488603 * y;
          shBasis[2] = 0.488603 * z;
          shBasis[3] = 0.488603 * x;
          shBasis[4] = 1.092548 * x * y;
          shBasis[5] = 1.092548 * y * z;
          shBasis[6] = 0.315392 * (3 * z * z - 1);
          shBasis[7] = 1.092548 * x * z;
          shBasis[8] = 0.546274 * (x * x - y * y);
        }
      };
      SphericalHarmonics32.prototype.isSphericalHarmonics3 = true;
      var LightProbe2 = class extends Light2 {
        constructor(sh = new SphericalHarmonics32(), intensity = 1) {
          super(void 0, intensity);
          this.sh = sh;
        }
        copy(source) {
          super.copy(source);
          this.sh.copy(source.sh);
          return this;
        }
        fromJSON(json) {
          this.intensity = json.intensity;
          this.sh.fromArray(json.sh);
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.sh = this.sh.toArray();
          return data;
        }
      };
      LightProbe2.prototype.isLightProbe = true;
      var MaterialLoader = class extends Loader2 {
        constructor(manager) {
          super(manager);
          this.textures = {};
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader4 = new FileLoader2(scope.manager);
          loader4.setPath(scope.path);
          loader4.setRequestHeader(scope.requestHeader);
          loader4.setWithCredentials(scope.withCredentials);
          loader4.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const textures = this.textures;
          function getTexture(name) {
            if (textures[name] === void 0) {
              console.warn("THREE.MaterialLoader: Undefined texture", name);
            }
            return textures[name];
          }
          const material = new Materials[json.type]();
          if (json.uuid !== void 0)
            material.uuid = json.uuid;
          if (json.name !== void 0)
            material.name = json.name;
          if (json.color !== void 0 && material.color !== void 0)
            material.color.setHex(json.color);
          if (json.roughness !== void 0)
            material.roughness = json.roughness;
          if (json.metalness !== void 0)
            material.metalness = json.metalness;
          if (json.sheen !== void 0)
            material.sheen = json.sheen;
          if (json.sheenColor !== void 0)
            material.sheenColor = new Color2().setHex(json.sheenColor);
          if (json.sheenRoughness !== void 0)
            material.sheenRoughness = json.sheenRoughness;
          if (json.emissive !== void 0 && material.emissive !== void 0)
            material.emissive.setHex(json.emissive);
          if (json.specular !== void 0 && material.specular !== void 0)
            material.specular.setHex(json.specular);
          if (json.specularIntensity !== void 0)
            material.specularIntensity = json.specularIntensity;
          if (json.specularColor !== void 0 && material.specularColor !== void 0)
            material.specularColor.setHex(json.specularColor);
          if (json.shininess !== void 0)
            material.shininess = json.shininess;
          if (json.clearcoat !== void 0)
            material.clearcoat = json.clearcoat;
          if (json.clearcoatRoughness !== void 0)
            material.clearcoatRoughness = json.clearcoatRoughness;
          if (json.transmission !== void 0)
            material.transmission = json.transmission;
          if (json.thickness !== void 0)
            material.thickness = json.thickness;
          if (json.attenuationDistance !== void 0)
            material.attenuationDistance = json.attenuationDistance;
          if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0)
            material.attenuationColor.setHex(json.attenuationColor);
          if (json.fog !== void 0)
            material.fog = json.fog;
          if (json.flatShading !== void 0)
            material.flatShading = json.flatShading;
          if (json.blending !== void 0)
            material.blending = json.blending;
          if (json.combine !== void 0)
            material.combine = json.combine;
          if (json.side !== void 0)
            material.side = json.side;
          if (json.shadowSide !== void 0)
            material.shadowSide = json.shadowSide;
          if (json.opacity !== void 0)
            material.opacity = json.opacity;
          if (json.transparent !== void 0)
            material.transparent = json.transparent;
          if (json.alphaTest !== void 0)
            material.alphaTest = json.alphaTest;
          if (json.depthTest !== void 0)
            material.depthTest = json.depthTest;
          if (json.depthWrite !== void 0)
            material.depthWrite = json.depthWrite;
          if (json.colorWrite !== void 0)
            material.colorWrite = json.colorWrite;
          if (json.stencilWrite !== void 0)
            material.stencilWrite = json.stencilWrite;
          if (json.stencilWriteMask !== void 0)
            material.stencilWriteMask = json.stencilWriteMask;
          if (json.stencilFunc !== void 0)
            material.stencilFunc = json.stencilFunc;
          if (json.stencilRef !== void 0)
            material.stencilRef = json.stencilRef;
          if (json.stencilFuncMask !== void 0)
            material.stencilFuncMask = json.stencilFuncMask;
          if (json.stencilFail !== void 0)
            material.stencilFail = json.stencilFail;
          if (json.stencilZFail !== void 0)
            material.stencilZFail = json.stencilZFail;
          if (json.stencilZPass !== void 0)
            material.stencilZPass = json.stencilZPass;
          if (json.wireframe !== void 0)
            material.wireframe = json.wireframe;
          if (json.wireframeLinewidth !== void 0)
            material.wireframeLinewidth = json.wireframeLinewidth;
          if (json.wireframeLinecap !== void 0)
            material.wireframeLinecap = json.wireframeLinecap;
          if (json.wireframeLinejoin !== void 0)
            material.wireframeLinejoin = json.wireframeLinejoin;
          if (json.rotation !== void 0)
            material.rotation = json.rotation;
          if (json.linewidth !== 1)
            material.linewidth = json.linewidth;
          if (json.dashSize !== void 0)
            material.dashSize = json.dashSize;
          if (json.gapSize !== void 0)
            material.gapSize = json.gapSize;
          if (json.scale !== void 0)
            material.scale = json.scale;
          if (json.polygonOffset !== void 0)
            material.polygonOffset = json.polygonOffset;
          if (json.polygonOffsetFactor !== void 0)
            material.polygonOffsetFactor = json.polygonOffsetFactor;
          if (json.polygonOffsetUnits !== void 0)
            material.polygonOffsetUnits = json.polygonOffsetUnits;
          if (json.dithering !== void 0)
            material.dithering = json.dithering;
          if (json.alphaToCoverage !== void 0)
            material.alphaToCoverage = json.alphaToCoverage;
          if (json.premultipliedAlpha !== void 0)
            material.premultipliedAlpha = json.premultipliedAlpha;
          if (json.visible !== void 0)
            material.visible = json.visible;
          if (json.toneMapped !== void 0)
            material.toneMapped = json.toneMapped;
          if (json.userData !== void 0)
            material.userData = json.userData;
          if (json.vertexColors !== void 0) {
            if (typeof json.vertexColors === "number") {
              material.vertexColors = json.vertexColors > 0 ? true : false;
            } else {
              material.vertexColors = json.vertexColors;
            }
          }
          if (json.uniforms !== void 0) {
            for (const name in json.uniforms) {
              const uniform = json.uniforms[name];
              material.uniforms[name] = {};
              switch (uniform.type) {
                case "t":
                  material.uniforms[name].value = getTexture(uniform.value);
                  break;
                case "c":
                  material.uniforms[name].value = new Color2().setHex(uniform.value);
                  break;
                case "v2":
                  material.uniforms[name].value = new Vector22().fromArray(uniform.value);
                  break;
                case "v3":
                  material.uniforms[name].value = new Vector32().fromArray(uniform.value);
                  break;
                case "v4":
                  material.uniforms[name].value = new Vector42().fromArray(uniform.value);
                  break;
                case "m3":
                  material.uniforms[name].value = new Matrix32().fromArray(uniform.value);
                  break;
                case "m4":
                  material.uniforms[name].value = new Matrix42().fromArray(uniform.value);
                  break;
                default:
                  material.uniforms[name].value = uniform.value;
              }
            }
          }
          if (json.defines !== void 0)
            material.defines = json.defines;
          if (json.vertexShader !== void 0)
            material.vertexShader = json.vertexShader;
          if (json.fragmentShader !== void 0)
            material.fragmentShader = json.fragmentShader;
          if (json.extensions !== void 0) {
            for (const key in json.extensions) {
              material.extensions[key] = json.extensions[key];
            }
          }
          if (json.shading !== void 0)
            material.flatShading = json.shading === 1;
          if (json.size !== void 0)
            material.size = json.size;
          if (json.sizeAttenuation !== void 0)
            material.sizeAttenuation = json.sizeAttenuation;
          if (json.map !== void 0)
            material.map = getTexture(json.map);
          if (json.matcap !== void 0)
            material.matcap = getTexture(json.matcap);
          if (json.alphaMap !== void 0)
            material.alphaMap = getTexture(json.alphaMap);
          if (json.bumpMap !== void 0)
            material.bumpMap = getTexture(json.bumpMap);
          if (json.bumpScale !== void 0)
            material.bumpScale = json.bumpScale;
          if (json.normalMap !== void 0)
            material.normalMap = getTexture(json.normalMap);
          if (json.normalMapType !== void 0)
            material.normalMapType = json.normalMapType;
          if (json.normalScale !== void 0) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
              normalScale = [normalScale, normalScale];
            }
            material.normalScale = new Vector22().fromArray(normalScale);
          }
          if (json.displacementMap !== void 0)
            material.displacementMap = getTexture(json.displacementMap);
          if (json.displacementScale !== void 0)
            material.displacementScale = json.displacementScale;
          if (json.displacementBias !== void 0)
            material.displacementBias = json.displacementBias;
          if (json.roughnessMap !== void 0)
            material.roughnessMap = getTexture(json.roughnessMap);
          if (json.metalnessMap !== void 0)
            material.metalnessMap = getTexture(json.metalnessMap);
          if (json.emissiveMap !== void 0)
            material.emissiveMap = getTexture(json.emissiveMap);
          if (json.emissiveIntensity !== void 0)
            material.emissiveIntensity = json.emissiveIntensity;
          if (json.specularMap !== void 0)
            material.specularMap = getTexture(json.specularMap);
          if (json.specularIntensityMap !== void 0)
            material.specularIntensityMap = getTexture(json.specularIntensityMap);
          if (json.specularColorMap !== void 0)
            material.specularColorMap = getTexture(json.specularColorMap);
          if (json.envMap !== void 0)
            material.envMap = getTexture(json.envMap);
          if (json.envMapIntensity !== void 0)
            material.envMapIntensity = json.envMapIntensity;
          if (json.reflectivity !== void 0)
            material.reflectivity = json.reflectivity;
          if (json.refractionRatio !== void 0)
            material.refractionRatio = json.refractionRatio;
          if (json.lightMap !== void 0)
            material.lightMap = getTexture(json.lightMap);
          if (json.lightMapIntensity !== void 0)
            material.lightMapIntensity = json.lightMapIntensity;
          if (json.aoMap !== void 0)
            material.aoMap = getTexture(json.aoMap);
          if (json.aoMapIntensity !== void 0)
            material.aoMapIntensity = json.aoMapIntensity;
          if (json.gradientMap !== void 0)
            material.gradientMap = getTexture(json.gradientMap);
          if (json.clearcoatMap !== void 0)
            material.clearcoatMap = getTexture(json.clearcoatMap);
          if (json.clearcoatRoughnessMap !== void 0)
            material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
          if (json.clearcoatNormalMap !== void 0)
            material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
          if (json.clearcoatNormalScale !== void 0)
            material.clearcoatNormalScale = new Vector22().fromArray(json.clearcoatNormalScale);
          if (json.transmissionMap !== void 0)
            material.transmissionMap = getTexture(json.transmissionMap);
          if (json.thicknessMap !== void 0)
            material.thicknessMap = getTexture(json.thicknessMap);
          if (json.sheenColorMap !== void 0)
            material.sheenColorMap = getTexture(json.sheenColorMap);
          if (json.sheenRoughnessMap !== void 0)
            material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
          return material;
        }
        setTextures(value) {
          this.textures = value;
          return this;
        }
      };
      var LoaderUtils2 = class {
        static decodeText(array) {
          if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
          }
          let s = "";
          for (let i2 = 0, il = array.length; i2 < il; i2++) {
            s += String.fromCharCode(array[i2]);
          }
          try {
            return decodeURIComponent(escape(s));
          } catch (e) {
            return s;
          }
        }
        static extractUrlBase(url) {
          const index = url.lastIndexOf("/");
          if (index === -1)
            return "./";
          return url.substr(0, index + 1);
        }
        static resolveURL(url, path) {
          if (typeof url !== "string" || url === "")
            return "";
          if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
            path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
          }
          if (/^(https?:)?\/\//i.test(url))
            return url;
          if (/^data:.*,.*$/i.test(url))
            return url;
          if (/^blob:.*$/i.test(url))
            return url;
          return path + url;
        }
      };
      var InstancedBufferGeometry2 = class extends BufferGeometry2 {
        constructor() {
          super();
          this.type = "InstancedBufferGeometry";
          this.instanceCount = Infinity;
        }
        copy(source) {
          super.copy(source);
          this.instanceCount = source.instanceCount;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const data = super.toJSON(this);
          data.instanceCount = this.instanceCount;
          data.isInstancedBufferGeometry = true;
          return data;
        }
      };
      InstancedBufferGeometry2.prototype.isInstancedBufferGeometry = true;
      var BufferGeometryLoader = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader4 = new FileLoader2(scope.manager);
          loader4.setPath(scope.path);
          loader4.setRequestHeader(scope.requestHeader);
          loader4.setWithCredentials(scope.withCredentials);
          loader4.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const interleavedBufferMap = {};
          const arrayBufferMap = {};
          function getInterleavedBuffer(json2, uuid) {
            if (interleavedBufferMap[uuid] !== void 0)
              return interleavedBufferMap[uuid];
            const interleavedBuffers = json2.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
            const array = getTypedArray(interleavedBuffer.type, buffer);
            const ib = new InterleavedBuffer2(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
          }
          function getArrayBuffer(json2, uuid) {
            if (arrayBufferMap[uuid] !== void 0)
              return arrayBufferMap[uuid];
            const arrayBuffers = json2.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
          }
          const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry2() : new BufferGeometry2();
          const index = json.data.index;
          if (index !== void 0) {
            const typedArray = getTypedArray(index.type, index.array);
            geometry.setIndex(new BufferAttribute2(typedArray, 1));
          }
          const attributes = json.data.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
              const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
              bufferAttribute = new InterleavedBufferAttribute2(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
              const typedArray = getTypedArray(attribute.type, attribute.array);
              const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute2 : BufferAttribute2;
              bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            if (attribute.usage !== void 0)
              bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== void 0) {
              bufferAttribute.updateRange.offset = attribute.updateRange.offset;
              bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry.setAttribute(key, bufferAttribute);
          }
          const morphAttributes = json.data.morphAttributes;
          if (morphAttributes) {
            for (const key in morphAttributes) {
              const attributeArray = morphAttributes[key];
              const array = [];
              for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
                const attribute = attributeArray[i2];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                  const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute2(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                  const typedArray = getTypedArray(attribute.type, attribute.array);
                  bufferAttribute = new BufferAttribute2(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== void 0)
                  bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
              }
              geometry.morphAttributes[key] = array;
            }
          }
          const morphTargetsRelative = json.data.morphTargetsRelative;
          if (morphTargetsRelative) {
            geometry.morphTargetsRelative = true;
          }
          const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
          if (groups !== void 0) {
            for (let i2 = 0, n = groups.length; i2 !== n; ++i2) {
              const group = groups[i2];
              geometry.addGroup(group.start, group.count, group.materialIndex);
            }
          }
          const boundingSphere = json.data.boundingSphere;
          if (boundingSphere !== void 0) {
            const center = new Vector32();
            if (boundingSphere.center !== void 0) {
              center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new Sphere2(center, boundingSphere.radius);
          }
          if (json.name)
            geometry.name = json.name;
          if (json.userData)
            geometry.userData = json.userData;
          return geometry;
        }
      };
      var ObjectLoader = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils2.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader4 = new FileLoader2(this.manager);
          loader4.setPath(this.path);
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(this.withCredentials);
          loader4.load(url, function(text) {
            let json = null;
            try {
              json = JSON.parse(text);
            } catch (error) {
              if (onError !== void 0)
                onError(error);
              console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
              return;
            }
            const metadata = json.metadata;
            if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
              console.error("THREE.ObjectLoader: Can't load " + url);
              return;
            }
            scope.parse(json, onLoad);
          }, onProgress, onError);
        }
        async loadAsync(url, onProgress) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils2.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader4 = new FileLoader2(this.manager);
          loader4.setPath(this.path);
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(this.withCredentials);
          const text = await loader4.loadAsync(url, onProgress);
          const json = JSON.parse(text);
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            throw new Error("THREE.ObjectLoader: Can't load " + url);
          }
          return await scope.parseAsync(json);
        }
        parse(json, onLoad) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = this.parseImages(json.images, function() {
            if (onLoad !== void 0)
              onLoad(object);
          });
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          if (onLoad !== void 0) {
            let hasImages = false;
            for (const uuid in images) {
              if (images[uuid] instanceof HTMLImageElement) {
                hasImages = true;
                break;
              }
            }
            if (hasImages === false)
              onLoad(object);
          }
          return object;
        }
        async parseAsync(json) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = await this.parseImagesAsync(json.images);
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          return object;
        }
        parseShapes(json) {
          const shapes = {};
          if (json !== void 0) {
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const shape = new Shape2().fromJSON(json[i2]);
              shapes[shape.uuid] = shape;
            }
          }
          return shapes;
        }
        parseSkeletons(json, object) {
          const skeletons = {};
          const bones = {};
          object.traverse(function(child) {
            if (child.isBone)
              bones[child.uuid] = child;
          });
          if (json !== void 0) {
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const skeleton = new Skeleton2().fromJSON(json[i2], bones);
              skeletons[skeleton.uuid] = skeleton;
            }
          }
          return skeletons;
        }
        parseGeometries(json, shapes) {
          const geometries = {};
          if (json !== void 0) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              let geometry;
              const data = json[i2];
              switch (data.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  geometry = bufferGeometryLoader.parse(data);
                  break;
                case "Geometry":
                  console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                  break;
                default:
                  if (data.type in Geometries) {
                    geometry = Geometries[data.type].fromJSON(data, shapes);
                  } else {
                    console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                  }
              }
              geometry.uuid = data.uuid;
              if (data.name !== void 0)
                geometry.name = data.name;
              if (geometry.isBufferGeometry === true && data.userData !== void 0)
                geometry.userData = data.userData;
              geometries[data.uuid] = geometry;
            }
          }
          return geometries;
        }
        parseMaterials(json, textures) {
          const cache = {};
          const materials = {};
          if (json !== void 0) {
            const loader4 = new MaterialLoader();
            loader4.setTextures(textures);
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const data = json[i2];
              if (data.type === "MultiMaterial") {
                const array = [];
                for (let j = 0; j < data.materials.length; j++) {
                  const material = data.materials[j];
                  if (cache[material.uuid] === void 0) {
                    cache[material.uuid] = loader4.parse(material);
                  }
                  array.push(cache[material.uuid]);
                }
                materials[data.uuid] = array;
              } else {
                if (cache[data.uuid] === void 0) {
                  cache[data.uuid] = loader4.parse(data);
                }
                materials[data.uuid] = cache[data.uuid];
              }
            }
          }
          return materials;
        }
        parseAnimations(json) {
          const animations = {};
          if (json !== void 0) {
            for (let i2 = 0; i2 < json.length; i2++) {
              const data = json[i2];
              const clip = AnimationClip2.parse(data);
              animations[clip.uuid] = clip;
            }
          }
          return animations;
        }
        parseImages(json, onLoad) {
          const scope = this;
          const images = {};
          let loader4;
          function loadImage(url) {
            scope.manager.itemStart(url);
            return loader4.load(url, function() {
              scope.manager.itemEnd(url);
            }, void 0, function() {
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            });
          }
          function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return loadImage(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            const manager = new LoadingManager2(onLoad);
            loader4 = new ImageLoader2(manager);
            loader4.setCrossOrigin(this.crossOrigin);
            for (let i2 = 0, il = json.length; i2 < il; i2++) {
              const image = json[i2];
              const url = image.url;
              if (Array.isArray(url)) {
                images[image.uuid] = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      images[image.uuid].push(deserializedImage);
                    } else {
                      images[image.uuid].push(new DataTexture2(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
              } else {
                const deserializedImage = deserializeImage(image.url);
                if (deserializedImage !== null) {
                  images[image.uuid] = deserializedImage;
                }
              }
            }
          }
          return images;
        }
        async parseImagesAsync(json) {
          const scope = this;
          const images = {};
          let loader4;
          async function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return await loader4.loadAsync(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            loader4 = new ImageLoader2(this.manager);
            loader4.setCrossOrigin(this.crossOrigin);
            for (let i2 = 0, il = json.length; i2 < il; i2++) {
              const image = json[i2];
              const url = image.url;
              if (Array.isArray(url)) {
                images[image.uuid] = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = await deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      images[image.uuid].push(deserializedImage);
                    } else {
                      images[image.uuid].push(new DataTexture2(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
              } else {
                const deserializedImage = await deserializeImage(image.url);
                if (deserializedImage !== null) {
                  images[image.uuid] = deserializedImage;
                }
              }
            }
          }
          return images;
        }
        parseTextures(json, images) {
          function parseConstant(value, type) {
            if (typeof value === "number")
              return value;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
            return type[value];
          }
          const textures = {};
          if (json !== void 0) {
            for (let i2 = 0, l = json.length; i2 < l; i2++) {
              const data = json[i2];
              if (data.image === void 0) {
                console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
              }
              if (images[data.image] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined image", data.image);
              }
              let texture;
              const image = images[data.image];
              if (Array.isArray(image)) {
                texture = new CubeTexture2(image);
                if (image.length === 6)
                  texture.needsUpdate = true;
              } else {
                if (image && image.data) {
                  texture = new DataTexture2(image.data, image.width, image.height);
                } else {
                  texture = new Texture2(image);
                }
                if (image)
                  texture.needsUpdate = true;
              }
              texture.uuid = data.uuid;
              if (data.name !== void 0)
                texture.name = data.name;
              if (data.mapping !== void 0)
                texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
              if (data.offset !== void 0)
                texture.offset.fromArray(data.offset);
              if (data.repeat !== void 0)
                texture.repeat.fromArray(data.repeat);
              if (data.center !== void 0)
                texture.center.fromArray(data.center);
              if (data.rotation !== void 0)
                texture.rotation = data.rotation;
              if (data.wrap !== void 0) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
              }
              if (data.format !== void 0)
                texture.format = data.format;
              if (data.type !== void 0)
                texture.type = data.type;
              if (data.encoding !== void 0)
                texture.encoding = data.encoding;
              if (data.minFilter !== void 0)
                texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
              if (data.magFilter !== void 0)
                texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
              if (data.anisotropy !== void 0)
                texture.anisotropy = data.anisotropy;
              if (data.flipY !== void 0)
                texture.flipY = data.flipY;
              if (data.premultiplyAlpha !== void 0)
                texture.premultiplyAlpha = data.premultiplyAlpha;
              if (data.unpackAlignment !== void 0)
                texture.unpackAlignment = data.unpackAlignment;
              if (data.userData !== void 0)
                texture.userData = data.userData;
              textures[data.uuid] = texture;
            }
          }
          return textures;
        }
        parseObject(data, geometries, materials, textures, animations) {
          let object;
          function getGeometry(name) {
            if (geometries[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined geometry", name);
            }
            return geometries[name];
          }
          function getMaterial(name) {
            if (name === void 0)
              return void 0;
            if (Array.isArray(name)) {
              const array = [];
              for (let i2 = 0, l = name.length; i2 < l; i2++) {
                const uuid = name[i2];
                if (materials[uuid] === void 0) {
                  console.warn("THREE.ObjectLoader: Undefined material", uuid);
                }
                array.push(materials[uuid]);
              }
              return array;
            }
            if (materials[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", name);
            }
            return materials[name];
          }
          function getTexture(uuid) {
            if (textures[uuid] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined texture", uuid);
            }
            return textures[uuid];
          }
          let geometry, material;
          switch (data.type) {
            case "Scene":
              object = new Scene2();
              if (data.background !== void 0) {
                if (Number.isInteger(data.background)) {
                  object.background = new Color2(data.background);
                } else {
                  object.background = getTexture(data.background);
                }
              }
              if (data.environment !== void 0) {
                object.environment = getTexture(data.environment);
              }
              if (data.fog !== void 0) {
                if (data.fog.type === "Fog") {
                  object.fog = new Fog2(data.fog.color, data.fog.near, data.fog.far);
                } else if (data.fog.type === "FogExp2") {
                  object.fog = new FogExp22(data.fog.color, data.fog.density);
                }
              }
              break;
            case "PerspectiveCamera":
              object = new PerspectiveCamera2(data.fov, data.aspect, data.near, data.far);
              if (data.focus !== void 0)
                object.focus = data.focus;
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.filmGauge !== void 0)
                object.filmGauge = data.filmGauge;
              if (data.filmOffset !== void 0)
                object.filmOffset = data.filmOffset;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "OrthographicCamera":
              object = new OrthographicCamera2(data.left, data.right, data.top, data.bottom, data.near, data.far);
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "AmbientLight":
              object = new AmbientLight2(data.color, data.intensity);
              break;
            case "DirectionalLight":
              object = new DirectionalLight2(data.color, data.intensity);
              break;
            case "PointLight":
              object = new PointLight2(data.color, data.intensity, data.distance, data.decay);
              break;
            case "RectAreaLight":
              object = new RectAreaLight2(data.color, data.intensity, data.width, data.height);
              break;
            case "SpotLight":
              object = new SpotLight2(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
              break;
            case "HemisphereLight":
              object = new HemisphereLight2(data.color, data.groundColor, data.intensity);
              break;
            case "LightProbe":
              object = new LightProbe2().fromJSON(data);
              break;
            case "SkinnedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new SkinnedMesh2(geometry, material);
              if (data.bindMode !== void 0)
                object.bindMode = data.bindMode;
              if (data.bindMatrix !== void 0)
                object.bindMatrix.fromArray(data.bindMatrix);
              if (data.skeleton !== void 0)
                object.skeleton = data.skeleton;
              break;
            case "Mesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new Mesh2(geometry, material);
              break;
            case "InstancedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              const count = data.count;
              const instanceMatrix = data.instanceMatrix;
              const instanceColor = data.instanceColor;
              object = new InstancedMesh2(geometry, material, count);
              object.instanceMatrix = new InstancedBufferAttribute2(new Float32Array(instanceMatrix.array), 16);
              if (instanceColor !== void 0)
                object.instanceColor = new InstancedBufferAttribute2(new Float32Array(instanceColor.array), instanceColor.itemSize);
              break;
            case "LOD":
              object = new LOD();
              break;
            case "Line":
              object = new Line2(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineLoop":
              object = new LineLoop2(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineSegments":
              object = new LineSegments2(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "PointCloud":
            case "Points":
              object = new Points2(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "Sprite":
              object = new Sprite2(getMaterial(data.material));
              break;
            case "Group":
              object = new Group2();
              break;
            case "Bone":
              object = new Bone2();
              break;
            default:
              object = new Object3D2();
          }
          object.uuid = data.uuid;
          if (data.name !== void 0)
            object.name = data.name;
          if (data.matrix !== void 0) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== void 0)
              object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate)
              object.matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== void 0)
              object.position.fromArray(data.position);
            if (data.rotation !== void 0)
              object.rotation.fromArray(data.rotation);
            if (data.quaternion !== void 0)
              object.quaternion.fromArray(data.quaternion);
            if (data.scale !== void 0)
              object.scale.fromArray(data.scale);
          }
          if (data.castShadow !== void 0)
            object.castShadow = data.castShadow;
          if (data.receiveShadow !== void 0)
            object.receiveShadow = data.receiveShadow;
          if (data.shadow) {
            if (data.shadow.bias !== void 0)
              object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== void 0)
              object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== void 0)
              object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== void 0)
              object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== void 0)
              object.shadow.camera = this.parseObject(data.shadow.camera);
          }
          if (data.visible !== void 0)
            object.visible = data.visible;
          if (data.frustumCulled !== void 0)
            object.frustumCulled = data.frustumCulled;
          if (data.renderOrder !== void 0)
            object.renderOrder = data.renderOrder;
          if (data.userData !== void 0)
            object.userData = data.userData;
          if (data.layers !== void 0)
            object.layers.mask = data.layers;
          if (data.children !== void 0) {
            const children = data.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              object.add(this.parseObject(children[i2], geometries, materials, textures, animations));
            }
          }
          if (data.animations !== void 0) {
            const objectAnimations = data.animations;
            for (let i2 = 0; i2 < objectAnimations.length; i2++) {
              const uuid = objectAnimations[i2];
              object.animations.push(animations[uuid]);
            }
          }
          if (data.type === "LOD") {
            if (data.autoUpdate !== void 0)
              object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for (let l = 0; l < levels.length; l++) {
              const level = levels[l];
              const child = object.getObjectByProperty("uuid", level.object);
              if (child !== void 0) {
                object.addLevel(child, level.distance);
              }
            }
          }
          return object;
        }
        bindSkeletons(object, skeletons) {
          if (Object.keys(skeletons).length === 0)
            return;
          object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
              const skeleton = skeletons[child.skeleton];
              if (skeleton === void 0) {
                console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
              } else {
                child.bind(skeleton, child.bindMatrix);
              }
            }
          });
        }
        setTexturePath(value) {
          console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
          return this.setResourcePath(value);
        }
      };
      var TEXTURE_MAPPING = {
        UVMapping: UVMapping2,
        CubeReflectionMapping: CubeReflectionMapping2,
        CubeRefractionMapping: CubeRefractionMapping2,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping2,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping2,
        CubeUVReflectionMapping: CubeUVReflectionMapping2,
        CubeUVRefractionMapping: CubeUVRefractionMapping2
      };
      var TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping2,
        ClampToEdgeWrapping: ClampToEdgeWrapping2,
        MirroredRepeatWrapping: MirroredRepeatWrapping2
      };
      var TEXTURE_FILTER = {
        NearestFilter: NearestFilter2,
        NearestMipmapNearestFilter: NearestMipmapNearestFilter2,
        NearestMipmapLinearFilter: NearestMipmapLinearFilter2,
        LinearFilter: LinearFilter2,
        LinearMipmapNearestFilter: LinearMipmapNearestFilter2,
        LinearMipmapLinearFilter: LinearMipmapLinearFilter2
      };
      var ImageBitmapLoader2 = class extends Loader2 {
        constructor(manager) {
          super(manager);
          if (typeof createImageBitmap === "undefined") {
            console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
          }
          if (typeof fetch === "undefined") {
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          }
          this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(options) {
          this.options = options;
          return this;
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache2.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const fetchOptions = {};
          fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
          fetchOptions.headers = this.requestHeader;
          fetch(url, fetchOptions).then(function(res) {
            return res.blob();
          }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function(imageBitmap) {
            Cache2.add(url, imageBitmap);
            if (onLoad)
              onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function(e) {
            if (onError)
              onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
          scope.manager.itemStart(url);
        }
      };
      ImageBitmapLoader2.prototype.isImageBitmapLoader = true;
      var _context2;
      var AudioContext2 = {
        getContext: function() {
          if (_context2 === void 0) {
            _context2 = new (window.AudioContext || window.webkitAudioContext)();
          }
          return _context2;
        },
        setContext: function(value) {
          _context2 = value;
        }
      };
      var AudioLoader2 = class extends Loader2 {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader4 = new FileLoader2(this.manager);
          loader4.setResponseType("arraybuffer");
          loader4.setPath(this.path);
          loader4.setRequestHeader(this.requestHeader);
          loader4.setWithCredentials(this.withCredentials);
          loader4.load(url, function(buffer) {
            try {
              const bufferCopy = buffer.slice(0);
              const context = AudioContext2.getContext();
              context.decodeAudioData(bufferCopy, function(audioBuffer) {
                onLoad(audioBuffer);
              });
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
      };
      var HemisphereLightProbe2 = class extends LightProbe2 {
        constructor(skyColor, groundColor, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color2().set(skyColor);
          const color2 = new Color2().set(groundColor);
          const sky = new Vector32(color1.r, color1.g, color1.b);
          const ground = new Vector32(color2.r, color2.g, color2.b);
          const c0 = Math.sqrt(Math.PI);
          const c1 = c0 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
          this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
        }
      };
      HemisphereLightProbe2.prototype.isHemisphereLightProbe = true;
      var AmbientLightProbe2 = class extends LightProbe2 {
        constructor(color, intensity = 1) {
          super(void 0, intensity);
          const color1 = new Color2().set(color);
          this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      };
      AmbientLightProbe2.prototype.isAmbientLightProbe = true;
      var _eyeRight = /* @__PURE__ */ new Matrix42();
      var _eyeLeft = /* @__PURE__ */ new Matrix42();
      var _projectionMatrix = /* @__PURE__ */ new Matrix42();
      var StereoCamera = class {
        constructor() {
          this.type = "StereoCamera";
          this.aspect = 1;
          this.eyeSep = 0.064;
          this.cameraL = new PerspectiveCamera2();
          this.cameraL.layers.enable(1);
          this.cameraL.matrixAutoUpdate = false;
          this.cameraR = new PerspectiveCamera2();
          this.cameraR.layers.enable(2);
          this.cameraR.matrixAutoUpdate = false;
          this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          };
        }
        update(camera) {
          const cache = this._cache;
          const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
          if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            _projectionMatrix.copy(camera.projectionMatrix);
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(DEG2RAD3 * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(_projectionMatrix);
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(_projectionMatrix);
          }
          this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
          this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
        }
      };
      var Clock2 = class {
        constructor(autoStart = true) {
          this.autoStart = autoStart;
          this.startTime = 0;
          this.oldTime = 0;
          this.elapsedTime = 0;
          this.running = false;
        }
        start() {
          this.startTime = now2();
          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;
        }
        stop() {
          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;
        }
        getElapsedTime() {
          this.getDelta();
          return this.elapsedTime;
        }
        getDelta() {
          let diff = 0;
          if (this.autoStart && !this.running) {
            this.start();
            return 0;
          }
          if (this.running) {
            const newTime = now2();
            diff = (newTime - this.oldTime) / 1e3;
            this.oldTime = newTime;
            this.elapsedTime += diff;
          }
          return diff;
        }
      };
      function now2() {
        return (typeof performance === "undefined" ? Date : performance).now();
      }
      var _position$1 = /* @__PURE__ */ new Vector32();
      var _quaternion$1 = /* @__PURE__ */ new Quaternion2();
      var _scale$1 = /* @__PURE__ */ new Vector32();
      var _orientation$1 = /* @__PURE__ */ new Vector32();
      var AudioListener = class extends Object3D2 {
        constructor() {
          super();
          this.type = "AudioListener";
          this.context = AudioContext2.getContext();
          this.gain = this.context.createGain();
          this.gain.connect(this.context.destination);
          this.filter = null;
          this.timeDelta = 0;
          this._clock = new Clock2();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
          }
          return this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(value) {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
          } else {
            this.gain.disconnect(this.context.destination);
          }
          this.filter = value;
          this.gain.connect(this.filter);
          this.filter.connect(this.context.destination);
          return this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          const listener = this.context.listener;
          const up = this.up;
          this.timeDelta = this._clock.getDelta();
          this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
          _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
          if (listener.positionX) {
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
          } else {
            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
          }
        }
      };
      var Audio2 = class extends Object3D2 {
        constructor(listener) {
          super();
          this.type = "Audio";
          this.listener = listener;
          this.context = listener.context;
          this.gain = this.context.createGain();
          this.gain.connect(listener.getInput());
          this.autoplay = false;
          this.buffer = null;
          this.detune = 0;
          this.loop = false;
          this.loopStart = 0;
          this.loopEnd = 0;
          this.offset = 0;
          this.duration = void 0;
          this.playbackRate = 1;
          this.isPlaying = false;
          this.hasPlaybackControl = true;
          this.source = null;
          this.sourceType = "empty";
          this._startedAt = 0;
          this._progress = 0;
          this._connected = false;
          this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(audioNode) {
          this.hasPlaybackControl = false;
          this.sourceType = "audioNode";
          this.source = audioNode;
          this.connect();
          return this;
        }
        setMediaElementSource(mediaElement) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaNode";
          this.source = this.context.createMediaElementSource(mediaElement);
          this.connect();
          return this;
        }
        setMediaStreamSource(mediaStream) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaStreamNode";
          this.source = this.context.createMediaStreamSource(mediaStream);
          this.connect();
          return this;
        }
        setBuffer(audioBuffer) {
          this.buffer = audioBuffer;
          this.sourceType = "buffer";
          if (this.autoplay)
            this.play();
          return this;
        }
        play(delay = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + delay;
          const source = this.context.createBufferSource();
          source.buffer = this.buffer;
          source.loop = this.loop;
          source.loopStart = this.loopStart;
          source.loopEnd = this.loopEnd;
          source.onended = this.onEnded.bind(this);
          source.start(this._startedAt, this._progress + this.offset, this.duration);
          this.isPlaying = true;
          this.source = source;
          this.setDetune(this.detune);
          this.setPlaybackRate(this.playbackRate);
          return this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) {
              this._progress = this._progress % (this.duration || this.buffer.duration);
            }
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
          }
          return this;
        }
        stop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._progress = 0;
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
          return this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
              this.filters[i2 - 1].connect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else {
            this.source.connect(this.getOutput());
          }
          this._connected = true;
          return this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
              this.filters[i2 - 1].disconnect(this.filters[i2]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else {
            this.source.disconnect(this.getOutput());
          }
          this._connected = false;
          return this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(value) {
          if (!value)
            value = [];
          if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
          } else {
            this.filters = value.slice();
          }
          return this;
        }
        setDetune(value) {
          this.detune = value;
          if (this.source.detune === void 0)
            return;
          if (this.isPlaying === true) {
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
          }
          return this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(filter) {
          return this.setFilters(filter ? [filter] : []);
        }
        setPlaybackRate(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.playbackRate = value;
          if (this.isPlaying === true) {
            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
          }
          return this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
          }
          return this.loop;
        }
        setLoop(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.loop = value;
          if (this.isPlaying === true) {
            this.source.loop = this.loop;
          }
          return this;
        }
        setLoopStart(value) {
          this.loopStart = value;
          return this;
        }
        setLoopEnd(value) {
          this.loopEnd = value;
          return this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
      };
      var _position = /* @__PURE__ */ new Vector32();
      var _quaternion = /* @__PURE__ */ new Quaternion2();
      var _scale = /* @__PURE__ */ new Vector32();
      var _orientation = /* @__PURE__ */ new Vector32();
      var PositionalAudio = class extends Audio2 {
        constructor(listener) {
          super(listener);
          this.panner = this.context.createPanner();
          this.panner.panningModel = "HRTF";
          this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(value) {
          this.panner.refDistance = value;
          return this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(value) {
          this.panner.rolloffFactor = value;
          return this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(value) {
          this.panner.distanceModel = value;
          return this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(value) {
          this.panner.maxDistance = value;
          return this;
        }
        setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
          this.panner.coneInnerAngle = coneInnerAngle;
          this.panner.coneOuterAngle = coneOuterAngle;
          this.panner.coneOuterGain = coneOuterGain;
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.hasPlaybackControl === true && this.isPlaying === false)
            return;
          this.matrixWorld.decompose(_position, _quaternion, _scale);
          _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
          const panner = this.panner;
          if (panner.positionX) {
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
          } else {
            panner.setPosition(_position.x, _position.y, _position.z);
            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
          }
        }
      };
      var AudioAnalyser2 = class {
        constructor(audio, fftSize = 2048) {
          this.analyser = audio.context.createAnalyser();
          this.analyser.fftSize = fftSize;
          this.data = new Uint8Array(this.analyser.frequencyBinCount);
          audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          this.analyser.getByteFrequencyData(this.data);
          return this.data;
        }
        getAverageFrequency() {
          let value = 0;
          const data = this.getFrequencyData();
          for (let i2 = 0; i2 < data.length; i2++) {
            value += data[i2];
          }
          return value / data.length;
        }
      };
      var PropertyMixer2 = class {
        constructor(binding, typeName, valueSize) {
          this.binding = binding;
          this.valueSize = valueSize;
          let mixFunction, mixFunctionAdditive, setIdentity;
          switch (typeName) {
            case "quaternion":
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;
              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;
            case "string":
            case "bool":
              mixFunction = this._select;
              mixFunctionAdditive = this._select;
              setIdentity = this._setAdditiveIdentityOther;
              this.buffer = new Array(valueSize * 5);
              break;
            default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;
              this.buffer = new Float64Array(valueSize * 5);
          }
          this._mixBufferRegion = mixFunction;
          this._mixBufferRegionAdditive = mixFunctionAdditive;
          this._setIdentity = setIdentity;
          this._origIndex = 3;
          this._addIndex = 4;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          this.useCount = 0;
          this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
          let currentWeight = this.cumulativeWeight;
          if (currentWeight === 0) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[offset + i2] = buffer[i2];
            }
            currentWeight = weight;
          } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
          }
          this.cumulativeWeight = currentWeight;
        }
        accumulateAdditive(weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
          if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
          }
          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;
        }
        apply(accuIndex) {
          const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
          }
          if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
          }
          for (let i2 = stride, e = stride + stride; i2 !== e; ++i2) {
            if (buffer[i2] !== buffer[i2 + stride]) {
              binding.setValue(buffer, offset);
              break;
            }
          }
        }
        saveOriginalState() {
          const binding = this.binding;
          const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
          binding.getValue(buffer, originalValueOffset);
          for (let i2 = stride, e = originalValueOffset; i2 !== e; ++i2) {
            buffer[i2] = buffer[originalValueOffset + i2 % stride];
          }
          this._setIdentity();
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);
        }
        _setAdditiveIdentityNumeric() {
          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;
          for (let i2 = startIndex; i2 < endIndex; i2++) {
            this.buffer[i2] = 0;
          }
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;
          for (let i2 = 0; i2 < this.valueSize; i2++) {
            this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
          }
        }
        _select(buffer, dstOffset, srcOffset, t, stride) {
          if (t >= 0.5) {
            for (let i2 = 0; i2 !== stride; ++i2) {
              buffer[dstOffset + i2] = buffer[srcOffset + i2];
            }
          }
        }
        _slerp(buffer, dstOffset, srcOffset, t) {
          Quaternion2.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          const workOffset = this._workIndex * stride;
          Quaternion2.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
          Quaternion2.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
        }
        _lerp(buffer, dstOffset, srcOffset, t, stride) {
          const s = 1 - t;
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j = dstOffset + i2;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i2] * t;
          }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            const j = dstOffset + i2;
            buffer[j] = buffer[j] + buffer[srcOffset + i2] * t;
          }
        }
      };
      var _RESERVED_CHARS_RE2 = "\\[\\]\\.:\\/";
      var _reservedRe2 = new RegExp("[" + _RESERVED_CHARS_RE2 + "]", "g");
      var _wordChar2 = "[^" + _RESERVED_CHARS_RE2 + "]";
      var _wordCharOrDot2 = "[^" + _RESERVED_CHARS_RE2.replace("\\.", "") + "]";
      var _directoryRe2 = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar2);
      var _nodeRe2 = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot2);
      var _objectRe2 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar2);
      var _propertyRe2 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar2);
      var _trackRe2 = new RegExp("^" + _directoryRe2 + _nodeRe2 + _objectRe2 + _propertyRe2 + "$");
      var _supportedObjectNames2 = ["material", "materials", "bones"];
      var Composite2 = class {
        constructor(targetGroup, path, optionalParsedPath) {
          const parsedPath = optionalParsedPath || PropertyBinding2.parseTrackName(path);
          this._targetGroup = targetGroup;
          this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
          this.bind();
          const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
          if (binding !== void 0)
            binding.getValue(array, offset);
        }
        setValue(array, offset) {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].setValue(array, offset);
          }
        }
        bind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].bind();
          }
        }
        unbind() {
          const bindings = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
            bindings[i2].unbind();
          }
        }
      };
      var PropertyBinding2 = class {
        constructor(rootNode, path, parsedPath) {
          this.path = path;
          this.parsedPath = parsedPath || PropertyBinding2.parseTrackName(path);
          this.node = PropertyBinding2.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
          this.rootNode = rootNode;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(root, path, parsedPath) {
          if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding2(root, path, parsedPath);
          } else {
            return new PropertyBinding2.Composite(root, path, parsedPath);
          }
        }
        static sanitizeNodeName(name) {
          return name.replace(/\s/g, "_").replace(_reservedRe2, "");
        }
        static parseTrackName(trackName) {
          const matches = _trackRe2.exec(trackName);
          if (!matches) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
          }
          const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
          };
          const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
          if (lastDot !== void 0 && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames2.indexOf(objectName) !== -1) {
              results.nodeName = results.nodeName.substring(0, lastDot);
              results.objectName = objectName;
            }
          }
          if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
          }
          return results;
        }
        static findNode(root, nodeName) {
          if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
          }
          if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== void 0) {
              return bone;
            }
          }
          if (root.children) {
            const searchNodeSubtree = function(children) {
              for (let i2 = 0; i2 < children.length; i2++) {
                const childNode = children[i2];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                  return childNode;
                }
                const result = searchNodeSubtree(childNode.children);
                if (result)
                  return result;
              }
              return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
              return subTreeNode;
            }
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(buffer, offset) {
          buffer[offset] = this.targetObject[this.propertyName];
        }
        _getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
            buffer[offset++] = source[i2];
          }
        }
        _getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
        _setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
            dest[i2] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
          this.bind();
          this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
          this.bind();
          this.setValue(sourceArray, offset);
        }
        bind() {
          let targetObject = this.node;
          const parsedPath = this.parsedPath;
          const objectName = parsedPath.objectName;
          const propertyName = parsedPath.propertyName;
          let propertyIndex = parsedPath.propertyIndex;
          if (!targetObject) {
            targetObject = PropertyBinding2.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
          }
          if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch (objectName) {
              case "materials":
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                targetObject = targetObject.material.materials;
                break;
              case "bones":
                if (!targetObject.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                targetObject = targetObject.skeleton.bones;
                for (let i2 = 0; i2 < targetObject.length; i2++) {
                  if (targetObject[i2].name === objectIndex) {
                    objectIndex = i2;
                    break;
                  }
                }
                break;
              default:
                if (targetObject[objectName] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== void 0) {
              if (targetObject[objectIndex] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                return;
              }
              targetObject = targetObject[objectIndex];
            }
          }
          const nodeProperty = targetObject[propertyName];
          if (nodeProperty === void 0) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
          }
          let versioning = this.Versioning.None;
          this.targetObject = targetObject;
          if (targetObject.needsUpdate !== void 0) {
            versioning = this.Versioning.NeedsUpdate;
          } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let bindingType = this.BindingType.Direct;
          if (propertyIndex !== void 0) {
            if (propertyName === "morphTargetInfluences") {
              if (!targetObject.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (targetObject.geometry.isBufferGeometry) {
                if (!targetObject.geometry.morphAttributes) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                  return;
                }
                if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                  propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                }
              } else {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                return;
              }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
          } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
          } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
          } else {
            this.propertyName = propertyName;
          }
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      };
      PropertyBinding2.Composite = Composite2;
      PropertyBinding2.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      PropertyBinding2.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      PropertyBinding2.prototype.GetterByBindingType = [PropertyBinding2.prototype._getValue_direct, PropertyBinding2.prototype._getValue_array, PropertyBinding2.prototype._getValue_arrayElement, PropertyBinding2.prototype._getValue_toArray];
      PropertyBinding2.prototype.SetterByBindingTypeAndVersioning = [[
        PropertyBinding2.prototype._setValue_direct,
        PropertyBinding2.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding2.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding2.prototype._setValue_array,
        PropertyBinding2.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding2.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding2.prototype._setValue_arrayElement,
        PropertyBinding2.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding2.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ], [
        PropertyBinding2.prototype._setValue_fromArray,
        PropertyBinding2.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding2.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]];
      var AnimationObjectGroup2 = class {
        constructor() {
          this.uuid = generateUUID2();
          this._objects = Array.prototype.slice.call(arguments);
          this.nCachedObjects_ = 0;
          const indices = {};
          this._indicesByUUID = indices;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            indices[arguments[i2].uuid] = i2;
          }
          this._paths = [];
          this._parsedPaths = [];
          this._bindings = [];
          this._bindingsIndicesByPath = {};
          const scope = this;
          this.stats = {
            objects: {
              get total() {
                return scope._objects.length;
              },
              get inUse() {
                return this.total - scope.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return scope._bindings.length;
            }
          };
        }
        add() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
          let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === void 0) {
              index = nObjects++;
              indicesByUUID[uuid] = index;
              objects.push(object);
              for (let j = 0, m = nBindings; j !== m; ++j) {
                bindings[j].push(new PropertyBinding2(object, paths[j], parsedPaths[j]));
              }
            } else if (index < nCachedObjects) {
              knownObject = objects[index];
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[uuid] = firstActiveIndex;
              objects[firstActiveIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                let binding = bindingsForPath[index];
                bindingsForPath[index] = lastCached;
                if (binding === void 0) {
                  binding = new PropertyBinding2(object, paths[j], parsedPaths[j]);
                }
                bindingsForPath[firstActiveIndex] = binding;
              }
            } else if (objects[index] !== knownObject) {
              console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0 && index >= nCachedObjects) {
              const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
              indicesByUUID[firstActiveObject.uuid] = index;
              objects[index] = firstActiveObject;
              indicesByUUID[uuid] = lastCachedIndex;
              objects[lastCachedIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                bindingsForPath[index] = firstActive;
                bindingsForPath[lastCachedIndex] = binding;
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        uncache() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
          for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
            const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0) {
              delete indicesByUUID[uuid];
              if (index < nCachedObjects) {
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                objects[firstActiveIndex] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                  bindingsForPath[index] = lastCached;
                  bindingsForPath[firstActiveIndex] = last;
                  bindingsForPath.pop();
                }
              } else {
                const lastIndex = --nObjects, lastObject = objects[lastIndex];
                if (lastIndex > 0) {
                  indicesByUUID[lastObject.uuid] = index;
                }
                objects[index] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j];
                  bindingsForPath[index] = bindingsForPath[lastIndex];
                  bindingsForPath.pop();
                }
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        subscribe_(path, parsedPath) {
          const indicesByPath = this._bindingsIndicesByPath;
          let index = indicesByPath[path];
          const bindings = this._bindings;
          if (index !== void 0)
            return bindings[index];
          const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
          index = bindings.length;
          indicesByPath[path] = index;
          paths.push(path);
          parsedPaths.push(parsedPath);
          bindings.push(bindingsForPath);
          for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
            const object = objects[i2];
            bindingsForPath[i2] = new PropertyBinding2(object, path, parsedPath);
          }
          return bindingsForPath;
        }
        unsubscribe_(path) {
          const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
          if (index !== void 0) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
          }
        }
      };
      AnimationObjectGroup2.prototype.isAnimationObjectGroup = true;
      var AnimationAction2 = class {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
          this._mixer = mixer;
          this._clip = clip;
          this._localRoot = localRoot;
          this.blendMode = blendMode;
          const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
          const interpolantSettings = {
            endingStart: ZeroCurvatureEnding2,
            endingEnd: ZeroCurvatureEnding2
          };
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const interpolant = tracks[i2].createInterpolant(null);
            interpolants[i2] = interpolant;
            interpolant.settings = interpolantSettings;
          }
          this._interpolantSettings = interpolantSettings;
          this._interpolants = interpolants;
          this._propertyBindings = new Array(nTracks);
          this._cacheIndex = null;
          this._byClipCacheIndex = null;
          this._timeScaleInterpolant = null;
          this._weightInterpolant = null;
          this.loop = LoopRepeat2;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this.timeScale = 1;
          this._effectiveTimeScale = 1;
          this.weight = 1;
          this._effectiveWeight = 1;
          this.repetitions = Infinity;
          this.paused = false;
          this.enabled = true;
          this.clampWhenFinished = false;
          this.zeroSlopeAtStart = true;
          this.zeroSlopeAtEnd = true;
        }
        play() {
          this._mixer._activateAction(this);
          return this;
        }
        stop() {
          this._mixer._deactivateAction(this);
          return this.reset();
        }
        reset() {
          this.paused = false;
          this.enabled = true;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(time) {
          this._startTime = time;
          return this;
        }
        setLoop(mode, repetitions) {
          this.loop = mode;
          this.repetitions = repetitions;
          return this;
        }
        setEffectiveWeight(weight) {
          this.weight = weight;
          this._effectiveWeight = this.enabled ? weight : 0;
          return this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(duration) {
          return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
          return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);
          if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
          }
          return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
          return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
          const weightInterpolant = this._weightInterpolant;
          if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
          }
          return this;
        }
        setEffectiveTimeScale(timeScale) {
          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;
          return this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(duration) {
          this.timeScale = this._clip.duration / duration;
          return this.stopWarping();
        }
        syncWith(action) {
          this.time = action.time;
          this.timeScale = action.timeScale;
          return this.stopWarping();
        }
        halt(duration) {
          return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
          const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
          let interpolant = this._timeScaleInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now3;
          times[1] = now3 + duration;
          values[0] = startTimeScale / timeScale;
          values[1] = endTimeScale / timeScale;
          return this;
        }
        stopWarping() {
          const timeScaleInterpolant = this._timeScaleInterpolant;
          if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
          }
          return this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(time, deltaTime, timeDirection, accuIndex) {
          if (!this.enabled) {
            this._updateWeight(time);
            return;
          }
          const startTime = this._startTime;
          if (startTime !== null) {
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
              return;
            }
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
          }
          deltaTime *= this._updateTimeScale(time);
          const clipTime = this._updateTime(deltaTime);
          const weight = this._updateWeight(time);
          if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch (this.blendMode) {
              case AdditiveAnimationBlendMode2:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulateAdditive(weight);
                }
                break;
              case NormalAnimationBlendMode2:
              default:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
          }
        }
        _updateWeight(time) {
          let weight = 0;
          if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              weight *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopFading();
                if (interpolantValue === 0) {
                  this.enabled = false;
                }
              }
            }
          }
          this._effectiveWeight = weight;
          return weight;
        }
        _updateTimeScale(time) {
          let timeScale = 0;
          if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time)[0];
              timeScale *= interpolantValue;
              if (time > interpolant.parameterPositions[1]) {
                this.stopWarping();
                if (timeScale === 0) {
                  this.paused = true;
                } else {
                  this.timeScale = timeScale;
                }
              }
            }
          }
          this._effectiveTimeScale = timeScale;
          return timeScale;
        }
        _updateTime(deltaTime) {
          const duration = this._clip.duration;
          const loop = this.loop;
          let time = this.time + deltaTime;
          let loopCount = this._loopCount;
          const pingPong = loop === LoopPingPong2;
          if (deltaTime === 0) {
            if (loopCount === -1)
              return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
          }
          if (loop === LoopOnce2) {
            if (loopCount === -1) {
              this._loopCount = 0;
              this._setEndings(true, true, false);
            }
            handle_stop: {
              if (time >= duration) {
                time = duration;
              } else if (time < 0) {
                time = 0;
              } else {
                this.time = time;
                break handle_stop;
              }
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime < 0 ? -1 : 1
              });
            }
          } else {
            if (loopCount === -1) {
              if (deltaTime >= 0) {
                loopCount = 0;
                this._setEndings(true, this.repetitions === 0, pingPong);
              } else {
                this._setEndings(this.repetitions === 0, true, pingPong);
              }
            }
            if (time >= duration || time < 0) {
              const loopDelta = Math.floor(time / duration);
              time -= duration * loopDelta;
              loopCount += Math.abs(loopDelta);
              const pending = this.repetitions - loopCount;
              if (pending <= 0) {
                if (this.clampWhenFinished)
                  this.paused = true;
                else
                  this.enabled = false;
                time = deltaTime > 0 ? duration : 0;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: deltaTime > 0 ? 1 : -1
                });
              } else {
                if (pending === 1) {
                  const atStart = deltaTime < 0;
                  this._setEndings(atStart, !atStart, pingPong);
                } else {
                  this._setEndings(false, false, pingPong);
                }
                this._loopCount = loopCount;
                this.time = time;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta
                });
              }
            } else {
              this.time = time;
            }
            if (pingPong && (loopCount & 1) === 1) {
              return duration - time;
            }
          }
          return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
          const settings = this._interpolantSettings;
          if (pingPong) {
            settings.endingStart = ZeroSlopeEnding2;
            settings.endingEnd = ZeroSlopeEnding2;
          } else {
            if (atStart) {
              settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding2 : ZeroCurvatureEnding2;
            } else {
              settings.endingStart = WrapAroundEnding2;
            }
            if (atEnd) {
              settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding2 : ZeroCurvatureEnding2;
            } else {
              settings.endingEnd = WrapAroundEnding2;
            }
          }
        }
        _scheduleFading(duration, weightNow, weightThen) {
          const mixer = this._mixer, now3 = mixer.time;
          let interpolant = this._weightInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values = interpolant.sampleValues;
          times[0] = now3;
          values[0] = weightNow;
          times[1] = now3 + duration;
          values[1] = weightThen;
          return this;
        }
      };
      var AnimationMixer2 = class extends EventDispatcher3 {
        constructor(root) {
          super();
          this._root = root;
          this._initMemoryManager();
          this._accuIndex = 0;
          this.time = 0;
          this.timeScale = 1;
        }
        _bindAction(action, prototypeAction) {
          const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
          let bindingsByName = bindingsByRoot[rootUuid];
          if (bindingsByName === void 0) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
          }
          for (let i2 = 0; i2 !== nTracks; ++i2) {
            const track = tracks[i2], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== void 0) {
              ++binding.referenceCount;
              bindings[i2] = binding;
            } else {
              binding = bindings[i2];
              if (binding !== void 0) {
                if (binding._cacheIndex === null) {
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                }
                continue;
              }
              const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
              binding = new PropertyMixer2(PropertyBinding2.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
              bindings[i2] = binding;
            }
            interpolants[i2].resultBuffer = binding.buffer;
          }
        }
        _activateAction(action) {
          if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
              const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
              this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
              this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
              const binding = bindings[i2];
              if (binding.useCount++ === 0) {
                this._lendBinding(binding);
                binding.saveOriginalState();
              }
            }
            this._lendAction(action);
          }
        }
        _deactivateAction(action) {
          if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
              const binding = bindings[i2];
              if (--binding.useCount === 0) {
                binding.restoreOriginalState();
                this._takeBackBinding(binding);
              }
            }
            this._takeBackAction(action);
          }
        }
        _initMemoryManager() {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          const scope = this;
          this.stats = {
            actions: {
              get total() {
                return scope._actions.length;
              },
              get inUse() {
                return scope._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return scope._bindings.length;
              },
              get inUse() {
                return scope._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return scope._controlInterpolants.length;
              },
              get inUse() {
                return scope._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(action) {
          const index = action._cacheIndex;
          return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
          const actions = this._actions, actionsByClip = this._actionsByClip;
          let actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip === void 0) {
            actionsForClip = {
              knownActions: [action],
              actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
          } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
          }
          action._cacheIndex = actions.length;
          actions.push(action);
          actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
          const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          action._cacheIndex = null;
          const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();
          action._byClipCacheIndex = null;
          const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
          delete actionByRoot[rootUuid];
          if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
          }
          this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (--binding.referenceCount === 0) {
              this._removeInactiveBinding(binding);
            }
          }
        }
        _lendAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;
          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;
          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;
        }
        _addInactiveBinding(binding, rootUuid, trackName) {
          const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
          let bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName === void 0) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
          }
          bindingByName[trackName] = binding;
          binding._cacheIndex = bindings.length;
          bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
          const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();
          delete bindingByName[trackName];
          if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
          }
        }
        _lendBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;
          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;
          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;
        }
        _lendControlInterpolant() {
          const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
          let interpolant = interpolants[lastActiveIndex];
          if (interpolant === void 0) {
            interpolant = new LinearInterpolant2(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
          }
          return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
          const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;
          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;
        }
        clipAction(clip, optionalRoot, blendMode) {
          const root = optionalRoot || this._root, rootUuid = root.uuid;
          let clipObject = typeof clip === "string" ? AnimationClip2.findByName(root, clip) : clip;
          const clipUuid = clipObject !== null ? clipObject.uuid : clip;
          const actionsForClip = this._actionsByClip[clipUuid];
          let prototypeAction = null;
          if (blendMode === void 0) {
            if (clipObject !== null) {
              blendMode = clipObject.blendMode;
            } else {
              blendMode = NormalAnimationBlendMode2;
            }
          }
          if (actionsForClip !== void 0) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
              return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
              clipObject = prototypeAction._clip;
          }
          if (clipObject === null)
            return null;
          const newAction = new AnimationAction2(this, clipObject, optionalRoot, blendMode);
          this._bindAction(newAction, prototypeAction);
          this._addInactiveAction(newAction, clipUuid, rootUuid);
          return newAction;
        }
        existingAction(clip, optionalRoot) {
          const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip2.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            return actionsForClip.actionByRoot[rootUuid] || null;
          }
          return null;
        }
        stopAllAction() {
          const actions = this._actions, nActions = this._nActiveActions;
          for (let i2 = nActions - 1; i2 >= 0; --i2) {
            actions[i2].stop();
          }
          return this;
        }
        update(deltaTime) {
          deltaTime *= this.timeScale;
          const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
          for (let i2 = 0; i2 !== nActions; ++i2) {
            const action = actions[i2];
            action._update(time, deltaTime, timeDirection, accuIndex);
          }
          const bindings = this._bindings, nBindings = this._nActiveBindings;
          for (let i2 = 0; i2 !== nBindings; ++i2) {
            bindings[i2].apply(accuIndex);
          }
          return this;
        }
        setTime(timeInSeconds) {
          this.time = 0;
          for (let i2 = 0; i2 < this._actions.length; i2++) {
            this._actions[i2].time = 0;
          }
          return this.update(timeInSeconds);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(clip) {
          const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            const actionsToRemove = actionsForClip.knownActions;
            for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
              const action = actionsToRemove[i2];
              this._deactivateAction(action);
              const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
              action._cacheIndex = null;
              action._byClipCacheIndex = null;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
          }
        }
        uncacheRoot(root) {
          const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
          for (const clipUuid in actionsByClip) {
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== void 0) {
              this._deactivateAction(action);
              this._removeInactiveAction(action);
            }
          }
          const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName !== void 0) {
            for (const trackName in bindingByName) {
              const binding = bindingByName[trackName];
              binding.restoreOriginalState();
              this._removeInactiveBinding(binding);
            }
          }
        }
        uncacheAction(clip, optionalRoot) {
          const action = this.existingAction(clip, optionalRoot);
          if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
      };
      AnimationMixer2.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      var Uniform2 = class {
        constructor(value) {
          if (typeof value === "string") {
            console.warn("THREE.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
          }
          this.value = value;
        }
        clone() {
          return new Uniform2(this.value.clone === void 0 ? this.value : this.value.clone());
        }
      };
      var InstancedInterleavedBuffer2 = class extends InterleavedBuffer2 {
        constructor(array, stride, meshPerAttribute = 1) {
          super(array, stride);
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        clone(data) {
          const ib = super.clone(data);
          ib.meshPerAttribute = this.meshPerAttribute;
          return ib;
        }
        toJSON(data) {
          const json = super.toJSON(data);
          json.isInstancedInterleavedBuffer = true;
          json.meshPerAttribute = this.meshPerAttribute;
          return json;
        }
      };
      InstancedInterleavedBuffer2.prototype.isInstancedInterleavedBuffer = true;
      var GLBufferAttribute2 = class {
        constructor(buffer, type, itemSize, elementSize, count) {
          this.buffer = buffer;
          this.type = type;
          this.itemSize = itemSize;
          this.elementSize = elementSize;
          this.count = count;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setBuffer(buffer) {
          this.buffer = buffer;
          return this;
        }
        setType(type, elementSize) {
          this.type = type;
          this.elementSize = elementSize;
          return this;
        }
        setItemSize(itemSize) {
          this.itemSize = itemSize;
          return this;
        }
        setCount(count) {
          this.count = count;
          return this;
        }
      };
      GLBufferAttribute2.prototype.isGLBufferAttribute = true;
      var Raycaster = class {
        constructor(origin, direction, near = 0, far = Infinity) {
          this.ray = new Ray2(origin, direction);
          this.near = near;
          this.far = far;
          this.camera = null;
          this.layers = new Layers2();
          this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(origin, direction) {
          this.ray.set(origin, direction);
        }
        setFromCamera(coords, camera) {
          if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
          } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
          } else {
            console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
          }
        }
        intersectObject(object, recursive = true, intersects3 = []) {
          intersectObject(object, this, intersects3, recursive);
          intersects3.sort(ascSort);
          return intersects3;
        }
        intersectObjects(objects, recursive = true, intersects3 = []) {
          for (let i2 = 0, l = objects.length; i2 < l; i2++) {
            intersectObject(objects[i2], this, intersects3, recursive);
          }
          intersects3.sort(ascSort);
          return intersects3;
        }
      };
      function ascSort(a, b) {
        return a.distance - b.distance;
      }
      function intersectObject(object, raycaster, intersects3, recursive) {
        if (object.layers.test(raycaster.layers)) {
          object.raycast(raycaster, intersects3);
        }
        if (recursive === true) {
          const children = object.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            intersectObject(children[i2], raycaster, intersects3, true);
          }
        }
      }
      var Spherical = class {
        constructor(radius = 1, phi = 0, theta = 0) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        set(radius, phi, theta) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.phi = other.phi;
          this.theta = other.theta;
          return this;
        }
        makeSafe() {
          const EPS = 1e-6;
          this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z) {
          this.radius = Math.sqrt(x * x + y * y + z * z);
          if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
          } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(clamp4(y / this.radius, -1, 1));
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var Cylindrical = class {
        constructor(radius = 1, theta = 0, y = 0) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        set(radius, theta, y) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.theta = other.theta;
          this.y = other.y;
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z) {
          this.radius = Math.sqrt(x * x + z * z);
          this.theta = Math.atan2(x, z);
          this.y = y;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var _vector$42 = /* @__PURE__ */ new Vector22();
      var Box22 = class {
        constructor(min = new Vector22(Infinity, Infinity), max = new Vector22(-Infinity, -Infinity)) {
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i2 = 0, il = points.length; i2 < il; i2++) {
            this.expandByPoint(points[i2]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$42.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = Infinity;
          this.max.x = this.max.y = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        getParameter(point, target) {
          return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$42.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      Box22.prototype.isBox2 = true;
      var _startP2 = /* @__PURE__ */ new Vector32();
      var _startEnd2 = /* @__PURE__ */ new Vector32();
      var Line32 = class {
        constructor(start = new Vector32(), end = new Vector32()) {
          this.start = start;
          this.end = end;
        }
        set(start, end) {
          this.start.copy(start);
          this.end.copy(end);
          return this;
        }
        copy(line) {
          this.start.copy(line.start);
          this.end.copy(line.end);
          return this;
        }
        getCenter(target) {
          return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
          return target.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, target) {
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
          _startP2.subVectors(point, this.start);
          _startEnd2.subVectors(this.end, this.start);
          const startEnd2 = _startEnd2.dot(_startEnd2);
          const startEnd_startP = _startEnd2.dot(_startP2);
          let t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = clamp4(t, 0, 1);
          }
          return t;
        }
        closestPointToPoint(point, clampToLine, target) {
          const t = this.closestPointToPointParameter(point, clampToLine);
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        applyMatrix4(matrix) {
          this.start.applyMatrix4(matrix);
          this.end.applyMatrix4(matrix);
          return this;
        }
        equals(line) {
          return line.start.equals(this.start) && line.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      var _vector$3 = /* @__PURE__ */ new Vector32();
      var SpotLightHelper = class extends Object3D2 {
        constructor(light, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry = new BufferGeometry2();
          const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
          for (let i2 = 0, j = 1, l = 32; i2 < l; i2++, j++) {
            const p1 = i2 / l * Math.PI * 2;
            const p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
          }
          geometry.setAttribute("position", new Float32BufferAttribute2(positions, 3));
          const material = new LineBasicMaterial2({
            fog: false,
            toneMapped: false
          });
          this.cone = new LineSegments2(geometry, material);
          this.add(this.cone);
          this.update();
        }
        dispose() {
          this.cone.geometry.dispose();
          this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const coneLength = this.light.distance ? this.light.distance : 1e3;
          const coneWidth = coneLength * Math.tan(this.light.angle);
          this.cone.scale.set(coneWidth, coneWidth, coneLength);
          _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
          this.cone.lookAt(_vector$3);
          if (this.color !== void 0) {
            this.cone.material.color.set(this.color);
          } else {
            this.cone.material.color.copy(this.light.color);
          }
        }
      };
      var _vector$22 = /* @__PURE__ */ new Vector32();
      var _boneMatrix2 = /* @__PURE__ */ new Matrix42();
      var _matrixWorldInv2 = /* @__PURE__ */ new Matrix42();
      var SkeletonHelper2 = class extends LineSegments2 {
        constructor(object) {
          const bones = getBoneList2(object);
          const geometry = new BufferGeometry2();
          const vertices = [];
          const colors = [];
          const color1 = new Color2(0, 0, 1);
          const color2 = new Color2(0, 1, 0);
          for (let i2 = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);
            }
          }
          geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material = new LineBasicMaterial2({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
          });
          super(geometry, material);
          this.type = "SkeletonHelper";
          this.isSkeletonHelper = true;
          this.root = object;
          this.bones = bones;
          this.matrix = object.matrixWorld;
          this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
          const bones = this.bones;
          const geometry = this.geometry;
          const position = geometry.getAttribute("position");
          _matrixWorldInv2.copy(this.root.matrixWorld).invert();
          for (let i2 = 0, j = 0; i2 < bones.length; i2++) {
            const bone = bones[i2];
            if (bone.parent && bone.parent.isBone) {
              _boneMatrix2.multiplyMatrices(_matrixWorldInv2, bone.matrixWorld);
              _vector$22.setFromMatrixPosition(_boneMatrix2);
              position.setXYZ(j, _vector$22.x, _vector$22.y, _vector$22.z);
              _boneMatrix2.multiplyMatrices(_matrixWorldInv2, bone.parent.matrixWorld);
              _vector$22.setFromMatrixPosition(_boneMatrix2);
              position.setXYZ(j + 1, _vector$22.x, _vector$22.y, _vector$22.z);
              j += 2;
            }
          }
          geometry.getAttribute("position").needsUpdate = true;
          super.updateMatrixWorld(force);
        }
      };
      function getBoneList2(object) {
        const boneList = [];
        if (object && object.isBone) {
          boneList.push(object);
        }
        for (let i2 = 0; i2 < object.children.length; i2++) {
          boneList.push.apply(boneList, getBoneList2(object.children[i2]));
        }
        return boneList;
      }
      var PointLightHelper = class extends Mesh2 {
        constructor(light, sphereSize, color) {
          const geometry = new SphereGeometry(sphereSize, 4, 2);
          const material = new MeshBasicMaterial2({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          super(geometry, material);
          this.light = light;
          this.light.updateMatrixWorld();
          this.color = color;
          this.type = "PointLightHelper";
          this.matrix = this.light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.update();
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
        update() {
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            this.material.color.copy(this.light.color);
          }
        }
      };
      var _vector$1 = /* @__PURE__ */ new Vector32();
      var _color1 = /* @__PURE__ */ new Color2();
      var _color2 = /* @__PURE__ */ new Color2();
      var HemisphereLightHelper = class extends Object3D2 {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          const geometry = new OctahedronGeometry(size);
          geometry.rotateY(Math.PI * 0.5);
          this.material = new MeshBasicMaterial2({
            wireframe: true,
            fog: false,
            toneMapped: false
          });
          if (this.color === void 0)
            this.material.vertexColors = true;
          const position = geometry.getAttribute("position");
          const colors = new Float32Array(position.count * 3);
          geometry.setAttribute("color", new BufferAttribute2(colors, 3));
          this.add(new Mesh2(geometry, this.material));
          this.update();
        }
        dispose() {
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        }
        update() {
          const mesh = this.children[0];
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            const colors = mesh.geometry.getAttribute("color");
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for (let i2 = 0, l = colors.count; i2 < l; i2++) {
              const color = i2 < l / 2 ? _color1 : _color2;
              colors.setXYZ(i2, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
          }
          mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      };
      var GridHelper2 = class extends LineSegments2 {
        constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
          color1 = new Color2(color1);
          color2 = new Color2(color2);
          const center = divisions / 2;
          const step = size / divisions;
          const halfSize = size / 2;
          const vertices = [], colors = [];
          for (let i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i2 === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
          }
          const geometry = new BufferGeometry2();
          geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material = new LineBasicMaterial2({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "GridHelper";
        }
      };
      var PolarGridHelper = class extends LineSegments2 {
        constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
          color1 = new Color2(color1);
          color2 = new Color2(color2);
          const vertices = [];
          const colors = [];
          for (let i2 = 0; i2 <= radials; i2++) {
            const v = i2 / radials * (Math.PI * 2);
            const x = Math.sin(v) * radius;
            const z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);
            const color = i2 & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
          }
          for (let i2 = 0; i2 <= circles; i2++) {
            const color = i2 & 1 ? color1 : color2;
            const r = radius - radius / circles * i2;
            for (let j = 0; j < divisions; j++) {
              let v = j / divisions * (Math.PI * 2);
              let x = Math.sin(v) * r;
              let z = Math.cos(v) * r;
              vertices.push(x, 0, z);
              colors.push(color.r, color.g, color.b);
              v = (j + 1) / divisions * (Math.PI * 2);
              x = Math.sin(v) * r;
              z = Math.cos(v) * r;
              vertices.push(x, 0, z);
              colors.push(color.r, color.g, color.b);
            }
          }
          const geometry = new BufferGeometry2();
          geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material = new LineBasicMaterial2({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "PolarGridHelper";
        }
      };
      var _v1 = /* @__PURE__ */ new Vector32();
      var _v2 = /* @__PURE__ */ new Vector32();
      var _v3 = /* @__PURE__ */ new Vector32();
      var DirectionalLightHelper = class extends Object3D2 {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.light.updateMatrixWorld();
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          if (size === void 0)
            size = 1;
          let geometry = new BufferGeometry2();
          geometry.setAttribute("position", new Float32BufferAttribute2([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
          const material = new LineBasicMaterial2({
            fog: false,
            toneMapped: false
          });
          this.lightPlane = new Line2(geometry, material);
          this.add(this.lightPlane);
          geometry = new BufferGeometry2();
          geometry.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 0, 0, 1], 3));
          this.targetLine = new Line2(geometry, material);
          this.add(this.targetLine);
          this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose();
          this.lightPlane.material.dispose();
          this.targetLine.geometry.dispose();
          this.targetLine.material.dispose();
        }
        update() {
          _v1.setFromMatrixPosition(this.light.matrixWorld);
          _v2.setFromMatrixPosition(this.light.target.matrixWorld);
          _v3.subVectors(_v2, _v1);
          this.lightPlane.lookAt(_v2);
          if (this.color !== void 0) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
          } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
          }
          this.targetLine.lookAt(_v2);
          this.targetLine.scale.z = _v3.length();
        }
      };
      var _vector = /* @__PURE__ */ new Vector32();
      var _camera = /* @__PURE__ */ new Camera2();
      var CameraHelper = class extends LineSegments2 {
        constructor(camera) {
          const geometry = new BufferGeometry2();
          const material = new LineBasicMaterial2({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
          });
          const vertices = [];
          const colors = [];
          const pointMap = {};
          const colorFrustum = new Color2(16755200);
          const colorCone = new Color2(16711680);
          const colorUp = new Color2(43775);
          const colorTarget = new Color2(16777215);
          const colorCross = new Color2(3355443);
          addLine("n1", "n2", colorFrustum);
          addLine("n2", "n4", colorFrustum);
          addLine("n4", "n3", colorFrustum);
          addLine("n3", "n1", colorFrustum);
          addLine("f1", "f2", colorFrustum);
          addLine("f2", "f4", colorFrustum);
          addLine("f4", "f3", colorFrustum);
          addLine("f3", "f1", colorFrustum);
          addLine("n1", "f1", colorFrustum);
          addLine("n2", "f2", colorFrustum);
          addLine("n3", "f3", colorFrustum);
          addLine("n4", "f4", colorFrustum);
          addLine("p", "n1", colorCone);
          addLine("p", "n2", colorCone);
          addLine("p", "n3", colorCone);
          addLine("p", "n4", colorCone);
          addLine("u1", "u2", colorUp);
          addLine("u2", "u3", colorUp);
          addLine("u3", "u1", colorUp);
          addLine("c", "t", colorTarget);
          addLine("p", "c", colorCross);
          addLine("cn1", "cn2", colorCross);
          addLine("cn3", "cn4", colorCross);
          addLine("cf1", "cf2", colorCross);
          addLine("cf3", "cf4", colorCross);
          function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
          }
          function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === void 0) {
              pointMap[id] = [];
            }
            pointMap[id].push(vertices.length / 3 - 1);
          }
          geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          super(geometry, material);
          this.type = "CameraHelper";
          this.camera = camera;
          if (this.camera.updateProjectionMatrix)
            this.camera.updateProjectionMatrix();
          this.matrix = camera.matrixWorld;
          this.matrixAutoUpdate = false;
          this.pointMap = pointMap;
          this.update();
        }
        update() {
          const geometry = this.geometry;
          const pointMap = this.pointMap;
          const w = 1, h = 1;
          _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
          setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
          setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
          setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
          setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
          setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
          setPoint("n4", pointMap, geometry, _camera, w, h, -1);
          setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
          setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
          setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
          setPoint("f4", pointMap, geometry, _camera, w, h, 1);
          setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
          setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
          setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
          setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
          setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
          setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
          setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
          setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
          setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
          setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
          setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
          geometry.getAttribute("position").needsUpdate = true;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      function setPoint(point, pointMap, geometry, camera, x, y, z) {
        _vector.set(x, y, z).unproject(camera);
        const points = pointMap[point];
        if (points !== void 0) {
          const position = geometry.getAttribute("position");
          for (let i2 = 0, l = points.length; i2 < l; i2++) {
            position.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
          }
        }
      }
      var _box = /* @__PURE__ */ new Box32();
      var BoxHelper = class extends LineSegments2 {
        constructor(object, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = new Float32Array(8 * 3);
          const geometry = new BufferGeometry2();
          geometry.setIndex(new BufferAttribute2(indices, 1));
          geometry.setAttribute("position", new BufferAttribute2(positions, 3));
          super(geometry, new LineBasicMaterial2({
            color,
            toneMapped: false
          }));
          this.object = object;
          this.type = "BoxHelper";
          this.matrixAutoUpdate = false;
          this.update();
        }
        update(object) {
          if (object !== void 0) {
            console.warn("THREE.BoxHelper: .update() has no longer arguments.");
          }
          if (this.object !== void 0) {
            _box.setFromObject(this.object);
          }
          if (_box.isEmpty())
            return;
          const min = _box.min;
          const max = _box.max;
          const position = this.geometry.attributes.position;
          const array = position.array;
          array[0] = max.x;
          array[1] = max.y;
          array[2] = max.z;
          array[3] = min.x;
          array[4] = max.y;
          array[5] = max.z;
          array[6] = min.x;
          array[7] = min.y;
          array[8] = max.z;
          array[9] = max.x;
          array[10] = min.y;
          array[11] = max.z;
          array[12] = max.x;
          array[13] = max.y;
          array[14] = min.z;
          array[15] = min.x;
          array[16] = max.y;
          array[17] = min.z;
          array[18] = min.x;
          array[19] = min.y;
          array[20] = min.z;
          array[21] = max.x;
          array[22] = min.y;
          array[23] = min.z;
          position.needsUpdate = true;
          this.geometry.computeBoundingSphere();
        }
        setFromObject(object) {
          this.object = object;
          this.update();
          return this;
        }
        copy(source) {
          LineSegments2.prototype.copy.call(this, source);
          this.object = source.object;
          return this;
        }
      };
      var Box3Helper = class extends LineSegments2 {
        constructor(box, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
          const geometry = new BufferGeometry2();
          geometry.setIndex(new BufferAttribute2(indices, 1));
          geometry.setAttribute("position", new Float32BufferAttribute2(positions, 3));
          super(geometry, new LineBasicMaterial2({
            color,
            toneMapped: false
          }));
          this.box = box;
          this.type = "Box3Helper";
          this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(force) {
          const box = this.box;
          if (box.isEmpty())
            return;
          box.getCenter(this.position);
          box.getSize(this.scale);
          this.scale.multiplyScalar(0.5);
          super.updateMatrixWorld(force);
        }
      };
      var PlaneHelper = class extends Line2 {
        constructor(plane, size = 1, hex = 16776960) {
          const color = hex;
          const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
          const geometry = new BufferGeometry2();
          geometry.setAttribute("position", new Float32BufferAttribute2(positions, 3));
          geometry.computeBoundingSphere();
          super(geometry, new LineBasicMaterial2({
            color,
            toneMapped: false
          }));
          this.type = "PlaneHelper";
          this.plane = plane;
          this.size = size;
          const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
          const geometry2 = new BufferGeometry2();
          geometry2.setAttribute("position", new Float32BufferAttribute2(positions2, 3));
          geometry2.computeBoundingSphere();
          this.add(new Mesh2(geometry2, new MeshBasicMaterial2({
            color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
          })));
        }
        updateMatrixWorld(force) {
          let scale = -this.plane.constant;
          if (Math.abs(scale) < 1e-8)
            scale = 1e-8;
          this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
          this.children[0].material.side = scale < 0 ? BackSide2 : FrontSide2;
          this.lookAt(this.plane.normal);
          super.updateMatrixWorld(force);
        }
      };
      var _axis = /* @__PURE__ */ new Vector32();
      var _lineGeometry;
      var _coneGeometry;
      var ArrowHelper = class extends Object3D2 {
        constructor(dir = new Vector32(0, 0, 1), origin = new Vector32(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
          super();
          this.type = "ArrowHelper";
          if (_lineGeometry === void 0) {
            _lineGeometry = new BufferGeometry2();
            _lineGeometry.setAttribute("position", new Float32BufferAttribute2([0, 0, 0, 0, 1, 0], 3));
            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
          }
          this.position.copy(origin);
          this.line = new Line2(_lineGeometry, new LineBasicMaterial2({
            color,
            toneMapped: false
          }));
          this.line.matrixAutoUpdate = false;
          this.add(this.line);
          this.cone = new Mesh2(_coneGeometry, new MeshBasicMaterial2({
            color,
            toneMapped: false
          }));
          this.cone.matrixAutoUpdate = false;
          this.add(this.cone);
          this.setDirection(dir);
          this.setLength(length, headLength, headWidth);
        }
        setDirection(dir) {
          if (dir.y > 0.99999) {
            this.quaternion.set(0, 0, 0, 1);
          } else if (dir.y < -0.99999) {
            this.quaternion.set(1, 0, 0, 0);
          } else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
          }
        }
        setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
          this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
          this.line.updateMatrix();
          this.cone.scale.set(headWidth, headLength, headWidth);
          this.cone.position.y = length;
          this.cone.updateMatrix();
        }
        setColor(color) {
          this.line.material.color.set(color);
          this.cone.material.color.set(color);
        }
        copy(source) {
          super.copy(source, false);
          this.line.copy(source.line);
          this.cone.copy(source.cone);
          return this;
        }
      };
      var AxesHelper = class extends LineSegments2 {
        constructor(size = 1) {
          const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
          const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
          const geometry = new BufferGeometry2();
          geometry.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute2(colors, 3));
          const material = new LineBasicMaterial2({
            vertexColors: true,
            toneMapped: false
          });
          super(geometry, material);
          this.type = "AxesHelper";
        }
        setColors(xAxisColor, yAxisColor, zAxisColor) {
          const color = new Color2();
          const array = this.geometry.attributes.color.array;
          color.set(xAxisColor);
          color.toArray(array, 0);
          color.toArray(array, 3);
          color.set(yAxisColor);
          color.toArray(array, 6);
          color.toArray(array, 9);
          color.set(zAxisColor);
          color.toArray(array, 12);
          color.toArray(array, 15);
          this.geometry.attributes.color.needsUpdate = true;
          return this;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      var ShapePath = class {
        constructor() {
          this.type = "ShapePath";
          this.color = new Color2();
          this.subPaths = [];
          this.currentPath = null;
        }
        moveTo(x, y) {
          this.currentPath = new Path2();
          this.subPaths.push(this.currentPath);
          this.currentPath.moveTo(x, y);
          return this;
        }
        lineTo(x, y) {
          this.currentPath.lineTo(x, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
          return this;
        }
        splineThru(pts) {
          this.currentPath.splineThru(pts);
          return this;
        }
        toShapes(isCCW, noHoles) {
          function toShapesNoHoles(inSubpaths) {
            const shapes2 = [];
            for (let i2 = 0, l = inSubpaths.length; i2 < l; i2++) {
              const tmpPath2 = inSubpaths[i2];
              const tmpShape2 = new Shape2();
              tmpShape2.curves = tmpPath2.curves;
              shapes2.push(tmpShape2);
            }
            return shapes2;
          }
          function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for (let p2 = polyLen - 1, q = 0; q < polyLen; p2 = q++) {
              let edgeLowPt = inPolygon[p2];
              let edgeHighPt = inPolygon[q];
              let edgeDx = edgeHighPt.x - edgeLowPt.x;
              let edgeDy = edgeHighPt.y - edgeLowPt.y;
              if (Math.abs(edgeDy) > Number.EPSILON) {
                if (edgeDy < 0) {
                  edgeLowPt = inPolygon[q];
                  edgeDx = -edgeDx;
                  edgeHighPt = inPolygon[p2];
                  edgeDy = -edgeDy;
                }
                if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                  continue;
                if (inPt.y === edgeLowPt.y) {
                  if (inPt.x === edgeLowPt.x)
                    return true;
                } else {
                  const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                  if (perpEdge === 0)
                    return true;
                  if (perpEdge < 0)
                    continue;
                  inside = !inside;
                }
              } else {
                if (inPt.y !== edgeLowPt.y)
                  continue;
                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                  return true;
              }
            }
            return inside;
          }
          const isClockWise = ShapeUtils2.isClockWise;
          const subPaths = this.subPaths;
          if (subPaths.length === 0)
            return [];
          if (noHoles === true)
            return toShapesNoHoles(subPaths);
          let solid, tmpPath, tmpShape;
          const shapes = [];
          if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape2();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
          }
          let holesFirst = !isClockWise(subPaths[0].getPoints());
          holesFirst = isCCW ? !holesFirst : holesFirst;
          const betterShapeHoles = [];
          const newShapes = [];
          let newShapeHoles = [];
          let mainIdx = 0;
          let tmpPoints;
          newShapes[mainIdx] = void 0;
          newShapeHoles[mainIdx] = [];
          for (let i2 = 0, l = subPaths.length; i2 < l; i2++) {
            tmpPath = subPaths[i2];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
              if (!holesFirst && newShapes[mainIdx])
                mainIdx++;
              newShapes[mainIdx] = {
                s: new Shape2(),
                p: tmpPoints
              };
              newShapes[mainIdx].s.curves = tmpPath.curves;
              if (holesFirst)
                mainIdx++;
              newShapeHoles[mainIdx] = [];
            } else {
              newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
              });
            }
          }
          if (!newShapes[0])
            return toShapesNoHoles(subPaths);
          if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              betterShapeHoles[sIdx] = [];
            }
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              const sho = newShapeHoles[sIdx];
              for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                const ho = sho[hIdx];
                let hole_unassigned = true;
                for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                  if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                    if (sIdx !== s2Idx)
                      toChange.push({
                        froms: sIdx,
                        tos: s2Idx,
                        hole: hIdx
                      });
                    if (hole_unassigned) {
                      hole_unassigned = false;
                      betterShapeHoles[s2Idx].push(ho);
                    } else {
                      ambiguous = true;
                    }
                  }
                }
                if (hole_unassigned) {
                  betterShapeHoles[sIdx].push(ho);
                }
              }
            }
            if (toChange.length > 0) {
              if (!ambiguous)
                newShapeHoles = betterShapeHoles;
            }
          }
          let tmpHoles;
          for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
            tmpShape = newShapes[i2].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i2];
            for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
              tmpShape.holes.push(tmpHoles[j].h);
            }
          }
          return shapes;
        }
      };
      var _floatView2 = new Float32Array(1);
      var _int32View2 = new Int32Array(_floatView2.buffer);
      var DataUtils = class {
        static toHalfFloat(val) {
          if (val > 65504) {
            console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504.");
            val = 65504;
          }
          _floatView2[0] = val;
          const x = _int32View2[0];
          let bits = x >> 16 & 32768;
          let m = x >> 12 & 2047;
          const e = x >> 23 & 255;
          if (e < 103)
            return bits;
          if (e > 142) {
            bits |= 31744;
            bits |= (e == 255 ? 0 : 1) && x & 8388607;
            return bits;
          }
          if (e < 113) {
            m |= 2048;
            bits |= (m >> 114 - e) + (m >> 113 - e & 1);
            return bits;
          }
          bits |= e - 112 << 10 | m >> 1;
          bits += m & 1;
          return bits;
        }
      };
      var LineStrip = 0;
      var LinePieces = 1;
      var NoColors = 0;
      var FaceColors = 1;
      var VertexColors = 2;
      function MeshFaceMaterial(materials) {
        console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
        return materials;
      }
      function MultiMaterial(materials = []) {
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function() {
          return materials.slice();
        };
        return materials;
      }
      function PointCloud(geometry, material) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        return new Points2(geometry, material);
      }
      function Particle2(material) {
        console.warn("THREE.Particle has been renamed to THREE.Sprite.");
        return new Sprite2(material);
      }
      function ParticleSystem(geometry, material) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        return new Points2(geometry, material);
      }
      function PointCloudMaterial(parameters) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial2(parameters);
      }
      function ParticleBasicMaterial(parameters) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial2(parameters);
      }
      function ParticleSystemMaterial(parameters) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        return new PointsMaterial2(parameters);
      }
      function Vertex(x, y, z) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        return new Vector32(x, y, z);
      }
      function DynamicBufferAttribute(array, itemSize) {
        console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
        return new BufferAttribute2(array, itemSize).setUsage(DynamicDrawUsage2);
      }
      function Int8Attribute(array, itemSize) {
        console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
        return new Int8BufferAttribute(array, itemSize);
      }
      function Uint8Attribute(array, itemSize) {
        console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
        return new Uint8BufferAttribute(array, itemSize);
      }
      function Uint8ClampedAttribute(array, itemSize) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
        return new Uint8ClampedBufferAttribute(array, itemSize);
      }
      function Int16Attribute(array, itemSize) {
        console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
        return new Int16BufferAttribute(array, itemSize);
      }
      function Uint16Attribute(array, itemSize) {
        console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
        return new Uint16BufferAttribute2(array, itemSize);
      }
      function Int32Attribute(array, itemSize) {
        console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
        return new Int32BufferAttribute(array, itemSize);
      }
      function Uint32Attribute(array, itemSize) {
        console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
        return new Uint32BufferAttribute2(array, itemSize);
      }
      function Float32Attribute(array, itemSize) {
        console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
        return new Float32BufferAttribute2(array, itemSize);
      }
      function Float64Attribute(array, itemSize) {
        console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
        return new Float64BufferAttribute(array, itemSize);
      }
      Curve2.create = function(construct, getPoint) {
        console.log("THREE.Curve.create() has been deprecated");
        construct.prototype = Object.create(Curve2.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
      };
      Path2.prototype.fromPoints = function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        return this.setFromPoints(points);
      };
      function AxisHelper(size) {
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
        return new AxesHelper(size);
      }
      function BoundingBoxHelper(object, color) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        return new BoxHelper(object, color);
      }
      function EdgesHelper(object, hex) {
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        return new LineSegments2(new EdgesGeometry(object.geometry), new LineBasicMaterial2({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      GridHelper2.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      };
      SkeletonHelper2.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      };
      function WireframeHelper(object, hex) {
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        return new LineSegments2(new WireframeGeometry(object.geometry), new LineBasicMaterial2({
          color: hex !== void 0 ? hex : 16777215
        }));
      }
      Loader2.prototype.extractUrlBase = function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils2.extractUrlBase(url);
      };
      Loader2.Handlers = {
        add: function() {
          console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
        },
        get: function() {
          console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
        }
      };
      function XHRLoader(manager) {
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
        return new FileLoader2(manager);
      }
      function BinaryTextureLoader(manager) {
        console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
        return new DataTextureLoader(manager);
      }
      Box22.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box22.prototype.empty = function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box22.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box22.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Box32.prototype.center = function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Box32.prototype.empty = function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Box32.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Box32.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Box32.prototype.size = function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
      };
      Sphere2.prototype.empty = function() {
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
      };
      Frustum2.prototype.setFromMatrix = function(m) {
        console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
        return this.setFromProjectionMatrix(m);
      };
      Line32.prototype.center = function(optionalTarget) {
        console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
      };
      Matrix32.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix32.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
      };
      Matrix32.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      };
      Matrix32.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
        return attribute.applyMatrix3(this);
      };
      Matrix32.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      };
      Matrix32.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Matrix42.prototype.extractPosition = function(m) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m);
      };
      Matrix42.prototype.flattenToArrayOffset = function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
      };
      Matrix42.prototype.getPosition = function() {
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return new Vector32().setFromMatrixColumn(this, 3);
      };
      Matrix42.prototype.setRotationFromQuaternion = function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
      };
      Matrix42.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      };
      Matrix42.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix42.prototype.multiplyVector4 = function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix42.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      };
      Matrix42.prototype.rotateAxis = function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
      };
      Matrix42.prototype.crossVector = function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
      };
      Matrix42.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      };
      Matrix42.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      };
      Matrix42.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      };
      Matrix42.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      };
      Matrix42.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      };
      Matrix42.prototype.applyToBufferAttribute = function(attribute) {
        console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
        return attribute.applyMatrix4(this);
      };
      Matrix42.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      };
      Matrix42.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
      };
      Matrix42.prototype.getInverse = function(matrix) {
        console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
        return this.copy(matrix).invert();
      };
      Plane2.prototype.isIntersectionLine = function(line) {
        console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
        return this.intersectsLine(line);
      };
      Quaternion2.prototype.multiplyVector3 = function(vector) {
        console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return vector.applyQuaternion(this);
      };
      Quaternion2.prototype.inverse = function() {
        console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
        return this.invert();
      };
      Ray2.prototype.isIntersectionBox = function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
      };
      Ray2.prototype.isIntersectionPlane = function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
      };
      Ray2.prototype.isIntersectionSphere = function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
      };
      Triangle2.prototype.area = function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
      };
      Triangle2.prototype.barycoordFromPoint = function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
      };
      Triangle2.prototype.midpoint = function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
      };
      Triangle2.prototypenormal = function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
      };
      Triangle2.prototype.plane = function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
      };
      Triangle2.barycoordFromPoint = function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle2.getBarycoord(point, a, b, c, target);
      };
      Triangle2.normal = function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle2.getNormal(a, b, c, target);
      };
      Shape2.prototype.extractAllPoints = function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
      };
      Shape2.prototype.extrude = function(options) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry2(this, options);
      };
      Shape2.prototype.makeGeometry = function(options) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry2(this, options);
      };
      Vector22.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector22.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector22.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector32.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      };
      Vector32.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      };
      Vector32.prototype.getPositionFromMatrix = function(m) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m);
      };
      Vector32.prototype.getScaleFromMatrix = function(m) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m);
      };
      Vector32.prototype.getColumnFromMatrix = function(index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
      };
      Vector32.prototype.applyProjection = function(m) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m);
      };
      Vector32.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector32.prototype.distanceToManhattan = function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
      };
      Vector32.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Vector42.prototype.fromAttribute = function(attribute, index, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
      };
      Vector42.prototype.lengthManhattan = function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
      };
      Object3D2.prototype.getChildByName = function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
      };
      Object3D2.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      };
      Object3D2.prototype.translate = function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
      };
      Object3D2.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      };
      Object3D2.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(Object3D2.prototype, {
        eulerOrder: {
          get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
          },
          set: function(value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
          }
        },
        useQuaternion: {
          get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          },
          set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
          }
        }
      });
      Mesh2.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      };
      Object.defineProperties(Mesh2.prototype, {
        drawMode: {
          get: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
            return TrianglesDrawMode2;
          },
          set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
          }
        }
      });
      SkinnedMesh2.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      };
      PerspectiveCamera2.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== void 0)
          this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
      };
      Object.defineProperties(Light2.prototype, {
        onlyShadow: {
          set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          }
        },
        shadowCameraFov: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = value;
          }
        },
        shadowCameraLeft: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = value;
          }
        },
        shadowCameraRight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = value;
          }
        },
        shadowCameraTop: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = value;
          }
        },
        shadowCameraBottom: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = value;
          }
        },
        shadowCameraNear: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = value;
          }
        },
        shadowCameraFar: {
          set: function(value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = value;
          }
        },
        shadowCameraVisible: {
          set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
          }
        },
        shadowBias: {
          set: function(value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
          }
        },
        shadowDarkness: {
          set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          }
        },
        shadowMapWidth: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
          }
        },
        shadowMapHeight: {
          set: function(value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
          }
        }
      });
      Object.defineProperties(BufferAttribute2.prototype, {
        length: {
          get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length;
          }
        },
        dynamic: {
          get: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            return this.usage === DynamicDrawUsage2;
          },
          set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
            this.setUsage(DynamicDrawUsage2);
          }
        }
      });
      BufferAttribute2.prototype.setDynamic = function(value) {
        console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage2 : StaticDrawUsage2);
        return this;
      };
      BufferAttribute2.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, BufferAttribute2.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      BufferGeometry2.prototype.addIndex = function(index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
      };
      BufferGeometry2.prototype.addAttribute = function(name, attribute) {
        console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
          console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
          return this.setAttribute(name, new BufferAttribute2(arguments[1], arguments[2]));
        }
        if (name === "index") {
          console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
          this.setIndex(attribute);
          return this;
        }
        return this.setAttribute(name, attribute);
      };
      BufferGeometry2.prototype.addDrawCall = function(start, count, indexOffset) {
        if (indexOffset !== void 0) {
          console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        }
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
      };
      BufferGeometry2.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
      };
      BufferGeometry2.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      };
      BufferGeometry2.prototype.removeAttribute = function(name) {
        console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
        return this.deleteAttribute(name);
      };
      BufferGeometry2.prototype.applyMatrix = function(matrix) {
        console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
        return this.applyMatrix4(matrix);
      };
      Object.defineProperties(BufferGeometry2.prototype, {
        drawcalls: {
          get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
          }
        },
        offsets: {
          get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
          }
        }
      });
      InterleavedBuffer2.prototype.setDynamic = function(value) {
        console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
        this.setUsage(value === true ? DynamicDrawUsage2 : StaticDrawUsage2);
        return this;
      };
      InterleavedBuffer2.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      };
      ExtrudeGeometry2.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      };
      ExtrudeGeometry2.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
      };
      ExtrudeGeometry2.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      };
      Scene2.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      };
      Uniform2.prototype.onUpdate = function() {
        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
        return this;
      };
      Object.defineProperties(Material2.prototype, {
        wrapAround: {
          get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
          }
        },
        overdraw: {
          get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          },
          set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
          }
        },
        wrapRGB: {
          get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new Color2();
          }
        },
        shading: {
          get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = value === FlatShading2;
          }
        },
        stencilMask: {
          get: function() {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            return this.stencilFuncMask;
          },
          set: function(value) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
            this.stencilFuncMask = value;
          }
        },
        vertexTangents: {
          get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          },
          set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
          }
        }
      });
      Object.defineProperties(ShaderMaterial2.prototype, {
        derivatives: {
          get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
          },
          set: function(value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
          }
        }
      });
      WebGLRenderer2.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      WebGLRenderer2.prototype.animate = function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
      };
      WebGLRenderer2.prototype.getCurrentRenderTarget = function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
      };
      WebGLRenderer2.prototype.getMaxAnisotropy = function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
      };
      WebGLRenderer2.prototype.getPrecision = function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
      };
      WebGLRenderer2.prototype.resetGLState = function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
      };
      WebGLRenderer2.prototype.supportsFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
      };
      WebGLRenderer2.prototype.supportsHalfFloatTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
      };
      WebGLRenderer2.prototype.supportsStandardDerivatives = function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
      };
      WebGLRenderer2.prototype.supportsCompressedTextureS3TC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
      };
      WebGLRenderer2.prototype.supportsCompressedTexturePVRTC = function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
      };
      WebGLRenderer2.prototype.supportsBlendMinMax = function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
      };
      WebGLRenderer2.prototype.supportsVertexTextures = function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
      };
      WebGLRenderer2.prototype.supportsInstancedArrays = function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
      };
      WebGLRenderer2.prototype.enableScissorTest = function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
      };
      WebGLRenderer2.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      };
      WebGLRenderer2.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      };
      WebGLRenderer2.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      };
      WebGLRenderer2.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      };
      WebGLRenderer2.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      };
      WebGLRenderer2.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      };
      WebGLRenderer2.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      };
      WebGLRenderer2.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      };
      WebGLRenderer2.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      };
      WebGLRenderer2.prototype.getActiveMipMapLevel = function() {
        console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
        return this.getActiveMipmapLevel();
      };
      Object.defineProperties(WebGLRenderer2.prototype, {
        shadowMapEnabled: {
          get: function() {
            return this.shadowMap.enabled;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
          }
        },
        shadowMapType: {
          get: function() {
            return this.shadowMap.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
          }
        },
        shadowMapCullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        context: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
            return this.getContext();
          }
        },
        vr: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
            return this.xr;
          }
        },
        gammaInput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
            return false;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          }
        },
        gammaOutput: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            return false;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
            this.outputEncoding = value === true ? sRGBEncoding2 : LinearEncoding2;
          }
        },
        toneMappingWhitePoint: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
            return 1;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          }
        },
        gammaFactor: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
            return 2;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          }
        }
      });
      Object.defineProperties(WebGLShadowMap2.prototype, {
        cullFace: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          }
        },
        renderReverseSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          }
        },
        renderSingleSided: {
          get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            return void 0;
          },
          set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          }
        }
      });
      function WebGLRenderTargetCube(width, height, options) {
        console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
        return new WebGLCubeRenderTarget2(width, options);
      }
      Object.defineProperties(WebGLRenderTarget3.prototype, {
        wrapS: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
          }
        },
        wrapT: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
          }
        },
        magFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
          }
        },
        minFilter: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
          }
        },
        anisotropy: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
          }
        },
        offset: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = value;
          }
        },
        repeat: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = value;
          }
        },
        format: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = value;
          }
        },
        type: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = value;
          }
        },
        generateMipmaps: {
          get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
          },
          set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
          }
        }
      });
      Audio2.prototype.load = function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const scope = this;
        const audioLoader = new AudioLoader2();
        audioLoader.load(file, function(buffer) {
          scope.setBuffer(buffer);
        });
        return this;
      };
      AudioAnalyser2.prototype.getData = function() {
        console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
        return this.getFrequencyData();
      };
      CubeCamera2.prototype.updateCubeMap = function(renderer, scene) {
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
        return this.update(renderer, scene);
      };
      CubeCamera2.prototype.clear = function(renderer, color, depth, stencil) {
        console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
        return this.renderTarget.clear(renderer, color, depth, stencil);
      };
      ImageUtils2.crossOrigin = void 0;
      ImageUtils2.loadTexture = function(url, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const loader4 = new TextureLoader2();
        loader4.setCrossOrigin(this.crossOrigin);
        const texture = loader4.load(url, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils2.loadTextureCube = function(urls, mapping, onLoad, onError) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const loader4 = new CubeTextureLoader2();
        loader4.setCrossOrigin(this.crossOrigin);
        const texture = loader4.load(urls, onLoad, void 0, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      };
      ImageUtils2.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      };
      ImageUtils2.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been removed");
      }
      function JSONLoader() {
        console.error("THREE.JSONLoader has been removed.");
      }
      var SceneUtils2 = {
        createMultiMaterialObject: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        detach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        },
        attach: function() {
          console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
        }
      };
      function LensFlare() {
        console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
      }
      function ParametricGeometry() {
        console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js");
        return new BufferGeometry2();
      }
      function TextGeometry() {
        console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js");
        return new BufferGeometry2();
      }
      function FontLoader() {
        console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
      }
      function Font() {
        console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
      }
      function ImmediateRenderObject() {
        console.error("THREE.ImmediateRenderObject has been removed.");
      }
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
          detail: {
            revision: REVISION2
          }
        }));
      }
      if (typeof window !== "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = REVISION2;
        }
      }
      exports.ACESFilmicToneMapping = ACESFilmicToneMapping2;
      exports.AddEquation = AddEquation2;
      exports.AddOperation = AddOperation2;
      exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode2;
      exports.AdditiveBlending = AdditiveBlending2;
      exports.AlphaFormat = AlphaFormat2;
      exports.AlwaysDepth = AlwaysDepth2;
      exports.AlwaysStencilFunc = AlwaysStencilFunc2;
      exports.AmbientLight = AmbientLight2;
      exports.AmbientLightProbe = AmbientLightProbe2;
      exports.AnimationClip = AnimationClip2;
      exports.AnimationLoader = AnimationLoader;
      exports.AnimationMixer = AnimationMixer2;
      exports.AnimationObjectGroup = AnimationObjectGroup2;
      exports.AnimationUtils = AnimationUtils2;
      exports.ArcCurve = ArcCurve2;
      exports.ArrayCamera = ArrayCamera2;
      exports.ArrowHelper = ArrowHelper;
      exports.Audio = Audio2;
      exports.AudioAnalyser = AudioAnalyser2;
      exports.AudioContext = AudioContext2;
      exports.AudioListener = AudioListener;
      exports.AudioLoader = AudioLoader2;
      exports.AxesHelper = AxesHelper;
      exports.AxisHelper = AxisHelper;
      exports.BackSide = BackSide2;
      exports.BasicDepthPacking = BasicDepthPacking2;
      exports.BasicShadowMap = BasicShadowMap;
      exports.BinaryTextureLoader = BinaryTextureLoader;
      exports.Bone = Bone2;
      exports.BooleanKeyframeTrack = BooleanKeyframeTrack2;
      exports.BoundingBoxHelper = BoundingBoxHelper;
      exports.Box2 = Box22;
      exports.Box3 = Box32;
      exports.Box3Helper = Box3Helper;
      exports.BoxBufferGeometry = BoxGeometry2;
      exports.BoxGeometry = BoxGeometry2;
      exports.BoxHelper = BoxHelper;
      exports.BufferAttribute = BufferAttribute2;
      exports.BufferGeometry = BufferGeometry2;
      exports.BufferGeometryLoader = BufferGeometryLoader;
      exports.ByteType = ByteType2;
      exports.Cache = Cache2;
      exports.Camera = Camera2;
      exports.CameraHelper = CameraHelper;
      exports.CanvasRenderer = CanvasRenderer;
      exports.CanvasTexture = CanvasTexture2;
      exports.CatmullRomCurve3 = CatmullRomCurve32;
      exports.CineonToneMapping = CineonToneMapping2;
      exports.CircleBufferGeometry = CircleGeometry;
      exports.CircleGeometry = CircleGeometry;
      exports.ClampToEdgeWrapping = ClampToEdgeWrapping2;
      exports.Clock = Clock2;
      exports.Color = Color2;
      exports.ColorKeyframeTrack = ColorKeyframeTrack2;
      exports.CompressedTexture = CompressedTexture2;
      exports.CompressedTextureLoader = CompressedTextureLoader2;
      exports.ConeBufferGeometry = ConeGeometry;
      exports.ConeGeometry = ConeGeometry;
      exports.CubeCamera = CubeCamera2;
      exports.CubeReflectionMapping = CubeReflectionMapping2;
      exports.CubeRefractionMapping = CubeRefractionMapping2;
      exports.CubeTexture = CubeTexture2;
      exports.CubeTextureLoader = CubeTextureLoader2;
      exports.CubeUVReflectionMapping = CubeUVReflectionMapping2;
      exports.CubeUVRefractionMapping = CubeUVRefractionMapping2;
      exports.CubicBezierCurve = CubicBezierCurve2;
      exports.CubicBezierCurve3 = CubicBezierCurve32;
      exports.CubicInterpolant = CubicInterpolant2;
      exports.CullFaceBack = CullFaceBack2;
      exports.CullFaceFront = CullFaceFront2;
      exports.CullFaceFrontBack = CullFaceFrontBack;
      exports.CullFaceNone = CullFaceNone2;
      exports.Curve = Curve2;
      exports.CurvePath = CurvePath2;
      exports.CustomBlending = CustomBlending2;
      exports.CustomToneMapping = CustomToneMapping2;
      exports.CylinderBufferGeometry = CylinderGeometry;
      exports.CylinderGeometry = CylinderGeometry;
      exports.Cylindrical = Cylindrical;
      exports.DataTexture = DataTexture2;
      exports.DataTexture2DArray = DataTexture2DArray2;
      exports.DataTexture3D = DataTexture3D2;
      exports.DataTextureLoader = DataTextureLoader;
      exports.DataUtils = DataUtils;
      exports.DecrementStencilOp = DecrementStencilOp;
      exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
      exports.DefaultLoadingManager = DefaultLoadingManager2;
      exports.DepthFormat = DepthFormat2;
      exports.DepthStencilFormat = DepthStencilFormat2;
      exports.DepthTexture = DepthTexture2;
      exports.DirectionalLight = DirectionalLight2;
      exports.DirectionalLightHelper = DirectionalLightHelper;
      exports.DiscreteInterpolant = DiscreteInterpolant2;
      exports.DodecahedronBufferGeometry = DodecahedronGeometry;
      exports.DodecahedronGeometry = DodecahedronGeometry;
      exports.DoubleSide = DoubleSide3;
      exports.DstAlphaFactor = DstAlphaFactor2;
      exports.DstColorFactor = DstColorFactor2;
      exports.DynamicBufferAttribute = DynamicBufferAttribute;
      exports.DynamicCopyUsage = DynamicCopyUsage;
      exports.DynamicDrawUsage = DynamicDrawUsage2;
      exports.DynamicReadUsage = DynamicReadUsage;
      exports.EdgesGeometry = EdgesGeometry;
      exports.EdgesHelper = EdgesHelper;
      exports.EllipseCurve = EllipseCurve2;
      exports.EqualDepth = EqualDepth2;
      exports.EqualStencilFunc = EqualStencilFunc;
      exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping2;
      exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping2;
      exports.Euler = Euler2;
      exports.EventDispatcher = EventDispatcher3;
      exports.ExtrudeBufferGeometry = ExtrudeGeometry2;
      exports.ExtrudeGeometry = ExtrudeGeometry2;
      exports.FaceColors = FaceColors;
      exports.FileLoader = FileLoader2;
      exports.FlatShading = FlatShading2;
      exports.Float16BufferAttribute = Float16BufferAttribute2;
      exports.Float32Attribute = Float32Attribute;
      exports.Float32BufferAttribute = Float32BufferAttribute2;
      exports.Float64Attribute = Float64Attribute;
      exports.Float64BufferAttribute = Float64BufferAttribute;
      exports.FloatType = FloatType2;
      exports.Fog = Fog2;
      exports.FogExp2 = FogExp22;
      exports.Font = Font;
      exports.FontLoader = FontLoader;
      exports.FramebufferTexture = FramebufferTexture2;
      exports.FrontSide = FrontSide2;
      exports.Frustum = Frustum2;
      exports.GLBufferAttribute = GLBufferAttribute2;
      exports.GLSL1 = GLSL1;
      exports.GLSL3 = GLSL32;
      exports.GreaterDepth = GreaterDepth2;
      exports.GreaterEqualDepth = GreaterEqualDepth2;
      exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
      exports.GreaterStencilFunc = GreaterStencilFunc;
      exports.GridHelper = GridHelper2;
      exports.Group = Group2;
      exports.HalfFloatType = HalfFloatType2;
      exports.HemisphereLight = HemisphereLight2;
      exports.HemisphereLightHelper = HemisphereLightHelper;
      exports.HemisphereLightProbe = HemisphereLightProbe2;
      exports.IcosahedronBufferGeometry = IcosahedronGeometry;
      exports.IcosahedronGeometry = IcosahedronGeometry;
      exports.ImageBitmapLoader = ImageBitmapLoader2;
      exports.ImageLoader = ImageLoader2;
      exports.ImageUtils = ImageUtils2;
      exports.ImmediateRenderObject = ImmediateRenderObject;
      exports.IncrementStencilOp = IncrementStencilOp;
      exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
      exports.InstancedBufferAttribute = InstancedBufferAttribute2;
      exports.InstancedBufferGeometry = InstancedBufferGeometry2;
      exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer2;
      exports.InstancedMesh = InstancedMesh2;
      exports.Int16Attribute = Int16Attribute;
      exports.Int16BufferAttribute = Int16BufferAttribute;
      exports.Int32Attribute = Int32Attribute;
      exports.Int32BufferAttribute = Int32BufferAttribute;
      exports.Int8Attribute = Int8Attribute;
      exports.Int8BufferAttribute = Int8BufferAttribute;
      exports.IntType = IntType2;
      exports.InterleavedBuffer = InterleavedBuffer2;
      exports.InterleavedBufferAttribute = InterleavedBufferAttribute2;
      exports.Interpolant = Interpolant2;
      exports.InterpolateDiscrete = InterpolateDiscrete2;
      exports.InterpolateLinear = InterpolateLinear2;
      exports.InterpolateSmooth = InterpolateSmooth2;
      exports.InvertStencilOp = InvertStencilOp;
      exports.JSONLoader = JSONLoader;
      exports.KeepStencilOp = KeepStencilOp2;
      exports.KeyframeTrack = KeyframeTrack2;
      exports.LOD = LOD;
      exports.LatheBufferGeometry = LatheGeometry;
      exports.LatheGeometry = LatheGeometry;
      exports.Layers = Layers2;
      exports.LensFlare = LensFlare;
      exports.LessDepth = LessDepth2;
      exports.LessEqualDepth = LessEqualDepth2;
      exports.LessEqualStencilFunc = LessEqualStencilFunc;
      exports.LessStencilFunc = LessStencilFunc;
      exports.Light = Light2;
      exports.LightProbe = LightProbe2;
      exports.Line = Line2;
      exports.Line3 = Line32;
      exports.LineBasicMaterial = LineBasicMaterial2;
      exports.LineCurve = LineCurve2;
      exports.LineCurve3 = LineCurve32;
      exports.LineDashedMaterial = LineDashedMaterial2;
      exports.LineLoop = LineLoop2;
      exports.LinePieces = LinePieces;
      exports.LineSegments = LineSegments2;
      exports.LineStrip = LineStrip;
      exports.LinearEncoding = LinearEncoding2;
      exports.LinearFilter = LinearFilter2;
      exports.LinearInterpolant = LinearInterpolant2;
      exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
      exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
      exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter2;
      exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter2;
      exports.LinearToneMapping = LinearToneMapping2;
      exports.Loader = Loader2;
      exports.LoaderUtils = LoaderUtils2;
      exports.LoadingManager = LoadingManager2;
      exports.LoopOnce = LoopOnce2;
      exports.LoopPingPong = LoopPingPong2;
      exports.LoopRepeat = LoopRepeat2;
      exports.LuminanceAlphaFormat = LuminanceAlphaFormat2;
      exports.LuminanceFormat = LuminanceFormat2;
      exports.MOUSE = MOUSE;
      exports.Material = Material2;
      exports.MaterialLoader = MaterialLoader;
      exports.Math = MathUtils6;
      exports.MathUtils = MathUtils6;
      exports.Matrix3 = Matrix32;
      exports.Matrix4 = Matrix42;
      exports.MaxEquation = MaxEquation2;
      exports.Mesh = Mesh2;
      exports.MeshBasicMaterial = MeshBasicMaterial2;
      exports.MeshDepthMaterial = MeshDepthMaterial2;
      exports.MeshDistanceMaterial = MeshDistanceMaterial2;
      exports.MeshFaceMaterial = MeshFaceMaterial;
      exports.MeshLambertMaterial = MeshLambertMaterial2;
      exports.MeshMatcapMaterial = MeshMatcapMaterial2;
      exports.MeshNormalMaterial = MeshNormalMaterial2;
      exports.MeshPhongMaterial = MeshPhongMaterial2;
      exports.MeshPhysicalMaterial = MeshPhysicalMaterial2;
      exports.MeshStandardMaterial = MeshStandardMaterial2;
      exports.MeshToonMaterial = MeshToonMaterial2;
      exports.MinEquation = MinEquation2;
      exports.MirroredRepeatWrapping = MirroredRepeatWrapping2;
      exports.MixOperation = MixOperation2;
      exports.MultiMaterial = MultiMaterial;
      exports.MultiplyBlending = MultiplyBlending2;
      exports.MultiplyOperation = MultiplyOperation2;
      exports.NearestFilter = NearestFilter2;
      exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
      exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
      exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter2;
      exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter2;
      exports.NeverDepth = NeverDepth2;
      exports.NeverStencilFunc = NeverStencilFunc;
      exports.NoBlending = NoBlending2;
      exports.NoColors = NoColors;
      exports.NoToneMapping = NoToneMapping2;
      exports.NormalAnimationBlendMode = NormalAnimationBlendMode2;
      exports.NormalBlending = NormalBlending2;
      exports.NotEqualDepth = NotEqualDepth2;
      exports.NotEqualStencilFunc = NotEqualStencilFunc;
      exports.NumberKeyframeTrack = NumberKeyframeTrack2;
      exports.Object3D = Object3D2;
      exports.ObjectLoader = ObjectLoader;
      exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap2;
      exports.OctahedronBufferGeometry = OctahedronGeometry;
      exports.OctahedronGeometry = OctahedronGeometry;
      exports.OneFactor = OneFactor2;
      exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor2;
      exports.OneMinusDstColorFactor = OneMinusDstColorFactor2;
      exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor2;
      exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor2;
      exports.OrthographicCamera = OrthographicCamera2;
      exports.PCFShadowMap = PCFShadowMap2;
      exports.PCFSoftShadowMap = PCFSoftShadowMap2;
      exports.PMREMGenerator = PMREMGenerator2;
      exports.ParametricGeometry = ParametricGeometry;
      exports.Particle = Particle2;
      exports.ParticleBasicMaterial = ParticleBasicMaterial;
      exports.ParticleSystem = ParticleSystem;
      exports.ParticleSystemMaterial = ParticleSystemMaterial;
      exports.Path = Path2;
      exports.PerspectiveCamera = PerspectiveCamera2;
      exports.Plane = Plane2;
      exports.PlaneBufferGeometry = PlaneGeometry2;
      exports.PlaneGeometry = PlaneGeometry2;
      exports.PlaneHelper = PlaneHelper;
      exports.PointCloud = PointCloud;
      exports.PointCloudMaterial = PointCloudMaterial;
      exports.PointLight = PointLight2;
      exports.PointLightHelper = PointLightHelper;
      exports.Points = Points2;
      exports.PointsMaterial = PointsMaterial2;
      exports.PolarGridHelper = PolarGridHelper;
      exports.PolyhedronBufferGeometry = PolyhedronGeometry;
      exports.PolyhedronGeometry = PolyhedronGeometry;
      exports.PositionalAudio = PositionalAudio;
      exports.PropertyBinding = PropertyBinding2;
      exports.PropertyMixer = PropertyMixer2;
      exports.QuadraticBezierCurve = QuadraticBezierCurve2;
      exports.QuadraticBezierCurve3 = QuadraticBezierCurve32;
      exports.Quaternion = Quaternion2;
      exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack2;
      exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant2;
      exports.REVISION = REVISION2;
      exports.RGBADepthPacking = RGBADepthPacking2;
      exports.RGBAFormat = RGBAFormat2;
      exports.RGBAIntegerFormat = RGBAIntegerFormat2;
      exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format2;
      exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format2;
      exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format2;
      exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format2;
      exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format2;
      exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format2;
      exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format2;
      exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format2;
      exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format2;
      exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format2;
      exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format2;
      exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format2;
      exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format2;
      exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format2;
      exports.RGBA_BPTC_Format = RGBA_BPTC_Format2;
      exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format2;
      exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format2;
      exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format2;
      exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format2;
      exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format2;
      exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format2;
      exports.RGBFormat = RGBFormat2;
      exports.RGB_ETC1_Format = RGB_ETC1_Format2;
      exports.RGB_ETC2_Format = RGB_ETC2_Format2;
      exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format2;
      exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format2;
      exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format2;
      exports.RGFormat = RGFormat2;
      exports.RGIntegerFormat = RGIntegerFormat2;
      exports.RawShaderMaterial = RawShaderMaterial2;
      exports.Ray = Ray2;
      exports.Raycaster = Raycaster;
      exports.RectAreaLight = RectAreaLight2;
      exports.RedFormat = RedFormat2;
      exports.RedIntegerFormat = RedIntegerFormat2;
      exports.ReinhardToneMapping = ReinhardToneMapping2;
      exports.RepeatWrapping = RepeatWrapping2;
      exports.ReplaceStencilOp = ReplaceStencilOp;
      exports.ReverseSubtractEquation = ReverseSubtractEquation2;
      exports.RingBufferGeometry = RingGeometry;
      exports.RingGeometry = RingGeometry;
      exports.Scene = Scene2;
      exports.SceneUtils = SceneUtils2;
      exports.ShaderChunk = ShaderChunk2;
      exports.ShaderLib = ShaderLib2;
      exports.ShaderMaterial = ShaderMaterial2;
      exports.ShadowMaterial = ShadowMaterial2;
      exports.Shape = Shape2;
      exports.ShapeBufferGeometry = ShapeGeometry2;
      exports.ShapeGeometry = ShapeGeometry2;
      exports.ShapePath = ShapePath;
      exports.ShapeUtils = ShapeUtils2;
      exports.ShortType = ShortType2;
      exports.Skeleton = Skeleton2;
      exports.SkeletonHelper = SkeletonHelper2;
      exports.SkinnedMesh = SkinnedMesh2;
      exports.SmoothShading = SmoothShading;
      exports.Sphere = Sphere2;
      exports.SphereBufferGeometry = SphereGeometry;
      exports.SphereGeometry = SphereGeometry;
      exports.Spherical = Spherical;
      exports.SphericalHarmonics3 = SphericalHarmonics32;
      exports.SplineCurve = SplineCurve2;
      exports.SpotLight = SpotLight2;
      exports.SpotLightHelper = SpotLightHelper;
      exports.Sprite = Sprite2;
      exports.SpriteMaterial = SpriteMaterial2;
      exports.SrcAlphaFactor = SrcAlphaFactor2;
      exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor2;
      exports.SrcColorFactor = SrcColorFactor2;
      exports.StaticCopyUsage = StaticCopyUsage;
      exports.StaticDrawUsage = StaticDrawUsage2;
      exports.StaticReadUsage = StaticReadUsage;
      exports.StereoCamera = StereoCamera;
      exports.StreamCopyUsage = StreamCopyUsage;
      exports.StreamDrawUsage = StreamDrawUsage;
      exports.StreamReadUsage = StreamReadUsage;
      exports.StringKeyframeTrack = StringKeyframeTrack2;
      exports.SubtractEquation = SubtractEquation2;
      exports.SubtractiveBlending = SubtractiveBlending2;
      exports.TOUCH = TOUCH;
      exports.TangentSpaceNormalMap = TangentSpaceNormalMap2;
      exports.TetrahedronBufferGeometry = TetrahedronGeometry;
      exports.TetrahedronGeometry = TetrahedronGeometry;
      exports.TextGeometry = TextGeometry;
      exports.Texture = Texture2;
      exports.TextureLoader = TextureLoader2;
      exports.TorusBufferGeometry = TorusGeometry;
      exports.TorusGeometry = TorusGeometry;
      exports.TorusKnotBufferGeometry = TorusKnotGeometry;
      exports.TorusKnotGeometry = TorusKnotGeometry;
      exports.Triangle = Triangle2;
      exports.TriangleFanDrawMode = TriangleFanDrawMode2;
      exports.TriangleStripDrawMode = TriangleStripDrawMode2;
      exports.TrianglesDrawMode = TrianglesDrawMode2;
      exports.TubeBufferGeometry = TubeGeometry;
      exports.TubeGeometry = TubeGeometry;
      exports.UVMapping = UVMapping2;
      exports.Uint16Attribute = Uint16Attribute;
      exports.Uint16BufferAttribute = Uint16BufferAttribute2;
      exports.Uint32Attribute = Uint32Attribute;
      exports.Uint32BufferAttribute = Uint32BufferAttribute2;
      exports.Uint8Attribute = Uint8Attribute;
      exports.Uint8BufferAttribute = Uint8BufferAttribute;
      exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
      exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
      exports.Uniform = Uniform2;
      exports.UniformsLib = UniformsLib2;
      exports.UniformsUtils = UniformsUtils2;
      exports.UnsignedByteType = UnsignedByteType2;
      exports.UnsignedInt248Type = UnsignedInt248Type2;
      exports.UnsignedIntType = UnsignedIntType2;
      exports.UnsignedShort4444Type = UnsignedShort4444Type2;
      exports.UnsignedShort5551Type = UnsignedShort5551Type2;
      exports.UnsignedShortType = UnsignedShortType2;
      exports.VSMShadowMap = VSMShadowMap2;
      exports.Vector2 = Vector22;
      exports.Vector3 = Vector32;
      exports.Vector4 = Vector42;
      exports.VectorKeyframeTrack = VectorKeyframeTrack2;
      exports.Vertex = Vertex;
      exports.VertexColors = VertexColors;
      exports.VideoTexture = VideoTexture2;
      exports.WebGL1Renderer = WebGL1Renderer2;
      exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget2;
      exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets2;
      exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget2;
      exports.WebGLRenderTarget = WebGLRenderTarget3;
      exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
      exports.WebGLRenderer = WebGLRenderer2;
      exports.WebGLUtils = WebGLUtils2;
      exports.WireframeGeometry = WireframeGeometry;
      exports.WireframeHelper = WireframeHelper;
      exports.WrapAroundEnding = WrapAroundEnding2;
      exports.XHRLoader = XHRLoader;
      exports.ZeroCurvatureEnding = ZeroCurvatureEnding2;
      exports.ZeroFactor = ZeroFactor2;
      exports.ZeroSlopeEnding = ZeroSlopeEnding2;
      exports.ZeroStencilOp = ZeroStencilOp;
      exports._SRGBAFormat = _SRGBAFormat2;
      exports.sRGBEncoding = sRGBEncoding2;
    }
  });

  // node_modules/@jocabola/math/lib/CachedCurve.js
  var require_CachedCurve = __commonJS({
    "node_modules/@jocabola/math/lib/CachedCurve.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CachedCurve = void 0;
      var three_1 = require_three();
      var MathUtils_1 = __importDefault(require_MathUtils());
      var TMP2 = new three_1.Vector3();
      var CachedCurve = class {
        constructor(curve, nPoints = 100) {
          this.points = curve.getPoints(nPoints);
          this.curve = curve;
          this.nPoints = this.points.length;
        }
        getPoint(t, target = null) {
          const T = t * (this.nPoints - 1);
          const k1 = ~~T;
          const k2 = k1 != T ? Math.min(this.nPoints - 1, Math.ceil(T)) : k1;
          if (k1 === k2)
            return this.points[k1];
          const fract = MathUtils_1.default.fract(T);
          if (target != null)
            return target.copy(this.points[k1]).lerp(this.points[k2], fract);
          return TMP2.copy(this.points[k1]).lerp(this.points[k2], fract);
        }
      };
      exports.CachedCurve = CachedCurve;
    }
  });

  // node_modules/@jocabola/math/lib/main.js
  var require_main = __commonJS({
    "node_modules/@jocabola/math/lib/main.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
            __createBinding(exports2, m, p2);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Vec = exports.MathUtils = exports.Random = void 0;
      var Random_1 = __importDefault(require_Random());
      exports.Random = Random_1.default;
      var MathUtils_1 = __importDefault(require_MathUtils());
      exports.MathUtils = MathUtils_1.default;
      var Vector_1 = __importDefault(require_Vector());
      exports.Vec = Vector_1.default;
      __exportStar(require_CachedCurve(), exports);
    }
  });

  // node_modules/@jocabola/gfx/lib/sim/LEDScreenTile.js
  var import_math, SCREEN_MAT, SCREEN_MAT_2, BASE_MAT, BASE_GEO, tmp2;
  var init_LEDScreenTile = __esm({
    "node_modules/@jocabola/gfx/lib/sim/LEDScreenTile.js"() {
      import_math = __toESM(require_main());
      init_three_module();
      SCREEN_MAT = new MeshBasicMaterial({
        map: new Texture(),
        color: 16777215
      });
      SCREEN_MAT.onBeforeCompile = (shader) => {
        shader.vertexShader = shader.vertexShader.replace("#include <uv2_pars_vertex>", `#include <uv2_pars_vertex>
        attribute vec2 cuv;
        varying vec2 vCUv;`);
        shader.vertexShader = shader.vertexShader.replace("#include <fog_vertex>", `vCUv = cuv;`);
        shader.fragmentShader = shader.fragmentShader.replace("#include <clipping_planes_pars_fragment>", `#include <clipping_planes_pars_fragment>
        varying vec2 vCUv;`);
        shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `diffuseColor.rgb = texture2D(map, vCUv).rgb;`);
      };
      SCREEN_MAT_2 = new MeshBasicMaterial({
        map: SCREEN_MAT.map,
        color: 16777215,
        opacity: 1,
        transparent: true
      });
      BASE_MAT = new MeshStandardMaterial({
        color: 3355443,
        roughness: 0.6,
        metalness: 0.4
      });
      BASE_GEO = new BoxGeometry(1, 1, 1);
      tmp2 = new Vector3();
    }
  });

  // node_modules/@jocabola/gfx/lib/main.js
  var init_main2 = __esm({
    "node_modules/@jocabola/gfx/lib/main.js"() {
      init_glInfo();
      init_FboHelper();
      init_FboUtils();
      init_RenderComposer();
      init_RenderPass();
      init_BlurPass();
      init_DoFPass();
      init_FXAAPass();
      init_Sketch();
      init_WebGLSketch();
      init_SceneUtils();
      init_GfxUtils();
      init_Simulator();
      init_LEDScreenTile();
    }
  });

  // node_modules/tweakpane/dist/tweakpane.js
  var require_tweakpane = __commonJS({
    "node_modules/tweakpane/dist/tweakpane.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.Tweakpane = {}));
      })(exports, function(exports2) {
        "use strict";
        class Semver {
          constructor(text) {
            const [core, prerelease] = text.split("-");
            const coreComps = core.split(".");
            this.major = parseInt(coreComps[0], 10);
            this.minor = parseInt(coreComps[1], 10);
            this.patch = parseInt(coreComps[2], 10);
            this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
          }
          toString() {
            const core = [this.major, this.minor, this.patch].join(".");
            return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
          }
        }
        class BladeApi {
          constructor(controller) {
            this.controller_ = controller;
          }
          get disabled() {
            return this.controller_.viewProps.get("disabled");
          }
          set disabled(disabled) {
            this.controller_.viewProps.set("disabled", disabled);
          }
          get hidden() {
            return this.controller_.viewProps.get("hidden");
          }
          set hidden(hidden) {
            this.controller_.viewProps.set("hidden", hidden);
          }
          dispose() {
            this.controller_.viewProps.set("disposed", true);
          }
        }
        class TpEvent {
          constructor(target) {
            this.target = target;
          }
        }
        class TpChangeEvent extends TpEvent {
          constructor(target, value, presetKey, last) {
            super(target);
            this.value = value;
            this.presetKey = presetKey;
            this.last = last !== null && last !== void 0 ? last : true;
          }
        }
        class TpUpdateEvent extends TpEvent {
          constructor(target, value, presetKey) {
            super(target);
            this.value = value;
            this.presetKey = presetKey;
          }
        }
        class TpFoldEvent extends TpEvent {
          constructor(target, expanded) {
            super(target);
            this.expanded = expanded;
          }
        }
        function forceCast(v) {
          return v;
        }
        function isEmpty(value) {
          return value === null || value === void 0;
        }
        function deepEqualsArray(a1, a2) {
          if (a1.length !== a2.length) {
            return false;
          }
          for (let i2 = 0; i2 < a1.length; i2++) {
            if (a1[i2] !== a2[i2]) {
              return false;
            }
          }
          return true;
        }
        const CREATE_MESSAGE_MAP = {
          alreadydisposed: () => "View has been already disposed",
          invalidparams: (context) => `Invalid parameters for '${context.name}'`,
          nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,
          nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,
          notbindable: () => `Value is not bindable`,
          propertynotfound: (context) => `Property '${context.name}' not found`,
          shouldneverhappen: () => "This error should never happen"
        };
        class TpError {
          constructor(config3) {
            var _a;
            this.message = (_a = CREATE_MESSAGE_MAP[config3.type](forceCast(config3.context))) !== null && _a !== void 0 ? _a : "Unexpected error";
            this.name = this.constructor.name;
            this.stack = new Error(this.message).stack;
            this.type = config3.type;
          }
          static alreadyDisposed() {
            return new TpError({ type: "alreadydisposed" });
          }
          static notBindable() {
            return new TpError({
              type: "notbindable"
            });
          }
          static propertyNotFound(name) {
            return new TpError({
              type: "propertynotfound",
              context: {
                name
              }
            });
          }
          static shouldNeverHappen() {
            return new TpError({ type: "shouldneverhappen" });
          }
        }
        class BindingTarget {
          constructor(obj, key, opt_id) {
            this.obj_ = obj;
            this.key_ = key;
            this.presetKey_ = opt_id !== null && opt_id !== void 0 ? opt_id : key;
          }
          static isBindable(obj) {
            if (obj === null) {
              return false;
            }
            if (typeof obj !== "object") {
              return false;
            }
            return true;
          }
          get key() {
            return this.key_;
          }
          get presetKey() {
            return this.presetKey_;
          }
          read() {
            return this.obj_[this.key_];
          }
          write(value) {
            this.obj_[this.key_] = value;
          }
          writeProperty(name, value) {
            const valueObj = this.read();
            if (!BindingTarget.isBindable(valueObj)) {
              throw TpError.notBindable();
            }
            if (!(name in valueObj)) {
              throw TpError.propertyNotFound(name);
            }
            valueObj[name] = value;
          }
        }
        class ButtonApi extends BladeApi {
          get label() {
            return this.controller_.props.get("label");
          }
          set label(label) {
            this.controller_.props.set("label", label);
          }
          get title() {
            var _a;
            return (_a = this.controller_.valueController.props.get("title")) !== null && _a !== void 0 ? _a : "";
          }
          set title(title) {
            this.controller_.valueController.props.set("title", title);
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            const emitter = this.controller_.valueController.emitter;
            emitter.on(eventName, () => {
              bh(new TpEvent(this));
            });
            return this;
          }
        }
        class Emitter2 {
          constructor() {
            this.observers_ = {};
          }
          on(eventName, handler) {
            let observers = this.observers_[eventName];
            if (!observers) {
              observers = this.observers_[eventName] = [];
            }
            observers.push({
              handler
            });
            return this;
          }
          off(eventName, handler) {
            const observers = this.observers_[eventName];
            if (observers) {
              this.observers_[eventName] = observers.filter((observer) => {
                return observer.handler !== handler;
              });
            }
            return this;
          }
          emit(eventName, event) {
            const observers = this.observers_[eventName];
            if (!observers) {
              return;
            }
            observers.forEach((observer) => {
              observer.handler(event);
            });
          }
        }
        const PREFIX = "tp";
        function ClassName(viewName) {
          const fn = (opt_elementName, opt_modifier) => {
            return [
              PREFIX,
              "-",
              viewName,
              "v",
              opt_elementName ? `_${opt_elementName}` : "",
              opt_modifier ? `-${opt_modifier}` : ""
            ].join("");
          };
          return fn;
        }
        function compose(h1, h2) {
          return (input) => h2(h1(input));
        }
        function extractValue(ev) {
          return ev.rawValue;
        }
        function bindValue(value, applyValue) {
          value.emitter.on("change", compose(extractValue, applyValue));
          applyValue(value.rawValue);
        }
        function bindValueMap(valueMap, key, applyValue) {
          bindValue(valueMap.value(key), applyValue);
        }
        function applyClass(elem, className2, active) {
          if (active) {
            elem.classList.add(className2);
          } else {
            elem.classList.remove(className2);
          }
        }
        function valueToClassName(elem, className2) {
          return (value) => {
            applyClass(elem, className2, value);
          };
        }
        function bindValueToTextContent(value, elem) {
          bindValue(value, (text) => {
            elem.textContent = text !== null && text !== void 0 ? text : "";
          });
        }
        const className$q = ClassName("btn");
        class ButtonView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$q());
            config3.viewProps.bindClassModifiers(this.element);
            const buttonElem = doc.createElement("button");
            buttonElem.classList.add(className$q("b"));
            config3.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement("div");
            titleElem.classList.add(className$q("t"));
            bindValueToTextContent(config3.props.value("title"), titleElem);
            this.buttonElement.appendChild(titleElem);
          }
        }
        class ButtonController {
          constructor(doc, config3) {
            this.emitter = new Emitter2();
            this.onClick_ = this.onClick_.bind(this);
            this.props = config3.props;
            this.viewProps = config3.viewProps;
            this.view = new ButtonView(doc, {
              props: this.props,
              viewProps: this.viewProps
            });
            this.view.buttonElement.addEventListener("click", this.onClick_);
          }
          onClick_() {
            this.emitter.emit("click", {
              sender: this
            });
          }
        }
        class BoundValue {
          constructor(initialValue, config3) {
            var _a;
            this.constraint_ = config3 === null || config3 === void 0 ? void 0 : config3.constraint;
            this.equals_ = (_a = config3 === null || config3 === void 0 ? void 0 : config3.equals) !== null && _a !== void 0 ? _a : (v1, v2) => v1 === v2;
            this.emitter = new Emitter2();
            this.rawValue_ = initialValue;
          }
          get constraint() {
            return this.constraint_;
          }
          get rawValue() {
            return this.rawValue_;
          }
          set rawValue(rawValue) {
            this.setRawValue(rawValue, {
              forceEmit: false,
              last: true
            });
          }
          setRawValue(rawValue, options) {
            const opts = options !== null && options !== void 0 ? options : {
              forceEmit: false,
              last: true
            };
            const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
            const changed = !this.equals_(this.rawValue_, constrainedValue);
            if (!changed && !opts.forceEmit) {
              return;
            }
            this.emitter.emit("beforechange", {
              sender: this
            });
            this.rawValue_ = constrainedValue;
            this.emitter.emit("change", {
              options: opts,
              rawValue: constrainedValue,
              sender: this
            });
          }
        }
        class PrimitiveValue {
          constructor(initialValue) {
            this.emitter = new Emitter2();
            this.value_ = initialValue;
          }
          get rawValue() {
            return this.value_;
          }
          set rawValue(value) {
            this.setRawValue(value, {
              forceEmit: false,
              last: true
            });
          }
          setRawValue(value, options) {
            const opts = options !== null && options !== void 0 ? options : {
              forceEmit: false,
              last: true
            };
            if (this.value_ === value && !opts.forceEmit) {
              return;
            }
            this.emitter.emit("beforechange", {
              sender: this
            });
            this.value_ = value;
            this.emitter.emit("change", {
              options: opts,
              rawValue: this.value_,
              sender: this
            });
          }
        }
        function createValue(initialValue, config3) {
          const constraint = config3 === null || config3 === void 0 ? void 0 : config3.constraint;
          const equals2 = config3 === null || config3 === void 0 ? void 0 : config3.equals;
          if (!constraint && !equals2) {
            return new PrimitiveValue(initialValue);
          }
          return new BoundValue(initialValue, config3);
        }
        class ValueMap {
          constructor(valueMap) {
            this.emitter = new Emitter2();
            this.valMap_ = valueMap;
            for (const key in this.valMap_) {
              const v = this.valMap_[key];
              v.emitter.on("change", () => {
                this.emitter.emit("change", {
                  key,
                  sender: this
                });
              });
            }
          }
          static createCore(initialValue) {
            const keys = Object.keys(initialValue);
            return keys.reduce((o, key) => {
              return Object.assign(o, {
                [key]: createValue(initialValue[key])
              });
            }, {});
          }
          static fromObject(initialValue) {
            const core = this.createCore(initialValue);
            return new ValueMap(core);
          }
          get(key) {
            return this.valMap_[key].rawValue;
          }
          set(key, value) {
            this.valMap_[key].rawValue = value;
          }
          value(key) {
            return this.valMap_[key];
          }
        }
        function parseObject(value, keyToParserMap) {
          const keys = Object.keys(keyToParserMap);
          const result = keys.reduce((tmp3, key) => {
            if (tmp3 === void 0) {
              return void 0;
            }
            const parser = keyToParserMap[key];
            const result2 = parser(value[key]);
            return result2.succeeded ? Object.assign(Object.assign({}, tmp3), { [key]: result2.value }) : void 0;
          }, {});
          return forceCast(result);
        }
        function parseArray(value, parseItem) {
          return value.reduce((tmp3, item) => {
            if (tmp3 === void 0) {
              return void 0;
            }
            const result = parseItem(item);
            if (!result.succeeded || result.value === void 0) {
              return void 0;
            }
            return [...tmp3, result.value];
          }, []);
        }
        function isObject(value) {
          if (value === null) {
            return false;
          }
          return typeof value === "object";
        }
        function createParamsParserBuilder(parse) {
          return (optional) => (v) => {
            if (!optional && v === void 0) {
              return {
                succeeded: false,
                value: void 0
              };
            }
            if (optional && v === void 0) {
              return {
                succeeded: true,
                value: void 0
              };
            }
            const result = parse(v);
            return result !== void 0 ? {
              succeeded: true,
              value: result
            } : {
              succeeded: false,
              value: void 0
            };
          };
        }
        function createParamsParserBuilders(optional) {
          return {
            custom: (parse) => createParamsParserBuilder(parse)(optional),
            boolean: createParamsParserBuilder((v) => typeof v === "boolean" ? v : void 0)(optional),
            number: createParamsParserBuilder((v) => typeof v === "number" ? v : void 0)(optional),
            string: createParamsParserBuilder((v) => typeof v === "string" ? v : void 0)(optional),
            function: createParamsParserBuilder((v) => typeof v === "function" ? v : void 0)(optional),
            constant: (value) => createParamsParserBuilder((v) => v === value ? value : void 0)(optional),
            raw: createParamsParserBuilder((v) => v)(optional),
            object: (keyToParserMap) => createParamsParserBuilder((v) => {
              if (!isObject(v)) {
                return void 0;
              }
              return parseObject(v, keyToParserMap);
            })(optional),
            array: (itemParser) => createParamsParserBuilder((v) => {
              if (!Array.isArray(v)) {
                return void 0;
              }
              return parseArray(v, itemParser);
            })(optional)
          };
        }
        const ParamsParsers = {
          optional: createParamsParserBuilders(true),
          required: createParamsParserBuilders(false)
        };
        function parseParams(value, keyToParserMap) {
          const result = ParamsParsers.required.object(keyToParserMap)(value);
          return result.succeeded ? result.value : void 0;
        }
        function disposeElement(elem) {
          if (elem && elem.parentElement) {
            elem.parentElement.removeChild(elem);
          }
          return null;
        }
        function getAllBladePositions() {
          return ["veryfirst", "first", "last", "verylast"];
        }
        const className$p = ClassName("");
        const POS_TO_CLASS_NAME_MAP = {
          veryfirst: "vfst",
          first: "fst",
          last: "lst",
          verylast: "vlst"
        };
        class BladeController {
          constructor(config3) {
            this.parent_ = null;
            this.blade = config3.blade;
            this.view = config3.view;
            this.viewProps = config3.viewProps;
            const elem = this.view.element;
            this.blade.value("positions").emitter.on("change", () => {
              getAllBladePositions().forEach((pos) => {
                elem.classList.remove(className$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
              });
              this.blade.get("positions").forEach((pos) => {
                elem.classList.add(className$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
              });
            });
            this.viewProps.handleDispose(() => {
              disposeElement(elem);
            });
          }
          get parent() {
            return this.parent_;
          }
        }
        const SVG_NS = "http://www.w3.org/2000/svg";
        function forceReflow(element) {
          element.offsetHeight;
        }
        function disableTransitionTemporarily(element, callback) {
          const t = element.style.transition;
          element.style.transition = "none";
          callback();
          element.style.transition = t;
        }
        function supportsTouch(doc) {
          return doc.ontouchstart !== void 0;
        }
        function getGlobalObject() {
          return new Function("return this")();
        }
        function getWindowDocument() {
          const globalObj = forceCast(getGlobalObject());
          return globalObj.document;
        }
        function getCanvasContext(canvasElement) {
          const win = canvasElement.ownerDocument.defaultView;
          if (!win) {
            return null;
          }
          const isBrowser = "document" in win;
          return isBrowser ? canvasElement.getContext("2d") : null;
        }
        const ICON_ID_TO_INNER_HTML_MAP = {
          check: '<path d="M2 8l4 4l8 -8"/>',
          dropdown: '<path d="M5 7h6l-3 3 z"/>',
          p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
        };
        function createSvgIconElement(document2, iconId) {
          const elem = document2.createElementNS(SVG_NS, "svg");
          elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
          return elem;
        }
        function insertElementAt(parentElement, element, index) {
          parentElement.insertBefore(element, parentElement.children[index]);
        }
        function removeElement(element) {
          if (element.parentElement) {
            element.parentElement.removeChild(element);
          }
        }
        function removeChildElements(element) {
          while (element.children.length > 0) {
            element.removeChild(element.children[0]);
          }
        }
        function removeChildNodes(element) {
          while (element.childNodes.length > 0) {
            element.removeChild(element.childNodes[0]);
          }
        }
        function findNextTarget(ev) {
          if (ev.relatedTarget) {
            return forceCast(ev.relatedTarget);
          }
          if ("explicitOriginalTarget" in ev) {
            return ev.explicitOriginalTarget;
          }
          return null;
        }
        const className$o = ClassName("lbl");
        function createLabelNode(doc, label) {
          const frag = doc.createDocumentFragment();
          const lineNodes = label.split("\n").map((line) => {
            return doc.createTextNode(line);
          });
          lineNodes.forEach((lineNode, index) => {
            if (index > 0) {
              frag.appendChild(doc.createElement("br"));
            }
            frag.appendChild(lineNode);
          });
          return frag;
        }
        class LabelView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$o());
            config3.viewProps.bindClassModifiers(this.element);
            const labelElem = doc.createElement("div");
            labelElem.classList.add(className$o("l"));
            bindValueMap(config3.props, "label", (value) => {
              if (isEmpty(value)) {
                this.element.classList.add(className$o(void 0, "nol"));
              } else {
                this.element.classList.remove(className$o(void 0, "nol"));
                removeChildNodes(labelElem);
                labelElem.appendChild(createLabelNode(doc, value));
              }
            });
            this.element.appendChild(labelElem);
            this.labelElement = labelElem;
            const valueElem = doc.createElement("div");
            valueElem.classList.add(className$o("v"));
            this.element.appendChild(valueElem);
            this.valueElement = valueElem;
          }
        }
        class LabelController extends BladeController {
          constructor(doc, config3) {
            const viewProps = config3.valueController.viewProps;
            super(Object.assign(Object.assign({}, config3), { view: new LabelView(doc, {
              props: config3.props,
              viewProps
            }), viewProps }));
            this.props = config3.props;
            this.valueController = config3.valueController;
            this.view.valueElement.appendChild(this.valueController.view.element);
          }
        }
        const ButtonBladePlugin = {
          id: "button",
          type: "blade",
          accept(params) {
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              title: p2.required.string,
              view: p2.required.constant("button"),
              label: p2.optional.string
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            return new LabelController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: new ButtonController(args.document, {
                props: ValueMap.fromObject({
                  title: args.params.title
                }),
                viewProps: args.viewProps
              })
            });
          },
          api(args) {
            if (!(args.controller instanceof LabelController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof ButtonController)) {
              return null;
            }
            return new ButtonApi(args.controller);
          }
        };
        class ValueBladeController extends BladeController {
          constructor(config3) {
            super(config3);
            this.value = config3.value;
          }
        }
        function createBlade() {
          return new ValueMap({
            positions: createValue([], {
              equals: deepEqualsArray
            })
          });
        }
        class Foldable extends ValueMap {
          constructor(valueMap) {
            super(valueMap);
          }
          static create(expanded) {
            const coreObj = {
              completed: true,
              expanded,
              expandedHeight: null,
              shouldFixHeight: false,
              temporaryExpanded: null
            };
            const core = ValueMap.createCore(coreObj);
            return new Foldable(core);
          }
          get styleExpanded() {
            var _a;
            return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0 ? _a : this.get("expanded");
          }
          get styleHeight() {
            if (!this.styleExpanded) {
              return "0";
            }
            const exHeight = this.get("expandedHeight");
            if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
              return `${exHeight}px`;
            }
            return "auto";
          }
          bindExpandedClass(elem, expandedClassName) {
            bindValueMap(this, "expanded", () => {
              const expanded = this.styleExpanded;
              if (expanded) {
                elem.classList.add(expandedClassName);
              } else {
                elem.classList.remove(expandedClassName);
              }
            });
          }
        }
        function computeExpandedFolderHeight(folder, containerElement) {
          let height = 0;
          disableTransitionTemporarily(containerElement, () => {
            folder.set("expandedHeight", null);
            folder.set("temporaryExpanded", true);
            forceReflow(containerElement);
            height = containerElement.clientHeight;
            folder.set("temporaryExpanded", null);
            forceReflow(containerElement);
          });
          return height;
        }
        function applyHeight(foldable, elem) {
          elem.style.height = foldable.styleHeight;
        }
        function bindFoldable(foldable, elem) {
          foldable.value("expanded").emitter.on("beforechange", () => {
            foldable.set("completed", false);
            if (isEmpty(foldable.get("expandedHeight"))) {
              foldable.set("expandedHeight", computeExpandedFolderHeight(foldable, elem));
            }
            foldable.set("shouldFixHeight", true);
            forceReflow(elem);
          });
          foldable.emitter.on("change", () => {
            applyHeight(foldable, elem);
          });
          applyHeight(foldable, elem);
          elem.addEventListener("transitionend", (ev) => {
            if (ev.propertyName !== "height") {
              return;
            }
            foldable.set("shouldFixHeight", false);
            foldable.set("expandedHeight", null);
            foldable.set("completed", true);
          });
        }
        class RackLikeApi extends BladeApi {
          constructor(controller, rackApi) {
            super(controller);
            this.rackApi_ = rackApi;
          }
        }
        function addButtonAsBlade(api, params) {
          return api.addBlade(Object.assign(Object.assign({}, params), { view: "button" }));
        }
        function addFolderAsBlade(api, params) {
          return api.addBlade(Object.assign(Object.assign({}, params), { view: "folder" }));
        }
        function addSeparatorAsBlade(api, opt_params) {
          const params = opt_params || {};
          return api.addBlade(Object.assign(Object.assign({}, params), { view: "separator" }));
        }
        function addTabAsBlade(api, params) {
          return api.addBlade(Object.assign(Object.assign({}, params), { view: "tab" }));
        }
        class NestedOrderedSet {
          constructor(extract) {
            this.emitter = new Emitter2();
            this.items_ = [];
            this.cache_ = /* @__PURE__ */ new Set();
            this.onSubListAdd_ = this.onSubListAdd_.bind(this);
            this.onSubListRemove_ = this.onSubListRemove_.bind(this);
            this.extract_ = extract;
          }
          get items() {
            return this.items_;
          }
          allItems() {
            return Array.from(this.cache_);
          }
          find(callback) {
            for (const item of this.allItems()) {
              if (callback(item)) {
                return item;
              }
            }
            return null;
          }
          includes(item) {
            return this.cache_.has(item);
          }
          add(item, opt_index) {
            if (this.includes(item)) {
              throw TpError.shouldNeverHappen();
            }
            const index = opt_index !== void 0 ? opt_index : this.items_.length;
            this.items_.splice(index, 0, item);
            this.cache_.add(item);
            const subList = this.extract_(item);
            if (subList) {
              subList.emitter.on("add", this.onSubListAdd_);
              subList.emitter.on("remove", this.onSubListRemove_);
              subList.allItems().forEach((item2) => {
                this.cache_.add(item2);
              });
            }
            this.emitter.emit("add", {
              index,
              item,
              root: this,
              target: this
            });
          }
          remove(item) {
            const index = this.items_.indexOf(item);
            if (index < 0) {
              return;
            }
            this.items_.splice(index, 1);
            this.cache_.delete(item);
            const subList = this.extract_(item);
            if (subList) {
              subList.emitter.off("add", this.onSubListAdd_);
              subList.emitter.off("remove", this.onSubListRemove_);
            }
            this.emitter.emit("remove", {
              index,
              item,
              root: this,
              target: this
            });
          }
          onSubListAdd_(ev) {
            this.cache_.add(ev.item);
            this.emitter.emit("add", {
              index: ev.index,
              item: ev.item,
              root: this,
              target: ev.target
            });
          }
          onSubListRemove_(ev) {
            this.cache_.delete(ev.item);
            this.emitter.emit("remove", {
              index: ev.index,
              item: ev.item,
              root: this,
              target: ev.target
            });
          }
        }
        class InputBindingApi extends BladeApi {
          constructor(controller) {
            super(controller);
            this.onBindingChange_ = this.onBindingChange_.bind(this);
            this.emitter_ = new Emitter2();
            this.controller_.binding.emitter.on("change", this.onBindingChange_);
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(label) {
            this.controller_.props.set("label", label);
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
          refresh() {
            this.controller_.binding.read();
          }
          onBindingChange_(ev) {
            const value = ev.sender.target.read();
            this.emitter_.emit("change", {
              event: new TpChangeEvent(this, forceCast(value), this.controller_.binding.target.presetKey, ev.options.last)
            });
          }
        }
        class InputBindingController extends LabelController {
          constructor(doc, config3) {
            super(doc, config3);
            this.binding = config3.binding;
          }
        }
        class MonitorBindingApi extends BladeApi {
          constructor(controller) {
            super(controller);
            this.onBindingUpdate_ = this.onBindingUpdate_.bind(this);
            this.emitter_ = new Emitter2();
            this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(label) {
            this.controller_.props.set("label", label);
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
          refresh() {
            this.controller_.binding.read();
          }
          onBindingUpdate_(ev) {
            const value = ev.sender.target.read();
            this.emitter_.emit("update", {
              event: new TpUpdateEvent(this, forceCast(value), this.controller_.binding.target.presetKey)
            });
          }
        }
        class MonitorBindingController extends LabelController {
          constructor(doc, config3) {
            super(doc, config3);
            this.binding = config3.binding;
            this.viewProps.bindDisabled(this.binding.ticker);
            this.viewProps.handleDispose(() => {
              this.binding.dispose();
            });
          }
        }
        function findSubBladeApiSet(api) {
          if (api instanceof RackApi) {
            return api["apiSet_"];
          }
          if (api instanceof RackLikeApi) {
            return api["rackApi_"]["apiSet_"];
          }
          return null;
        }
        function getApiByController(apiSet, controller) {
          const api = apiSet.find((api2) => api2.controller_ === controller);
          if (!api) {
            throw TpError.shouldNeverHappen();
          }
          return api;
        }
        function createBindingTarget(obj, key, opt_id) {
          if (!BindingTarget.isBindable(obj)) {
            throw TpError.notBindable();
          }
          return new BindingTarget(obj, key, opt_id);
        }
        class RackApi extends BladeApi {
          constructor(controller, pool) {
            super(controller);
            this.onRackAdd_ = this.onRackAdd_.bind(this);
            this.onRackRemove_ = this.onRackRemove_.bind(this);
            this.onRackInputChange_ = this.onRackInputChange_.bind(this);
            this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this);
            this.emitter_ = new Emitter2();
            this.apiSet_ = new NestedOrderedSet(findSubBladeApiSet);
            this.pool_ = pool;
            const rack = this.controller_.rack;
            rack.emitter.on("add", this.onRackAdd_);
            rack.emitter.on("remove", this.onRackRemove_);
            rack.emitter.on("inputchange", this.onRackInputChange_);
            rack.emitter.on("monitorupdate", this.onRackMonitorUpdate_);
            rack.children.forEach((bc) => {
              this.setUpApi_(bc);
            });
          }
          get children() {
            return this.controller_.rack.children.map((bc) => getApiByController(this.apiSet_, bc));
          }
          addInput(object, key, opt_params) {
            const params = opt_params || {};
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createInput(doc, createBindingTarget(object, key, params.presetKey), params);
            const api = new InputBindingApi(bc);
            return this.add(api, params.index);
          }
          addMonitor(object, key, opt_params) {
            const params = opt_params || {};
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createMonitor(doc, createBindingTarget(object, key), params);
            const api = new MonitorBindingApi(bc);
            return forceCast(this.add(api, params.index));
          }
          addFolder(params) {
            return addFolderAsBlade(this, params);
          }
          addButton(params) {
            return addButtonAsBlade(this, params);
          }
          addSeparator(opt_params) {
            return addSeparatorAsBlade(this, opt_params);
          }
          addTab(params) {
            return addTabAsBlade(this, params);
          }
          add(api, opt_index) {
            this.controller_.rack.add(api.controller_, opt_index);
            const gapi = this.apiSet_.find((a) => a.controller_ === api.controller_);
            if (gapi) {
              this.apiSet_.remove(gapi);
            }
            this.apiSet_.add(api);
            return api;
          }
          remove(api) {
            this.controller_.rack.remove(api.controller_);
          }
          addBlade(params) {
            const doc = this.controller_.view.element.ownerDocument;
            const bc = this.pool_.createBlade(doc, params);
            const api = this.pool_.createBladeApi(bc);
            return this.add(api, params.index);
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
          setUpApi_(bc) {
            const api = this.apiSet_.find((api2) => api2.controller_ === bc);
            if (!api) {
              this.apiSet_.add(this.pool_.createBladeApi(bc));
            }
          }
          onRackAdd_(ev) {
            this.setUpApi_(ev.bladeController);
          }
          onRackRemove_(ev) {
            if (ev.isRoot) {
              const api = getApiByController(this.apiSet_, ev.bladeController);
              this.apiSet_.remove(api);
            }
          }
          onRackInputChange_(ev) {
            const bc = ev.bladeController;
            if (bc instanceof InputBindingController) {
              const api = getApiByController(this.apiSet_, bc);
              const binding = bc.binding;
              this.emitter_.emit("change", {
                event: new TpChangeEvent(api, forceCast(binding.target.read()), binding.target.presetKey, ev.options.last)
              });
            } else if (bc instanceof ValueBladeController) {
              const api = getApiByController(this.apiSet_, bc);
              this.emitter_.emit("change", {
                event: new TpChangeEvent(api, bc.value.rawValue, void 0, ev.options.last)
              });
            }
          }
          onRackMonitorUpdate_(ev) {
            if (!(ev.bladeController instanceof MonitorBindingController)) {
              throw TpError.shouldNeverHappen();
            }
            const api = getApiByController(this.apiSet_, ev.bladeController);
            const binding = ev.bladeController.binding;
            this.emitter_.emit("update", {
              event: new TpUpdateEvent(api, forceCast(binding.target.read()), binding.target.presetKey)
            });
          }
        }
        class FolderApi extends RackLikeApi {
          constructor(controller, pool) {
            super(controller, new RackApi(controller.rackController, pool));
            this.emitter_ = new Emitter2();
            this.controller_.foldable.value("expanded").emitter.on("change", (ev) => {
              this.emitter_.emit("fold", {
                event: new TpFoldEvent(this, ev.sender.rawValue)
              });
            });
            this.rackApi_.on("change", (ev) => {
              this.emitter_.emit("change", {
                event: ev
              });
            });
            this.rackApi_.on("update", (ev) => {
              this.emitter_.emit("update", {
                event: ev
              });
            });
          }
          get expanded() {
            return this.controller_.foldable.get("expanded");
          }
          set expanded(expanded) {
            this.controller_.foldable.set("expanded", expanded);
          }
          get title() {
            return this.controller_.props.get("title");
          }
          set title(title) {
            this.controller_.props.set("title", title);
          }
          get children() {
            return this.rackApi_.children;
          }
          addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
          }
          addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
          }
          addFolder(params) {
            return this.rackApi_.addFolder(params);
          }
          addButton(params) {
            return this.rackApi_.addButton(params);
          }
          addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
          }
          addTab(params) {
            return this.rackApi_.addTab(params);
          }
          add(api, opt_index) {
            return this.rackApi_.add(api, opt_index);
          }
          remove(api) {
            this.rackApi_.remove(api);
          }
          addBlade(params) {
            return this.rackApi_.addBlade(params);
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
        }
        class RackLikeController extends BladeController {
          constructor(config3) {
            super({
              blade: config3.blade,
              view: config3.view,
              viewProps: config3.rackController.viewProps
            });
            this.rackController = config3.rackController;
          }
        }
        class PlainView {
          constructor(doc, config3) {
            const className2 = ClassName(config3.viewName);
            this.element = doc.createElement("div");
            this.element.classList.add(className2());
            config3.viewProps.bindClassModifiers(this.element);
          }
        }
        function findInputBindingController(bcs, b) {
          for (let i2 = 0; i2 < bcs.length; i2++) {
            const bc = bcs[i2];
            if (bc instanceof InputBindingController && bc.binding === b) {
              return bc;
            }
          }
          return null;
        }
        function findMonitorBindingController(bcs, b) {
          for (let i2 = 0; i2 < bcs.length; i2++) {
            const bc = bcs[i2];
            if (bc instanceof MonitorBindingController && bc.binding === b) {
              return bc;
            }
          }
          return null;
        }
        function findValueBladeController(bcs, v) {
          for (let i2 = 0; i2 < bcs.length; i2++) {
            const bc = bcs[i2];
            if (bc instanceof ValueBladeController && bc.value === v) {
              return bc;
            }
          }
          return null;
        }
        function findSubRack(bc) {
          if (bc instanceof RackController) {
            return bc.rack;
          }
          if (bc instanceof RackLikeController) {
            return bc.rackController.rack;
          }
          return null;
        }
        function findSubBladeControllerSet(bc) {
          const rack = findSubRack(bc);
          return rack ? rack["bcSet_"] : null;
        }
        class BladeRack {
          constructor(blade) {
            var _a;
            this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
            this.onSetAdd_ = this.onSetAdd_.bind(this);
            this.onSetRemove_ = this.onSetRemove_.bind(this);
            this.onChildDispose_ = this.onChildDispose_.bind(this);
            this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
            this.onChildInputChange_ = this.onChildInputChange_.bind(this);
            this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this);
            this.onChildValueChange_ = this.onChildValueChange_.bind(this);
            this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
            this.onDescendantLayout_ = this.onDescendantLayout_.bind(this);
            this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this);
            this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this);
            this.emitter = new Emitter2();
            this.blade_ = blade !== null && blade !== void 0 ? blade : null;
            (_a = this.blade_) === null || _a === void 0 ? void 0 : _a.value("positions").emitter.on("change", this.onBladePositionsChange_);
            this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
            this.bcSet_.emitter.on("add", this.onSetAdd_);
            this.bcSet_.emitter.on("remove", this.onSetRemove_);
          }
          get children() {
            return this.bcSet_.items;
          }
          add(bc, opt_index) {
            if (bc.parent) {
              bc.parent.remove(bc);
            }
            bc["parent_"] = this;
            this.bcSet_.add(bc, opt_index);
          }
          remove(bc) {
            bc["parent_"] = null;
            this.bcSet_.remove(bc);
          }
          find(controllerClass) {
            return forceCast(this.bcSet_.allItems().filter((bc) => {
              return bc instanceof controllerClass;
            }));
          }
          onSetAdd_(ev) {
            this.updatePositions_();
            const isRoot = ev.target === ev.root;
            this.emitter.emit("add", {
              bladeController: ev.item,
              index: ev.index,
              isRoot,
              sender: this
            });
            if (!isRoot) {
              return;
            }
            const bc = ev.item;
            bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
            bc.blade.value("positions").emitter.on("change", this.onChildPositionsChange_);
            bc.viewProps.handleDispose(this.onChildDispose_);
            if (bc instanceof InputBindingController) {
              bc.binding.emitter.on("change", this.onChildInputChange_);
            } else if (bc instanceof MonitorBindingController) {
              bc.binding.emitter.on("update", this.onChildMonitorUpdate_);
            } else if (bc instanceof ValueBladeController) {
              bc.value.emitter.on("change", this.onChildValueChange_);
            } else {
              const rack = findSubRack(bc);
              if (rack) {
                const emitter = rack.emitter;
                emitter.on("layout", this.onDescendantLayout_);
                emitter.on("inputchange", this.onDescendantInputChange_);
                emitter.on("monitorupdate", this.onDescendantMonitorUpdate_);
              }
            }
          }
          onSetRemove_(ev) {
            this.updatePositions_();
            const isRoot = ev.target === ev.root;
            this.emitter.emit("remove", {
              bladeController: ev.item,
              isRoot,
              sender: this
            });
            if (!isRoot) {
              return;
            }
            const bc = ev.item;
            if (bc instanceof InputBindingController) {
              bc.binding.emitter.off("change", this.onChildInputChange_);
            } else if (bc instanceof MonitorBindingController) {
              bc.binding.emitter.off("update", this.onChildMonitorUpdate_);
            } else if (bc instanceof ValueBladeController) {
              bc.value.emitter.off("change", this.onChildValueChange_);
            } else {
              const rack = findSubRack(bc);
              if (rack) {
                const emitter = rack.emitter;
                emitter.off("layout", this.onDescendantLayout_);
                emitter.off("inputchange", this.onDescendantInputChange_);
                emitter.off("monitorupdate", this.onDescendantMonitorUpdate_);
              }
            }
          }
          updatePositions_() {
            const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get("hidden"));
            const firstVisibleItem = visibleItems[0];
            const lastVisibleItem = visibleItems[visibleItems.length - 1];
            this.bcSet_.items.forEach((bc) => {
              const ps = [];
              if (bc === firstVisibleItem) {
                ps.push("first");
                if (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) {
                  ps.push("veryfirst");
                }
              }
              if (bc === lastVisibleItem) {
                ps.push("last");
                if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
                  ps.push("verylast");
                }
              }
              bc.blade.set("positions", ps);
            });
          }
          onChildPositionsChange_() {
            this.updatePositions_();
            this.emitter.emit("layout", {
              sender: this
            });
          }
          onChildViewPropsChange_(_ev) {
            this.updatePositions_();
            this.emitter.emit("layout", {
              sender: this
            });
          }
          onChildDispose_() {
            const disposedUcs = this.bcSet_.items.filter((bc) => {
              return bc.viewProps.get("disposed");
            });
            disposedUcs.forEach((bc) => {
              this.bcSet_.remove(bc);
            });
          }
          onChildInputChange_(ev) {
            const bc = findInputBindingController(this.find(InputBindingController), ev.sender);
            if (!bc) {
              throw TpError.shouldNeverHappen();
            }
            this.emitter.emit("inputchange", {
              bladeController: bc,
              options: ev.options,
              sender: this
            });
          }
          onChildMonitorUpdate_(ev) {
            const bc = findMonitorBindingController(this.find(MonitorBindingController), ev.sender);
            if (!bc) {
              throw TpError.shouldNeverHappen();
            }
            this.emitter.emit("monitorupdate", {
              bladeController: bc,
              sender: this
            });
          }
          onChildValueChange_(ev) {
            const bc = findValueBladeController(this.find(ValueBladeController), ev.sender);
            if (!bc) {
              throw TpError.shouldNeverHappen();
            }
            this.emitter.emit("inputchange", {
              bladeController: bc,
              options: ev.options,
              sender: this
            });
          }
          onDescendantLayout_(_) {
            this.updatePositions_();
            this.emitter.emit("layout", {
              sender: this
            });
          }
          onDescendantInputChange_(ev) {
            this.emitter.emit("inputchange", {
              bladeController: ev.bladeController,
              options: ev.options,
              sender: this
            });
          }
          onDescendantMonitorUpdate_(ev) {
            this.emitter.emit("monitorupdate", {
              bladeController: ev.bladeController,
              sender: this
            });
          }
          onBladePositionsChange_() {
            this.updatePositions_();
          }
        }
        class RackController extends BladeController {
          constructor(doc, config3) {
            super(Object.assign(Object.assign({}, config3), { view: new PlainView(doc, {
              viewName: "brk",
              viewProps: config3.viewProps
            }) }));
            this.onRackAdd_ = this.onRackAdd_.bind(this);
            this.onRackRemove_ = this.onRackRemove_.bind(this);
            const rack = new BladeRack(config3.root ? void 0 : config3.blade);
            rack.emitter.on("add", this.onRackAdd_);
            rack.emitter.on("remove", this.onRackRemove_);
            this.rack = rack;
            this.viewProps.handleDispose(() => {
              for (let i2 = this.rack.children.length - 1; i2 >= 0; i2--) {
                const bc = this.rack.children[i2];
                bc.viewProps.set("disposed", true);
              }
            });
          }
          onRackAdd_(ev) {
            if (!ev.isRoot) {
              return;
            }
            insertElementAt(this.view.element, ev.bladeController.view.element, ev.index);
          }
          onRackRemove_(ev) {
            if (!ev.isRoot) {
              return;
            }
            removeElement(ev.bladeController.view.element);
          }
        }
        const bladeContainerClassName = ClassName("cnt");
        class FolderView {
          constructor(doc, config3) {
            this.className_ = ClassName(config3.viewName || "fld");
            this.element = doc.createElement("div");
            this.element.classList.add(this.className_(), bladeContainerClassName());
            config3.viewProps.bindClassModifiers(this.element);
            this.foldable_ = config3.foldable;
            this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded"));
            bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
            const buttonElem = doc.createElement("button");
            buttonElem.classList.add(this.className_("b"));
            bindValueMap(config3.props, "title", (title) => {
              if (isEmpty(title)) {
                this.element.classList.add(this.className_(void 0, "not"));
              } else {
                this.element.classList.remove(this.className_(void 0, "not"));
              }
            });
            config3.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement("div");
            titleElem.classList.add(this.className_("t"));
            bindValueToTextContent(config3.props.value("title"), titleElem);
            this.buttonElement.appendChild(titleElem);
            this.titleElement = titleElem;
            const markElem = doc.createElement("div");
            markElem.classList.add(this.className_("m"));
            this.buttonElement.appendChild(markElem);
            const containerElem = config3.containerElement;
            containerElem.classList.add(this.className_("c"));
            this.element.appendChild(containerElem);
            this.containerElement = containerElem;
          }
        }
        class FolderController extends RackLikeController {
          constructor(doc, config3) {
            var _a;
            const foldable = Foldable.create((_a = config3.expanded) !== null && _a !== void 0 ? _a : true);
            const rc = new RackController(doc, {
              blade: config3.blade,
              root: config3.root,
              viewProps: config3.viewProps
            });
            super(Object.assign(Object.assign({}, config3), { rackController: rc, view: new FolderView(doc, {
              containerElement: rc.view.element,
              foldable,
              props: config3.props,
              viewName: config3.root ? "rot" : void 0,
              viewProps: config3.viewProps
            }) }));
            this.onTitleClick_ = this.onTitleClick_.bind(this);
            this.props = config3.props;
            this.foldable = foldable;
            bindFoldable(this.foldable, this.view.containerElement);
            this.view.buttonElement.addEventListener("click", this.onTitleClick_);
          }
          get document() {
            return this.view.element.ownerDocument;
          }
          onTitleClick_() {
            this.foldable.set("expanded", !this.foldable.get("expanded"));
          }
        }
        const FolderBladePlugin = {
          id: "folder",
          type: "blade",
          accept(params) {
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              title: p2.required.string,
              view: p2.required.constant("folder"),
              expanded: p2.optional.boolean
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            return new FolderController(args.document, {
              blade: args.blade,
              expanded: args.params.expanded,
              props: ValueMap.fromObject({
                title: args.params.title
              }),
              viewProps: args.viewProps
            });
          },
          api(args) {
            if (!(args.controller instanceof FolderController)) {
              return null;
            }
            return new FolderApi(args.controller, args.pool);
          }
        };
        class LabeledValueController extends ValueBladeController {
          constructor(doc, config3) {
            const viewProps = config3.valueController.viewProps;
            super(Object.assign(Object.assign({}, config3), { value: config3.valueController.value, view: new LabelView(doc, {
              props: config3.props,
              viewProps
            }), viewProps }));
            this.props = config3.props;
            this.valueController = config3.valueController;
            this.view.valueElement.appendChild(this.valueController.view.element);
          }
        }
        class SeparatorApi extends BladeApi {
        }
        const className$n = ClassName("spr");
        class SeparatorView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$n());
            config3.viewProps.bindClassModifiers(this.element);
            const hrElem = doc.createElement("hr");
            hrElem.classList.add(className$n("r"));
            this.element.appendChild(hrElem);
          }
        }
        class SeparatorController extends BladeController {
          constructor(doc, config3) {
            super(Object.assign(Object.assign({}, config3), { view: new SeparatorView(doc, {
              viewProps: config3.viewProps
            }) }));
          }
        }
        const SeparatorBladePlugin = {
          id: "separator",
          type: "blade",
          accept(params) {
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              view: p2.required.constant("separator")
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            return new SeparatorController(args.document, {
              blade: args.blade,
              viewProps: args.viewProps
            });
          },
          api(args) {
            if (!(args.controller instanceof SeparatorController)) {
              return null;
            }
            return new SeparatorApi(args.controller);
          }
        };
        const className$m = ClassName("");
        function valueToModifier(elem, modifier) {
          return valueToClassName(elem, className$m(void 0, modifier));
        }
        class ViewProps extends ValueMap {
          constructor(valueMap) {
            super(valueMap);
          }
          static create(opt_initialValue) {
            var _a, _b;
            const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
            const coreObj = {
              disabled: (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
              disposed: false,
              hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false
            };
            const core = ValueMap.createCore(coreObj);
            return new ViewProps(core);
          }
          bindClassModifiers(elem) {
            bindValueMap(this, "disabled", valueToModifier(elem, "disabled"));
            bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
          }
          bindDisabled(target) {
            bindValueMap(this, "disabled", (disabled) => {
              target.disabled = disabled;
            });
          }
          bindTabIndex(elem) {
            bindValueMap(this, "disabled", (disabled) => {
              elem.tabIndex = disabled ? -1 : 0;
            });
          }
          handleDispose(callback) {
            this.value("disposed").emitter.on("change", (disposed) => {
              if (disposed) {
                callback();
              }
            });
          }
        }
        const className$l = ClassName("tbi");
        class TabItemView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$l());
            config3.viewProps.bindClassModifiers(this.element);
            bindValueMap(config3.props, "selected", (selected) => {
              if (selected) {
                this.element.classList.add(className$l(void 0, "sel"));
              } else {
                this.element.classList.remove(className$l(void 0, "sel"));
              }
            });
            const buttonElem = doc.createElement("button");
            buttonElem.classList.add(className$l("b"));
            config3.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const titleElem = doc.createElement("div");
            titleElem.classList.add(className$l("t"));
            bindValueToTextContent(config3.props.value("title"), titleElem);
            this.buttonElement.appendChild(titleElem);
            this.titleElement = titleElem;
          }
        }
        class TabItemController {
          constructor(doc, config3) {
            this.emitter = new Emitter2();
            this.onClick_ = this.onClick_.bind(this);
            this.props = config3.props;
            this.viewProps = config3.viewProps;
            this.view = new TabItemView(doc, {
              props: config3.props,
              viewProps: config3.viewProps
            });
            this.view.buttonElement.addEventListener("click", this.onClick_);
          }
          onClick_() {
            this.emitter.emit("click", {
              sender: this
            });
          }
        }
        class TabPageController {
          constructor(doc, config3) {
            this.onItemClick_ = this.onItemClick_.bind(this);
            this.ic_ = new TabItemController(doc, {
              props: config3.itemProps,
              viewProps: ViewProps.create()
            });
            this.ic_.emitter.on("click", this.onItemClick_);
            this.cc_ = new RackController(doc, {
              blade: createBlade(),
              viewProps: ViewProps.create()
            });
            this.props = config3.props;
            bindValueMap(this.props, "selected", (selected) => {
              this.itemController.props.set("selected", selected);
              this.contentController.viewProps.set("hidden", !selected);
            });
          }
          get itemController() {
            return this.ic_;
          }
          get contentController() {
            return this.cc_;
          }
          onItemClick_() {
            this.props.set("selected", true);
          }
        }
        class TabPageApi {
          constructor(controller, contentRackApi) {
            this.controller_ = controller;
            this.rackApi_ = contentRackApi;
          }
          get title() {
            var _a;
            return (_a = this.controller_.itemController.props.get("title")) !== null && _a !== void 0 ? _a : "";
          }
          set title(title) {
            this.controller_.itemController.props.set("title", title);
          }
          get selected() {
            return this.controller_.props.get("selected");
          }
          set selected(selected) {
            this.controller_.props.set("selected", selected);
          }
          get children() {
            return this.rackApi_.children;
          }
          addButton(params) {
            return this.rackApi_.addButton(params);
          }
          addFolder(params) {
            return this.rackApi_.addFolder(params);
          }
          addSeparator(opt_params) {
            return this.rackApi_.addSeparator(opt_params);
          }
          addTab(params) {
            return this.rackApi_.addTab(params);
          }
          add(api, opt_index) {
            this.rackApi_.add(api, opt_index);
          }
          remove(api) {
            this.rackApi_.remove(api);
          }
          addInput(object, key, opt_params) {
            return this.rackApi_.addInput(object, key, opt_params);
          }
          addMonitor(object, key, opt_params) {
            return this.rackApi_.addMonitor(object, key, opt_params);
          }
          addBlade(params) {
            return this.rackApi_.addBlade(params);
          }
        }
        class TabApi extends RackLikeApi {
          constructor(controller, pool) {
            super(controller, new RackApi(controller.rackController, pool));
            this.onPageAdd_ = this.onPageAdd_.bind(this);
            this.onPageRemove_ = this.onPageRemove_.bind(this);
            this.emitter_ = new Emitter2();
            this.pageApiMap_ = /* @__PURE__ */ new Map();
            this.rackApi_.on("change", (ev) => {
              this.emitter_.emit("change", {
                event: ev
              });
            });
            this.rackApi_.on("update", (ev) => {
              this.emitter_.emit("update", {
                event: ev
              });
            });
            this.controller_.pageSet.emitter.on("add", this.onPageAdd_);
            this.controller_.pageSet.emitter.on("remove", this.onPageRemove_);
            this.controller_.pageSet.items.forEach((pc) => {
              this.setUpPageApi_(pc);
            });
          }
          get pages() {
            return this.controller_.pageSet.items.map((pc) => {
              const api = this.pageApiMap_.get(pc);
              if (!api) {
                throw TpError.shouldNeverHappen();
              }
              return api;
            });
          }
          addPage(params) {
            const doc = this.controller_.view.element.ownerDocument;
            const pc = new TabPageController(doc, {
              itemProps: ValueMap.fromObject({
                selected: false,
                title: params.title
              }),
              props: ValueMap.fromObject({
                selected: false
              })
            });
            this.controller_.add(pc, params.index);
            const api = this.pageApiMap_.get(pc);
            if (!api) {
              throw TpError.shouldNeverHappen();
            }
            return api;
          }
          removePage(index) {
            this.controller_.remove(index);
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
          setUpPageApi_(pc) {
            const rackApi = this.rackApi_["apiSet_"].find((api2) => api2.controller_ === pc.contentController);
            if (!rackApi) {
              throw TpError.shouldNeverHappen();
            }
            const api = new TabPageApi(pc, rackApi);
            this.pageApiMap_.set(pc, api);
          }
          onPageAdd_(ev) {
            this.setUpPageApi_(ev.item);
          }
          onPageRemove_(ev) {
            const api = this.pageApiMap_.get(ev.item);
            if (!api) {
              throw TpError.shouldNeverHappen();
            }
            this.pageApiMap_.delete(ev.item);
          }
        }
        const className$k = ClassName("tab");
        class TabView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$k(), bladeContainerClassName());
            config3.viewProps.bindClassModifiers(this.element);
            bindValue(config3.empty, valueToClassName(this.element, className$k(void 0, "nop")));
            const itemsElem = doc.createElement("div");
            itemsElem.classList.add(className$k("i"));
            this.element.appendChild(itemsElem);
            this.itemsElement = itemsElem;
            const contentsElem = config3.contentsElement;
            contentsElem.classList.add(className$k("c"));
            this.element.appendChild(contentsElem);
            this.contentsElement = contentsElem;
          }
        }
        class TabController extends RackLikeController {
          constructor(doc, config3) {
            const cr = new RackController(doc, {
              blade: config3.blade,
              viewProps: config3.viewProps
            });
            const empty = createValue(true);
            super({
              blade: config3.blade,
              rackController: cr,
              view: new TabView(doc, {
                contentsElement: cr.view.element,
                empty,
                viewProps: config3.viewProps
              })
            });
            this.onPageAdd_ = this.onPageAdd_.bind(this);
            this.onPageRemove_ = this.onPageRemove_.bind(this);
            this.onPageSelectedChange_ = this.onPageSelectedChange_.bind(this);
            this.pageSet_ = new NestedOrderedSet(() => null);
            this.pageSet_.emitter.on("add", this.onPageAdd_);
            this.pageSet_.emitter.on("remove", this.onPageRemove_);
            this.empty_ = empty;
            this.applyPages_();
          }
          get pageSet() {
            return this.pageSet_;
          }
          add(pc, opt_index) {
            this.pageSet_.add(pc, opt_index !== null && opt_index !== void 0 ? opt_index : this.pageSet_.items.length);
          }
          remove(index) {
            this.pageSet_.remove(this.pageSet_.items[index]);
          }
          applyPages_() {
            this.keepSelection_();
            this.empty_.rawValue = this.pageSet_.items.length === 0;
          }
          onPageAdd_(ev) {
            const pc = ev.item;
            insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
            this.rackController.rack.add(pc.contentController, ev.index);
            pc.props.value("selected").emitter.on("change", this.onPageSelectedChange_);
            this.applyPages_();
          }
          onPageRemove_(ev) {
            const pc = ev.item;
            removeElement(pc.itemController.view.element);
            this.rackController.rack.remove(pc.contentController);
            pc.props.value("selected").emitter.off("change", this.onPageSelectedChange_);
            this.applyPages_();
          }
          keepSelection_() {
            if (this.pageSet_.items.length === 0) {
              return;
            }
            const firstSelIndex = this.pageSet_.items.findIndex((pc) => pc.props.get("selected"));
            if (firstSelIndex < 0) {
              this.pageSet_.items.forEach((pc, i2) => {
                pc.props.set("selected", i2 === 0);
              });
            } else {
              this.pageSet_.items.forEach((pc, i2) => {
                pc.props.set("selected", i2 === firstSelIndex);
              });
            }
          }
          onPageSelectedChange_(ev) {
            if (ev.rawValue) {
              const index = this.pageSet_.items.findIndex((pc) => pc.props.value("selected") === ev.sender);
              this.pageSet_.items.forEach((pc, i2) => {
                pc.props.set("selected", i2 === index);
              });
            } else {
              this.keepSelection_();
            }
          }
        }
        const TabBladePlugin = {
          id: "tab",
          type: "blade",
          accept(params) {
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              pages: p2.required.array(p2.required.object({ title: p2.required.string })),
              view: p2.required.constant("tab")
            });
            if (!result || result.pages.length === 0) {
              return null;
            }
            return { params: result };
          },
          controller(args) {
            const c = new TabController(args.document, {
              blade: args.blade,
              viewProps: args.viewProps
            });
            args.params.pages.forEach((p2) => {
              const pc = new TabPageController(args.document, {
                itemProps: ValueMap.fromObject({
                  selected: false,
                  title: p2.title
                }),
                props: ValueMap.fromObject({
                  selected: false
                })
              });
              c.add(pc);
            });
            return c;
          },
          api(args) {
            if (!(args.controller instanceof TabController)) {
              return null;
            }
            return new TabApi(args.controller, args.pool);
          }
        };
        function createBladeController(plugin, args) {
          const ac = plugin.accept(args.params);
          if (!ac) {
            return null;
          }
          const disabled = ParamsParsers.optional.boolean(args.params["disabled"]).value;
          const hidden = ParamsParsers.optional.boolean(args.params["hidden"]).value;
          return plugin.controller({
            blade: createBlade(),
            document: args.document,
            params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled, hidden })),
            viewProps: ViewProps.create({
              disabled,
              hidden
            })
          });
        }
        class ManualTicker {
          constructor() {
            this.disabled = false;
            this.emitter = new Emitter2();
          }
          dispose() {
          }
          tick() {
            if (this.disabled) {
              return;
            }
            this.emitter.emit("tick", {
              sender: this
            });
          }
        }
        class IntervalTicker {
          constructor(doc, interval) {
            this.disabled_ = false;
            this.timerId_ = null;
            this.onTick_ = this.onTick_.bind(this);
            this.doc_ = doc;
            this.emitter = new Emitter2();
            this.interval_ = interval;
            this.setTimer_();
          }
          get disabled() {
            return this.disabled_;
          }
          set disabled(inactive) {
            this.disabled_ = inactive;
            if (this.disabled_) {
              this.clearTimer_();
            } else {
              this.setTimer_();
            }
          }
          dispose() {
            this.clearTimer_();
          }
          clearTimer_() {
            if (this.timerId_ === null) {
              return;
            }
            const win = this.doc_.defaultView;
            if (win) {
              win.clearInterval(this.timerId_);
            }
            this.timerId_ = null;
          }
          setTimer_() {
            this.clearTimer_();
            if (this.interval_ <= 0) {
              return;
            }
            const win = this.doc_.defaultView;
            if (win) {
              this.timerId_ = win.setInterval(this.onTick_, this.interval_);
            }
          }
          onTick_() {
            if (this.disabled_) {
              return;
            }
            this.emitter.emit("tick", {
              sender: this
            });
          }
        }
        class CompositeConstraint {
          constructor(constraints) {
            this.constraints = constraints;
          }
          constrain(value) {
            return this.constraints.reduce((result, c) => {
              return c.constrain(result);
            }, value);
          }
        }
        function findConstraint(c, constraintClass) {
          if (c instanceof constraintClass) {
            return c;
          }
          if (c instanceof CompositeConstraint) {
            const result = c.constraints.reduce((tmpResult, sc3) => {
              if (tmpResult) {
                return tmpResult;
              }
              return sc3 instanceof constraintClass ? sc3 : null;
            }, null);
            if (result) {
              return result;
            }
          }
          return null;
        }
        class ListConstraint {
          constructor(options) {
            this.options = options;
          }
          constrain(value) {
            const opts = this.options;
            if (opts.length === 0) {
              return value;
            }
            const matched = opts.filter((item) => {
              return item.value === value;
            }).length > 0;
            return matched ? value : opts[0].value;
          }
        }
        class RangeConstraint {
          constructor(config3) {
            this.maxValue = config3.max;
            this.minValue = config3.min;
          }
          constrain(value) {
            let result = value;
            if (!isEmpty(this.minValue)) {
              result = Math.max(result, this.minValue);
            }
            if (!isEmpty(this.maxValue)) {
              result = Math.min(result, this.maxValue);
            }
            return result;
          }
        }
        class StepConstraint {
          constructor(step) {
            this.step = step;
          }
          constrain(value) {
            const r = value < 0 ? -Math.round(-value / this.step) : Math.round(value / this.step);
            return r * this.step;
          }
        }
        const className$j = ClassName("lst");
        class ListView {
          constructor(doc, config3) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.props_ = config3.props;
            this.element = doc.createElement("div");
            this.element.classList.add(className$j());
            config3.viewProps.bindClassModifiers(this.element);
            const selectElem = doc.createElement("select");
            selectElem.classList.add(className$j("s"));
            bindValueMap(this.props_, "options", (opts) => {
              removeChildElements(selectElem);
              opts.forEach((item, index) => {
                const optionElem = doc.createElement("option");
                optionElem.dataset.index = String(index);
                optionElem.textContent = item.text;
                optionElem.value = String(item.value);
                selectElem.appendChild(optionElem);
              });
            });
            config3.viewProps.bindDisabled(selectElem);
            this.element.appendChild(selectElem);
            this.selectElement = selectElem;
            const markElem = doc.createElement("div");
            markElem.classList.add(className$j("m"));
            markElem.appendChild(createSvgIconElement(doc, "dropdown"));
            this.element.appendChild(markElem);
            config3.value.emitter.on("change", this.onValueChange_);
            this.value_ = config3.value;
            this.update_();
          }
          update_() {
            this.selectElement.value = String(this.value_.rawValue);
          }
          onValueChange_() {
            this.update_();
          }
        }
        class ListController {
          constructor(doc, config3) {
            this.onSelectChange_ = this.onSelectChange_.bind(this);
            this.props = config3.props;
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new ListView(doc, {
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            });
            this.view.selectElement.addEventListener("change", this.onSelectChange_);
          }
          onSelectChange_(e) {
            const selectElem = forceCast(e.currentTarget);
            const optElem = selectElem.selectedOptions.item(0);
            if (!optElem) {
              return;
            }
            const itemIndex = Number(optElem.dataset.index);
            this.value.rawValue = this.props.get("options")[itemIndex].value;
          }
        }
        const className$i = ClassName("pop");
        class PopupView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$i());
            config3.viewProps.bindClassModifiers(this.element);
            bindValue(config3.shows, valueToClassName(this.element, className$i(void 0, "v")));
          }
        }
        class PopupController {
          constructor(doc, config3) {
            this.shows = createValue(false);
            this.viewProps = config3.viewProps;
            this.view = new PopupView(doc, {
              shows: this.shows,
              viewProps: this.viewProps
            });
          }
        }
        const className$h = ClassName("txt");
        class TextView {
          constructor(doc, config3) {
            this.onChange_ = this.onChange_.bind(this);
            this.element = doc.createElement("div");
            this.element.classList.add(className$h());
            config3.viewProps.bindClassModifiers(this.element);
            this.props_ = config3.props;
            this.props_.emitter.on("change", this.onChange_);
            const inputElem = doc.createElement("input");
            inputElem.classList.add(className$h("i"));
            inputElem.type = "text";
            config3.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            config3.value.emitter.on("change", this.onChange_);
            this.value_ = config3.value;
            this.refresh();
          }
          refresh() {
            const formatter = this.props_.get("formatter");
            this.inputElement.value = formatter(this.value_.rawValue);
          }
          onChange_() {
            this.refresh();
          }
        }
        class TextController {
          constructor(doc, config3) {
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.parser_ = config3.parser;
            this.props = config3.props;
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new TextView(doc, {
              props: config3.props,
              value: this.value,
              viewProps: this.viewProps
            });
            this.view.inputElement.addEventListener("change", this.onInputChange_);
          }
          onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            const value = inputElem.value;
            const parsedValue = this.parser_(value);
            if (!isEmpty(parsedValue)) {
              this.value.rawValue = parsedValue;
            }
            this.view.refresh();
          }
        }
        function boolToString(value) {
          return String(value);
        }
        function boolFromUnknown(value) {
          if (value === "false") {
            return false;
          }
          return !!value;
        }
        function BooleanFormatter(value) {
          return boolToString(value);
        }
        class NumberLiteralNode {
          constructor(text) {
            this.text = text;
          }
          evaluate() {
            return Number(this.text);
          }
          toString() {
            return this.text;
          }
        }
        const BINARY_OPERATION_MAP = {
          "**": (v1, v2) => Math.pow(v1, v2),
          "*": (v1, v2) => v1 * v2,
          "/": (v1, v2) => v1 / v2,
          "%": (v1, v2) => v1 % v2,
          "+": (v1, v2) => v1 + v2,
          "-": (v1, v2) => v1 - v2,
          "<<": (v1, v2) => v1 << v2,
          ">>": (v1, v2) => v1 >> v2,
          ">>>": (v1, v2) => v1 >>> v2,
          "&": (v1, v2) => v1 & v2,
          "^": (v1, v2) => v1 ^ v2,
          "|": (v1, v2) => v1 | v2
        };
        class BinaryOperationNode {
          constructor(operator, left, right) {
            this.left = left;
            this.operator = operator;
            this.right = right;
          }
          evaluate() {
            const op = BINARY_OPERATION_MAP[this.operator];
            if (!op) {
              throw new Error(`unexpected binary operator: '${this.operator}`);
            }
            return op(this.left.evaluate(), this.right.evaluate());
          }
          toString() {
            return [
              "b(",
              this.left.toString(),
              this.operator,
              this.right.toString(),
              ")"
            ].join(" ");
          }
        }
        const UNARY_OPERATION_MAP = {
          "+": (v) => v,
          "-": (v) => -v,
          "~": (v) => ~v
        };
        class UnaryOperationNode {
          constructor(operator, expr) {
            this.operator = operator;
            this.expression = expr;
          }
          evaluate() {
            const op = UNARY_OPERATION_MAP[this.operator];
            if (!op) {
              throw new Error(`unexpected unary operator: '${this.operator}`);
            }
            return op(this.expression.evaluate());
          }
          toString() {
            return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
          }
        }
        function combineReader(parsers) {
          return (text, cursor) => {
            for (let i2 = 0; i2 < parsers.length; i2++) {
              const result = parsers[i2](text, cursor);
              if (result !== "") {
                return result;
              }
            }
            return "";
          };
        }
        function readWhitespace(text, cursor) {
          var _a;
          const m = text.substr(cursor).match(/^\s+/);
          return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
        }
        function readNonZeroDigit(text, cursor) {
          const ch = text.substr(cursor, 1);
          return ch.match(/^[1-9]$/) ? ch : "";
        }
        function readDecimalDigits(text, cursor) {
          var _a;
          const m = text.substr(cursor).match(/^[0-9]+/);
          return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
        }
        function readSignedInteger(text, cursor) {
          const ds = readDecimalDigits(text, cursor);
          if (ds !== "") {
            return ds;
          }
          const sign2 = text.substr(cursor, 1);
          cursor += 1;
          if (sign2 !== "-" && sign2 !== "+") {
            return "";
          }
          const sds = readDecimalDigits(text, cursor);
          if (sds === "") {
            return "";
          }
          return sign2 + sds;
        }
        function readExponentPart(text, cursor) {
          const e = text.substr(cursor, 1);
          cursor += 1;
          if (e.toLowerCase() !== "e") {
            return "";
          }
          const si = readSignedInteger(text, cursor);
          if (si === "") {
            return "";
          }
          return e + si;
        }
        function readDecimalIntegerLiteral(text, cursor) {
          const ch = text.substr(cursor, 1);
          if (ch === "0") {
            return ch;
          }
          const nzd = readNonZeroDigit(text, cursor);
          cursor += nzd.length;
          if (nzd === "") {
            return "";
          }
          return nzd + readDecimalDigits(text, cursor);
        }
        function readDecimalLiteral1(text, cursor) {
          const dil = readDecimalIntegerLiteral(text, cursor);
          cursor += dil.length;
          if (dil === "") {
            return "";
          }
          const dot = text.substr(cursor, 1);
          cursor += dot.length;
          if (dot !== ".") {
            return "";
          }
          const dds = readDecimalDigits(text, cursor);
          cursor += dds.length;
          return dil + dot + dds + readExponentPart(text, cursor);
        }
        function readDecimalLiteral2(text, cursor) {
          const dot = text.substr(cursor, 1);
          cursor += dot.length;
          if (dot !== ".") {
            return "";
          }
          const dds = readDecimalDigits(text, cursor);
          cursor += dds.length;
          if (dds === "") {
            return "";
          }
          return dot + dds + readExponentPart(text, cursor);
        }
        function readDecimalLiteral3(text, cursor) {
          const dil = readDecimalIntegerLiteral(text, cursor);
          cursor += dil.length;
          if (dil === "") {
            return "";
          }
          return dil + readExponentPart(text, cursor);
        }
        const readDecimalLiteral = combineReader([
          readDecimalLiteral1,
          readDecimalLiteral2,
          readDecimalLiteral3
        ]);
        function parseBinaryDigits(text, cursor) {
          var _a;
          const m = text.substr(cursor).match(/^[01]+/);
          return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
        }
        function readBinaryIntegerLiteral(text, cursor) {
          const prefix = text.substr(cursor, 2);
          cursor += prefix.length;
          if (prefix.toLowerCase() !== "0b") {
            return "";
          }
          const bds = parseBinaryDigits(text, cursor);
          if (bds === "") {
            return "";
          }
          return prefix + bds;
        }
        function readOctalDigits(text, cursor) {
          var _a;
          const m = text.substr(cursor).match(/^[0-7]+/);
          return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
        }
        function readOctalIntegerLiteral(text, cursor) {
          const prefix = text.substr(cursor, 2);
          cursor += prefix.length;
          if (prefix.toLowerCase() !== "0o") {
            return "";
          }
          const ods = readOctalDigits(text, cursor);
          if (ods === "") {
            return "";
          }
          return prefix + ods;
        }
        function readHexDigits(text, cursor) {
          var _a;
          const m = text.substr(cursor).match(/^[0-9a-f]+/i);
          return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
        }
        function readHexIntegerLiteral(text, cursor) {
          const prefix = text.substr(cursor, 2);
          cursor += prefix.length;
          if (prefix.toLowerCase() !== "0x") {
            return "";
          }
          const hds = readHexDigits(text, cursor);
          if (hds === "") {
            return "";
          }
          return prefix + hds;
        }
        const readNonDecimalIntegerLiteral = combineReader([
          readBinaryIntegerLiteral,
          readOctalIntegerLiteral,
          readHexIntegerLiteral
        ]);
        const readNumericLiteral = combineReader([
          readNonDecimalIntegerLiteral,
          readDecimalLiteral
        ]);
        function parseLiteral(text, cursor) {
          const num = readNumericLiteral(text, cursor);
          cursor += num.length;
          if (num === "") {
            return null;
          }
          return {
            evaluable: new NumberLiteralNode(num),
            cursor
          };
        }
        function parseParenthesizedExpression(text, cursor) {
          const op = text.substr(cursor, 1);
          cursor += op.length;
          if (op !== "(") {
            return null;
          }
          const expr = parseExpression(text, cursor);
          if (!expr) {
            return null;
          }
          cursor = expr.cursor;
          cursor += readWhitespace(text, cursor).length;
          const cl = text.substr(cursor, 1);
          cursor += cl.length;
          if (cl !== ")") {
            return null;
          }
          return {
            evaluable: expr.evaluable,
            cursor
          };
        }
        function parsePrimaryExpression(text, cursor) {
          return parseLiteral(text, cursor) || parseParenthesizedExpression(text, cursor);
        }
        function parseUnaryExpression(text, cursor) {
          const expr = parsePrimaryExpression(text, cursor);
          if (expr) {
            return expr;
          }
          const op = text.substr(cursor, 1);
          cursor += op.length;
          if (op !== "+" && op !== "-" && op !== "~") {
            return null;
          }
          const num = parseUnaryExpression(text, cursor);
          if (!num) {
            return null;
          }
          cursor = num.cursor;
          return {
            cursor,
            evaluable: new UnaryOperationNode(op, num.evaluable)
          };
        }
        function readBinaryOperator(ops, text, cursor) {
          cursor += readWhitespace(text, cursor).length;
          const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
          if (!op) {
            return null;
          }
          cursor += op.length;
          cursor += readWhitespace(text, cursor).length;
          return {
            cursor,
            operator: op
          };
        }
        function createBinaryOperationExpressionParser(exprParser, ops) {
          return (text, cursor) => {
            const firstExpr = exprParser(text, cursor);
            if (!firstExpr) {
              return null;
            }
            cursor = firstExpr.cursor;
            let expr = firstExpr.evaluable;
            for (; ; ) {
              const op = readBinaryOperator(ops, text, cursor);
              if (!op) {
                break;
              }
              cursor = op.cursor;
              const nextExpr = exprParser(text, cursor);
              if (!nextExpr) {
                return null;
              }
              cursor = nextExpr.cursor;
              expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
            }
            return expr ? {
              cursor,
              evaluable: expr
            } : null;
          };
        }
        const parseBinaryOperationExpression = [
          ["**"],
          ["*", "/", "%"],
          ["+", "-"],
          ["<<", ">>>", ">>"],
          ["&"],
          ["^"],
          ["|"]
        ].reduce((parser, ops) => {
          return createBinaryOperationExpressionParser(parser, ops);
        }, parseUnaryExpression);
        function parseExpression(text, cursor) {
          cursor += readWhitespace(text, cursor).length;
          return parseBinaryOperationExpression(text, cursor);
        }
        function parseEcmaNumberExpression(text) {
          const expr = parseExpression(text, 0);
          if (!expr) {
            return null;
          }
          const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
          if (cursor !== text.length) {
            return null;
          }
          return expr.evaluable;
        }
        function parseNumber(text) {
          var _a;
          const r = parseEcmaNumberExpression(text);
          return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a !== void 0 ? _a : null;
        }
        function numberFromUnknown(value) {
          if (typeof value === "number") {
            return value;
          }
          if (typeof value === "string") {
            const pv = parseNumber(value);
            if (!isEmpty(pv)) {
              return pv;
            }
          }
          return 0;
        }
        function numberToString(value) {
          return String(value);
        }
        function createNumberFormatter(digits) {
          return (value) => {
            return value.toFixed(Math.max(Math.min(digits, 20), 0));
          };
        }
        const innerFormatter = createNumberFormatter(0);
        function formatPercentage(value) {
          return innerFormatter(value) + "%";
        }
        function stringFromUnknown(value) {
          return String(value);
        }
        function formatString(value) {
          return value;
        }
        function fillBuffer(buffer, bufferSize) {
          while (buffer.length < bufferSize) {
            buffer.push(void 0);
          }
        }
        function initializeBuffer(bufferSize) {
          const buffer = [];
          fillBuffer(buffer, bufferSize);
          return createValue(buffer);
        }
        function createTrimmedBuffer(buffer) {
          const index = buffer.indexOf(void 0);
          return forceCast(index < 0 ? buffer : buffer.slice(0, index));
        }
        function createPushedBuffer(buffer, newValue) {
          const newBuffer = [...createTrimmedBuffer(buffer), newValue];
          if (newBuffer.length > buffer.length) {
            newBuffer.splice(0, newBuffer.length - buffer.length);
          } else {
            fillBuffer(newBuffer, buffer.length);
          }
          return newBuffer;
        }
        function connectValues({ primary, secondary, forward, backward }) {
          let changing = false;
          function preventFeedback(callback) {
            if (changing) {
              return;
            }
            changing = true;
            callback();
            changing = false;
          }
          primary.emitter.on("change", (ev) => {
            preventFeedback(() => {
              secondary.setRawValue(forward(primary, secondary), ev.options);
            });
          });
          secondary.emitter.on("change", (ev) => {
            preventFeedback(() => {
              primary.setRawValue(backward(primary, secondary), ev.options);
            });
            preventFeedback(() => {
              secondary.setRawValue(forward(primary, secondary), ev.options);
            });
          });
          preventFeedback(() => {
            secondary.setRawValue(forward(primary, secondary), {
              forceEmit: false,
              last: true
            });
          });
        }
        function getStepForKey(baseStep, keys) {
          const step = baseStep * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
          if (keys.upKey) {
            return +step;
          } else if (keys.downKey) {
            return -step;
          }
          return 0;
        }
        function getVerticalStepKeys(ev) {
          return {
            altKey: ev.altKey,
            downKey: ev.key === "ArrowDown",
            shiftKey: ev.shiftKey,
            upKey: ev.key === "ArrowUp"
          };
        }
        function getHorizontalStepKeys(ev) {
          return {
            altKey: ev.altKey,
            downKey: ev.key === "ArrowLeft",
            shiftKey: ev.shiftKey,
            upKey: ev.key === "ArrowRight"
          };
        }
        function isVerticalArrowKey(key) {
          return key === "ArrowUp" || key === "ArrowDown";
        }
        function isArrowKey(key) {
          return isVerticalArrowKey(key) || key === "ArrowLeft" || key === "ArrowRight";
        }
        function computeOffset$1(ev, elem) {
          const win = elem.ownerDocument.defaultView;
          const rect = elem.getBoundingClientRect();
          return {
            x: ev.pageX - ((win && win.scrollX || 0) + rect.left),
            y: ev.pageY - ((win && win.scrollY || 0) + rect.top)
          };
        }
        class PointerHandler {
          constructor(element) {
            this.lastTouch_ = null;
            this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
            this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
            this.onMouseDown_ = this.onMouseDown_.bind(this);
            this.onTouchEnd_ = this.onTouchEnd_.bind(this);
            this.onTouchMove_ = this.onTouchMove_.bind(this);
            this.onTouchStart_ = this.onTouchStart_.bind(this);
            this.elem_ = element;
            this.emitter = new Emitter2();
            element.addEventListener("touchstart", this.onTouchStart_, {
              passive: false
            });
            element.addEventListener("touchmove", this.onTouchMove_, {
              passive: true
            });
            element.addEventListener("touchend", this.onTouchEnd_);
            element.addEventListener("mousedown", this.onMouseDown_);
          }
          computePosition_(offset) {
            const rect = this.elem_.getBoundingClientRect();
            return {
              bounds: {
                width: rect.width,
                height: rect.height
              },
              point: offset ? {
                x: offset.x,
                y: offset.y
              } : null
            };
          }
          onMouseDown_(ev) {
            var _a;
            ev.preventDefault();
            (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
            const doc = this.elem_.ownerDocument;
            doc.addEventListener("mousemove", this.onDocumentMouseMove_);
            doc.addEventListener("mouseup", this.onDocumentMouseUp_);
            this.emitter.emit("down", {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset$1(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
          onDocumentMouseMove_(ev) {
            this.emitter.emit("move", {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset$1(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
          onDocumentMouseUp_(ev) {
            const doc = this.elem_.ownerDocument;
            doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
            doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
            this.emitter.emit("up", {
              altKey: ev.altKey,
              data: this.computePosition_(computeOffset$1(ev, this.elem_)),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
          onTouchStart_(ev) {
            ev.preventDefault();
            const touch = ev.targetTouches.item(0);
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit("down", {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : void 0),
              sender: this,
              shiftKey: ev.shiftKey
            });
            this.lastTouch_ = touch;
          }
          onTouchMove_(ev) {
            const touch = ev.targetTouches.item(0);
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit("move", {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : void 0),
              sender: this,
              shiftKey: ev.shiftKey
            });
            this.lastTouch_ = touch;
          }
          onTouchEnd_(ev) {
            var _a;
            const touch = (_a = ev.targetTouches.item(0)) !== null && _a !== void 0 ? _a : this.lastTouch_;
            const rect = this.elem_.getBoundingClientRect();
            this.emitter.emit("up", {
              altKey: ev.altKey,
              data: this.computePosition_(touch ? {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
              } : void 0),
              sender: this,
              shiftKey: ev.shiftKey
            });
          }
        }
        function mapRange3(value, start1, end1, start2, end2) {
          const p2 = (value - start1) / (end1 - start1);
          return start2 + p2 * (end2 - start2);
        }
        function getDecimalDigits(value) {
          const text = String(value.toFixed(10));
          const frac = text.split(".")[1];
          return frac.replace(/0+$/, "").length;
        }
        function constrainRange(value, min, max) {
          return Math.min(Math.max(value, min), max);
        }
        function loopRange(value, max) {
          return (value % max + max) % max;
        }
        const className$g = ClassName("txt");
        class NumberTextView {
          constructor(doc, config3) {
            this.onChange_ = this.onChange_.bind(this);
            this.props_ = config3.props;
            this.props_.emitter.on("change", this.onChange_);
            this.element = doc.createElement("div");
            this.element.classList.add(className$g(), className$g(void 0, "num"));
            if (config3.arrayPosition) {
              this.element.classList.add(className$g(void 0, config3.arrayPosition));
            }
            config3.viewProps.bindClassModifiers(this.element);
            const inputElem = doc.createElement("input");
            inputElem.classList.add(className$g("i"));
            inputElem.type = "text";
            config3.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            this.onDraggingChange_ = this.onDraggingChange_.bind(this);
            this.dragging_ = config3.dragging;
            this.dragging_.emitter.on("change", this.onDraggingChange_);
            this.element.classList.add(className$g());
            this.inputElement.classList.add(className$g("i"));
            const knobElem = doc.createElement("div");
            knobElem.classList.add(className$g("k"));
            this.element.appendChild(knobElem);
            this.knobElement = knobElem;
            const guideElem = doc.createElementNS(SVG_NS, "svg");
            guideElem.classList.add(className$g("g"));
            this.knobElement.appendChild(guideElem);
            const bodyElem = doc.createElementNS(SVG_NS, "path");
            bodyElem.classList.add(className$g("gb"));
            guideElem.appendChild(bodyElem);
            this.guideBodyElem_ = bodyElem;
            const headElem = doc.createElementNS(SVG_NS, "path");
            headElem.classList.add(className$g("gh"));
            guideElem.appendChild(headElem);
            this.guideHeadElem_ = headElem;
            const tooltipElem = doc.createElement("div");
            tooltipElem.classList.add(ClassName("tt")());
            this.knobElement.appendChild(tooltipElem);
            this.tooltipElem_ = tooltipElem;
            config3.value.emitter.on("change", this.onChange_);
            this.value = config3.value;
            this.refresh();
          }
          onDraggingChange_(ev) {
            if (ev.rawValue === null) {
              this.element.classList.remove(className$g(void 0, "drg"));
              return;
            }
            this.element.classList.add(className$g(void 0, "drg"));
            const x = ev.rawValue / this.props_.get("draggingScale");
            const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
            const adx = constrainRange(-aox, -4, 4);
            this.guideHeadElem_.setAttributeNS(null, "d", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(" "));
            this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
            const formatter = this.props_.get("formatter");
            this.tooltipElem_.textContent = formatter(this.value.rawValue);
            this.tooltipElem_.style.left = `${x}px`;
          }
          refresh() {
            const formatter = this.props_.get("formatter");
            this.inputElement.value = formatter(this.value.rawValue);
          }
          onChange_() {
            this.refresh();
          }
        }
        class NumberTextController {
          constructor(doc, config3) {
            this.originRawValue_ = 0;
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
            this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.baseStep_ = config3.baseStep;
            this.parser_ = config3.parser;
            this.props = config3.props;
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.dragging_ = createValue(null);
            this.view = new NumberTextView(doc, {
              arrayPosition: config3.arrayPosition,
              dragging: this.dragging_,
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            });
            this.view.inputElement.addEventListener("change", this.onInputChange_);
            this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
            this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
            const ph = new PointerHandler(this.view.knobElement);
            ph.emitter.on("down", this.onPointerDown_);
            ph.emitter.on("move", this.onPointerMove_);
            ph.emitter.on("up", this.onPointerUp_);
          }
          onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            const value = inputElem.value;
            const parsedValue = this.parser_(value);
            if (!isEmpty(parsedValue)) {
              this.value.rawValue = parsedValue;
            }
            this.view.refresh();
          }
          onInputKeyDown_(ev) {
            const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
            if (step === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue + step, {
              forceEmit: false,
              last: false
            });
          }
          onInputKeyUp_(ev) {
            const step = getStepForKey(this.baseStep_, getVerticalStepKeys(ev));
            if (step === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
          onPointerDown_() {
            this.originRawValue_ = this.value.rawValue;
            this.dragging_.rawValue = 0;
          }
          computeDraggingValue_(data) {
            if (!data.point) {
              return null;
            }
            const dx = data.point.x - data.bounds.width / 2;
            return this.originRawValue_ + dx * this.props.get("draggingScale");
          }
          onPointerMove_(ev) {
            const v = this.computeDraggingValue_(ev.data);
            if (v === null) {
              return;
            }
            this.value.setRawValue(v, {
              forceEmit: false,
              last: false
            });
            this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
          }
          onPointerUp_(ev) {
            const v = this.computeDraggingValue_(ev.data);
            if (v === null) {
              return;
            }
            this.value.setRawValue(v, {
              forceEmit: true,
              last: true
            });
            this.dragging_.rawValue = null;
          }
        }
        const className$f = ClassName("sld");
        class SliderView {
          constructor(doc, config3) {
            this.onChange_ = this.onChange_.bind(this);
            this.props_ = config3.props;
            this.props_.emitter.on("change", this.onChange_);
            this.element = doc.createElement("div");
            this.element.classList.add(className$f());
            config3.viewProps.bindClassModifiers(this.element);
            const trackElem = doc.createElement("div");
            trackElem.classList.add(className$f("t"));
            config3.viewProps.bindTabIndex(trackElem);
            this.element.appendChild(trackElem);
            this.trackElement = trackElem;
            const knobElem = doc.createElement("div");
            knobElem.classList.add(className$f("k"));
            this.trackElement.appendChild(knobElem);
            this.knobElement = knobElem;
            config3.value.emitter.on("change", this.onChange_);
            this.value = config3.value;
            this.update_();
          }
          update_() {
            const p2 = constrainRange(mapRange3(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
            this.knobElement.style.width = `${p2}%`;
          }
          onChange_() {
            this.update_();
          }
        }
        class SliderController {
          constructor(doc, config3) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.baseStep_ = config3.baseStep;
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.props = config3.props;
            this.view = new SliderView(doc, {
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            });
            this.ptHandler_ = new PointerHandler(this.view.trackElement);
            this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
            this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
            this.ptHandler_.emitter.on("up", this.onPointerUp_);
            this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
            this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }
            this.value.setRawValue(mapRange3(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), opts);
          }
          onPointerDownOrMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(ev) {
            const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            if (step === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue + step, {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(ev) {
            const step = getStepForKey(this.baseStep_, getHorizontalStepKeys(ev));
            if (step === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        const className$e = ClassName("sldtxt");
        class SliderTextView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$e());
            const sliderElem = doc.createElement("div");
            sliderElem.classList.add(className$e("s"));
            this.sliderView_ = config3.sliderView;
            sliderElem.appendChild(this.sliderView_.element);
            this.element.appendChild(sliderElem);
            const textElem = doc.createElement("div");
            textElem.classList.add(className$e("t"));
            this.textView_ = config3.textView;
            textElem.appendChild(this.textView_.element);
            this.element.appendChild(textElem);
          }
        }
        class SliderTextController {
          constructor(doc, config3) {
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.sliderC_ = new SliderController(doc, {
              baseStep: config3.baseStep,
              props: config3.sliderProps,
              value: config3.value,
              viewProps: this.viewProps
            });
            this.textC_ = new NumberTextController(doc, {
              baseStep: config3.baseStep,
              parser: config3.parser,
              props: config3.textProps,
              value: config3.value,
              viewProps: config3.viewProps
            });
            this.view = new SliderTextView(doc, {
              sliderView: this.sliderC_.view,
              textView: this.textC_.view
            });
          }
          get sliderController() {
            return this.sliderC_;
          }
          get textController() {
            return this.textC_;
          }
        }
        function writePrimitive(target, value) {
          target.write(value);
        }
        function parseListOptions(value) {
          const p2 = ParamsParsers;
          if (Array.isArray(value)) {
            return p2.required.array(p2.required.object({
              text: p2.required.string,
              value: p2.required.raw
            }))(value).value;
          }
          if (typeof value === "object") {
            return p2.required.raw(value).value;
          }
          return void 0;
        }
        function parsePickerLayout(value) {
          if (value === "inline" || value === "popup") {
            return value;
          }
          return void 0;
        }
        function parsePointDimensionParams(value) {
          const p2 = ParamsParsers;
          return p2.required.object({
            max: p2.optional.number,
            min: p2.optional.number,
            step: p2.optional.number
          })(value).value;
        }
        function normalizeListOptions(options) {
          if (Array.isArray(options)) {
            return options;
          }
          const items = [];
          Object.keys(options).forEach((text) => {
            items.push({ text, value: options[text] });
          });
          return items;
        }
        function createListConstraint(options) {
          return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
        }
        function findListItems(constraint) {
          const c = constraint ? findConstraint(constraint, ListConstraint) : null;
          if (!c) {
            return null;
          }
          return c.options;
        }
        function findStep(constraint) {
          const c = constraint ? findConstraint(constraint, StepConstraint) : null;
          if (!c) {
            return null;
          }
          return c.step;
        }
        function getSuitableDecimalDigits(constraint, rawValue) {
          const sc3 = constraint && findConstraint(constraint, StepConstraint);
          if (sc3) {
            return getDecimalDigits(sc3.step);
          }
          return Math.max(getDecimalDigits(rawValue), 2);
        }
        function getBaseStep(constraint) {
          const step = findStep(constraint);
          return step !== null && step !== void 0 ? step : 1;
        }
        function getSuitableDraggingScale(constraint, rawValue) {
          var _a;
          const sc3 = constraint && findConstraint(constraint, StepConstraint);
          const base = Math.abs((_a = sc3 === null || sc3 === void 0 ? void 0 : sc3.step) !== null && _a !== void 0 ? _a : rawValue);
          return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
        }
        const className$d = ClassName("ckb");
        class CheckboxView {
          constructor(doc, config3) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.element = doc.createElement("div");
            this.element.classList.add(className$d());
            config3.viewProps.bindClassModifiers(this.element);
            const labelElem = doc.createElement("label");
            labelElem.classList.add(className$d("l"));
            this.element.appendChild(labelElem);
            const inputElem = doc.createElement("input");
            inputElem.classList.add(className$d("i"));
            inputElem.type = "checkbox";
            labelElem.appendChild(inputElem);
            this.inputElement = inputElem;
            config3.viewProps.bindDisabled(this.inputElement);
            const wrapperElem = doc.createElement("div");
            wrapperElem.classList.add(className$d("w"));
            labelElem.appendChild(wrapperElem);
            const markElem = createSvgIconElement(doc, "check");
            wrapperElem.appendChild(markElem);
            config3.value.emitter.on("change", this.onValueChange_);
            this.value = config3.value;
            this.update_();
          }
          update_() {
            this.inputElement.checked = this.value.rawValue;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class CheckboxController {
          constructor(doc, config3) {
            this.onInputChange_ = this.onInputChange_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new CheckboxView(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
            this.view.inputElement.addEventListener("change", this.onInputChange_);
          }
          onInputChange_(e) {
            const inputElem = forceCast(e.currentTarget);
            this.value.rawValue = inputElem.checked;
          }
        }
        function createConstraint$5(params) {
          const constraints = [];
          const lc = createListConstraint(params.options);
          if (lc) {
            constraints.push(lc);
          }
          return new CompositeConstraint(constraints);
        }
        const BooleanInputPlugin = {
          id: "input-bool",
          type: "input",
          accept: (value, params) => {
            if (typeof value !== "boolean") {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              options: p2.optional.custom(parseListOptions)
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => boolFromUnknown,
            constraint: (args) => createConstraint$5(args.params),
            writer: (_args) => writePrimitive
          },
          controller: (args) => {
            var _a;
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            if (c && findConstraint(c, ListConstraint)) {
              return new ListController(doc, {
                props: ValueMap.fromObject({
                  options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
                }),
                value,
                viewProps: args.viewProps
              });
            }
            return new CheckboxController(doc, {
              value,
              viewProps: args.viewProps
            });
          }
        };
        const className$c = ClassName("col");
        class ColorView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$c());
            config3.foldable.bindExpandedClass(this.element, className$c(void 0, "expanded"));
            bindValueMap(config3.foldable, "completed", valueToClassName(this.element, className$c(void 0, "cpl")));
            const headElem = doc.createElement("div");
            headElem.classList.add(className$c("h"));
            this.element.appendChild(headElem);
            const swatchElem = doc.createElement("div");
            swatchElem.classList.add(className$c("s"));
            headElem.appendChild(swatchElem);
            this.swatchElement = swatchElem;
            const textElem = doc.createElement("div");
            textElem.classList.add(className$c("t"));
            headElem.appendChild(textElem);
            this.textElement = textElem;
            if (config3.pickerLayout === "inline") {
              const pickerElem = doc.createElement("div");
              pickerElem.classList.add(className$c("p"));
              this.element.appendChild(pickerElem);
              this.pickerElement = pickerElem;
            } else {
              this.pickerElement = null;
            }
          }
        }
        function rgbToHsl(r, g, b) {
          const rp = constrainRange(r / 255, 0, 1);
          const gp = constrainRange(g / 255, 0, 1);
          const bp = constrainRange(b / 255, 0, 1);
          const cmax = Math.max(rp, gp, bp);
          const cmin = Math.min(rp, gp, bp);
          const c = cmax - cmin;
          let h = 0;
          let s = 0;
          const l = (cmin + cmax) / 2;
          if (c !== 0) {
            s = c / (1 - Math.abs(cmax + cmin - 1));
            if (rp === cmax) {
              h = (gp - bp) / c;
            } else if (gp === cmax) {
              h = 2 + (bp - rp) / c;
            } else {
              h = 4 + (rp - gp) / c;
            }
            h = h / 6 + (h < 0 ? 1 : 0);
          }
          return [h * 360, s * 100, l * 100];
        }
        function hslToRgb(h, s, l) {
          const hp = (h % 360 + 360) % 360;
          const sp = constrainRange(s / 100, 0, 1);
          const lp = constrainRange(l / 100, 0, 1);
          const c = (1 - Math.abs(2 * lp - 1)) * sp;
          const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
          const m = lp - c / 2;
          let rp, gp, bp;
          if (hp >= 0 && hp < 60) {
            [rp, gp, bp] = [c, x, 0];
          } else if (hp >= 60 && hp < 120) {
            [rp, gp, bp] = [x, c, 0];
          } else if (hp >= 120 && hp < 180) {
            [rp, gp, bp] = [0, c, x];
          } else if (hp >= 180 && hp < 240) {
            [rp, gp, bp] = [0, x, c];
          } else if (hp >= 240 && hp < 300) {
            [rp, gp, bp] = [x, 0, c];
          } else {
            [rp, gp, bp] = [c, 0, x];
          }
          return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
        }
        function rgbToHsv(r, g, b) {
          const rp = constrainRange(r / 255, 0, 1);
          const gp = constrainRange(g / 255, 0, 1);
          const bp = constrainRange(b / 255, 0, 1);
          const cmax = Math.max(rp, gp, bp);
          const cmin = Math.min(rp, gp, bp);
          const d = cmax - cmin;
          let h;
          if (d === 0) {
            h = 0;
          } else if (cmax === rp) {
            h = 60 * (((gp - bp) / d % 6 + 6) % 6);
          } else if (cmax === gp) {
            h = 60 * ((bp - rp) / d + 2);
          } else {
            h = 60 * ((rp - gp) / d + 4);
          }
          const s = cmax === 0 ? 0 : d / cmax;
          const v = cmax;
          return [h, s * 100, v * 100];
        }
        function hsvToRgb(h, s, v) {
          const hp = loopRange(h, 360);
          const sp = constrainRange(s / 100, 0, 1);
          const vp = constrainRange(v / 100, 0, 1);
          const c = vp * sp;
          const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
          const m = vp - c;
          let rp, gp, bp;
          if (hp >= 0 && hp < 60) {
            [rp, gp, bp] = [c, x, 0];
          } else if (hp >= 60 && hp < 120) {
            [rp, gp, bp] = [x, c, 0];
          } else if (hp >= 120 && hp < 180) {
            [rp, gp, bp] = [0, c, x];
          } else if (hp >= 180 && hp < 240) {
            [rp, gp, bp] = [0, x, c];
          } else if (hp >= 240 && hp < 300) {
            [rp, gp, bp] = [x, 0, c];
          } else {
            [rp, gp, bp] = [c, 0, x];
          }
          return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
        }
        function hslToHsv(h, s, l) {
          const sd = l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100);
          return [
            h,
            sd !== 0 ? s * (100 - Math.abs(2 * l - 100)) / sd : 0,
            l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100)
          ];
        }
        function hsvToHsl(h, s, v) {
          const sd = 100 - Math.abs(v * (200 - s) / 100 - 100);
          return [h, sd !== 0 ? s * v / sd : 0, v * (200 - s) / (2 * 100)];
        }
        function removeAlphaComponent(comps) {
          return [comps[0], comps[1], comps[2]];
        }
        function appendAlphaComponent(comps, alpha) {
          return [comps[0], comps[1], comps[2], alpha];
        }
        const MODE_CONVERTER_MAP = {
          hsl: {
            hsl: (h, s, l) => [h, s, l],
            hsv: hslToHsv,
            rgb: hslToRgb
          },
          hsv: {
            hsl: hsvToHsl,
            hsv: (h, s, v) => [h, s, v],
            rgb: hsvToRgb
          },
          rgb: {
            hsl: rgbToHsl,
            hsv: rgbToHsv,
            rgb: (r, g, b) => [r, g, b]
          }
        };
        function convertColorMode(components, fromMode, toMode) {
          return MODE_CONVERTER_MAP[fromMode][toMode](...components);
        }
        const CONSTRAINT_MAP = {
          hsl: (comps) => {
            var _a;
            return [
              loopRange(comps[0], 360),
              constrainRange(comps[1], 0, 100),
              constrainRange(comps[2], 0, 100),
              constrainRange((_a = comps[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)
            ];
          },
          hsv: (comps) => {
            var _a;
            return [
              loopRange(comps[0], 360),
              constrainRange(comps[1], 0, 100),
              constrainRange(comps[2], 0, 100),
              constrainRange((_a = comps[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)
            ];
          },
          rgb: (comps) => {
            var _a;
            return [
              constrainRange(comps[0], 0, 255),
              constrainRange(comps[1], 0, 255),
              constrainRange(comps[2], 0, 255),
              constrainRange((_a = comps[3]) !== null && _a !== void 0 ? _a : 1, 0, 1)
            ];
          }
        };
        function isRgbColorComponent(obj, key) {
          if (typeof obj !== "object" || isEmpty(obj)) {
            return false;
          }
          return key in obj && typeof obj[key] === "number";
        }
        class Color2 {
          constructor(comps, mode) {
            this.mode_ = mode;
            this.comps_ = CONSTRAINT_MAP[mode](comps);
          }
          static black() {
            return new Color2([0, 0, 0], "rgb");
          }
          static fromObject(obj) {
            const comps = "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
            return new Color2(comps, "rgb");
          }
          static toRgbaObject(color) {
            return color.toRgbaObject();
          }
          static isRgbColorObject(obj) {
            return isRgbColorComponent(obj, "r") && isRgbColorComponent(obj, "g") && isRgbColorComponent(obj, "b");
          }
          static isRgbaColorObject(obj) {
            return this.isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
          }
          static isColorObject(obj) {
            return this.isRgbColorObject(obj);
          }
          static equals(v1, v2) {
            if (v1.mode_ !== v2.mode_) {
              return false;
            }
            const comps1 = v1.comps_;
            const comps2 = v2.comps_;
            for (let i2 = 0; i2 < comps1.length; i2++) {
              if (comps1[i2] !== comps2[i2]) {
                return false;
              }
            }
            return true;
          }
          get mode() {
            return this.mode_;
          }
          getComponents(opt_mode) {
            return appendAlphaComponent(convertColorMode(removeAlphaComponent(this.comps_), this.mode_, opt_mode || this.mode_), this.comps_[3]);
          }
          toRgbaObject() {
            const rgbComps = this.getComponents("rgb");
            return {
              r: rgbComps[0],
              g: rgbComps[1],
              b: rgbComps[2],
              a: rgbComps[3]
            };
          }
        }
        const className$b = ClassName("colp");
        class ColorPickerView {
          constructor(doc, config3) {
            this.alphaViews_ = null;
            this.element = doc.createElement("div");
            this.element.classList.add(className$b());
            const hsvElem = doc.createElement("div");
            hsvElem.classList.add(className$b("hsv"));
            const svElem = doc.createElement("div");
            svElem.classList.add(className$b("sv"));
            this.svPaletteView_ = config3.svPaletteView;
            svElem.appendChild(this.svPaletteView_.element);
            hsvElem.appendChild(svElem);
            const hElem = doc.createElement("div");
            hElem.classList.add(className$b("h"));
            this.hPaletteView_ = config3.hPaletteView;
            hElem.appendChild(this.hPaletteView_.element);
            hsvElem.appendChild(hElem);
            this.element.appendChild(hsvElem);
            const rgbElem = doc.createElement("div");
            rgbElem.classList.add(className$b("rgb"));
            this.textView_ = config3.textView;
            rgbElem.appendChild(this.textView_.element);
            this.element.appendChild(rgbElem);
            if (config3.alphaViews) {
              this.alphaViews_ = {
                palette: config3.alphaViews.palette,
                text: config3.alphaViews.text
              };
              const aElem = doc.createElement("div");
              aElem.classList.add(className$b("a"));
              const apElem = doc.createElement("div");
              apElem.classList.add(className$b("ap"));
              apElem.appendChild(this.alphaViews_.palette.element);
              aElem.appendChild(apElem);
              const atElem = doc.createElement("div");
              atElem.classList.add(className$b("at"));
              atElem.appendChild(this.alphaViews_.text.element);
              aElem.appendChild(atElem);
              this.element.appendChild(aElem);
            }
          }
          get allFocusableElements() {
            const elems = [
              this.svPaletteView_.element,
              this.hPaletteView_.element,
              this.textView_.modeSelectElement,
              ...this.textView_.textViews.map((v) => v.inputElement)
            ];
            if (this.alphaViews_) {
              elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
            }
            return elems;
          }
        }
        function parseColorInputParams(params) {
          const p2 = ParamsParsers;
          return parseParams(params, {
            alpha: p2.optional.boolean,
            expanded: p2.optional.boolean,
            picker: p2.optional.custom(parsePickerLayout)
          });
        }
        function getBaseStepForColor(forAlpha) {
          return forAlpha ? 0.1 : 1;
        }
        function parseCssNumberOrPercentage(text, maxValue) {
          const m = text.match(/^(.+)%$/);
          if (!m) {
            return Math.min(parseFloat(text), maxValue);
          }
          return Math.min(parseFloat(m[1]) * 0.01 * maxValue, maxValue);
        }
        const ANGLE_TO_DEG_MAP = {
          deg: (angle) => angle,
          grad: (angle) => angle * 360 / 400,
          rad: (angle) => angle * 360 / (2 * Math.PI),
          turn: (angle) => angle * 360
        };
        function parseCssNumberOrAngle(text) {
          const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
          if (!m) {
            return parseFloat(text);
          }
          const angle = parseFloat(m[1]);
          const unit = m[2];
          return ANGLE_TO_DEG_MAP[unit](angle);
        }
        const NOTATION_TO_PARSER_MAP = {
          "func.rgb": (text) => {
            const m = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!m) {
              return null;
            }
            const comps = [
              parseCssNumberOrPercentage(m[1], 255),
              parseCssNumberOrPercentage(m[2], 255),
              parseCssNumberOrPercentage(m[3], 255)
            ];
            if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
              return null;
            }
            return new Color2(comps, "rgb");
          },
          "func.rgba": (text) => {
            const m = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!m) {
              return null;
            }
            const comps = [
              parseCssNumberOrPercentage(m[1], 255),
              parseCssNumberOrPercentage(m[2], 255),
              parseCssNumberOrPercentage(m[3], 255),
              parseCssNumberOrPercentage(m[4], 1)
            ];
            if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
              return null;
            }
            return new Color2(comps, "rgb");
          },
          "func.hsl": (text) => {
            const m = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!m) {
              return null;
            }
            const comps = [
              parseCssNumberOrAngle(m[1]),
              parseCssNumberOrPercentage(m[2], 100),
              parseCssNumberOrPercentage(m[3], 100)
            ];
            if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
              return null;
            }
            return new Color2(comps, "hsl");
          },
          "func.hsla": (text) => {
            const m = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
            if (!m) {
              return null;
            }
            const comps = [
              parseCssNumberOrAngle(m[1]),
              parseCssNumberOrPercentage(m[2], 100),
              parseCssNumberOrPercentage(m[3], 100),
              parseCssNumberOrPercentage(m[4], 1)
            ];
            if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
              return null;
            }
            return new Color2(comps, "hsl");
          },
          "hex.rgb": (text) => {
            const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
            if (mRgb) {
              return new Color2([
                parseInt(mRgb[1] + mRgb[1], 16),
                parseInt(mRgb[2] + mRgb[2], 16),
                parseInt(mRgb[3] + mRgb[3], 16)
              ], "rgb");
            }
            const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
            if (mRrggbb) {
              return new Color2([
                parseInt(mRrggbb[1], 16),
                parseInt(mRrggbb[2], 16),
                parseInt(mRrggbb[3], 16)
              ], "rgb");
            }
            return null;
          },
          "hex.rgba": (text) => {
            const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
            if (mRgb) {
              return new Color2([
                parseInt(mRgb[1] + mRgb[1], 16),
                parseInt(mRgb[2] + mRgb[2], 16),
                parseInt(mRgb[3] + mRgb[3], 16),
                mapRange3(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)
              ], "rgb");
            }
            const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
            if (mRrggbb) {
              return new Color2([
                parseInt(mRrggbb[1], 16),
                parseInt(mRrggbb[2], 16),
                parseInt(mRrggbb[3], 16),
                mapRange3(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)
              ], "rgb");
            }
            return null;
          }
        };
        function getColorNotation(text) {
          const notations = Object.keys(NOTATION_TO_PARSER_MAP);
          return notations.reduce((result, notation) => {
            if (result) {
              return result;
            }
            const subparser = NOTATION_TO_PARSER_MAP[notation];
            return subparser(text) ? notation : null;
          }, null);
        }
        const CompositeColorParser = (text) => {
          const notation = getColorNotation(text);
          return notation ? NOTATION_TO_PARSER_MAP[notation](text) : null;
        };
        function hasAlphaComponent(notation) {
          return notation === "func.hsla" || notation === "func.rgba" || notation === "hex.rgba";
        }
        function colorFromString(value) {
          if (typeof value === "string") {
            const cv = CompositeColorParser(value);
            if (cv) {
              return cv;
            }
          }
          return Color2.black();
        }
        function zerofill(comp) {
          const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
          return hex.length === 1 ? `0${hex}` : hex;
        }
        function colorToHexRgbString(value, prefix = "#") {
          const hexes = removeAlphaComponent(value.getComponents("rgb")).map(zerofill).join("");
          return `${prefix}${hexes}`;
        }
        function colorToHexRgbaString(value, prefix = "#") {
          const rgbaComps = value.getComponents("rgb");
          const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join("");
          return `${prefix}${hexes}`;
        }
        function colorToFunctionalRgbString(value) {
          const formatter = createNumberFormatter(0);
          const comps = removeAlphaComponent(value.getComponents("rgb")).map((comp) => formatter(comp));
          return `rgb(${comps.join(", ")})`;
        }
        function colorToFunctionalRgbaString(value) {
          const aFormatter = createNumberFormatter(2);
          const rgbFormatter = createNumberFormatter(0);
          const comps = value.getComponents("rgb").map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return formatter(comp);
          });
          return `rgba(${comps.join(", ")})`;
        }
        function colorToFunctionalHslString(value) {
          const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage
          ];
          const comps = removeAlphaComponent(value.getComponents("hsl")).map((comp, index) => formatters[index](comp));
          return `hsl(${comps.join(", ")})`;
        }
        function colorToFunctionalHslaString(value) {
          const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
            createNumberFormatter(2)
          ];
          const comps = value.getComponents("hsl").map((comp, index) => formatters[index](comp));
          return `hsla(${comps.join(", ")})`;
        }
        const NOTATION_TO_STRINGIFIER_MAP = {
          "func.hsl": colorToFunctionalHslString,
          "func.hsla": colorToFunctionalHslaString,
          "func.rgb": colorToFunctionalRgbString,
          "func.rgba": colorToFunctionalRgbaString,
          "hex.rgb": colorToHexRgbString,
          "hex.rgba": colorToHexRgbaString
        };
        function getColorStringifier(notation) {
          return NOTATION_TO_STRINGIFIER_MAP[notation];
        }
        const className$a = ClassName("apl");
        class APaletteView {
          constructor(doc, config3) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config3.value;
            this.value.emitter.on("change", this.onValueChange_);
            this.element = doc.createElement("div");
            this.element.classList.add(className$a());
            config3.viewProps.bindTabIndex(this.element);
            const barElem = doc.createElement("div");
            barElem.classList.add(className$a("b"));
            this.element.appendChild(barElem);
            const colorElem = doc.createElement("div");
            colorElem.classList.add(className$a("c"));
            barElem.appendChild(colorElem);
            this.colorElem_ = colorElem;
            const markerElem = doc.createElement("div");
            markerElem.classList.add(className$a("m"));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            const previewElem = doc.createElement("div");
            previewElem.classList.add(className$a("p"));
            this.markerElem_.appendChild(previewElem);
            this.previewElem_ = previewElem;
            this.update_();
          }
          update_() {
            const c = this.value.rawValue;
            const rgbaComps = c.getComponents("rgb");
            const leftColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], "rgb");
            const rightColor = new Color2([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], "rgb");
            const gradientComps = [
              "to right",
              colorToFunctionalRgbaString(leftColor),
              colorToFunctionalRgbaString(rightColor)
            ];
            this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
            this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
            const left = mapRange3(rgbaComps[3], 0, 1, 0, 100);
            this.markerElem_.style.left = `${left}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class APaletteController {
          constructor(doc, config3) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new APaletteView(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on("down", this.onPointerDown_);
            this.ptHandler_.emitter.on("move", this.onPointerMove_);
            this.ptHandler_.emitter.on("up", this.onPointerUp_);
            this.view.element.addEventListener("keydown", this.onKeyDown_);
            this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }
            const alpha = d.point.x / d.bounds.width;
            const c = this.value.rawValue;
            const [h, s, v] = c.getComponents("hsv");
            this.value.setRawValue(new Color2([h, s, v, alpha], "hsv"), opts);
          }
          onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(ev) {
            const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
            if (step === 0) {
              return;
            }
            const c = this.value.rawValue;
            const [h, s, v, a] = c.getComponents("hsv");
            this.value.setRawValue(new Color2([h, s, v, a + step], "hsv"), {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(ev) {
            const step = getStepForKey(getBaseStepForColor(true), getHorizontalStepKeys(ev));
            if (step === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        const className$9 = ClassName("coltxt");
        function createModeSelectElement(doc) {
          const selectElem = doc.createElement("select");
          const items = [
            { text: "RGB", value: "rgb" },
            { text: "HSL", value: "hsl" },
            { text: "HSV", value: "hsv" }
          ];
          selectElem.appendChild(items.reduce((frag, item) => {
            const optElem = doc.createElement("option");
            optElem.textContent = item.text;
            optElem.value = item.value;
            frag.appendChild(optElem);
            return frag;
          }, doc.createDocumentFragment()));
          return selectElem;
        }
        class ColorTextView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$9());
            const modeElem = doc.createElement("div");
            modeElem.classList.add(className$9("m"));
            this.modeElem_ = createModeSelectElement(doc);
            this.modeElem_.classList.add(className$9("ms"));
            modeElem.appendChild(this.modeSelectElement);
            const modeMarkerElem = doc.createElement("div");
            modeMarkerElem.classList.add(className$9("mm"));
            modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
            modeElem.appendChild(modeMarkerElem);
            this.element.appendChild(modeElem);
            const textsElem = doc.createElement("div");
            textsElem.classList.add(className$9("w"));
            this.element.appendChild(textsElem);
            this.textsElem_ = textsElem;
            this.textViews_ = config3.textViews;
            this.applyTextViews_();
            bindValue(config3.colorMode, (mode) => {
              this.modeElem_.value = mode;
            });
          }
          get modeSelectElement() {
            return this.modeElem_;
          }
          get textViews() {
            return this.textViews_;
          }
          set textViews(textViews) {
            this.textViews_ = textViews;
            this.applyTextViews_();
          }
          applyTextViews_() {
            removeChildElements(this.textsElem_);
            const doc = this.element.ownerDocument;
            this.textViews_.forEach((v) => {
              const compElem = doc.createElement("div");
              compElem.classList.add(className$9("c"));
              compElem.appendChild(v.element);
              this.textsElem_.appendChild(compElem);
            });
          }
        }
        const FORMATTER = createNumberFormatter(0);
        const MODE_TO_CONSTRAINT_MAP = {
          rgb: () => {
            return new RangeConstraint({ min: 0, max: 255 });
          },
          hsl: (index) => {
            return index === 0 ? new RangeConstraint({ min: 0, max: 360 }) : new RangeConstraint({ min: 0, max: 100 });
          },
          hsv: (index) => {
            return index === 0 ? new RangeConstraint({ min: 0, max: 360 }) : new RangeConstraint({ min: 0, max: 100 });
          }
        };
        function createComponentController(doc, config3, index) {
          return new NumberTextController(doc, {
            arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
            baseStep: getBaseStepForColor(false),
            parser: config3.parser,
            props: ValueMap.fromObject({
              draggingScale: 1,
              formatter: FORMATTER
            }),
            value: createValue(0, {
              constraint: MODE_TO_CONSTRAINT_MAP[config3.colorMode](index)
            }),
            viewProps: config3.viewProps
          });
        }
        class ColorTextController {
          constructor(doc, config3) {
            this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
            this.parser_ = config3.parser;
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.colorMode = createValue(this.value.rawValue.mode);
            this.ccs_ = this.createComponentControllers_(doc);
            this.view = new ColorTextView(doc, {
              colorMode: this.colorMode,
              textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
            });
            this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
          }
          createComponentControllers_(doc) {
            const cc = {
              colorMode: this.colorMode.rawValue,
              parser: this.parser_,
              viewProps: this.viewProps
            };
            const ccs = [
              createComponentController(doc, cc, 0),
              createComponentController(doc, cc, 1),
              createComponentController(doc, cc, 2)
            ];
            ccs.forEach((cs, index) => {
              connectValues({
                primary: this.value,
                secondary: cs.value,
                forward: (p2) => {
                  return p2.rawValue.getComponents(this.colorMode.rawValue)[index];
                },
                backward: (p2, s) => {
                  const pickedMode = this.colorMode.rawValue;
                  const comps = p2.rawValue.getComponents(pickedMode);
                  comps[index] = s.rawValue;
                  return new Color2(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode);
                }
              });
            });
            return ccs;
          }
          onModeSelectChange_(ev) {
            const selectElem = ev.currentTarget;
            this.colorMode.rawValue = selectElem.value;
            this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
            this.view.textViews = [
              this.ccs_[0].view,
              this.ccs_[1].view,
              this.ccs_[2].view
            ];
          }
        }
        const className$8 = ClassName("hpl");
        class HPaletteView {
          constructor(doc, config3) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config3.value;
            this.value.emitter.on("change", this.onValueChange_);
            this.element = doc.createElement("div");
            this.element.classList.add(className$8());
            config3.viewProps.bindTabIndex(this.element);
            const colorElem = doc.createElement("div");
            colorElem.classList.add(className$8("c"));
            this.element.appendChild(colorElem);
            const markerElem = doc.createElement("div");
            markerElem.classList.add(className$8("m"));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            this.update_();
          }
          update_() {
            const c = this.value.rawValue;
            const [h] = c.getComponents("hsv");
            this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new Color2([h, 100, 100], "hsv"));
            const left = mapRange3(h, 0, 360, 0, 100);
            this.markerElem_.style.left = `${left}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class HPaletteController {
          constructor(doc, config3) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new HPaletteView(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on("down", this.onPointerDown_);
            this.ptHandler_.emitter.on("move", this.onPointerMove_);
            this.ptHandler_.emitter.on("up", this.onPointerUp_);
            this.view.element.addEventListener("keydown", this.onKeyDown_);
            this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }
            const hue = mapRange3(d.point.x, 0, d.bounds.width, 0, 360);
            const c = this.value.rawValue;
            const [, s, v, a] = c.getComponents("hsv");
            this.value.setRawValue(new Color2([hue, s, v, a], "hsv"), opts);
          }
          onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(ev) {
            const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
            if (step === 0) {
              return;
            }
            const c = this.value.rawValue;
            const [h, s, v, a] = c.getComponents("hsv");
            this.value.setRawValue(new Color2([h + step, s, v, a], "hsv"), {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(ev) {
            const step = getStepForKey(getBaseStepForColor(false), getHorizontalStepKeys(ev));
            if (step === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        const className$7 = ClassName("svp");
        const CANVAS_RESOL = 64;
        class SvPaletteView {
          constructor(doc, config3) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.value = config3.value;
            this.value.emitter.on("change", this.onValueChange_);
            this.element = doc.createElement("div");
            this.element.classList.add(className$7());
            config3.viewProps.bindTabIndex(this.element);
            const canvasElem = doc.createElement("canvas");
            canvasElem.height = CANVAS_RESOL;
            canvasElem.width = CANVAS_RESOL;
            canvasElem.classList.add(className$7("c"));
            this.element.appendChild(canvasElem);
            this.canvasElement = canvasElem;
            const markerElem = doc.createElement("div");
            markerElem.classList.add(className$7("m"));
            this.element.appendChild(markerElem);
            this.markerElem_ = markerElem;
            this.update_();
          }
          update_() {
            const ctx = getCanvasContext(this.canvasElement);
            if (!ctx) {
              return;
            }
            const c = this.value.rawValue;
            const hsvComps = c.getComponents("hsv");
            const width = this.canvasElement.width;
            const height = this.canvasElement.height;
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            for (let iy = 0; iy < height; iy++) {
              for (let ix = 0; ix < width; ix++) {
                const s = mapRange3(ix, 0, width, 0, 100);
                const v = mapRange3(iy, 0, height, 100, 0);
                const rgbComps = hsvToRgb(hsvComps[0], s, v);
                const i2 = (iy * width + ix) * 4;
                data[i2] = rgbComps[0];
                data[i2 + 1] = rgbComps[1];
                data[i2 + 2] = rgbComps[2];
                data[i2 + 3] = 255;
              }
            }
            ctx.putImageData(imgData, 0, 0);
            const left = mapRange3(hsvComps[1], 0, 100, 0, 100);
            this.markerElem_.style.left = `${left}%`;
            const top = mapRange3(hsvComps[2], 0, 100, 100, 0);
            this.markerElem_.style.top = `${top}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class SvPaletteController {
          constructor(doc, config3) {
            this.onKeyDown_ = this.onKeyDown_.bind(this);
            this.onKeyUp_ = this.onKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new SvPaletteView(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
            this.ptHandler_ = new PointerHandler(this.view.element);
            this.ptHandler_.emitter.on("down", this.onPointerDown_);
            this.ptHandler_.emitter.on("move", this.onPointerMove_);
            this.ptHandler_.emitter.on("up", this.onPointerUp_);
            this.view.element.addEventListener("keydown", this.onKeyDown_);
            this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }
            const saturation = mapRange3(d.point.x, 0, d.bounds.width, 0, 100);
            const value = mapRange3(d.point.y, 0, d.bounds.height, 100, 0);
            const [h, , , a] = this.value.rawValue.getComponents("hsv");
            this.value.setRawValue(new Color2([h, saturation, value, a], "hsv"), opts);
          }
          onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
              ev.preventDefault();
            }
            const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
            const baseStep = getBaseStepForColor(false);
            const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
            if (ds === 0 && dv === 0) {
              return;
            }
            this.value.setRawValue(new Color2([h, s + ds, v + dv, a], "hsv"), {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(ev) {
            const baseStep = getBaseStepForColor(false);
            const ds = getStepForKey(baseStep, getHorizontalStepKeys(ev));
            const dv = getStepForKey(baseStep, getVerticalStepKeys(ev));
            if (ds === 0 && dv === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        class ColorPickerController {
          constructor(doc, config3) {
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.hPaletteC_ = new HPaletteController(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
            this.svPaletteC_ = new SvPaletteController(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
            this.alphaIcs_ = config3.supportsAlpha ? {
              palette: new APaletteController(doc, {
                value: this.value,
                viewProps: this.viewProps
              }),
              text: new NumberTextController(doc, {
                parser: parseNumber,
                baseStep: 0.1,
                props: ValueMap.fromObject({
                  draggingScale: 0.01,
                  formatter: createNumberFormatter(2)
                }),
                value: createValue(0, {
                  constraint: new RangeConstraint({ min: 0, max: 1 })
                }),
                viewProps: this.viewProps
              })
            } : null;
            if (this.alphaIcs_) {
              connectValues({
                primary: this.value,
                secondary: this.alphaIcs_.text.value,
                forward: (p2) => {
                  return p2.rawValue.getComponents()[3];
                },
                backward: (p2, s) => {
                  const comps = p2.rawValue.getComponents();
                  comps[3] = s.rawValue;
                  return new Color2(comps, p2.rawValue.mode);
                }
              });
            }
            this.textC_ = new ColorTextController(doc, {
              parser: parseNumber,
              value: this.value,
              viewProps: this.viewProps
            });
            this.view = new ColorPickerView(doc, {
              alphaViews: this.alphaIcs_ ? {
                palette: this.alphaIcs_.palette.view,
                text: this.alphaIcs_.text.view
              } : null,
              hPaletteView: this.hPaletteC_.view,
              supportsAlpha: config3.supportsAlpha,
              svPaletteView: this.svPaletteC_.view,
              textView: this.textC_.view
            });
          }
          get textController() {
            return this.textC_;
          }
        }
        const className$6 = ClassName("colsw");
        class ColorSwatchView {
          constructor(doc, config3) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            config3.value.emitter.on("change", this.onValueChange_);
            this.value = config3.value;
            this.element = doc.createElement("div");
            this.element.classList.add(className$6());
            config3.viewProps.bindClassModifiers(this.element);
            const swatchElem = doc.createElement("div");
            swatchElem.classList.add(className$6("sw"));
            this.element.appendChild(swatchElem);
            this.swatchElem_ = swatchElem;
            const buttonElem = doc.createElement("button");
            buttonElem.classList.add(className$6("b"));
            config3.viewProps.bindDisabled(buttonElem);
            this.element.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            this.update_();
          }
          update_() {
            const value = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
          }
          onValueChange_() {
            this.update_();
          }
        }
        class ColorSwatchController {
          constructor(doc, config3) {
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new ColorSwatchView(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        class ColorController {
          constructor(doc, config3) {
            this.onButtonBlur_ = this.onButtonBlur_.bind(this);
            this.onButtonClick_ = this.onButtonClick_.bind(this);
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
            this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.foldable_ = Foldable.create(config3.expanded);
            this.swatchC_ = new ColorSwatchController(doc, {
              value: this.value,
              viewProps: this.viewProps
            });
            const buttonElem = this.swatchC_.view.buttonElement;
            buttonElem.addEventListener("blur", this.onButtonBlur_);
            buttonElem.addEventListener("click", this.onButtonClick_);
            this.textC_ = new TextController(doc, {
              parser: config3.parser,
              props: ValueMap.fromObject({
                formatter: config3.formatter
              }),
              value: this.value,
              viewProps: this.viewProps
            });
            this.view = new ColorView(doc, {
              foldable: this.foldable_,
              pickerLayout: config3.pickerLayout
            });
            this.view.swatchElement.appendChild(this.swatchC_.view.element);
            this.view.textElement.appendChild(this.textC_.view.element);
            this.popC_ = config3.pickerLayout === "popup" ? new PopupController(doc, {
              viewProps: this.viewProps
            }) : null;
            const pickerC = new ColorPickerController(doc, {
              supportsAlpha: config3.supportsAlpha,
              value: this.value,
              viewProps: this.viewProps
            });
            pickerC.view.allFocusableElements.forEach((elem) => {
              elem.addEventListener("blur", this.onPopupChildBlur_);
              elem.addEventListener("keydown", this.onPopupChildKeydown_);
            });
            this.pickerC_ = pickerC;
            if (this.popC_) {
              this.view.element.appendChild(this.popC_.view.element);
              this.popC_.view.element.appendChild(pickerC.view.element);
              connectValues({
                primary: this.foldable_.value("expanded"),
                secondary: this.popC_.shows,
                forward: (p2) => p2.rawValue,
                backward: (_, s) => s.rawValue
              });
            } else if (this.view.pickerElement) {
              this.view.pickerElement.appendChild(this.pickerC_.view.element);
              bindFoldable(this.foldable_, this.view.pickerElement);
            }
          }
          get textController() {
            return this.textC_;
          }
          onButtonBlur_(e) {
            if (!this.popC_) {
              return;
            }
            const elem = this.view.element;
            const nextTarget = forceCast(e.relatedTarget);
            if (!nextTarget || !elem.contains(nextTarget)) {
              this.popC_.shows.rawValue = false;
            }
          }
          onButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded"));
            if (this.foldable_.get("expanded")) {
              this.pickerC_.view.allFocusableElements[0].focus();
            }
          }
          onPopupChildBlur_(ev) {
            if (!this.popC_) {
              return;
            }
            const elem = this.popC_.view.element;
            const nextTarget = findNextTarget(ev);
            if (nextTarget && elem.contains(nextTarget)) {
              return;
            }
            if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
              return;
            }
            this.popC_.shows.rawValue = false;
          }
          onPopupChildKeydown_(ev) {
            if (this.popC_) {
              if (ev.key === "Escape") {
                this.popC_.shows.rawValue = false;
              }
            } else if (this.view.pickerElement) {
              if (ev.key === "Escape") {
                this.swatchC_.view.buttonElement.focus();
              }
            }
          }
        }
        function colorFromObject(value) {
          if (Color2.isColorObject(value)) {
            return Color2.fromObject(value);
          }
          return Color2.black();
        }
        function colorToRgbNumber(value) {
          return removeAlphaComponent(value.getComponents("rgb")).reduce((result, comp) => {
            return result << 8 | Math.floor(comp) & 255;
          }, 0);
        }
        function colorToRgbaNumber(value) {
          return value.getComponents("rgb").reduce((result, comp, index) => {
            const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
            return result << 8 | hex;
          }, 0) >>> 0;
        }
        function numberToRgbColor(num) {
          return new Color2([num >> 16 & 255, num >> 8 & 255, num & 255], "rgb");
        }
        function numberToRgbaColor(num) {
          return new Color2([
            num >> 24 & 255,
            num >> 16 & 255,
            num >> 8 & 255,
            mapRange3(num & 255, 0, 255, 0, 1)
          ], "rgb");
        }
        function colorFromRgbNumber(value) {
          if (typeof value !== "number") {
            return Color2.black();
          }
          return numberToRgbColor(value);
        }
        function colorFromRgbaNumber(value) {
          if (typeof value !== "number") {
            return Color2.black();
          }
          return numberToRgbaColor(value);
        }
        function createColorStringWriter(notation) {
          const stringify = getColorStringifier(notation);
          return (target, value) => {
            writePrimitive(target, stringify(value));
          };
        }
        function createColorNumberWriter(supportsAlpha) {
          const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
          return (target, value) => {
            writePrimitive(target, colorToNumber(value));
          };
        }
        function writeRgbaColorObject(target, value) {
          const obj = value.toRgbaObject();
          target.writeProperty("r", obj.r);
          target.writeProperty("g", obj.g);
          target.writeProperty("b", obj.b);
          target.writeProperty("a", obj.a);
        }
        function writeRgbColorObject(target, value) {
          const obj = value.toRgbaObject();
          target.writeProperty("r", obj.r);
          target.writeProperty("g", obj.g);
          target.writeProperty("b", obj.b);
        }
        function createColorObjectWriter(supportsAlpha) {
          return supportsAlpha ? writeRgbaColorObject : writeRgbColorObject;
        }
        function shouldSupportAlpha$1(inputParams) {
          return "alpha" in inputParams && inputParams.alpha === true;
        }
        function createFormatter$1(supportsAlpha) {
          return supportsAlpha ? (v) => colorToHexRgbaString(v, "0x") : (v) => colorToHexRgbString(v, "0x");
        }
        const NumberColorInputPlugin = {
          id: "input-color-number",
          type: "input",
          accept: (value, params) => {
            if (typeof value !== "number") {
              return null;
            }
            if (!("view" in params)) {
              return null;
            }
            if (params.view !== "color") {
              return null;
            }
            const result = parseColorInputParams(params);
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (args) => {
              return shouldSupportAlpha$1(args.params) ? colorFromRgbaNumber : colorFromRgbNumber;
            },
            equals: Color2.equals,
            writer: (args) => {
              return createColorNumberWriter(shouldSupportAlpha$1(args.params));
            }
          },
          controller: (args) => {
            const supportsAlpha = shouldSupportAlpha$1(args.params);
            const expanded = "expanded" in args.params ? args.params.expanded : void 0;
            const picker = "picker" in args.params ? args.params.picker : void 0;
            return new ColorController(args.document, {
              expanded: expanded !== null && expanded !== void 0 ? expanded : false,
              formatter: createFormatter$1(supportsAlpha),
              parser: CompositeColorParser,
              pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
              supportsAlpha,
              value: args.value,
              viewProps: args.viewProps
            });
          }
        };
        function shouldSupportAlpha(initialValue) {
          return Color2.isRgbaColorObject(initialValue);
        }
        const ObjectColorInputPlugin = {
          id: "input-color-object",
          type: "input",
          accept: (value, params) => {
            if (!Color2.isColorObject(value)) {
              return null;
            }
            const result = parseColorInputParams(params);
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => colorFromObject,
            equals: Color2.equals,
            writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue))
          },
          controller: (args) => {
            const supportsAlpha = Color2.isRgbaColorObject(args.initialValue);
            const expanded = "expanded" in args.params ? args.params.expanded : void 0;
            const picker = "picker" in args.params ? args.params.picker : void 0;
            const formatter = supportsAlpha ? colorToHexRgbaString : colorToHexRgbString;
            return new ColorController(args.document, {
              expanded: expanded !== null && expanded !== void 0 ? expanded : false,
              formatter,
              parser: CompositeColorParser,
              pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
              supportsAlpha,
              value: args.value,
              viewProps: args.viewProps
            });
          }
        };
        const StringColorInputPlugin = {
          id: "input-color-string",
          type: "input",
          accept: (value, params) => {
            if (typeof value !== "string") {
              return null;
            }
            if ("view" in params && params.view === "text") {
              return null;
            }
            const notation = getColorNotation(value);
            if (!notation) {
              return null;
            }
            const result = parseColorInputParams(params);
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => colorFromString,
            equals: Color2.equals,
            writer: (args) => {
              const notation = getColorNotation(args.initialValue);
              if (!notation) {
                throw TpError.shouldNeverHappen();
              }
              return createColorStringWriter(notation);
            }
          },
          controller: (args) => {
            const notation = getColorNotation(args.initialValue);
            if (!notation) {
              throw TpError.shouldNeverHappen();
            }
            const stringifier = getColorStringifier(notation);
            const expanded = "expanded" in args.params ? args.params.expanded : void 0;
            const picker = "picker" in args.params ? args.params.picker : void 0;
            return new ColorController(args.document, {
              expanded: expanded !== null && expanded !== void 0 ? expanded : false,
              formatter: stringifier,
              parser: CompositeColorParser,
              pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
              supportsAlpha: hasAlphaComponent(notation),
              value: args.value,
              viewProps: args.viewProps
            });
          }
        };
        class PointNdConstraint {
          constructor(config3) {
            this.components = config3.components;
            this.asm_ = config3.assembly;
          }
          constrain(value) {
            const comps = this.asm_.toComponents(value).map((comp, index) => {
              var _a, _b;
              return (_b = (_a = this.components[index]) === null || _a === void 0 ? void 0 : _a.constrain(comp)) !== null && _b !== void 0 ? _b : comp;
            });
            return this.asm_.fromComponents(comps);
          }
        }
        const className$5 = ClassName("pndtxt");
        class PointNdTextView {
          constructor(doc, config3) {
            this.textViews = config3.textViews;
            this.element = doc.createElement("div");
            this.element.classList.add(className$5());
            this.textViews.forEach((v) => {
              const axisElem = doc.createElement("div");
              axisElem.classList.add(className$5("a"));
              axisElem.appendChild(v.element);
              this.element.appendChild(axisElem);
            });
          }
        }
        function createAxisController(doc, config3, index) {
          return new NumberTextController(doc, {
            arrayPosition: index === 0 ? "fst" : index === config3.axes.length - 1 ? "lst" : "mid",
            baseStep: config3.axes[index].baseStep,
            parser: config3.parser,
            props: config3.axes[index].textProps,
            value: createValue(0, {
              constraint: config3.axes[index].constraint
            }),
            viewProps: config3.viewProps
          });
        }
        class PointNdTextController {
          constructor(doc, config3) {
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.acs_ = config3.axes.map((_, index) => createAxisController(doc, config3, index));
            this.acs_.forEach((c, index) => {
              connectValues({
                primary: this.value,
                secondary: c.value,
                forward: (p2) => {
                  return config3.assembly.toComponents(p2.rawValue)[index];
                },
                backward: (p2, s) => {
                  const comps = config3.assembly.toComponents(p2.rawValue);
                  comps[index] = s.rawValue;
                  return config3.assembly.fromComponents(comps);
                }
              });
            });
            this.view = new PointNdTextView(doc, {
              textViews: this.acs_.map((ac) => ac.view)
            });
          }
        }
        function createStepConstraint(params) {
          if ("step" in params && !isEmpty(params.step)) {
            return new StepConstraint(params.step);
          }
          return null;
        }
        function createRangeConstraint(params) {
          if ("max" in params && !isEmpty(params.max) || "min" in params && !isEmpty(params.min)) {
            return new RangeConstraint({
              max: params.max,
              min: params.min
            });
          }
          return null;
        }
        function createConstraint$4(params) {
          const constraints = [];
          const sc3 = createStepConstraint(params);
          if (sc3) {
            constraints.push(sc3);
          }
          const rc = createRangeConstraint(params);
          if (rc) {
            constraints.push(rc);
          }
          const lc = createListConstraint(params.options);
          if (lc) {
            constraints.push(lc);
          }
          return new CompositeConstraint(constraints);
        }
        function findRange(constraint) {
          const c = constraint ? findConstraint(constraint, RangeConstraint) : null;
          if (!c) {
            return [void 0, void 0];
          }
          return [c.minValue, c.maxValue];
        }
        function estimateSuitableRange(constraint) {
          const [min, max] = findRange(constraint);
          return [min !== null && min !== void 0 ? min : 0, max !== null && max !== void 0 ? max : 100];
        }
        const NumberInputPlugin = {
          id: "input-number",
          type: "input",
          accept: (value, params) => {
            if (typeof value !== "number") {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              format: p2.optional.function,
              max: p2.optional.number,
              min: p2.optional.number,
              options: p2.optional.custom(parseListOptions),
              step: p2.optional.number
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => numberFromUnknown,
            constraint: (args) => createConstraint$4(args.params),
            writer: (_args) => writePrimitive
          },
          controller: (args) => {
            var _a, _b;
            const value = args.value;
            const c = args.constraint;
            if (c && findConstraint(c, ListConstraint)) {
              return new ListController(args.document, {
                props: ValueMap.fromObject({
                  options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
                }),
                value,
                viewProps: args.viewProps
              });
            }
            const formatter = (_b = "format" in args.params ? args.params.format : void 0) !== null && _b !== void 0 ? _b : createNumberFormatter(getSuitableDecimalDigits(c, value.rawValue));
            if (c && findConstraint(c, RangeConstraint)) {
              const [min, max] = estimateSuitableRange(c);
              return new SliderTextController(args.document, {
                baseStep: getBaseStep(c),
                parser: parseNumber,
                sliderProps: ValueMap.fromObject({
                  maxValue: max,
                  minValue: min
                }),
                textProps: ValueMap.fromObject({
                  draggingScale: getSuitableDraggingScale(c, value.rawValue),
                  formatter
                }),
                value,
                viewProps: args.viewProps
              });
            }
            return new NumberTextController(args.document, {
              baseStep: getBaseStep(c),
              parser: parseNumber,
              props: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(c, value.rawValue),
                formatter
              }),
              value,
              viewProps: args.viewProps
            });
          }
        };
        class Point2d {
          constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
          }
          getComponents() {
            return [this.x, this.y];
          }
          static isObject(obj) {
            if (isEmpty(obj)) {
              return false;
            }
            const x = obj.x;
            const y = obj.y;
            if (typeof x !== "number" || typeof y !== "number") {
              return false;
            }
            return true;
          }
          static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y
            };
          }
        }
        const Point2dAssembly = {
          toComponents: (p2) => p2.getComponents(),
          fromComponents: (comps) => new Point2d(...comps)
        };
        const className$4 = ClassName("p2d");
        class Point2dView {
          constructor(doc, config3) {
            this.element = doc.createElement("div");
            this.element.classList.add(className$4());
            config3.viewProps.bindClassModifiers(this.element);
            bindValue(config3.expanded, valueToClassName(this.element, className$4(void 0, "expanded")));
            const headElem = doc.createElement("div");
            headElem.classList.add(className$4("h"));
            this.element.appendChild(headElem);
            const buttonElem = doc.createElement("button");
            buttonElem.classList.add(className$4("b"));
            buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
            config3.viewProps.bindDisabled(buttonElem);
            headElem.appendChild(buttonElem);
            this.buttonElement = buttonElem;
            const textElem = doc.createElement("div");
            textElem.classList.add(className$4("t"));
            headElem.appendChild(textElem);
            this.textElement = textElem;
            if (config3.pickerLayout === "inline") {
              const pickerElem = doc.createElement("div");
              pickerElem.classList.add(className$4("p"));
              this.element.appendChild(pickerElem);
              this.pickerElement = pickerElem;
            } else {
              this.pickerElement = null;
            }
          }
        }
        const className$3 = ClassName("p2dp");
        class Point2dPickerView {
          constructor(doc, config3) {
            this.onFoldableChange_ = this.onFoldableChange_.bind(this);
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.invertsY_ = config3.invertsY;
            this.maxValue_ = config3.maxValue;
            this.element = doc.createElement("div");
            this.element.classList.add(className$3());
            if (config3.layout === "popup") {
              this.element.classList.add(className$3(void 0, "p"));
            }
            const padElem = doc.createElement("div");
            padElem.classList.add(className$3("p"));
            config3.viewProps.bindTabIndex(padElem);
            this.element.appendChild(padElem);
            this.padElement = padElem;
            const svgElem = doc.createElementNS(SVG_NS, "svg");
            svgElem.classList.add(className$3("g"));
            this.padElement.appendChild(svgElem);
            this.svgElem_ = svgElem;
            const xAxisElem = doc.createElementNS(SVG_NS, "line");
            xAxisElem.classList.add(className$3("ax"));
            xAxisElem.setAttributeNS(null, "x1", "0");
            xAxisElem.setAttributeNS(null, "y1", "50%");
            xAxisElem.setAttributeNS(null, "x2", "100%");
            xAxisElem.setAttributeNS(null, "y2", "50%");
            this.svgElem_.appendChild(xAxisElem);
            const yAxisElem = doc.createElementNS(SVG_NS, "line");
            yAxisElem.classList.add(className$3("ax"));
            yAxisElem.setAttributeNS(null, "x1", "50%");
            yAxisElem.setAttributeNS(null, "y1", "0");
            yAxisElem.setAttributeNS(null, "x2", "50%");
            yAxisElem.setAttributeNS(null, "y2", "100%");
            this.svgElem_.appendChild(yAxisElem);
            const lineElem = doc.createElementNS(SVG_NS, "line");
            lineElem.classList.add(className$3("l"));
            lineElem.setAttributeNS(null, "x1", "50%");
            lineElem.setAttributeNS(null, "y1", "50%");
            this.svgElem_.appendChild(lineElem);
            this.lineElem_ = lineElem;
            const markerElem = doc.createElement("div");
            markerElem.classList.add(className$3("m"));
            this.padElement.appendChild(markerElem);
            this.markerElem_ = markerElem;
            config3.value.emitter.on("change", this.onValueChange_);
            this.value = config3.value;
            this.update_();
          }
          get allFocusableElements() {
            return [this.padElement];
          }
          update_() {
            const [x, y] = this.value.rawValue.getComponents();
            const max = this.maxValue_;
            const px2 = mapRange3(x, -max, +max, 0, 100);
            const py2 = mapRange3(y, -max, +max, 0, 100);
            const ipy = this.invertsY_ ? 100 - py2 : py2;
            this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
            this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
            this.markerElem_.style.left = `${px2}%`;
            this.markerElem_.style.top = `${ipy}%`;
          }
          onValueChange_() {
            this.update_();
          }
          onFoldableChange_() {
            this.update_();
          }
        }
        function computeOffset(ev, baseSteps, invertsY) {
          return [
            getStepForKey(baseSteps[0], getHorizontalStepKeys(ev)),
            getStepForKey(baseSteps[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)
          ];
        }
        class Point2dPickerController {
          constructor(doc, config3) {
            this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
            this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
            this.onPointerDown_ = this.onPointerDown_.bind(this);
            this.onPointerMove_ = this.onPointerMove_.bind(this);
            this.onPointerUp_ = this.onPointerUp_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.baseSteps_ = config3.baseSteps;
            this.maxValue_ = config3.maxValue;
            this.invertsY_ = config3.invertsY;
            this.view = new Point2dPickerView(doc, {
              invertsY: this.invertsY_,
              layout: config3.layout,
              maxValue: this.maxValue_,
              value: this.value,
              viewProps: this.viewProps
            });
            this.ptHandler_ = new PointerHandler(this.view.padElement);
            this.ptHandler_.emitter.on("down", this.onPointerDown_);
            this.ptHandler_.emitter.on("move", this.onPointerMove_);
            this.ptHandler_.emitter.on("up", this.onPointerUp_);
            this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
            this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
          }
          handlePointerEvent_(d, opts) {
            if (!d.point) {
              return;
            }
            const max = this.maxValue_;
            const px2 = mapRange3(d.point.x, 0, d.bounds.width, -max, +max);
            const py2 = mapRange3(this.invertsY_ ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);
            this.value.setRawValue(new Point2d(px2, py2), opts);
          }
          onPointerDown_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(ev) {
            this.handlePointerEvent_(ev.data, {
              forceEmit: true,
              last: true
            });
          }
          onPadKeyDown_(ev) {
            if (isArrowKey(ev.key)) {
              ev.preventDefault();
            }
            const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
            if (dx === 0 && dy === 0) {
              return;
            }
            this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
              forceEmit: false,
              last: false
            });
          }
          onPadKeyUp_(ev) {
            const [dx, dy] = computeOffset(ev, this.baseSteps_, this.invertsY_);
            if (dx === 0 && dy === 0) {
              return;
            }
            this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        class Point2dController {
          constructor(doc, config3) {
            var _a, _b;
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
            this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
            this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
            this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.foldable_ = Foldable.create(config3.expanded);
            this.popC_ = config3.pickerLayout === "popup" ? new PopupController(doc, {
              viewProps: this.viewProps
            }) : null;
            const padC = new Point2dPickerController(doc, {
              baseSteps: [config3.axes[0].baseStep, config3.axes[1].baseStep],
              invertsY: config3.invertsY,
              layout: config3.pickerLayout,
              maxValue: config3.maxValue,
              value: this.value,
              viewProps: this.viewProps
            });
            padC.view.allFocusableElements.forEach((elem) => {
              elem.addEventListener("blur", this.onPopupChildBlur_);
              elem.addEventListener("keydown", this.onPopupChildKeydown_);
            });
            this.pickerC_ = padC;
            this.textC_ = new PointNdTextController(doc, {
              assembly: Point2dAssembly,
              axes: config3.axes,
              parser: config3.parser,
              value: this.value,
              viewProps: this.viewProps
            });
            this.view = new Point2dView(doc, {
              expanded: this.foldable_.value("expanded"),
              pickerLayout: config3.pickerLayout,
              viewProps: this.viewProps
            });
            this.view.textElement.appendChild(this.textC_.view.element);
            (_a = this.view.buttonElement) === null || _a === void 0 ? void 0 : _a.addEventListener("blur", this.onPadButtonBlur_);
            (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener("click", this.onPadButtonClick_);
            if (this.popC_) {
              this.view.element.appendChild(this.popC_.view.element);
              this.popC_.view.element.appendChild(this.pickerC_.view.element);
              connectValues({
                primary: this.foldable_.value("expanded"),
                secondary: this.popC_.shows,
                forward: (p2) => p2.rawValue,
                backward: (_, s) => s.rawValue
              });
            } else if (this.view.pickerElement) {
              this.view.pickerElement.appendChild(this.pickerC_.view.element);
              bindFoldable(this.foldable_, this.view.pickerElement);
            }
          }
          onPadButtonBlur_(e) {
            if (!this.popC_) {
              return;
            }
            const elem = this.view.element;
            const nextTarget = forceCast(e.relatedTarget);
            if (!nextTarget || !elem.contains(nextTarget)) {
              this.popC_.shows.rawValue = false;
            }
          }
          onPadButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded"));
            if (this.foldable_.get("expanded")) {
              this.pickerC_.view.allFocusableElements[0].focus();
            }
          }
          onPopupChildBlur_(ev) {
            if (!this.popC_) {
              return;
            }
            const elem = this.popC_.view.element;
            const nextTarget = findNextTarget(ev);
            if (nextTarget && elem.contains(nextTarget)) {
              return;
            }
            if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
              return;
            }
            this.popC_.shows.rawValue = false;
          }
          onPopupChildKeydown_(ev) {
            if (this.popC_) {
              if (ev.key === "Escape") {
                this.popC_.shows.rawValue = false;
              }
            } else if (this.view.pickerElement) {
              if (ev.key === "Escape") {
                this.view.buttonElement.focus();
              }
            }
          }
        }
        function point2dFromUnknown(value) {
          return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
        }
        function writePoint2d(target, value) {
          target.writeProperty("x", value.x);
          target.writeProperty("y", value.y);
        }
        function createDimensionConstraint$2(params) {
          if (!params) {
            return void 0;
          }
          const constraints = [];
          if (!isEmpty(params.step)) {
            constraints.push(new StepConstraint(params.step));
          }
          if (!isEmpty(params.max) || !isEmpty(params.min)) {
            constraints.push(new RangeConstraint({
              max: params.max,
              min: params.min
            }));
          }
          return new CompositeConstraint(constraints);
        }
        function createConstraint$3(params) {
          return new PointNdConstraint({
            assembly: Point2dAssembly,
            components: [
              createDimensionConstraint$2("x" in params ? params.x : void 0),
              createDimensionConstraint$2("y" in params ? params.y : void 0)
            ]
          });
        }
        function getSuitableMaxDimensionValue(constraint, rawValue) {
          const rc = constraint && findConstraint(constraint, RangeConstraint);
          if (rc) {
            return Math.max(Math.abs(rc.minValue || 0), Math.abs(rc.maxValue || 0));
          }
          const step = getBaseStep(constraint);
          return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
        }
        function getSuitableMaxValue(initialValue, constraint) {
          const xc = constraint instanceof PointNdConstraint ? constraint.components[0] : void 0;
          const yc = constraint instanceof PointNdConstraint ? constraint.components[1] : void 0;
          const xr = getSuitableMaxDimensionValue(xc, initialValue.x);
          const yr = getSuitableMaxDimensionValue(yc, initialValue.y);
          return Math.max(xr, yr);
        }
        function createAxis$2(initialValue, constraint) {
          return {
            baseStep: getBaseStep(constraint),
            constraint,
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(constraint, initialValue),
              formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
            })
          };
        }
        function shouldInvertY(params) {
          if (!("y" in params)) {
            return false;
          }
          const yParams = params.y;
          if (!yParams) {
            return false;
          }
          return "inverted" in yParams ? !!yParams.inverted : false;
        }
        const Point2dInputPlugin = {
          id: "input-point2d",
          type: "input",
          accept: (value, params) => {
            if (!Point2d.isObject(value)) {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              expanded: p2.optional.boolean,
              picker: p2.optional.custom(parsePickerLayout),
              x: p2.optional.custom(parsePointDimensionParams),
              y: p2.optional.object({
                inverted: p2.optional.boolean,
                max: p2.optional.number,
                min: p2.optional.number,
                step: p2.optional.number
              })
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => point2dFromUnknown,
            constraint: (args) => createConstraint$3(args.params),
            equals: Point2d.equals,
            writer: (_args) => writePoint2d
          },
          controller: (args) => {
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
              throw TpError.shouldNeverHappen();
            }
            const expanded = "expanded" in args.params ? args.params.expanded : void 0;
            const picker = "picker" in args.params ? args.params.picker : void 0;
            return new Point2dController(doc, {
              axes: [
                createAxis$2(value.rawValue.x, c.components[0]),
                createAxis$2(value.rawValue.y, c.components[1])
              ],
              expanded: expanded !== null && expanded !== void 0 ? expanded : false,
              invertsY: shouldInvertY(args.params),
              maxValue: getSuitableMaxValue(value.rawValue, c),
              parser: parseNumber,
              pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
              value,
              viewProps: args.viewProps
            });
          }
        };
        class Point3d {
          constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
          }
          getComponents() {
            return [this.x, this.y, this.z];
          }
          static isObject(obj) {
            if (isEmpty(obj)) {
              return false;
            }
            const x = obj.x;
            const y = obj.y;
            const z = obj.z;
            if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number") {
              return false;
            }
            return true;
          }
          static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z
            };
          }
        }
        const Point3dAssembly = {
          toComponents: (p2) => p2.getComponents(),
          fromComponents: (comps) => new Point3d(...comps)
        };
        function point3dFromUnknown(value) {
          return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d();
        }
        function writePoint3d(target, value) {
          target.writeProperty("x", value.x);
          target.writeProperty("y", value.y);
          target.writeProperty("z", value.z);
        }
        function createDimensionConstraint$1(params) {
          if (!params) {
            return void 0;
          }
          const constraints = [];
          if (!isEmpty(params.step)) {
            constraints.push(new StepConstraint(params.step));
          }
          if (!isEmpty(params.max) || !isEmpty(params.min)) {
            constraints.push(new RangeConstraint({
              max: params.max,
              min: params.min
            }));
          }
          return new CompositeConstraint(constraints);
        }
        function createConstraint$2(params) {
          return new PointNdConstraint({
            assembly: Point3dAssembly,
            components: [
              createDimensionConstraint$1("x" in params ? params.x : void 0),
              createDimensionConstraint$1("y" in params ? params.y : void 0),
              createDimensionConstraint$1("z" in params ? params.z : void 0)
            ]
          });
        }
        function createAxis$1(initialValue, constraint) {
          return {
            baseStep: getBaseStep(constraint),
            constraint,
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(constraint, initialValue),
              formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
            })
          };
        }
        const Point3dInputPlugin = {
          id: "input-point3d",
          type: "input",
          accept: (value, params) => {
            if (!Point3d.isObject(value)) {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              x: p2.optional.custom(parsePointDimensionParams),
              y: p2.optional.custom(parsePointDimensionParams),
              z: p2.optional.custom(parsePointDimensionParams)
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => point3dFromUnknown,
            constraint: (args) => createConstraint$2(args.params),
            equals: Point3d.equals,
            writer: (_args) => writePoint3d
          },
          controller: (args) => {
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
              throw TpError.shouldNeverHappen();
            }
            return new PointNdTextController(args.document, {
              assembly: Point3dAssembly,
              axes: [
                createAxis$1(value.rawValue.x, c.components[0]),
                createAxis$1(value.rawValue.y, c.components[1]),
                createAxis$1(value.rawValue.z, c.components[2])
              ],
              parser: parseNumber,
              value,
              viewProps: args.viewProps
            });
          }
        };
        class Point4d {
          constructor(x = 0, y = 0, z = 0, w = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
          }
          getComponents() {
            return [this.x, this.y, this.z, this.w];
          }
          static isObject(obj) {
            if (isEmpty(obj)) {
              return false;
            }
            const x = obj.x;
            const y = obj.y;
            const z = obj.z;
            const w = obj.w;
            if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number" || typeof w !== "number") {
              return false;
            }
            return true;
          }
          static equals(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z,
              w: this.w
            };
          }
        }
        const Point4dAssembly = {
          toComponents: (p2) => p2.getComponents(),
          fromComponents: (comps) => new Point4d(...comps)
        };
        function point4dFromUnknown(value) {
          return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
        }
        function writePoint4d(target, value) {
          target.writeProperty("x", value.x);
          target.writeProperty("y", value.y);
          target.writeProperty("z", value.z);
          target.writeProperty("w", value.w);
        }
        function createDimensionConstraint(params) {
          if (!params) {
            return void 0;
          }
          const constraints = [];
          if (!isEmpty(params.step)) {
            constraints.push(new StepConstraint(params.step));
          }
          if (!isEmpty(params.max) || !isEmpty(params.min)) {
            constraints.push(new RangeConstraint({
              max: params.max,
              min: params.min
            }));
          }
          return new CompositeConstraint(constraints);
        }
        function createConstraint$1(params) {
          return new PointNdConstraint({
            assembly: Point4dAssembly,
            components: [
              createDimensionConstraint("x" in params ? params.x : void 0),
              createDimensionConstraint("y" in params ? params.y : void 0),
              createDimensionConstraint("z" in params ? params.z : void 0),
              createDimensionConstraint("w" in params ? params.w : void 0)
            ]
          });
        }
        function createAxis(initialValue, constraint) {
          return {
            baseStep: getBaseStep(constraint),
            constraint,
            textProps: ValueMap.fromObject({
              draggingScale: getSuitableDraggingScale(constraint, initialValue),
              formatter: createNumberFormatter(getSuitableDecimalDigits(constraint, initialValue))
            })
          };
        }
        const Point4dInputPlugin = {
          id: "input-point4d",
          type: "input",
          accept: (value, params) => {
            if (!Point4d.isObject(value)) {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              x: p2.optional.custom(parsePointDimensionParams),
              y: p2.optional.custom(parsePointDimensionParams),
              z: p2.optional.custom(parsePointDimensionParams),
              w: p2.optional.custom(parsePointDimensionParams)
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => point4dFromUnknown,
            constraint: (args) => createConstraint$1(args.params),
            equals: Point4d.equals,
            writer: (_args) => writePoint4d
          },
          controller: (args) => {
            const value = args.value;
            const c = args.constraint;
            if (!(c instanceof PointNdConstraint)) {
              throw TpError.shouldNeverHappen();
            }
            return new PointNdTextController(args.document, {
              assembly: Point4dAssembly,
              axes: value.rawValue.getComponents().map((comp, index) => createAxis(comp, c.components[index])),
              parser: parseNumber,
              value,
              viewProps: args.viewProps
            });
          }
        };
        function createConstraint(params) {
          const constraints = [];
          const lc = createListConstraint(params.options);
          if (lc) {
            constraints.push(lc);
          }
          return new CompositeConstraint(constraints);
        }
        const StringInputPlugin = {
          id: "input-string",
          type: "input",
          accept: (value, params) => {
            if (typeof value !== "string") {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              options: p2.optional.custom(parseListOptions)
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => stringFromUnknown,
            constraint: (args) => createConstraint(args.params),
            writer: (_args) => writePrimitive
          },
          controller: (args) => {
            var _a;
            const doc = args.document;
            const value = args.value;
            const c = args.constraint;
            if (c && findConstraint(c, ListConstraint)) {
              return new ListController(doc, {
                props: ValueMap.fromObject({
                  options: (_a = findListItems(c)) !== null && _a !== void 0 ? _a : []
                }),
                value,
                viewProps: args.viewProps
              });
            }
            return new TextController(doc, {
              parser: (v) => v,
              props: ValueMap.fromObject({
                formatter: formatString
              }),
              value,
              viewProps: args.viewProps
            });
          }
        };
        const Constants = {
          monitor: {
            defaultInterval: 200,
            defaultLineCount: 3
          }
        };
        const className$2 = ClassName("mll");
        class MultiLogView {
          constructor(doc, config3) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.formatter_ = config3.formatter;
            this.element = doc.createElement("div");
            this.element.classList.add(className$2());
            config3.viewProps.bindClassModifiers(this.element);
            const textareaElem = doc.createElement("textarea");
            textareaElem.classList.add(className$2("i"));
            textareaElem.style.height = `calc(var(--bld-us) * ${config3.lineCount})`;
            textareaElem.readOnly = true;
            config3.viewProps.bindDisabled(textareaElem);
            this.element.appendChild(textareaElem);
            this.textareaElem_ = textareaElem;
            config3.value.emitter.on("change", this.onValueUpdate_);
            this.value = config3.value;
            this.update_();
          }
          update_() {
            const elem = this.textareaElem_;
            const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
            const lines = [];
            this.value.rawValue.forEach((value) => {
              if (value !== void 0) {
                lines.push(this.formatter_(value));
              }
            });
            elem.textContent = lines.join("\n");
            if (shouldScroll) {
              elem.scrollTop = elem.scrollHeight;
            }
          }
          onValueUpdate_() {
            this.update_();
          }
        }
        class MultiLogController {
          constructor(doc, config3) {
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new MultiLogView(doc, {
              formatter: config3.formatter,
              lineCount: config3.lineCount,
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        const className$1 = ClassName("sgl");
        class SingleLogView {
          constructor(doc, config3) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.formatter_ = config3.formatter;
            this.element = doc.createElement("div");
            this.element.classList.add(className$1());
            config3.viewProps.bindClassModifiers(this.element);
            const inputElem = doc.createElement("input");
            inputElem.classList.add(className$1("i"));
            inputElem.readOnly = true;
            inputElem.type = "text";
            config3.viewProps.bindDisabled(inputElem);
            this.element.appendChild(inputElem);
            this.inputElement = inputElem;
            config3.value.emitter.on("change", this.onValueUpdate_);
            this.value = config3.value;
            this.update_();
          }
          update_() {
            const values = this.value.rawValue;
            const lastValue = values[values.length - 1];
            this.inputElement.value = lastValue !== void 0 ? this.formatter_(lastValue) : "";
          }
          onValueUpdate_() {
            this.update_();
          }
        }
        class SingleLogController {
          constructor(doc, config3) {
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.view = new SingleLogView(doc, {
              formatter: config3.formatter,
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        const BooleanMonitorPlugin = {
          id: "monitor-bool",
          type: "monitor",
          accept: (value, params) => {
            if (typeof value !== "boolean") {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              lineCount: p2.optional.number
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => boolFromUnknown
          },
          controller: (args) => {
            var _a;
            if (args.value.rawValue.length === 1) {
              return new SingleLogController(args.document, {
                formatter: BooleanFormatter,
                value: args.value,
                viewProps: args.viewProps
              });
            }
            return new MultiLogController(args.document, {
              formatter: BooleanFormatter,
              lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
              value: args.value,
              viewProps: args.viewProps
            });
          }
        };
        class GraphCursor {
          constructor() {
            this.emitter = new Emitter2();
            this.index_ = -1;
          }
          get index() {
            return this.index_;
          }
          set index(index) {
            const changed = this.index_ !== index;
            if (changed) {
              this.index_ = index;
              this.emitter.emit("change", {
                index,
                sender: this
              });
            }
          }
        }
        const className = ClassName("grl");
        class GraphLogView {
          constructor(doc, config3) {
            this.onCursorChange_ = this.onCursorChange_.bind(this);
            this.onValueUpdate_ = this.onValueUpdate_.bind(this);
            this.element = doc.createElement("div");
            this.element.classList.add(className());
            config3.viewProps.bindClassModifiers(this.element);
            this.formatter_ = config3.formatter;
            this.minValue_ = config3.minValue;
            this.maxValue_ = config3.maxValue;
            this.cursor_ = config3.cursor;
            this.cursor_.emitter.on("change", this.onCursorChange_);
            const svgElem = doc.createElementNS(SVG_NS, "svg");
            svgElem.classList.add(className("g"));
            svgElem.style.height = `calc(var(--bld-us) * ${config3.lineCount})`;
            this.element.appendChild(svgElem);
            this.svgElem_ = svgElem;
            const lineElem = doc.createElementNS(SVG_NS, "polyline");
            this.svgElem_.appendChild(lineElem);
            this.lineElem_ = lineElem;
            const tooltipElem = doc.createElement("div");
            tooltipElem.classList.add(className("t"), ClassName("tt")());
            this.element.appendChild(tooltipElem);
            this.tooltipElem_ = tooltipElem;
            config3.value.emitter.on("change", this.onValueUpdate_);
            this.value = config3.value;
            this.update_();
          }
          get graphElement() {
            return this.svgElem_;
          }
          update_() {
            const bounds = this.svgElem_.getBoundingClientRect();
            const maxIndex = this.value.rawValue.length - 1;
            const min = this.minValue_;
            const max = this.maxValue_;
            const points = [];
            this.value.rawValue.forEach((v, index) => {
              if (v === void 0) {
                return;
              }
              const x = mapRange3(index, 0, maxIndex, 0, bounds.width);
              const y = mapRange3(v, min, max, bounds.height, 0);
              points.push([x, y].join(","));
            });
            this.lineElem_.setAttributeNS(null, "points", points.join(" "));
            const tooltipElem = this.tooltipElem_;
            const value = this.value.rawValue[this.cursor_.index];
            if (value === void 0) {
              tooltipElem.classList.remove(className("t", "a"));
              return;
            }
            const tx = mapRange3(this.cursor_.index, 0, maxIndex, 0, bounds.width);
            const ty = mapRange3(value, min, max, bounds.height, 0);
            tooltipElem.style.left = `${tx}px`;
            tooltipElem.style.top = `${ty}px`;
            tooltipElem.textContent = `${this.formatter_(value)}`;
            if (!tooltipElem.classList.contains(className("t", "a"))) {
              tooltipElem.classList.add(className("t", "a"), className("t", "in"));
              forceReflow(tooltipElem);
              tooltipElem.classList.remove(className("t", "in"));
            }
          }
          onValueUpdate_() {
            this.update_();
          }
          onCursorChange_() {
            this.update_();
          }
        }
        class GraphLogController {
          constructor(doc, config3) {
            this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
            this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
            this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
            this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
            this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
            this.value = config3.value;
            this.viewProps = config3.viewProps;
            this.cursor_ = new GraphCursor();
            this.view = new GraphLogView(doc, {
              cursor: this.cursor_,
              formatter: config3.formatter,
              lineCount: config3.lineCount,
              maxValue: config3.maxValue,
              minValue: config3.minValue,
              value: this.value,
              viewProps: this.viewProps
            });
            if (!supportsTouch(doc)) {
              this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
              this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
            } else {
              const ph = new PointerHandler(this.view.element);
              ph.emitter.on("down", this.onGraphPointerDown_);
              ph.emitter.on("move", this.onGraphPointerMove_);
              ph.emitter.on("up", this.onGraphPointerUp_);
            }
          }
          onGraphMouseLeave_() {
            this.cursor_.index = -1;
          }
          onGraphMouseMove_(ev) {
            const bounds = this.view.element.getBoundingClientRect();
            this.cursor_.index = Math.floor(mapRange3(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
          }
          onGraphPointerDown_(ev) {
            this.onGraphPointerMove_(ev);
          }
          onGraphPointerMove_(ev) {
            if (!ev.data.point) {
              this.cursor_.index = -1;
              return;
            }
            this.cursor_.index = Math.floor(mapRange3(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
          }
          onGraphPointerUp_() {
            this.cursor_.index = -1;
          }
        }
        function createFormatter(params) {
          return "format" in params && !isEmpty(params.format) ? params.format : createNumberFormatter(2);
        }
        function createTextMonitor(args) {
          var _a;
          if (args.value.rawValue.length === 1) {
            return new SingleLogController(args.document, {
              formatter: createFormatter(args.params),
              value: args.value,
              viewProps: args.viewProps
            });
          }
          return new MultiLogController(args.document, {
            formatter: createFormatter(args.params),
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            value: args.value,
            viewProps: args.viewProps
          });
        }
        function createGraphMonitor(args) {
          var _a, _b, _c;
          return new GraphLogController(args.document, {
            formatter: createFormatter(args.params),
            lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
            maxValue: (_b = "max" in args.params ? args.params.max : null) !== null && _b !== void 0 ? _b : 100,
            minValue: (_c = "min" in args.params ? args.params.min : null) !== null && _c !== void 0 ? _c : 0,
            value: args.value,
            viewProps: args.viewProps
          });
        }
        function shouldShowGraph(params) {
          return "view" in params && params.view === "graph";
        }
        const NumberMonitorPlugin = {
          id: "monitor-number",
          type: "monitor",
          accept: (value, params) => {
            if (typeof value !== "number") {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              format: p2.optional.function,
              lineCount: p2.optional.number,
              max: p2.optional.number,
              min: p2.optional.number,
              view: p2.optional.string
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,
            reader: (_args) => numberFromUnknown
          },
          controller: (args) => {
            if (shouldShowGraph(args.params)) {
              return createGraphMonitor(args);
            }
            return createTextMonitor(args);
          }
        };
        const StringMonitorPlugin = {
          id: "monitor-string",
          type: "monitor",
          accept: (value, params) => {
            if (typeof value !== "string") {
              return null;
            }
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              lineCount: p2.optional.number,
              multiline: p2.optional.boolean
            });
            return result ? {
              initialValue: value,
              params: result
            } : null;
          },
          binding: {
            reader: (_args) => stringFromUnknown
          },
          controller: (args) => {
            var _a;
            const value = args.value;
            const multiline = value.rawValue.length > 1 || "multiline" in args.params && args.params.multiline;
            if (multiline) {
              return new MultiLogController(args.document, {
                formatter: formatString,
                lineCount: (_a = args.params.lineCount) !== null && _a !== void 0 ? _a : Constants.monitor.defaultLineCount,
                value,
                viewProps: args.viewProps
              });
            }
            return new SingleLogController(args.document, {
              formatter: formatString,
              value,
              viewProps: args.viewProps
            });
          }
        };
        class InputBinding {
          constructor(config3) {
            this.onValueChange_ = this.onValueChange_.bind(this);
            this.reader = config3.reader;
            this.writer = config3.writer;
            this.emitter = new Emitter2();
            this.value = config3.value;
            this.value.emitter.on("change", this.onValueChange_);
            this.target = config3.target;
            this.read();
          }
          read() {
            const targetValue = this.target.read();
            if (targetValue !== void 0) {
              this.value.rawValue = this.reader(targetValue);
            }
          }
          write_(rawValue) {
            this.writer(this.target, rawValue);
          }
          onValueChange_(ev) {
            this.write_(ev.rawValue);
            this.emitter.emit("change", {
              options: ev.options,
              rawValue: ev.rawValue,
              sender: this
            });
          }
        }
        function createInputBindingController(plugin, args) {
          const result = plugin.accept(args.target.read(), args.params);
          if (isEmpty(result)) {
            return null;
          }
          const p2 = ParamsParsers;
          const valueArgs = {
            target: args.target,
            initialValue: result.initialValue,
            params: result.params
          };
          const reader = plugin.binding.reader(valueArgs);
          const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : void 0;
          const value = createValue(reader(result.initialValue), {
            constraint,
            equals: plugin.binding.equals
          });
          const binding = new InputBinding({
            reader,
            target: args.target,
            value,
            writer: plugin.binding.writer(valueArgs)
          });
          const disabled = p2.optional.boolean(args.params.disabled).value;
          const hidden = p2.optional.boolean(args.params.hidden).value;
          const controller = plugin.controller({
            constraint,
            document: args.document,
            initialValue: result.initialValue,
            params: result.params,
            value: binding.value,
            viewProps: ViewProps.create({
              disabled,
              hidden
            })
          });
          const label = p2.optional.string(args.params.label).value;
          return new InputBindingController(args.document, {
            binding,
            blade: createBlade(),
            props: ValueMap.fromObject({
              label: label || args.target.key
            }),
            valueController: controller
          });
        }
        class MonitorBinding {
          constructor(config3) {
            this.onTick_ = this.onTick_.bind(this);
            this.reader_ = config3.reader;
            this.target = config3.target;
            this.emitter = new Emitter2();
            this.value = config3.value;
            this.ticker = config3.ticker;
            this.ticker.emitter.on("tick", this.onTick_);
            this.read();
          }
          dispose() {
            this.ticker.dispose();
          }
          read() {
            const targetValue = this.target.read();
            if (targetValue === void 0) {
              return;
            }
            const buffer = this.value.rawValue;
            const newValue = this.reader_(targetValue);
            this.value.rawValue = createPushedBuffer(buffer, newValue);
            this.emitter.emit("update", {
              rawValue: newValue,
              sender: this
            });
          }
          onTick_(_) {
            this.read();
          }
        }
        function createTicker(document2, interval) {
          return interval === 0 ? new ManualTicker() : new IntervalTicker(document2, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
        }
        function createMonitorBindingController(plugin, args) {
          var _a, _b, _c;
          const P = ParamsParsers;
          const result = plugin.accept(args.target.read(), args.params);
          if (isEmpty(result)) {
            return null;
          }
          const bindingArgs = {
            target: args.target,
            initialValue: result.initialValue,
            params: result.params
          };
          const reader = plugin.binding.reader(bindingArgs);
          const bufferSize = (_b = (_a = P.optional.number(args.params.bufferSize).value) !== null && _a !== void 0 ? _a : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b !== void 0 ? _b : 1;
          const interval = P.optional.number(args.params.interval).value;
          const binding = new MonitorBinding({
            reader,
            target: args.target,
            ticker: createTicker(args.document, interval),
            value: initializeBuffer(bufferSize)
          });
          const disabled = P.optional.boolean(args.params.disabled).value;
          const hidden = P.optional.boolean(args.params.hidden).value;
          const controller = plugin.controller({
            document: args.document,
            params: result.params,
            value: binding.value,
            viewProps: ViewProps.create({
              disabled,
              hidden
            })
          });
          const label = (_c = P.optional.string(args.params.label).value) !== null && _c !== void 0 ? _c : args.target.key;
          return new MonitorBindingController(args.document, {
            binding,
            blade: createBlade(),
            props: ValueMap.fromObject({
              label
            }),
            valueController: controller
          });
        }
        class PluginPool {
          constructor() {
            this.pluginsMap_ = {
              blades: [],
              inputs: [],
              monitors: []
            };
          }
          getAll() {
            return [
              ...this.pluginsMap_.blades,
              ...this.pluginsMap_.inputs,
              ...this.pluginsMap_.monitors
            ];
          }
          register(r) {
            if (r.type === "blade") {
              this.pluginsMap_.blades.unshift(r);
            } else if (r.type === "input") {
              this.pluginsMap_.inputs.unshift(r);
            } else if (r.type === "monitor") {
              this.pluginsMap_.monitors.unshift(r);
            }
          }
          createInput(document2, target, params) {
            const initialValue = target.read();
            if (isEmpty(initialValue)) {
              throw new TpError({
                context: {
                  key: target.key
                },
                type: "nomatchingcontroller"
              });
            }
            const bc = this.pluginsMap_.inputs.reduce((result, plugin) => result || createInputBindingController(plugin, {
              document: document2,
              target,
              params
            }), null);
            if (bc) {
              return bc;
            }
            throw new TpError({
              context: {
                key: target.key
              },
              type: "nomatchingcontroller"
            });
          }
          createMonitor(document2, target, params) {
            const bc = this.pluginsMap_.monitors.reduce((result, plugin) => result || createMonitorBindingController(plugin, {
              document: document2,
              params,
              target
            }), null);
            if (bc) {
              return bc;
            }
            throw new TpError({
              context: {
                key: target.key
              },
              type: "nomatchingcontroller"
            });
          }
          createBlade(document2, params) {
            const bc = this.pluginsMap_.blades.reduce((result, plugin) => result || createBladeController(plugin, {
              document: document2,
              params
            }), null);
            if (!bc) {
              throw new TpError({
                type: "nomatchingview",
                context: {
                  params
                }
              });
            }
            return bc;
          }
          createBladeApi(bc) {
            if (bc instanceof InputBindingController) {
              return new InputBindingApi(bc);
            }
            if (bc instanceof MonitorBindingController) {
              return new MonitorBindingApi(bc);
            }
            if (bc instanceof RackController) {
              return new RackApi(bc, this);
            }
            const api = this.pluginsMap_.blades.reduce((result, plugin) => result || plugin.api({
              controller: bc,
              pool: this
            }), null);
            if (!api) {
              throw TpError.shouldNeverHappen();
            }
            return api;
          }
        }
        function createDefaultPluginPool() {
          const pool = new PluginPool();
          [
            Point2dInputPlugin,
            Point3dInputPlugin,
            Point4dInputPlugin,
            StringInputPlugin,
            NumberInputPlugin,
            StringColorInputPlugin,
            ObjectColorInputPlugin,
            NumberColorInputPlugin,
            BooleanInputPlugin,
            BooleanMonitorPlugin,
            StringMonitorPlugin,
            NumberMonitorPlugin,
            ButtonBladePlugin,
            FolderBladePlugin,
            SeparatorBladePlugin,
            TabBladePlugin
          ].forEach((p2) => {
            pool.register(p2);
          });
          return pool;
        }
        class ListApi extends BladeApi {
          constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter2();
            this.controller_.valueController.value.emitter.on("change", (ev) => {
              this.emitter_.emit("change", {
                event: new TpChangeEvent(this, ev.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(label) {
            this.controller_.props.set("label", label);
          }
          get options() {
            return this.controller_.valueController.props.get("options");
          }
          set options(options) {
            this.controller_.valueController.props.set("options", options);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(value) {
            this.controller_.valueController.value.rawValue = value;
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
        }
        class SliderApi extends BladeApi {
          constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter2();
            this.controller_.valueController.value.emitter.on("change", (ev) => {
              this.emitter_.emit("change", {
                event: new TpChangeEvent(this, ev.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(label) {
            this.controller_.props.set("label", label);
          }
          get maxValue() {
            return this.controller_.valueController.sliderController.props.get("maxValue");
          }
          set maxValue(maxValue) {
            this.controller_.valueController.sliderController.props.set("maxValue", maxValue);
          }
          get minValue() {
            return this.controller_.valueController.sliderController.props.get("minValue");
          }
          set minValue(minValue) {
            this.controller_.valueController.sliderController.props.set("minValue", minValue);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(value) {
            this.controller_.valueController.value.rawValue = value;
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
        }
        class TextApi extends BladeApi {
          constructor(controller) {
            super(controller);
            this.emitter_ = new Emitter2();
            this.controller_.valueController.value.emitter.on("change", (ev) => {
              this.emitter_.emit("change", {
                event: new TpChangeEvent(this, ev.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(label) {
            this.controller_.props.set("label", label);
          }
          get formatter() {
            return this.controller_.valueController.props.get("formatter");
          }
          set formatter(formatter) {
            this.controller_.valueController.props.set("formatter", formatter);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(value) {
            this.controller_.valueController.value.rawValue = value;
          }
          on(eventName, handler) {
            const bh = handler.bind(this);
            this.emitter_.on(eventName, (ev) => {
              bh(ev.event);
            });
            return this;
          }
        }
        const ListBladePlugin = function() {
          return {
            id: "list",
            type: "blade",
            accept(params) {
              const p2 = ParamsParsers;
              const result = parseParams(params, {
                options: p2.required.custom(parseListOptions),
                value: p2.required.raw,
                view: p2.required.constant("list"),
                label: p2.optional.string
              });
              return result ? { params: result } : null;
            },
            controller(args) {
              const ic = new ListController(args.document, {
                props: ValueMap.fromObject({
                  options: normalizeListOptions(args.params.options)
                }),
                value: createValue(args.params.value),
                viewProps: args.viewProps
              });
              return new LabeledValueController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                  label: args.params.label
                }),
                valueController: ic
              });
            },
            api(args) {
              if (!(args.controller instanceof LabeledValueController)) {
                return null;
              }
              if (!(args.controller.valueController instanceof ListController)) {
                return null;
              }
              return new ListApi(args.controller);
            }
          };
        }();
        function exportPresetJson(targets) {
          return targets.reduce((result, target) => {
            return Object.assign(result, {
              [target.presetKey]: target.read()
            });
          }, {});
        }
        function importPresetJson(targets, preset) {
          targets.forEach((target) => {
            const value = preset[target.presetKey];
            if (value !== void 0) {
              target.write(value);
            }
          });
        }
        class RootApi extends FolderApi {
          constructor(controller, pool) {
            super(controller, pool);
          }
          get element() {
            return this.controller_.view.element;
          }
          importPreset(preset) {
            const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
              return ibc.binding.target;
            });
            importPresetJson(targets, preset);
            this.refresh();
          }
          exportPreset() {
            const targets = this.controller_.rackController.rack.find(InputBindingController).map((ibc) => {
              return ibc.binding.target;
            });
            return exportPresetJson(targets);
          }
          refresh() {
            this.controller_.rackController.rack.find(InputBindingController).forEach((ibc) => {
              ibc.binding.read();
            });
            this.controller_.rackController.rack.find(MonitorBindingController).forEach((mbc) => {
              mbc.binding.read();
            });
          }
        }
        class RootController extends FolderController {
          constructor(doc, config3) {
            super(doc, {
              expanded: config3.expanded,
              blade: config3.blade,
              props: config3.props,
              root: true,
              viewProps: config3.viewProps
            });
          }
        }
        const SliderBladePlugin = {
          id: "slider",
          type: "blade",
          accept(params) {
            const p2 = ParamsParsers;
            const result = parseParams(params, {
              max: p2.required.number,
              min: p2.required.number,
              view: p2.required.constant("slider"),
              format: p2.optional.function,
              label: p2.optional.string,
              value: p2.optional.number
            });
            return result ? { params: result } : null;
          },
          controller(args) {
            var _a, _b;
            const v = (_a = args.params.value) !== null && _a !== void 0 ? _a : 0;
            const vc = new SliderTextController(args.document, {
              baseStep: 1,
              parser: parseNumber,
              sliderProps: ValueMap.fromObject({
                maxValue: args.params.max,
                minValue: args.params.min
              }),
              textProps: ValueMap.fromObject({
                draggingScale: getSuitableDraggingScale(void 0, v),
                formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString
              }),
              value: createValue(v),
              viewProps: args.viewProps
            });
            return new LabeledValueController(args.document, {
              blade: args.blade,
              props: ValueMap.fromObject({
                label: args.params.label
              }),
              valueController: vc
            });
          },
          api(args) {
            if (!(args.controller instanceof LabeledValueController)) {
              return null;
            }
            if (!(args.controller.valueController instanceof SliderTextController)) {
              return null;
            }
            return new SliderApi(args.controller);
          }
        };
        const TextBladePlugin = function() {
          return {
            id: "text",
            type: "blade",
            accept(params) {
              const p2 = ParamsParsers;
              const result = parseParams(params, {
                parse: p2.required.function,
                value: p2.required.raw,
                view: p2.required.constant("text"),
                format: p2.optional.function,
                label: p2.optional.string
              });
              return result ? { params: result } : null;
            },
            controller(args) {
              var _a;
              const ic = new TextController(args.document, {
                parser: args.params.parse,
                props: ValueMap.fromObject({
                  formatter: (_a = args.params.format) !== null && _a !== void 0 ? _a : (v) => String(v)
                }),
                value: createValue(args.params.value),
                viewProps: args.viewProps
              });
              return new LabeledValueController(args.document, {
                blade: args.blade,
                props: ValueMap.fromObject({
                  label: args.params.label
                }),
                valueController: ic
              });
            },
            api(args) {
              if (!(args.controller instanceof LabeledValueController)) {
                return null;
              }
              if (!(args.controller.valueController instanceof TextController)) {
                return null;
              }
              return new TextApi(args.controller);
            }
          };
        }();
        function createDefaultWrapperElement(doc) {
          const elem = doc.createElement("div");
          elem.classList.add(ClassName("dfw")());
          if (doc.body) {
            doc.body.appendChild(elem);
          }
          return elem;
        }
        function embedStyle(doc, id, css) {
          if (doc.querySelector(`style[data-tp-style=${id}]`)) {
            return;
          }
          const styleElem = doc.createElement("style");
          styleElem.dataset.tpStyle = id;
          styleElem.textContent = css;
          doc.head.appendChild(styleElem);
        }
        class Pane3 extends RootApi {
          constructor(opt_config) {
            var _a;
            const config3 = opt_config || {};
            const doc = (_a = config3.document) !== null && _a !== void 0 ? _a : getWindowDocument();
            const pool = createDefaultPluginPool();
            const rootController = new RootController(doc, {
              expanded: config3.expanded,
              blade: createBlade(),
              props: ValueMap.fromObject({
                title: config3.title
              }),
              viewProps: ViewProps.create()
            });
            super(rootController, pool);
            this.pool_ = pool;
            this.containerElem_ = config3.container || createDefaultWrapperElement(doc);
            this.containerElem_.appendChild(this.element);
            this.doc_ = doc;
            this.usesDefaultWrapper_ = !config3.container;
            this.setUpDefaultPlugins_();
          }
          get document() {
            if (!this.doc_) {
              throw TpError.alreadyDisposed();
            }
            return this.doc_;
          }
          dispose() {
            const containerElem = this.containerElem_;
            if (!containerElem) {
              throw TpError.alreadyDisposed();
            }
            if (this.usesDefaultWrapper_) {
              const parentElem = containerElem.parentElement;
              if (parentElem) {
                parentElem.removeChild(containerElem);
              }
            }
            this.containerElem_ = null;
            this.doc_ = null;
            super.dispose();
          }
          registerPlugin(bundle2) {
            const plugins = "plugin" in bundle2 ? [bundle2.plugin] : "plugins" in bundle2 ? bundle2.plugins : [];
            plugins.forEach((p2) => {
              this.pool_.register(p2);
              this.embedPluginStyle_(p2);
            });
          }
          embedPluginStyle_(plugin) {
            if (plugin.css) {
              embedStyle(this.document, `plugin-${plugin.id}`, plugin.css);
            }
          }
          setUpDefaultPlugins_() {
            embedStyle(this.document, "default", ".tp-lstv_s,.tp-btnv_b,.tp-p2dv_b,.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i,.tp-grlv_g,.tp-sglv_i,.tp-mllv_i,.tp-fldv_b,.tp-rotv_b,.tp-ckbv_i,.tp-coltxtv_ms,.tp-tbiv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-lstv_s,.tp-btnv_b,.tp-p2dv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-lstv_s:hover,.tp-btnv_b:hover,.tp-p2dv_b:hover{background-color:var(--btn-bg-h)}.tp-lstv_s:focus,.tp-btnv_b:focus,.tp-p2dv_b:focus{background-color:var(--btn-bg-f)}.tp-lstv_s:active,.tp-btnv_b:active,.tp-p2dv_b:active{background-color:var(--btn-bg-a)}.tp-lstv_s:disabled,.tp-btnv_b:disabled,.tp-p2dv_b:disabled{opacity:0.5}.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-colswv_sw:hover,.tp-p2dpv_p:hover,.tp-txtv_i:hover{background-color:var(--in-bg-h)}.tp-colswv_sw:focus,.tp-p2dpv_p:focus,.tp-txtv_i:focus{background-color:var(--in-bg-f)}.tp-colswv_sw:active,.tp-p2dpv_p:active,.tp-txtv_i:active{background-color:var(--in-bg-a)}.tp-colswv_sw:disabled,.tp-p2dpv_p:disabled,.tp-txtv_i:disabled{opacity:0.5}.tp-grlv_g,.tp-sglv_i,.tp-mllv_i{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);width:100%}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono,Source Code Pro,Menlo,Courier,monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #2f3137);--bs-sh: var(--tp-base-shadow-color, rgba(0,0,0,0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #2f3137);--cnt-bg: var(--tp-container-background-color, rgba(187,188,196,0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187,188,196,0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187,188,196,0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187,188,196,0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187,188,196,0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187,188,196,0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187,188,196,0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187,188,196,0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187,188,196,0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0,0,0,0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187,188,196,0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(0,0,0,0.2))}.tp-fldv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-rotv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1 * var(--cnt-v-p))}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-rotv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-fldv_c>.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv{margin-left:4px}.tp-fldv_c>.tp-fldv>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c .tp-fldv>.tp-fldv_c,.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-tabv>.tp-tabv_i,.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-fldv_c .tp-tabv>.tp-tabv_c,.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_b,.tp-rotv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-fldv_b:hover,.tp-rotv_b:hover{background-color:var(--cnt-bg-h)}.tp-fldv_b:focus,.tp-rotv_b:focus{background-color:var(--cnt-bg-f)}.tp-fldv_b:active,.tp-rotv_b:active{background-color:var(--cnt-bg-a)}.tp-fldv_b:disabled,.tp-rotv_b:disabled{opacity:0.5}.tp-fldv_m,.tp-rotv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:'';display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px) / 2 - 2px);margin:auto;opacity:0.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m,.tp-rotv.tp-rotv-expanded .tp-rotv_m{transform:none}.tp-fldv_c,.tp-rotv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c,.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c{display:none}.tp-fldv.tp-fldv-expanded>.tp-fldv_c,.tp-rotv.tp-rotv-expanded .tp-rotv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-coltxtv_m,.tp-lstv{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-coltxtv_mm,.tp-lstv_m{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-coltxtv_mm svg,.tp-lstv_m svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-coltxtv_mm svg path,.tp-lstv_m svg path{fill:currentColor}.tp-coltxtv_w,.tp-pndtxtv{display:flex}.tp-coltxtv_c,.tp-pndtxtv_a{width:100%}.tp-coltxtv_c+.tp-coltxtv_c,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-pndtxtv_a{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:0.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:'';height:2px;left:calc(-1 * var(--cnt-h-p));position:absolute;right:calc(-1 * var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us) * 4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0,0,0,0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,0.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,0.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br)}.tp-colswv.tp-v-disabled{opacity:0.5}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,0.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:'';display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us) * 3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left 0.05s, top 0.05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:0.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:0.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:0.5}.tp-mllv_i{display:block;height:calc(var(--bld-us) * 3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:0.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:0.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:0.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:0.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:'';display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:0.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:0.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:0.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:0.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:0.1;position:absolute;top:0;transition:border-radius 0.1s, height 0.1s, transform 0.1s, width 0.1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:'';font-size:0.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}");
            this.pool_.getAll().forEach((plugin) => {
              this.embedPluginStyle_(plugin);
            });
            this.registerPlugin({
              plugins: [
                SliderBladePlugin,
                ListBladePlugin,
                TabBladePlugin,
                TextBladePlugin
              ]
            });
          }
        }
        const VERSION = new Semver("3.0.7");
        exports2.BladeApi = BladeApi;
        exports2.ButtonApi = ButtonApi;
        exports2.FolderApi = FolderApi;
        exports2.InputBindingApi = InputBindingApi;
        exports2.ListApi = ListApi;
        exports2.MonitorBindingApi = MonitorBindingApi;
        exports2.Pane = Pane3;
        exports2.SeparatorApi = SeparatorApi;
        exports2.SliderApi = SliderApi;
        exports2.TabApi = TabApi;
        exports2.TabPageApi = TabPageApi;
        exports2.TextApi = TextApi;
        exports2.TpChangeEvent = TpChangeEvent;
        exports2.VERSION = VERSION;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@jocabola/phy/lib/phy/particle.js
  var require_particle = __commonJS({
    "node_modules/@jocabola/phy/lib/phy/particle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Spring = exports.Particle = void 0;
      var math_1 = require_main();
      var Particle2 = function() {
        function Particle3(id, drag, lifetime) {
          if (id === void 0) {
            id = 0;
          }
          if (drag === void 0) {
            drag = 0.03;
          }
          if (lifetime === void 0) {
            lifetime = -1;
          }
          this.id = id;
          this.age = 0;
          this.lifetime = lifetime;
          this.drag = drag;
          this.state = 0;
          this.position = new math_1.Vec();
          this.prev = new math_1.Vec();
          this.force = new math_1.Vec();
          this.tmp = new math_1.Vec();
        }
        Object.defineProperty(Particle3.prototype, "locked", {
          get: function() {
            return this.state === 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Particle3.prototype, "dead", {
          get: function() {
            return this.state === 3;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Particle3.prototype, "idle", {
          get: function() {
            return this.state === 2;
          },
          enumerable: false,
          configurable: true
        });
        Particle3.prototype.lock = function() {
          this.state = 1;
        };
        Particle3.prototype.unlock = function() {
          this.state = 2;
        };
        Particle3.prototype.die = function() {
          this.state = 3;
        };
        Particle3.prototype.setPosition = function(x, y, z) {
          if (z === void 0) {
            z = 0;
          }
          this.position.set(x, y, z);
          this.prev.set(x, y, z);
        };
        Particle3.prototype.copyPosition = function(v) {
          this.setPosition(v.x, v.y, v.z);
        };
        Particle3.prototype.update = function() {
          if (this.lifetime > 0 && this.age === this.lifetime)
            this.state = 3;
          if (this.state > 0)
            return;
          this.age++;
          this.tmp.copy(this.position);
          this.position.x += this.position.x - this.prev.x + this.force.x;
          this.position.y += this.position.y - this.prev.y + this.force.y;
          this.position.z += this.position.z - this.prev.z + this.force.z;
          this.force.set(0, 0, 0);
          this.prev.copy(this.tmp);
          this.prev.lerp(this.position, this.drag);
        };
        return Particle3;
      }();
      exports.Particle = Particle2;
      var Spring = function() {
        function Spring2(a, b, strength) {
          if (strength === void 0) {
            strength = 0.5;
          }
          this.restLength = 0;
          this.a = a;
          this.b = b;
          this.strength = strength;
          this.restLength = this.a.position.distanceTo(this.b.position);
        }
        Spring2.prototype.update = function() {
          var delta = this.b.position.clone().sub(this.a.position);
          var dist = delta.length() + Number.MIN_VALUE;
          var normDistStrength = (dist - this.restLength) / dist * this.strength;
          if (normDistStrength === 0)
            return;
          delta.scale(normDistStrength);
          if (!this.a.locked) {
            this.a.position.add(delta);
          }
          if (!this.b.locked) {
            this.b.position.sub(delta);
          }
        };
        return Spring2;
      }();
      exports.Spring = Spring;
    }
  });

  // node_modules/@jocabola/phy/lib/phy/physics.js
  var require_physics = __commonJS({
    "node_modules/@jocabola/phy/lib/phy/physics.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Physics = exports.Emitter = exports.Constraint = exports.Behaviour = void 0;
      var particle_1 = require_particle();
      var Behaviour2 = function() {
        function Behaviour3() {
        }
        Behaviour3.prototype.prepare = function() {
        };
        Behaviour3.prototype.apply = function(p2) {
        };
        return Behaviour3;
      }();
      exports.Behaviour = Behaviour2;
      var Constraint = function() {
        function Constraint2() {
        }
        Constraint2.prototype.prepare = function() {
        };
        Constraint2.prototype.apply = function(p2) {
        };
        return Constraint2;
      }();
      exports.Constraint = Constraint;
      var Emitter2 = function() {
        function Emitter3(physics, options) {
          if (options === void 0) {
            options = {};
          }
          this.id = 0;
          this.physics = physics;
          this.rate = options.rate != void 0 ? options.rate : 1;
          this.interval = options.interval != void 0 ? options.interval : 1;
          this.max = options.max != void 0 ? options.max : 1;
          this.timer = -1;
        }
        Emitter3.prototype.update = function() {
          if (this.timer === -1 || this.timer === this.interval) {
            this.timer = 0;
            for (var i2 = 0; i2 < this.rate; i2++) {
              if (this.physics.size() >= this.max)
                return;
              var p2 = this.create();
              this.init(p2);
              this.physics.addParticle(p2);
            }
          }
          this.timer++;
        };
        Emitter3.prototype.create = function() {
          return new particle_1.Particle(this.id++);
        };
        Emitter3.prototype.init = function(p2) {
        };
        return Emitter3;
      }();
      exports.Emitter = Emitter2;
      var Physics3 = function() {
        function Physics4(emitter, options) {
          if (emitter === void 0) {
            emitter = null;
          }
          if (options === void 0) {
            options = {};
          }
          this.particles = [];
          this.springs = [];
          this.behaviours = [];
          this.constraints = [];
          this.emitter = emitter;
          this.constraintIterations = options.constraintIterations != void 0 ? options.constraintIterations : 1;
          this.springIterations = options.springIterations != void 0 ? options.springIterations : 1;
        }
        Physics4.prototype.addParticle = function(particle) {
          this.particles.push(particle);
        };
        Physics4.prototype.addSpring = function(spring) {
          this.springs.push(spring);
        };
        Physics4.prototype.addBehaviour = function(behaviour) {
          this.behaviours.push(behaviour);
        };
        Physics4.prototype.addConstraint = function(constraint) {
          this.constraints.push(constraint);
        };
        Physics4.prototype.update = function() {
          if (this.emitter !== null)
            this.emitter.update();
          this.applyEffectors(this.behaviours, this.particles);
          var sl = this.springs.length;
          for (var i2 = 0; i2 < this.constraintIterations; i2++) {
            this.applyEffectors(this.constraints, this.particles);
            for (var j = 0; j < this.springIterations; j++) {
              for (var k = 0; k < sl; k++) {
                this.springs[k].update();
              }
            }
          }
          var dead = [];
          var pl = this.particles.length;
          for (var pi = 0; pi < pl; pi++) {
            var p2 = this.particles[pi];
            p2.update();
            if (p2.dead)
              dead.push(p2);
          }
          var dl = dead.length;
          for (var di = 0; di < dl; di++) {
            this.particles.splice(this.particles.indexOf(dead[di]), 1);
          }
        };
        Physics4.prototype.applyEffectors = function(effectors, particles) {
          var el = effectors.length;
          var pl = particles.length;
          for (var i2 = 0; i2 < el; i2++) {
            effectors[i2].prepare();
            for (var k = 0; k < pl; k++) {
              if (particles[k].state === 0) {
                effectors[i2].apply(particles[k]);
              }
            }
          }
        };
        Physics4.prototype.size = function() {
          return this.particles.length;
        };
        return Physics4;
      }();
      exports.Physics = Physics3;
    }
  });

  // node_modules/@jocabola/phy/lib/main.js
  var require_main2 = __commonJS({
    "node_modules/@jocabola/phy/lib/main.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Physics = exports.Emitter = exports.Constraint = exports.Behaviour = exports.Spring = exports.Particle = void 0;
      var particle_1 = require_particle();
      Object.defineProperty(exports, "Particle", { enumerable: true, get: function() {
        return particle_1.Particle;
      } });
      Object.defineProperty(exports, "Spring", { enumerable: true, get: function() {
        return particle_1.Spring;
      } });
      var physics_1 = require_physics();
      Object.defineProperty(exports, "Behaviour", { enumerable: true, get: function() {
        return physics_1.Behaviour;
      } });
      Object.defineProperty(exports, "Constraint", { enumerable: true, get: function() {
        return physics_1.Constraint;
      } });
      Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
        return physics_1.Emitter;
      } });
      Object.defineProperty(exports, "Physics", { enumerable: true, get: function() {
        return physics_1.Physics;
      } });
    }
  });

  // node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config, _defaults, _suppressOverwrites, _bigNum, _tinyNum, _2PI, _HALF_PI, _gsID, _sqrt, _cos, _sin, _isString, _isFunction, _isNumber, _isUndefined, _isObject, _isNotFalse, _windowExists, _isFuncOrString, _isTypedArray, _isArray, _strictNumExp, _numExp, _numWithUnitExp, _complexStringNumExp, _relExp, _delimitedValueExp, _unitExp, _globalTimeline, _win, _coreInitted, _doc, _globals, _installScope, _coreReady, _install, _missingPlugin, _warn, _addGlobal, _emptyFunc, _reservedProps, _lazyTweens, _lazyLookup, _lastRenderedFrame, _plugins, _effects, _nextGCFrame, _harnessPlugins, _callbackNames, _harness, _getCache, _getProperty, _forEachName, _round, _roundPrecise, _arrayContainsAny, _lazyRender, _lazySafeRender, _numericIfPossible, _passThrough, _setDefaults, _setKeyframeDefaults, _merge, _mergeDeep, _copyExcluding, _inheritDefaults, _arraysMatch, _addLinkedListItem, _removeLinkedListItem, _removeFromParent, _uncache, _recacheAncestors, _hasNoPausedAncestors, _elapsedCycleDuration, _animationCycle, _parentToChildTotalTime, _setEnd, _alignPlayhead, _postAddChecks, _addToTimeline, _scrollTrigger, _attemptInitTween, _parentPlayheadIsBeforeStart, _isFromOrFromStart, _renderZeroDurationTween, _findNextPauseTween, _setDuration, _onUpdateTotalDuration, _zeroPosition, _parsePosition, _createTweenType, _conditionalReturn, _clamp, getUnit, clamp2, _slice, _isArrayLike, _flatten, toArray, selector, shuffle, distribute, _roundModifier, snap, random, pipe, unitize, normalize, _wrapArray, wrap, wrapYoyo, _replaceRandom, mapRange, interpolate, _getLabelInDirection, _callback, _interrupt, _quickTween, _createPlugin, _255, _colorLookup, _hue, splitColor, _colorOrderData, _formatColors, _colorExp, _hslExp, _colorStringFilter, _tickerActive, _ticker, _wake, _easeMap, _customEaseExp, _quotesExp, _parseObjectInString, _valueInParentheses, _configEaseFromString, _invertEase, _propagateYoyoEase, _parseEase, _insertEase, _easeInOutFromOut, _configElastic, _configBack, GSCache, Animation, Timeline, _addComplexStringPropTween, _addPropTween, _processVars, _checkPlugin, _overwritingTween, _initTween, _addAliasesToVars, _parseKeyframe, _parseFuncOrString, _staggerTweenProps, _staggerPropsToSkip, Tween, _setterPlain, _setterFunc, _setterFuncWithParam, _setterAttribute, _getSetter, _renderPlain, _renderBoolean, _renderComplexString, _renderPropTweens, _addPluginModifier, _killPropTweensOf, _setterWithModifier, _sortPropTweensByPriority, PropTween, _gsap, _getPluginPropTween, _addModifiers, _buildModifierPlugin, gsap, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ;
  var init_gsap_core = __esm({
    "node_modules/gsap/gsap-core.js"() {
      _config = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
          lineHeight: ""
        }
      };
      _defaults = {
        duration: 0.5,
        overwrite: false,
        delay: 0
      };
      _bigNum = 1e8;
      _tinyNum = 1 / _bigNum;
      _2PI = Math.PI * 2;
      _HALF_PI = _2PI / 4;
      _gsID = 0;
      _sqrt = Math.sqrt;
      _cos = Math.cos;
      _sin = Math.sin;
      _isString = function _isString2(value) {
        return typeof value === "string";
      };
      _isFunction = function _isFunction2(value) {
        return typeof value === "function";
      };
      _isNumber = function _isNumber2(value) {
        return typeof value === "number";
      };
      _isUndefined = function _isUndefined2(value) {
        return typeof value === "undefined";
      };
      _isObject = function _isObject2(value) {
        return typeof value === "object";
      };
      _isNotFalse = function _isNotFalse2(value) {
        return value !== false;
      };
      _windowExists = function _windowExists2() {
        return typeof window !== "undefined";
      };
      _isFuncOrString = function _isFuncOrString2(value) {
        return _isFunction(value) || _isString(value);
      };
      _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
      };
      _isArray = Array.isArray;
      _strictNumExp = /(?:-?\.?\d|\.)+/gi;
      _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
      _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
      _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
      _relExp = /[+-]=-?[.\d]+/;
      _delimitedValueExp = /[^,'"\[\]\s]+/gi;
      _unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i;
      _globals = {};
      _installScope = {};
      _install = function _install2(scope) {
        return (_installScope = _merge(scope, _globals)) && gsap;
      };
      _missingPlugin = function _missingPlugin2(property, value) {
        return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
      };
      _warn = function _warn2(message, suppress) {
        return !suppress && console.warn(message);
      };
      _addGlobal = function _addGlobal2(name, obj) {
        return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
      };
      _emptyFunc = function _emptyFunc2() {
        return 0;
      };
      _reservedProps = {};
      _lazyTweens = [];
      _lazyLookup = {};
      _plugins = {};
      _effects = {};
      _nextGCFrame = 30;
      _harnessPlugins = [];
      _callbackNames = "";
      _harness = function _harness2(targets) {
        var target = targets[0], harnessPlugin, i2;
        _isObject(target) || _isFunction(target) || (targets = [targets]);
        if (!(harnessPlugin = (target._gsap || {}).harness)) {
          i2 = _harnessPlugins.length;
          while (i2-- && !_harnessPlugins[i2].targetTest(target)) {
          }
          harnessPlugin = _harnessPlugins[i2];
        }
        i2 = targets.length;
        while (i2--) {
          targets[i2] && (targets[i2]._gsap || (targets[i2]._gsap = new GSCache(targets[i2], harnessPlugin))) || targets.splice(i2, 1);
        }
        return targets;
      };
      _getCache = function _getCache2(target) {
        return target._gsap || _harness(toArray(target))[0]._gsap;
      };
      _getProperty = function _getProperty2(target, property, v) {
        return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
      };
      _forEachName = function _forEachName2(names, func) {
        return (names = names.split(",")).forEach(func) || names;
      };
      _round = function _round2(value) {
        return Math.round(value * 1e5) / 1e5 || 0;
      };
      _roundPrecise = function _roundPrecise2(value) {
        return Math.round(value * 1e7) / 1e7 || 0;
      };
      _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
        var l = toFind.length, i2 = 0;
        for (; toSearch.indexOf(toFind[i2]) < 0 && ++i2 < l; ) {
        }
        return i2 < l;
      };
      _lazyRender = function _lazyRender2() {
        var l = _lazyTweens.length, a = _lazyTweens.slice(0), i2, tween;
        _lazyLookup = {};
        _lazyTweens.length = 0;
        for (i2 = 0; i2 < l; i2++) {
          tween = a[i2];
          tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
        }
      };
      _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
        _lazyTweens.length && _lazyRender();
        animation.render(time, suppressEvents, force);
        _lazyTweens.length && _lazyRender();
      };
      _numericIfPossible = function _numericIfPossible2(value) {
        var n = parseFloat(value);
        return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
      };
      _passThrough = function _passThrough2(p2) {
        return p2;
      };
      _setDefaults = function _setDefaults2(obj, defaults2) {
        for (var p2 in defaults2) {
          p2 in obj || (obj[p2] = defaults2[p2]);
        }
        return obj;
      };
      _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
        return function(obj, defaults2) {
          for (var p2 in defaults2) {
            p2 in obj || p2 === "duration" && excludeDuration || p2 === "ease" || (obj[p2] = defaults2[p2]);
          }
        };
      };
      _merge = function _merge2(base, toMerge) {
        for (var p2 in toMerge) {
          base[p2] = toMerge[p2];
        }
        return base;
      };
      _mergeDeep = function _mergeDeep2(base, toMerge) {
        for (var p2 in toMerge) {
          p2 !== "__proto__" && p2 !== "constructor" && p2 !== "prototype" && (base[p2] = _isObject(toMerge[p2]) ? _mergeDeep2(base[p2] || (base[p2] = {}), toMerge[p2]) : toMerge[p2]);
        }
        return base;
      };
      _copyExcluding = function _copyExcluding2(obj, excluding) {
        var copy = {}, p2;
        for (p2 in obj) {
          p2 in excluding || (copy[p2] = obj[p2]);
        }
        return copy;
      };
      _inheritDefaults = function _inheritDefaults2(vars) {
        var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
        if (_isNotFalse(vars.inherit)) {
          while (parent) {
            func(vars, parent.vars.defaults);
            parent = parent.parent || parent._dp;
          }
        }
        return vars;
      };
      _arraysMatch = function _arraysMatch2(a1, a2) {
        var i2 = a1.length, match = i2 === a2.length;
        while (match && i2-- && a1[i2] === a2[i2]) {
        }
        return i2 < 0;
      };
      _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
        if (firstProp === void 0) {
          firstProp = "_first";
        }
        if (lastProp === void 0) {
          lastProp = "_last";
        }
        var prev = parent[lastProp], t;
        if (sortBy) {
          t = child[sortBy];
          while (prev && prev[sortBy] > t) {
            prev = prev._prev;
          }
        }
        if (prev) {
          child._next = prev._next;
          prev._next = child;
        } else {
          child._next = parent[firstProp];
          parent[firstProp] = child;
        }
        if (child._next) {
          child._next._prev = child;
        } else {
          parent[lastProp] = child;
        }
        child._prev = prev;
        child.parent = child._dp = parent;
        return child;
      };
      _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
        if (firstProp === void 0) {
          firstProp = "_first";
        }
        if (lastProp === void 0) {
          lastProp = "_last";
        }
        var prev = child._prev, next = child._next;
        if (prev) {
          prev._next = next;
        } else if (parent[firstProp] === child) {
          parent[firstProp] = next;
        }
        if (next) {
          next._prev = prev;
        } else if (parent[lastProp] === child) {
          parent[lastProp] = prev;
        }
        child._next = child._prev = child.parent = null;
      };
      _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
        child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
        child._act = 0;
      };
      _uncache = function _uncache2(animation, child) {
        if (animation && (!child || child._end > animation._dur || child._start < 0)) {
          var a = animation;
          while (a) {
            a._dirty = 1;
            a = a.parent;
          }
        }
        return animation;
      };
      _recacheAncestors = function _recacheAncestors2(animation) {
        var parent = animation.parent;
        while (parent && parent.parent) {
          parent._dirty = 1;
          parent.totalDuration();
          parent = parent.parent;
        }
        return animation;
      };
      _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
        return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
      };
      _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
        return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
      };
      _animationCycle = function _animationCycle2(tTime, cycleDuration) {
        var whole = Math.floor(tTime /= cycleDuration);
        return tTime && whole === tTime ? whole - 1 : whole;
      };
      _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
        return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
      };
      _setEnd = function _setEnd2(animation) {
        return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
      };
      _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
        var parent = animation._dp;
        if (parent && parent.smoothChildTiming && animation._ts) {
          animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
          _setEnd(animation);
          parent._dirty || _uncache(parent, animation);
        }
        return animation;
      };
      _postAddChecks = function _postAddChecks2(timeline2, child) {
        var t;
        if (child._time || child._initted && !child._dur) {
          t = _parentToChildTotalTime(timeline2.rawTime(), child);
          if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
            child.render(t, true);
          }
        }
        if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
          if (timeline2._dur < timeline2.duration()) {
            t = timeline2;
            while (t._dp) {
              t.rawTime() >= 0 && t.totalTime(t._tTime);
              t = t._dp;
            }
          }
          timeline2._zTime = -_tinyNum;
        }
      };
      _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
        child.parent && _removeFromParent(child);
        child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
        child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
        _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
        _isFromOrFromStart(child) || (timeline2._recent = child);
        skipChecks || _postAddChecks(timeline2, child);
        return timeline2;
      };
      _scrollTrigger = function _scrollTrigger2(animation, trigger) {
        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
      };
      _attemptInitTween = function _attemptInitTween2(tween, totalTime, force, suppressEvents) {
        _initTween(tween, totalTime);
        if (!tween._initted) {
          return 1;
        }
        if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
          _lazyTweens.push(tween);
          tween._lazy = [totalTime, suppressEvents];
          return 1;
        }
      };
      _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
        var parent = _ref.parent;
        return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
      };
      _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
        var data = _ref2.data;
        return data === "isFromStart" || data === "isStart";
      };
      _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
        var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
        if (repeatDelay && tween._repeat) {
          tTime = _clamp(0, tween._tDur, totalTime);
          iteration = _animationCycle(tTime, repeatDelay);
          tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
          if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
            prevRatio = 1 - ratio;
            tween.vars.repeatRefresh && tween._initted && tween.invalidate();
          }
        }
        if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
          if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
            return;
          }
          prevIteration = tween._zTime;
          tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
          suppressEvents || (suppressEvents = totalTime && !prevIteration);
          tween.ratio = ratio;
          tween._from && (ratio = 1 - ratio);
          tween._time = 0;
          tween._tTime = tTime;
          pt = tween._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
          tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
          tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
          if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
            ratio && _removeFromParent(tween, 1);
            if (!suppressEvents) {
              _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
              tween._prom && tween._prom();
            }
          }
        } else if (!tween._zTime) {
          tween._zTime = totalTime;
        }
      };
      _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
        var child;
        if (time > prevTime) {
          child = animation._first;
          while (child && child._start <= time) {
            if (child.data === "isPause" && child._start > prevTime) {
              return child;
            }
            child = child._next;
          }
        } else {
          child = animation._last;
          while (child && child._start >= time) {
            if (child.data === "isPause" && child._start < prevTime) {
              return child;
            }
            child = child._prev;
          }
        }
      };
      _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
        var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
        totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
        animation._dur = dur;
        animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
        totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
        skipUncache || _uncache(animation.parent, animation);
        return animation;
      };
      _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
        return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
      };
      _zeroPosition = {
        _start: 0,
        endTime: _emptyFunc,
        totalDuration: _emptyFunc
      };
      _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
        var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i2, offset, isPercent;
        if (_isString(position) && (isNaN(position) || position in labels)) {
          offset = position.charAt(0);
          isPercent = position.substr(-1) === "%";
          i2 = position.indexOf("=");
          if (offset === "<" || offset === ">") {
            i2 >= 0 && (position = position.replace(/=/, ""));
            return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i2 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
          }
          if (i2 < 0) {
            position in labels || (labels[position] = clippedDuration);
            return labels[position];
          }
          offset = parseFloat(position.charAt(i2 - 1) + position.substr(i2 + 1));
          if (isPercent && percentAnimation) {
            offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
          }
          return i2 > 1 ? _parsePosition2(animation, position.substr(0, i2 - 1), percentAnimation) + offset : clippedDuration + offset;
        }
        return position == null ? clippedDuration : +position;
      };
      _createTweenType = function _createTweenType2(type, params, timeline2) {
        var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
        isLegacy && (vars.duration = params[1]);
        vars.parent = timeline2;
        if (type) {
          irVars = vars;
          parent = timeline2;
          while (parent && !("immediateRender" in irVars)) {
            irVars = parent.vars.defaults || {};
            parent = _isNotFalse(parent.vars.inherit) && parent.parent;
          }
          vars.immediateRender = _isNotFalse(irVars.immediateRender);
          type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
        }
        return new Tween(params[0], vars, params[varsIndex + 1]);
      };
      _conditionalReturn = function _conditionalReturn2(value, func) {
        return value || value === 0 ? func(value) : func;
      };
      _clamp = function _clamp2(min, max, value) {
        return value < min ? min : value > max ? max : value;
      };
      getUnit = function getUnit2(value, v) {
        return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : value.substr(v.index + v[0].length);
      };
      clamp2 = function clamp3(min, max, value) {
        return _conditionalReturn(value, function(v) {
          return _clamp(min, max, v);
        });
      };
      _slice = [].slice;
      _isArrayLike = function _isArrayLike2(value, nonEmpty) {
        return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
      };
      _flatten = function _flatten2(ar, leaveStrings, accumulator) {
        if (accumulator === void 0) {
          accumulator = [];
        }
        return ar.forEach(function(value) {
          var _accumulator;
          return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
        }) || accumulator;
      };
      toArray = function toArray2(value, scope, leaveStrings) {
        return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
      };
      selector = function selector2(value) {
        value = toArray(value)[0] || _warn("Invalid scope") || {};
        return function(v) {
          var el = value.current || value.nativeElement || value;
          return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
        };
      };
      shuffle = function shuffle2(a) {
        return a.sort(function() {
          return 0.5 - Math.random();
        });
      };
      distribute = function distribute2(v) {
        if (_isFunction(v)) {
          return v;
        }
        var vars = _isObject(v) ? v : {
          each: v
        }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
        if (_isString(from)) {
          ratioX = ratioY = {
            center: 0.5,
            edges: 0.5,
            end: 1
          }[from] || 0;
        } else if (!isDecimal && ratios) {
          ratioX = from[0];
          ratioY = from[1];
        }
        return function(i2, target, a) {
          var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
          if (!distances) {
            wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
            if (!wrapAt) {
              max = -_bigNum;
              while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
              }
              wrapAt--;
            }
            distances = cache[l] = [];
            originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
            originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
            max = 0;
            min = _bigNum;
            for (j = 0; j < l; j++) {
              x = j % wrapAt - originX;
              y = originY - (j / wrapAt | 0);
              distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
              d > max && (max = d);
              d < min && (min = d);
            }
            from === "random" && shuffle(distances);
            distances.max = max - min;
            distances.min = min;
            distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
            distances.b = l < 0 ? base - l : base;
            distances.u = getUnit(vars.amount || vars.each) || 0;
            ease = ease && l < 0 ? _invertEase(ease) : ease;
          }
          l = (distances[i2] - distances.min) / distances.max || 0;
          return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
        };
      };
      _roundModifier = function _roundModifier2(v) {
        var p2 = Math.pow(10, ((v + "").split(".")[1] || "").length);
        return function(raw) {
          var n = Math.round(parseFloat(raw) / v) * v * p2;
          return (n - n % 1) / p2 + (_isNumber(raw) ? 0 : getUnit(raw));
        };
      };
      snap = function snap2(snapTo, value) {
        var isArray = _isArray(snapTo), radius, is2D;
        if (!isArray && _isObject(snapTo)) {
          radius = isArray = snapTo.radius || _bigNum;
          if (snapTo.values) {
            snapTo = toArray(snapTo.values);
            if (is2D = !_isNumber(snapTo[0])) {
              radius *= radius;
            }
          } else {
            snapTo = _roundModifier(snapTo.increment);
          }
        }
        return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
          is2D = snapTo(raw);
          return Math.abs(is2D - raw) <= radius ? is2D : raw;
        } : function(raw) {
          var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i2 = snapTo.length, dx, dy;
          while (i2--) {
            if (is2D) {
              dx = snapTo[i2].x - x;
              dy = snapTo[i2].y - y;
              dx = dx * dx + dy * dy;
            } else {
              dx = Math.abs(snapTo[i2] - x);
            }
            if (dx < min) {
              min = dx;
              closest = i2;
            }
          }
          closest = !radius || min <= radius ? snapTo[closest] : raw;
          return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
        });
      };
      random = function random2(min, max, roundingIncrement, returnFunction) {
        return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
          return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
        });
      };
      pipe = function pipe2() {
        for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
          functions[_key] = arguments[_key];
        }
        return function(value) {
          return functions.reduce(function(v, f) {
            return f(v);
          }, value);
        };
      };
      unitize = function unitize2(func, unit) {
        return function(value) {
          return func(parseFloat(value)) + (unit || getUnit(value));
        };
      };
      normalize = function normalize2(min, max, value) {
        return mapRange(min, max, 0, 1, value);
      };
      _wrapArray = function _wrapArray2(a, wrapper, value) {
        return _conditionalReturn(value, function(index) {
          return a[~~wrapper(index)];
        });
      };
      wrap = function wrap2(min, max, value) {
        var range = max - min;
        return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
          return (range + (value2 - min) % range) % range + min;
        });
      };
      wrapYoyo = function wrapYoyo2(min, max, value) {
        var range = max - min, total = range * 2;
        return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
          value2 = (total + (value2 - min) % total) % total || 0;
          return min + (value2 > range ? total - value2 : value2);
        });
      };
      _replaceRandom = function _replaceRandom2(value) {
        var prev = 0, s = "", i2, nums, end, isArray;
        while (~(i2 = value.indexOf("random(", prev))) {
          end = value.indexOf(")", i2);
          isArray = value.charAt(i2 + 7) === "[";
          nums = value.substr(i2 + 7, end - i2 - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
          s += value.substr(prev, i2 - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
          prev = end + 1;
        }
        return s + value.substr(prev, value.length - prev);
      };
      mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
        var inRange = inMax - inMin, outRange = outMax - outMin;
        return _conditionalReturn(value, function(value2) {
          return outMin + ((value2 - inMin) / inRange * outRange || 0);
        });
      };
      interpolate = function interpolate2(start, end, progress, mutate) {
        var func = isNaN(start + end) ? 0 : function(p3) {
          return (1 - p3) * start + p3 * end;
        };
        if (!func) {
          var isString = _isString(start), master = {}, p2, i2, interpolators, l, il;
          progress === true && (mutate = 1) && (progress = null);
          if (isString) {
            start = {
              p: start
            };
            end = {
              p: end
            };
          } else if (_isArray(start) && !_isArray(end)) {
            interpolators = [];
            l = start.length;
            il = l - 2;
            for (i2 = 1; i2 < l; i2++) {
              interpolators.push(interpolate2(start[i2 - 1], start[i2]));
            }
            l--;
            func = function func2(p3) {
              p3 *= l;
              var i3 = Math.min(il, ~~p3);
              return interpolators[i3](p3 - i3);
            };
            progress = end;
          } else if (!mutate) {
            start = _merge(_isArray(start) ? [] : {}, start);
          }
          if (!interpolators) {
            for (p2 in end) {
              _addPropTween.call(master, start, p2, "get", end[p2]);
            }
            func = function func2(p3) {
              return _renderPropTweens(p3, master) || (isString ? start.p : start);
            };
          }
        }
        return _conditionalReturn(progress, func);
      };
      _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
        var labels = timeline2.labels, min = _bigNum, p2, distance, label;
        for (p2 in labels) {
          distance = labels[p2] - fromTime;
          if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
            label = p2;
            min = distance;
          }
        }
        return label;
      };
      _callback = function _callback2(animation, type, executeLazyFirst) {
        var v = animation.vars, callback = v[type], params, scope;
        if (!callback) {
          return;
        }
        params = v[type + "Params"];
        scope = v.callbackScope || animation;
        executeLazyFirst && _lazyTweens.length && _lazyRender();
        return params ? callback.apply(scope, params) : callback.call(scope);
      };
      _interrupt = function _interrupt2(animation) {
        _removeFromParent(animation);
        animation.scrollTrigger && animation.scrollTrigger.kill(false);
        animation.progress() < 1 && _callback(animation, "onInterrupt");
        return animation;
      };
      _createPlugin = function _createPlugin2(config3) {
        config3 = !config3.name && config3["default"] || config3;
        var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
          this._props = [];
        } : config3, instanceDefaults = {
          init: _emptyFunc,
          render: _renderPropTweens,
          add: _addPropTween,
          kill: _killPropTweensOf,
          modifier: _addPluginModifier,
          rawVars: 0
        }, statics = {
          targetTest: 0,
          get: 0,
          getSetter: _getSetter,
          aliases: {},
          register: 0
        };
        _wake();
        if (config3 !== Plugin) {
          if (_plugins[name]) {
            return;
          }
          _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
          _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
          _plugins[Plugin.prop = name] = Plugin;
          if (config3.targetTest) {
            _harnessPlugins.push(Plugin);
            _reservedProps[name] = 1;
          }
          name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
        }
        _addGlobal(name, Plugin);
        config3.register && config3.register(gsap, Plugin, PropTween);
      };
      _255 = 255;
      _colorLookup = {
        aqua: [0, _255, _255],
        lime: [0, _255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, _255],
        navy: [0, 0, 128],
        white: [_255, _255, _255],
        olive: [128, 128, 0],
        yellow: [_255, _255, 0],
        orange: [_255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [_255, 0, 0],
        pink: [_255, 192, 203],
        cyan: [0, _255, _255],
        transparent: [_255, _255, _255, 0]
      };
      _hue = function _hue2(h, m1, m2) {
        h += h < 0 ? 1 : h > 1 ? -1 : 0;
        return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
      };
      splitColor = function splitColor2(v, toHSL, forceAlpha) {
        var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h, s, l, max, min, d, wasHSL;
        if (!a) {
          if (v.substr(-1) === ",") {
            v = v.substr(0, v.length - 1);
          }
          if (_colorLookup[v]) {
            a = _colorLookup[v];
          } else if (v.charAt(0) === "#") {
            if (v.length < 6) {
              r = v.charAt(1);
              g = v.charAt(2);
              b = v.charAt(3);
              v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
            }
            if (v.length === 9) {
              a = parseInt(v.substr(1, 6), 16);
              return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
            }
            v = parseInt(v.substr(1), 16);
            a = [v >> 16, v >> 8 & _255, v & _255];
          } else if (v.substr(0, 3) === "hsl") {
            a = wasHSL = v.match(_strictNumExp);
            if (!toHSL) {
              h = +a[0] % 360 / 360;
              s = +a[1] / 100;
              l = +a[2] / 100;
              g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
              r = l * 2 - g;
              a.length > 3 && (a[3] *= 1);
              a[0] = _hue(h + 1 / 3, r, g);
              a[1] = _hue(h, r, g);
              a[2] = _hue(h - 1 / 3, r, g);
            } else if (~v.indexOf("=")) {
              a = v.match(_numExp);
              forceAlpha && a.length < 4 && (a[3] = 1);
              return a;
            }
          } else {
            a = v.match(_strictNumExp) || _colorLookup.transparent;
          }
          a = a.map(Number);
        }
        if (toHSL && !wasHSL) {
          r = a[0] / _255;
          g = a[1] / _255;
          b = a[2] / _255;
          max = Math.max(r, g, b);
          min = Math.min(r, g, b);
          l = (max + min) / 2;
          if (max === min) {
            h = s = 0;
          } else {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
            h *= 60;
          }
          a[0] = ~~(h + 0.5);
          a[1] = ~~(s * 100 + 0.5);
          a[2] = ~~(l * 100 + 0.5);
        }
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      };
      _colorOrderData = function _colorOrderData2(v) {
        var values = [], c = [], i2 = -1;
        v.split(_colorExp).forEach(function(v2) {
          var a = v2.match(_numWithUnitExp) || [];
          values.push.apply(values, a);
          c.push(i2 += a.length + 1);
        });
        values.c = c;
        return values;
      };
      _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
        var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i2 = 0, c, shell, d, l;
        if (!colors) {
          return s;
        }
        colors = colors.map(function(color) {
          return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
        });
        if (orderMatchData) {
          d = _colorOrderData(s);
          c = orderMatchData.c;
          if (c.join(result) !== d.c.join(result)) {
            shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
            l = shell.length - 1;
            for (; i2 < l; i2++) {
              result += shell[i2] + (~c.indexOf(i2) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
            }
          }
        }
        if (!shell) {
          shell = s.split(_colorExp);
          l = shell.length - 1;
          for (; i2 < l; i2++) {
            result += shell[i2] + colors[i2];
          }
        }
        return result + shell[l];
      };
      _colorExp = function() {
        var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p2;
        for (p2 in _colorLookup) {
          s += "|" + p2 + "\\b";
        }
        return new RegExp(s + ")", "gi");
      }();
      _hslExp = /hsl[a]?\(/;
      _colorStringFilter = function _colorStringFilter2(a) {
        var combined = a.join(" "), toHSL;
        _colorExp.lastIndex = 0;
        if (_colorExp.test(combined)) {
          toHSL = _hslExp.test(combined);
          a[1] = _formatColors(a[1], toHSL);
          a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
          return true;
        }
      };
      _ticker = function() {
        var _getTime3 = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime3(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id3, _req, _raf, _self, _delta, _i2, _tick = function _tick2(v) {
          var elapsed = _getTime3() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
          elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
          _lastUpdate += elapsed;
          time = _lastUpdate - _startTime;
          overlap = time - _nextTime;
          if (overlap > 0 || manual) {
            frame = ++_self.frame;
            _delta = time - _self.time * 1e3;
            _self.time = time = time / 1e3;
            _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
            dispatch = 1;
          }
          manual || (_id3 = _req(_tick2));
          if (dispatch) {
            for (_i2 = 0; _i2 < _listeners2.length; _i2++) {
              _listeners2[_i2](time, _delta, frame, v);
            }
          }
        };
        _self = {
          time: 0,
          frame: 0,
          tick: function tick() {
            _tick(true);
          },
          deltaRatio: function deltaRatio(fps) {
            return _delta / (1e3 / (fps || 60));
          },
          wake: function wake() {
            if (_coreReady) {
              if (!_coreInitted && _windowExists()) {
                _win = _coreInitted = window;
                _doc = _win.document || {};
                _globals.gsap = gsap;
                (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
                _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                _raf = _win.requestAnimationFrame;
              }
              _id3 && _self.sleep();
              _req = _raf || function(f) {
                return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
              };
              _tickerActive = 1;
              _tick(2);
            }
          },
          sleep: function sleep() {
            (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id3);
            _tickerActive = 0;
            _req = _emptyFunc;
          },
          lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
            _lagThreshold = threshold || 1 / _tinyNum;
            _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
          },
          fps: function fps(_fps) {
            _gap = 1e3 / (_fps || 240);
            _nextTime = _self.time * 1e3 + _gap;
          },
          add: function add(callback) {
            _listeners2.indexOf(callback) < 0 && _listeners2.push(callback);
            _wake();
          },
          remove: function remove(callback, i2) {
            ~(i2 = _listeners2.indexOf(callback)) && _listeners2.splice(i2, 1) && _i2 >= i2 && _i2--;
          },
          _listeners: _listeners2
        };
        return _self;
      }();
      _wake = function _wake2() {
        return !_tickerActive && _ticker.wake();
      };
      _easeMap = {};
      _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
      _quotesExp = /["']/g;
      _parseObjectInString = function _parseObjectInString2(value) {
        var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i2 = 1, l = split.length, index, val, parsedVal;
        for (; i2 < l; i2++) {
          val = split[i2];
          index = i2 !== l - 1 ? val.lastIndexOf(",") : val.length;
          parsedVal = val.substr(0, index);
          obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
          key = val.substr(index + 1).trim();
        }
        return obj;
      };
      _valueInParentheses = function _valueInParentheses2(value) {
        var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
        return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
      };
      _configEaseFromString = function _configEaseFromString2(name) {
        var split = (name + "").split("("), ease = _easeMap[split[0]];
        return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
      };
      _invertEase = function _invertEase2(ease) {
        return function(p2) {
          return 1 - ease(1 - p2);
        };
      };
      _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
        var child = timeline2._first, ease;
        while (child) {
          if (child instanceof Timeline) {
            _propagateYoyoEase2(child, isYoyo);
          } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
            if (child.timeline) {
              _propagateYoyoEase2(child.timeline, isYoyo);
            } else {
              ease = child._ease;
              child._ease = child._yEase;
              child._yEase = ease;
              child._yoyo = isYoyo;
            }
          }
          child = child._next;
        }
      };
      _parseEase = function _parseEase2(ease, defaultEase) {
        return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
      };
      _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
        if (easeOut === void 0) {
          easeOut = function easeOut2(p2) {
            return 1 - easeIn(1 - p2);
          };
        }
        if (easeInOut === void 0) {
          easeInOut = function easeInOut2(p2) {
            return p2 < 0.5 ? easeIn(p2 * 2) / 2 : 1 - easeIn((1 - p2) * 2) / 2;
          };
        }
        var ease = {
          easeIn,
          easeOut,
          easeInOut
        }, lowercaseName;
        _forEachName(names, function(name) {
          _easeMap[name] = _globals[name] = ease;
          _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
          for (var p2 in ease) {
            _easeMap[lowercaseName + (p2 === "easeIn" ? ".in" : p2 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p2] = ease[p2];
          }
        });
        return ease;
      };
      _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
        return function(p2) {
          return p2 < 0.5 ? (1 - easeOut(1 - p2 * 2)) / 2 : 0.5 + easeOut((p2 - 0.5) * 2) / 2;
        };
      };
      _configElastic = function _configElastic2(type, amplitude, period) {
        var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p4) {
          return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p2) + 1;
        }, ease = type === "out" ? easeOut : type === "in" ? function(p4) {
          return 1 - easeOut(1 - p4);
        } : _easeInOutFromOut(easeOut);
        p2 = _2PI / p2;
        ease.config = function(amplitude2, period2) {
          return _configElastic2(type, amplitude2, period2);
        };
        return ease;
      };
      _configBack = function _configBack2(type, overshoot) {
        if (overshoot === void 0) {
          overshoot = 1.70158;
        }
        var easeOut = function easeOut2(p2) {
          return p2 ? --p2 * p2 * ((overshoot + 1) * p2 + overshoot) + 1 : 0;
        }, ease = type === "out" ? easeOut : type === "in" ? function(p2) {
          return 1 - easeOut(1 - p2);
        } : _easeInOutFromOut(easeOut);
        ease.config = function(overshoot2) {
          return _configBack2(type, overshoot2);
        };
        return ease;
      };
      _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i2) {
        var power = i2 < 5 ? i2 + 1 : i2;
        _insertEase(name + ",Power" + (power - 1), i2 ? function(p2) {
          return Math.pow(p2, power);
        } : function(p2) {
          return p2;
        }, function(p2) {
          return 1 - Math.pow(1 - p2, power);
        }, function(p2) {
          return p2 < 0.5 ? Math.pow(p2 * 2, power) / 2 : 1 - Math.pow((1 - p2) * 2, power) / 2;
        });
      });
      _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
      _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
      (function(n, c) {
        var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p2) {
          return p2 < n1 ? n * p2 * p2 : p2 < n2 ? n * Math.pow(p2 - 1.5 / c, 2) + 0.75 : p2 < n3 ? n * (p2 -= 2.25 / c) * p2 + 0.9375 : n * Math.pow(p2 - 2.625 / c, 2) + 0.984375;
        };
        _insertEase("Bounce", function(p2) {
          return 1 - easeOut(1 - p2);
        }, easeOut);
      })(7.5625, 2.75);
      _insertEase("Expo", function(p2) {
        return p2 ? Math.pow(2, 10 * (p2 - 1)) : 0;
      });
      _insertEase("Circ", function(p2) {
        return -(_sqrt(1 - p2 * p2) - 1);
      });
      _insertEase("Sine", function(p2) {
        return p2 === 1 ? 1 : -_cos(p2 * _HALF_PI) + 1;
      });
      _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
      _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
        config: function config(steps, immediateStart) {
          if (steps === void 0) {
            steps = 1;
          }
          var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
          return function(p4) {
            return ((p2 * _clamp(0, max, p4) | 0) + p3) * p1;
          };
        }
      };
      _defaults.ease = _easeMap["quad.out"];
      _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
        return _callbackNames += name + "," + name + "Params,";
      });
      GSCache = function GSCache2(target, harness) {
        this.id = _gsID++;
        target._gsap = this;
        this.target = target;
        this.harness = harness;
        this.get = harness ? harness.get : _getProperty;
        this.set = harness ? harness.getSetter : _getSetter;
      };
      Animation = /* @__PURE__ */ function() {
        function Animation2(vars) {
          this.vars = vars;
          this._delay = +vars.delay || 0;
          if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
            this._rDelay = vars.repeatDelay || 0;
            this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
          }
          this._ts = 1;
          _setDuration(this, +vars.duration, 1, 1);
          this.data = vars.data;
          _tickerActive || _ticker.wake();
        }
        var _proto = Animation2.prototype;
        _proto.delay = function delay(value) {
          if (value || value === 0) {
            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
            this._delay = value;
            return this;
          }
          return this._delay;
        };
        _proto.duration = function duration(value) {
          return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
        };
        _proto.totalDuration = function totalDuration(value) {
          if (!arguments.length) {
            return this._tDur;
          }
          this._dirty = 0;
          return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
        };
        _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
          _wake();
          if (!arguments.length) {
            return this._tTime;
          }
          var parent = this._dp;
          if (parent && parent.smoothChildTiming && this._ts) {
            _alignPlayhead(this, _totalTime);
            !parent._dp || parent.parent || _postAddChecks(parent, this);
            while (parent && parent.parent) {
              if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
                parent.totalTime(parent._tTime, true);
              }
              parent = parent.parent;
            }
            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
              _addToTimeline(this._dp, this, this._start - this._delay);
            }
          }
          if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
            this._ts || (this._pTime = _totalTime);
            _lazySafeRender(this, _totalTime, suppressEvents);
          }
          return this;
        };
        _proto.time = function time(value, suppressEvents) {
          return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
        };
        _proto.totalProgress = function totalProgress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
        };
        _proto.progress = function progress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
        };
        _proto.iteration = function iteration(value, suppressEvents) {
          var cycleDuration = this.duration() + this._rDelay;
          return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
        };
        _proto.timeScale = function timeScale(value) {
          if (!arguments.length) {
            return this._rts === -_tinyNum ? 0 : this._rts;
          }
          if (this._rts === value) {
            return this;
          }
          var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
          this._rts = +value || 0;
          this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
          _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
          _setEnd(this);
          return this;
        };
        _proto.paused = function paused(value) {
          if (!arguments.length) {
            return this._ps;
          }
          if (this._ps !== value) {
            this._ps = value;
            if (value) {
              this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
              this._ts = this._act = 0;
            } else {
              _wake();
              this._ts = this._rts;
              this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
            }
          }
          return this;
        };
        _proto.startTime = function startTime(value) {
          if (arguments.length) {
            this._start = value;
            var parent = this.parent || this._dp;
            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
            return this;
          }
          return this._start;
        };
        _proto.endTime = function endTime(includeRepeats) {
          return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
        };
        _proto.rawTime = function rawTime(wrapRepeats) {
          var parent = this.parent || this._dp;
          return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
        };
        _proto.globalTime = function globalTime(rawTime) {
          var animation = this, time = arguments.length ? rawTime : animation.rawTime();
          while (animation) {
            time = animation._start + time / (animation._ts || 1);
            animation = animation._dp;
          }
          return time;
        };
        _proto.repeat = function repeat(value) {
          if (arguments.length) {
            this._repeat = value === Infinity ? -2 : value;
            return _onUpdateTotalDuration(this);
          }
          return this._repeat === -2 ? Infinity : this._repeat;
        };
        _proto.repeatDelay = function repeatDelay(value) {
          if (arguments.length) {
            var time = this._time;
            this._rDelay = value;
            _onUpdateTotalDuration(this);
            return time ? this.time(time) : this;
          }
          return this._rDelay;
        };
        _proto.yoyo = function yoyo(value) {
          if (arguments.length) {
            this._yoyo = value;
            return this;
          }
          return this._yoyo;
        };
        _proto.seek = function seek(position, suppressEvents) {
          return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
        };
        _proto.restart = function restart(includeDelay, suppressEvents) {
          return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
        };
        _proto.play = function play(from, suppressEvents) {
          from != null && this.seek(from, suppressEvents);
          return this.reversed(false).paused(false);
        };
        _proto.reverse = function reverse(from, suppressEvents) {
          from != null && this.seek(from || this.totalDuration(), suppressEvents);
          return this.reversed(true).paused(false);
        };
        _proto.pause = function pause(atTime, suppressEvents) {
          atTime != null && this.seek(atTime, suppressEvents);
          return this.paused(true);
        };
        _proto.resume = function resume() {
          return this.paused(false);
        };
        _proto.reversed = function reversed(value) {
          if (arguments.length) {
            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
            return this;
          }
          return this._rts < 0;
        };
        _proto.invalidate = function invalidate() {
          this._initted = this._act = 0;
          this._zTime = -_tinyNum;
          return this;
        };
        _proto.isActive = function isActive() {
          var parent = this.parent || this._dp, start = this._start, rawTime;
          return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
        };
        _proto.eventCallback = function eventCallback(type, callback, params) {
          var vars = this.vars;
          if (arguments.length > 1) {
            if (!callback) {
              delete vars[type];
            } else {
              vars[type] = callback;
              params && (vars[type + "Params"] = params);
              type === "onUpdate" && (this._onUpdate = callback);
            }
            return this;
          }
          return vars[type];
        };
        _proto.then = function then(onFulfilled) {
          var self2 = this;
          return new Promise(function(resolve) {
            var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
              var _then = self2.then;
              self2.then = null;
              _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
              resolve(f);
              self2.then = _then;
            };
            if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
              _resolve();
            } else {
              self2._prom = _resolve;
            }
          });
        };
        _proto.kill = function kill2() {
          _interrupt(this);
        };
        return Animation2;
      }();
      _setDefaults(Animation.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: false,
        parent: null,
        _initted: false,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -_tinyNum,
        _prom: 0,
        _ps: false,
        _rts: 1
      });
      Timeline = /* @__PURE__ */ function(_Animation) {
        _inheritsLoose(Timeline2, _Animation);
        function Timeline2(vars, position) {
          var _this;
          if (vars === void 0) {
            vars = {};
          }
          _this = _Animation.call(this, vars) || this;
          _this.labels = {};
          _this.smoothChildTiming = !!vars.smoothChildTiming;
          _this.autoRemoveChildren = !!vars.autoRemoveChildren;
          _this._sort = _isNotFalse(vars.sortChildren);
          _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
          vars.reversed && _this.reverse();
          vars.paused && _this.paused(true);
          vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
          return _this;
        }
        var _proto2 = Timeline2.prototype;
        _proto2.to = function to(targets, vars, position) {
          _createTweenType(0, arguments, this);
          return this;
        };
        _proto2.from = function from(targets, vars, position) {
          _createTweenType(1, arguments, this);
          return this;
        };
        _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
          _createTweenType(2, arguments, this);
          return this;
        };
        _proto2.set = function set(targets, vars, position) {
          vars.duration = 0;
          vars.parent = this;
          _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
          vars.immediateRender = !!vars.immediateRender;
          new Tween(targets, vars, _parsePosition(this, position), 1);
          return this;
        };
        _proto2.call = function call(callback, params, position) {
          return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
        };
        _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.duration = duration;
          vars.stagger = vars.stagger || stagger;
          vars.onComplete = onCompleteAll;
          vars.onCompleteParams = onCompleteAllParams;
          vars.parent = this;
          new Tween(targets, vars, _parsePosition(this, position));
          return this;
        };
        _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.runBackwards = 1;
          _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
          return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
        };
        _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
          toVars.startAt = fromVars;
          _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
          return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
        };
        _proto2.render = function render6(totalTime, suppressEvents, force) {
          var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
          this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
          if (tTime !== this._tTime || force || crossingStart) {
            if (prevTime !== this._time && dur) {
              tTime += this._time - prevTime;
              totalTime += this._time - prevTime;
            }
            time = tTime;
            prevStart = this._start;
            timeScale = this._ts;
            prevPaused = !timeScale;
            if (crossingStart) {
              dur || (prevTime = this._zTime);
              (totalTime || !suppressEvents) && (this._zTime = totalTime);
            }
            if (this._repeat) {
              yoyo = this._yoyo;
              cycleDuration = dur + this._rDelay;
              if (this._repeat < -1 && totalTime < 0) {
                return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
              }
              time = _roundPrecise(tTime % cycleDuration);
              if (tTime === tDur) {
                iteration = this._repeat;
                time = dur;
              } else {
                iteration = ~~(tTime / cycleDuration);
                if (iteration && iteration === tTime / cycleDuration) {
                  time = dur;
                  iteration--;
                }
                time > dur && (time = dur);
              }
              prevIteration = _animationCycle(this._tTime, cycleDuration);
              !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration);
              if (yoyo && iteration & 1) {
                time = dur - time;
                isYoyo = 1;
              }
              if (iteration !== prevIteration && !this._lock) {
                var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
                iteration < prevIteration && (rewinding = !rewinding);
                prevTime = rewinding ? 0 : dur;
                this._lock = 1;
                this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                this._tTime = tTime;
                !suppressEvents && this.parent && _callback(this, "onRepeat");
                this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                  return this;
                }
                dur = this._dur;
                tDur = this._tDur;
                if (doesWrap) {
                  this._lock = 2;
                  prevTime = rewinding ? dur : -1e-4;
                  this.render(prevTime, true);
                  this.vars.repeatRefresh && !isYoyo && this.invalidate();
                }
                this._lock = 0;
                if (!this._ts && !prevPaused) {
                  return this;
                }
                _propagateYoyoEase(this, isYoyo);
              }
            }
            if (this._hasPause && !this._forcing && this._lock < 2) {
              pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
              if (pauseTween) {
                tTime -= time - (time = pauseTween._start);
              }
            }
            this._tTime = tTime;
            this._time = time;
            this._act = !timeScale;
            if (!this._initted) {
              this._onUpdate = this.vars.onUpdate;
              this._initted = 1;
              this._zTime = totalTime;
              prevTime = 0;
            }
            if (!prevTime && time && !suppressEvents) {
              _callback(this, "onStart");
              if (this._tTime !== tTime) {
                return this;
              }
            }
            if (time >= prevTime && totalTime >= 0) {
              child = this._first;
              while (child) {
                next = child._next;
                if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                  if (child.parent !== this) {
                    return this.render(totalTime, suppressEvents, force);
                  }
                  child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                  if (time !== this._time || !this._ts && !prevPaused) {
                    pauseTween = 0;
                    next && (tTime += this._zTime = -_tinyNum);
                    break;
                  }
                }
                child = next;
              }
            } else {
              child = this._last;
              var adjustedTime = totalTime < 0 ? totalTime : time;
              while (child) {
                next = child._prev;
                if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                  if (child.parent !== this) {
                    return this.render(totalTime, suppressEvents, force);
                  }
                  child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);
                  if (time !== this._time || !this._ts && !prevPaused) {
                    pauseTween = 0;
                    next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                    break;
                  }
                }
                child = next;
              }
            }
            if (pauseTween && !suppressEvents) {
              this.pause();
              pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
              if (this._ts) {
                this._start = prevStart;
                _setEnd(this);
                return this.render(totalTime, suppressEvents, force);
              }
            }
            this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
            if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) {
              if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
                if (!this._lock) {
                  (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                  if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                    _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                  }
                }
              }
            }
          }
          return this;
        };
        _proto2.add = function add(child, position) {
          var _this2 = this;
          _isNumber(position) || (position = _parsePosition(this, position, child));
          if (!(child instanceof Animation)) {
            if (_isArray(child)) {
              child.forEach(function(obj) {
                return _this2.add(obj, position);
              });
              return this;
            }
            if (_isString(child)) {
              return this.addLabel(child, position);
            }
            if (_isFunction(child)) {
              child = Tween.delayedCall(0, child);
            } else {
              return this;
            }
          }
          return this !== child ? _addToTimeline(this, child, position) : this;
        };
        _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
          if (nested === void 0) {
            nested = true;
          }
          if (tweens === void 0) {
            tweens = true;
          }
          if (timelines === void 0) {
            timelines = true;
          }
          if (ignoreBeforeTime === void 0) {
            ignoreBeforeTime = -_bigNum;
          }
          var a = [], child = this._first;
          while (child) {
            if (child._start >= ignoreBeforeTime) {
              if (child instanceof Tween) {
                tweens && a.push(child);
              } else {
                timelines && a.push(child);
                nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
              }
            }
            child = child._next;
          }
          return a;
        };
        _proto2.getById = function getById2(id) {
          var animations = this.getChildren(1, 1, 1), i2 = animations.length;
          while (i2--) {
            if (animations[i2].vars.id === id) {
              return animations[i2];
            }
          }
        };
        _proto2.remove = function remove(child) {
          if (_isString(child)) {
            return this.removeLabel(child);
          }
          if (_isFunction(child)) {
            return this.killTweensOf(child);
          }
          _removeLinkedListItem(this, child);
          if (child === this._recent) {
            this._recent = this._last;
          }
          return _uncache(this);
        };
        _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
          if (!arguments.length) {
            return this._tTime;
          }
          this._forcing = 1;
          if (!this._dp && this._ts) {
            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
          }
          _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
          this._forcing = 0;
          return this;
        };
        _proto2.addLabel = function addLabel(label, position) {
          this.labels[label] = _parsePosition(this, position);
          return this;
        };
        _proto2.removeLabel = function removeLabel(label) {
          delete this.labels[label];
          return this;
        };
        _proto2.addPause = function addPause(position, callback, params) {
          var t = Tween.delayedCall(0, callback || _emptyFunc, params);
          t.data = "isPause";
          this._hasPause = 1;
          return _addToTimeline(this, t, _parsePosition(this, position));
        };
        _proto2.removePause = function removePause(position) {
          var child = this._first;
          position = _parsePosition(this, position);
          while (child) {
            if (child._start === position && child.data === "isPause") {
              _removeFromParent(child);
            }
            child = child._next;
          }
        };
        _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          var tweens = this.getTweensOf(targets, onlyActive), i2 = tweens.length;
          while (i2--) {
            _overwritingTween !== tweens[i2] && tweens[i2].kill(targets, props);
          }
          return this;
        };
        _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
          var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
          while (child) {
            if (child instanceof Tween) {
              if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
                a.push(child);
              }
            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
              a.push.apply(a, children);
            }
            child = child._next;
          }
          return a;
        };
        _proto2.tweenTo = function tweenTo(position, vars) {
          vars = vars || {};
          var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
            ease: vars.ease || "none",
            lazy: false,
            immediateRender: false,
            time: endTime,
            overwrite: "auto",
            duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
            onStart: function onStart() {
              tl.pause();
              if (!initted) {
                var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
                initted = 1;
              }
              _onStart && _onStart.apply(tween, onStartParams || []);
            }
          }, vars));
          return immediateRender ? tween.render(0) : tween;
        };
        _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
          return this.tweenTo(toPosition, _setDefaults({
            startAt: {
              time: _parsePosition(this, fromPosition)
            }
          }, vars));
        };
        _proto2.recent = function recent() {
          return this._recent;
        };
        _proto2.nextLabel = function nextLabel(afterTime) {
          if (afterTime === void 0) {
            afterTime = this._time;
          }
          return _getLabelInDirection(this, _parsePosition(this, afterTime));
        };
        _proto2.previousLabel = function previousLabel(beforeTime) {
          if (beforeTime === void 0) {
            beforeTime = this._time;
          }
          return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
        };
        _proto2.currentLabel = function currentLabel(value) {
          return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
        };
        _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
          if (ignoreBeforeTime === void 0) {
            ignoreBeforeTime = 0;
          }
          var child = this._first, labels = this.labels, p2;
          while (child) {
            if (child._start >= ignoreBeforeTime) {
              child._start += amount;
              child._end += amount;
            }
            child = child._next;
          }
          if (adjustLabels) {
            for (p2 in labels) {
              if (labels[p2] >= ignoreBeforeTime) {
                labels[p2] += amount;
              }
            }
          }
          return _uncache(this);
        };
        _proto2.invalidate = function invalidate() {
          var child = this._first;
          this._lock = 0;
          while (child) {
            child.invalidate();
            child = child._next;
          }
          return _Animation.prototype.invalidate.call(this);
        };
        _proto2.clear = function clear(includeLabels) {
          if (includeLabels === void 0) {
            includeLabels = true;
          }
          var child = this._first, next;
          while (child) {
            next = child._next;
            this.remove(child);
            child = next;
          }
          this._dp && (this._time = this._tTime = this._pTime = 0);
          includeLabels && (this.labels = {});
          return _uncache(this);
        };
        _proto2.totalDuration = function totalDuration(value) {
          var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent;
          if (arguments.length) {
            return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
          }
          if (self2._dirty) {
            parent = self2.parent;
            while (child) {
              prev = child._prev;
              child._dirty && child.totalDuration();
              start = child._start;
              if (start > prevStart && self2._sort && child._ts && !self2._lock) {
                self2._lock = 1;
                _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
              } else {
                prevStart = start;
              }
              if (start < 0 && child._ts) {
                max -= start;
                if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
                  self2._start += start / self2._ts;
                  self2._time -= start;
                  self2._tTime -= start;
                }
                self2.shiftChildren(-start, false, -Infinity);
                prevStart = 0;
              }
              child._end > max && child._ts && (max = child._end);
              child = prev;
            }
            _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
            self2._dirty = 0;
          }
          return self2._tDur;
        };
        Timeline2.updateRoot = function updateRoot(time) {
          if (_globalTimeline._ts) {
            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
            _lastRenderedFrame = _ticker.frame;
          }
          if (_ticker.frame >= _nextGCFrame) {
            _nextGCFrame += _config.autoSleep || 120;
            var child = _globalTimeline._first;
            if (!child || !child._ts) {
              if (_config.autoSleep && _ticker._listeners.length < 2) {
                while (child && !child._ts) {
                  child = child._next;
                }
                child || _ticker.sleep();
              }
            }
          }
        };
        return Timeline2;
      }(Animation);
      _setDefaults(Timeline.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
      });
      _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
        var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;
        pt.b = start;
        pt.e = end;
        start += "";
        end += "";
        if (hasRandom = ~end.indexOf("random(")) {
          end = _replaceRandom(end);
        }
        if (stringFilter) {
          a = [start, end];
          stringFilter(a, target, prop);
          start = a[0];
          end = a[1];
        }
        startNums = start.match(_complexStringNumExp) || [];
        while (result = _complexStringNumExp.exec(end)) {
          endNum = result[0];
          chunk = end.substring(index, result.index);
          if (color) {
            color = (color + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(") {
            color = 1;
          }
          if (endNum !== startNums[matchIndex++]) {
            startNum = parseFloat(startNums[matchIndex - 1]) || 0;
            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              s: startNum,
              c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
              m: color && color < 4 ? Math.round : 0
            };
            index = _complexStringNumExp.lastIndex;
          }
        }
        pt.c = index < end.length ? end.substring(index, end.length) : "";
        pt.fp = funcParam;
        if (_relExp.test(end) || hasRandom) {
          pt.e = 0;
        }
        this._pt = pt;
        return pt;
      };
      _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
        _isFunction(end) && (end = end(index || 0, target, targets));
        var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
        if (_isString(end)) {
          if (~end.indexOf("random(")) {
            end = _replaceRandom(end);
          }
          if (end.charAt(1) === "=") {
            pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
            if (pt || pt === 0) {
              end = pt;
            }
          }
        }
        if (parsedStart !== end) {
          if (!isNaN(parsedStart * end) && end !== "") {
            pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
            funcParam && (pt.fp = funcParam);
            modifier && pt.modifier(modifier, this, target);
            return this._pt = pt;
          }
          !currentValue && !(prop in target) && _missingPlugin(prop, end);
          return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
        }
      };
      _processVars = function _processVars2(vars, index, target, targets, tween) {
        _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
        if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
          return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
        }
        var copy = {}, p2;
        for (p2 in vars) {
          copy[p2] = _parseFuncOrString(vars[p2], tween, index, target, targets);
        }
        return copy;
      };
      _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
        var plugin, pt, ptLookup, i2;
        if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
          if (tween !== _quickTween) {
            ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
            i2 = plugin._props.length;
            while (i2--) {
              ptLookup[plugin._props[i2]] = pt;
            }
          }
        }
        return plugin;
      };
      _initTween = function _initTween2(tween, time) {
        var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, onUpdateParams = vars.onUpdateParams, callbackScope = vars.callbackScope, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i2, p2, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
        tl && (!keyframes || !ease) && (ease = "none");
        tween._ease = _parseEase(ease, _defaults.ease);
        tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
        if (yoyoEase && tween._yoyo && !tween._repeat) {
          yoyoEase = tween._yEase;
          tween._yEase = tween._ease;
          tween._ease = yoyoEase;
        }
        tween._from = !tl && !!vars.runBackwards;
        if (!tl || keyframes && !vars.stagger) {
          harness = targets[0] ? _getCache(targets[0]).harness : 0;
          harnessVars = harness && vars[harness.prop];
          cleanVars = _copyExcluding(vars, _reservedProps);
          prevStartAt && _removeFromParent(prevStartAt.render(-1, true));
          if (startAt) {
            _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
              data: "isStart",
              overwrite: false,
              parent,
              immediateRender: true,
              lazy: _isNotFalse(lazy),
              startAt: null,
              delay: 0,
              onUpdate,
              onUpdateParams,
              callbackScope,
              stagger: 0
            }, startAt)));
            time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true);
            if (immediateRender) {
              time > 0 && !autoRevert && (tween._startAt = 0);
              if (dur && time <= 0) {
                time && (tween._zTime = time);
                return;
              }
            } else if (autoRevert === false) {
              tween._startAt = 0;
            }
          } else if (runBackwards && dur) {
            if (prevStartAt) {
              !autoRevert && (tween._startAt = 0);
            } else {
              time && (immediateRender = false);
              p2 = _setDefaults({
                overwrite: false,
                data: "isFromStart",
                lazy: immediateRender && _isNotFalse(lazy),
                immediateRender,
                stagger: 0,
                parent
              }, cleanVars);
              harnessVars && (p2[harness.prop] = harnessVars);
              _removeFromParent(tween._startAt = Tween.set(targets, p2));
              time < 0 && tween._startAt.render(-1, true);
              tween._zTime = time;
              if (!immediateRender) {
                _initTween2(tween._startAt, _tinyNum);
              } else if (!time) {
                return;
              }
            }
          }
          tween._pt = 0;
          lazy = dur && _isNotFalse(lazy) || lazy && !dur;
          for (i2 = 0; i2 < targets.length; i2++) {
            target = targets[i2];
            gsData = target._gsap || _harness(targets)[i2]._gsap;
            tween._ptLookup[i2] = ptLookup = {};
            _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
            index = fullTargets === targets ? i2 : fullTargets.indexOf(target);
            if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
              tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
              plugin._props.forEach(function(name) {
                ptLookup[name] = pt;
              });
              plugin.priority && (hasPriority = 1);
            }
            if (!harness || harnessVars) {
              for (p2 in cleanVars) {
                if (_plugins[p2] && (plugin = _checkPlugin(p2, cleanVars, tween, index, target, fullTargets))) {
                  plugin.priority && (hasPriority = 1);
                } else {
                  ptLookup[p2] = pt = _addPropTween.call(tween, target, p2, "get", cleanVars[p2], index, fullTargets, 0, vars.stringFilter);
                }
              }
            }
            tween._op && tween._op[i2] && tween.kill(target, tween._op[i2]);
            if (autoOverwrite && tween._pt) {
              _overwritingTween = tween;
              _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
              overwritten = !tween.parent;
              _overwritingTween = 0;
            }
            tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
          }
          hasPriority && _sortPropTweensByPriority(tween);
          tween._onInit && tween._onInit(tween);
        }
        tween._onUpdate = onUpdate;
        tween._initted = (!tween._op || tween._pt) && !overwritten;
        keyframes && time <= 0 && tl.render(_bigNum, true, true);
      };
      _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
        var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p2, i2, aliases;
        if (!propertyAliases) {
          return vars;
        }
        copy = _merge({}, vars);
        for (p2 in propertyAliases) {
          if (p2 in copy) {
            aliases = propertyAliases[p2].split(",");
            i2 = aliases.length;
            while (i2--) {
              copy[aliases[i2]] = copy[p2];
            }
          }
        }
        return copy;
      };
      _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
        var ease = obj.ease || easeEach || "power1.inOut", p2, a;
        if (_isArray(obj)) {
          a = allProps[prop] || (allProps[prop] = []);
          obj.forEach(function(value, i2) {
            return a.push({
              t: i2 / (obj.length - 1) * 100,
              v: value,
              e: ease
            });
          });
        } else {
          for (p2 in obj) {
            a = allProps[p2] || (allProps[p2] = []);
            p2 === "ease" || a.push({
              t: parseFloat(prop),
              v: obj[p2],
              e: ease
            });
          }
        }
      };
      _parseFuncOrString = function _parseFuncOrString2(value, tween, i2, target, targets) {
        return _isFunction(value) ? value.call(tween, i2, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
      };
      _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase";
      _staggerPropsToSkip = {};
      _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
        return _staggerPropsToSkip[name] = 1;
      });
      Tween = /* @__PURE__ */ function(_Animation2) {
        _inheritsLoose(Tween2, _Animation2);
        function Tween2(targets, vars, position, skipInherit) {
          var _this3;
          if (typeof vars === "number") {
            position.duration = vars;
            vars = position;
            position = null;
          }
          _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
          var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i2, copy, l, p2, curTarget, staggerFunc, staggerVarsToMerge;
          _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
          _this3._ptLookup = [];
          _this3._overwrite = overwrite;
          if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
            vars = _this3.vars;
            tl = _this3.timeline = new Timeline({
              data: "nested",
              defaults: defaults2 || {}
            });
            tl.kill();
            tl.parent = tl._dp = _assertThisInitialized(_this3);
            tl._start = 0;
            if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
              l = parsedTargets.length;
              staggerFunc = stagger && distribute(stagger);
              if (_isObject(stagger)) {
                for (p2 in stagger) {
                  if (~_staggerTweenProps.indexOf(p2)) {
                    staggerVarsToMerge || (staggerVarsToMerge = {});
                    staggerVarsToMerge[p2] = stagger[p2];
                  }
                }
              }
              for (i2 = 0; i2 < l; i2++) {
                copy = _copyExcluding(vars, _staggerPropsToSkip);
                copy.stagger = 0;
                yoyoEase && (copy.yoyoEase = yoyoEase);
                staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
                curTarget = parsedTargets[i2];
                copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i2, curTarget, parsedTargets);
                copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i2, curTarget, parsedTargets) || 0) - _this3._delay;
                if (!stagger && l === 1 && copy.delay) {
                  _this3._delay = delay = copy.delay;
                  _this3._start += delay;
                  copy.delay = 0;
                }
                tl.to(curTarget, copy, staggerFunc ? staggerFunc(i2, curTarget, parsedTargets) : 0);
                tl._ease = _easeMap.none;
              }
              tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
            } else if (keyframes) {
              _inheritDefaults(_setDefaults(tl.vars.defaults, {
                ease: "none"
              }));
              tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
              var time = 0, a, kf, v;
              if (_isArray(keyframes)) {
                keyframes.forEach(function(frame) {
                  return tl.to(parsedTargets, frame, ">");
                });
              } else {
                copy = {};
                for (p2 in keyframes) {
                  p2 === "ease" || p2 === "easeEach" || _parseKeyframe(p2, keyframes[p2], copy, keyframes.easeEach);
                }
                for (p2 in copy) {
                  a = copy[p2].sort(function(a2, b) {
                    return a2.t - b.t;
                  });
                  time = 0;
                  for (i2 = 0; i2 < a.length; i2++) {
                    kf = a[i2];
                    v = {
                      ease: kf.e,
                      duration: (kf.t - (i2 ? a[i2 - 1].t : 0)) / 100 * duration
                    };
                    v[p2] = kf.v;
                    tl.to(parsedTargets, v, time);
                    time += v.duration;
                  }
                }
                tl.duration() < duration && tl.to({}, {
                  duration: duration - tl.duration()
                });
              }
            }
            duration || _this3.duration(duration = tl.duration());
          } else {
            _this3.timeline = 0;
          }
          if (overwrite === true && !_suppressOverwrites) {
            _overwritingTween = _assertThisInitialized(_this3);
            _globalTimeline.killTweensOf(parsedTargets);
            _overwritingTween = 0;
          }
          _addToTimeline(parent, _assertThisInitialized(_this3), position);
          vars.reversed && _this3.reverse();
          vars.paused && _this3.paused(true);
          if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
            _this3._tTime = -_tinyNum;
            _this3.render(Math.max(0, -delay));
          }
          scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
          return _this3;
        }
        var _proto3 = Tween2.prototype;
        _proto3.render = function render6(totalTime, suppressEvents, force) {
          var prevTime = this._time, tDur = this._tDur, dur = this._dur, tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
          if (!dur) {
            _renderZeroDurationTween(this, totalTime, suppressEvents, force);
          } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
            time = tTime;
            timeline2 = this.timeline;
            if (this._repeat) {
              cycleDuration = dur + this._rDelay;
              if (this._repeat < -1 && totalTime < 0) {
                return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
              }
              time = _roundPrecise(tTime % cycleDuration);
              if (tTime === tDur) {
                iteration = this._repeat;
                time = dur;
              } else {
                iteration = ~~(tTime / cycleDuration);
                if (iteration && iteration === tTime / cycleDuration) {
                  time = dur;
                  iteration--;
                }
                time > dur && (time = dur);
              }
              isYoyo = this._yoyo && iteration & 1;
              if (isYoyo) {
                yoyoEase = this._yEase;
                time = dur - time;
              }
              prevIteration = _animationCycle(this._tTime, cycleDuration);
              if (time === prevTime && !force && this._initted) {
                return this;
              }
              if (iteration !== prevIteration) {
                timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
                if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                  this._lock = force = 1;
                  this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
                }
              }
            }
            if (!this._initted) {
              if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
                this._tTime = 0;
                return this;
              }
              if (dur !== this._dur) {
                return this.render(totalTime, suppressEvents, force);
              }
            }
            this._tTime = tTime;
            this._time = time;
            if (!this._act && this._ts) {
              this._act = 1;
              this._lazy = 0;
            }
            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
            if (this._from) {
              this.ratio = ratio = 1 - ratio;
            }
            if (time && !prevTime && !suppressEvents) {
              _callback(this, "onStart");
              if (this._tTime !== tTime) {
                return this;
              }
            }
            pt = this._pt;
            while (pt) {
              pt.r(ratio, pt.d);
              pt = pt._next;
            }
            timeline2 && timeline2.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
            if (this._onUpdate && !suppressEvents) {
              totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force);
              _callback(this, "onUpdate");
            }
            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
              totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
              (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
                _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
          return this;
        };
        _proto3.targets = function targets() {
          return this._targets;
        };
        _proto3.invalidate = function invalidate() {
          this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
          this._ptLookup = [];
          this.timeline && this.timeline.invalidate();
          return _Animation2.prototype.invalidate.call(this);
        };
        _proto3.kill = function kill2(targets, vars) {
          if (vars === void 0) {
            vars = "all";
          }
          if (!targets && (!vars || vars === "all")) {
            this._lazy = this._pt = 0;
            return this.parent ? _interrupt(this) : this;
          }
          if (this.timeline) {
            var tDur = this.timeline.totalDuration();
            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
            return this;
          }
          var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p2, pt, i2;
          if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
            vars === "all" && (this._pt = 0);
            return _interrupt(this);
          }
          overwrittenProps = this._op = this._op || [];
          if (vars !== "all") {
            if (_isString(vars)) {
              p2 = {};
              _forEachName(vars, function(name) {
                return p2[name] = 1;
              });
              vars = p2;
            }
            vars = _addAliasesToVars(parsedTargets, vars);
          }
          i2 = parsedTargets.length;
          while (i2--) {
            if (~killingTargets.indexOf(parsedTargets[i2])) {
              curLookup = propTweenLookup[i2];
              if (vars === "all") {
                overwrittenProps[i2] = vars;
                props = curLookup;
                curOverwriteProps = {};
              } else {
                curOverwriteProps = overwrittenProps[i2] = overwrittenProps[i2] || {};
                props = vars;
              }
              for (p2 in props) {
                pt = curLookup && curLookup[p2];
                if (pt) {
                  if (!("kill" in pt.d) || pt.d.kill(p2) === true) {
                    _removeLinkedListItem(this, pt, "_pt");
                  }
                  delete curLookup[p2];
                }
                if (curOverwriteProps !== "all") {
                  curOverwriteProps[p2] = 1;
                }
              }
            }
          }
          this._initted && !this._pt && firstPT && _interrupt(this);
          return this;
        };
        Tween2.to = function to(targets, vars) {
          return new Tween2(targets, vars, arguments[2]);
        };
        Tween2.from = function from(targets, vars) {
          return _createTweenType(1, arguments);
        };
        Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
          return new Tween2(callback, 0, {
            immediateRender: false,
            lazy: false,
            overwrite: false,
            delay,
            onComplete: callback,
            onReverseComplete: callback,
            onCompleteParams: params,
            onReverseCompleteParams: params,
            callbackScope: scope
          });
        };
        Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
          return _createTweenType(2, arguments);
        };
        Tween2.set = function set(targets, vars) {
          vars.duration = 0;
          vars.repeatDelay || (vars.repeat = 0);
          return new Tween2(targets, vars);
        };
        Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          return _globalTimeline.killTweensOf(targets, props, onlyActive);
        };
        return Tween2;
      }(Animation);
      _setDefaults(Tween.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
      });
      _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
        Tween[name] = function() {
          var tl = new Timeline(), params = _slice.call(arguments, 0);
          params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
          return tl[name].apply(tl, params);
        };
      });
      _setterPlain = function _setterPlain2(target, property, value) {
        return target[property] = value;
      };
      _setterFunc = function _setterFunc2(target, property, value) {
        return target[property](value);
      };
      _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
        return target[property](data.fp, value);
      };
      _setterAttribute = function _setterAttribute2(target, property, value) {
        return target.setAttribute(property, value);
      };
      _getSetter = function _getSetter2(target, property) {
        return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
      };
      _renderPlain = function _renderPlain2(ratio, data) {
        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
      };
      _renderBoolean = function _renderBoolean2(ratio, data) {
        return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
      };
      _renderComplexString = function _renderComplexString2(ratio, data) {
        var pt = data._pt, s = "";
        if (!ratio && data.b) {
          s = data.b;
        } else if (ratio === 1 && data.e) {
          s = data.e;
        } else {
          while (pt) {
            s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
            pt = pt._next;
          }
          s += data.c;
        }
        data.set(data.t, data.p, s, data);
      };
      _renderPropTweens = function _renderPropTweens2(ratio, data) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      };
      _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
        var pt = this._pt, next;
        while (pt) {
          next = pt._next;
          pt.p === property && pt.modifier(modifier, tween, target);
          pt = next;
        }
      };
      _killPropTweensOf = function _killPropTweensOf2(property) {
        var pt = this._pt, hasNonDependentRemaining, next;
        while (pt) {
          next = pt._next;
          if (pt.p === property && !pt.op || pt.op === property) {
            _removeLinkedListItem(this, pt, "_pt");
          } else if (!pt.dep) {
            hasNonDependentRemaining = 1;
          }
          pt = next;
        }
        return !hasNonDependentRemaining;
      };
      _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
        data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
      };
      _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
        var pt = parent._pt, next, pt2, first, last;
        while (pt) {
          next = pt._next;
          pt2 = first;
          while (pt2 && pt2.pr > pt.pr) {
            pt2 = pt2._next;
          }
          if (pt._prev = pt2 ? pt2._prev : last) {
            pt._prev._next = pt;
          } else {
            first = pt;
          }
          if (pt._next = pt2) {
            pt2._prev = pt;
          } else {
            last = pt;
          }
          pt = next;
        }
        parent._pt = first;
      };
      PropTween = /* @__PURE__ */ function() {
        function PropTween4(next, target, prop, start, change, renderer, data, setter, priority) {
          this.t = target;
          this.s = start;
          this.c = change;
          this.p = prop;
          this.r = renderer || _renderPlain;
          this.d = data || this;
          this.set = setter || _setterPlain;
          this.pr = priority || 0;
          this._next = next;
          if (next) {
            next._prev = this;
          }
        }
        var _proto4 = PropTween4.prototype;
        _proto4.modifier = function modifier(func, tween, target) {
          this.mSet = this.mSet || this.set;
          this.set = _setterWithModifier;
          this.m = func;
          this.mt = target;
          this.tween = tween;
        };
        return PropTween4;
      }();
      _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
        return _reservedProps[name] = 1;
      });
      _globals.TweenMax = _globals.TweenLite = Tween;
      _globals.TimelineLite = _globals.TimelineMax = Timeline;
      _globalTimeline = new Timeline({
        sortChildren: false,
        defaults: _defaults,
        autoRemoveChildren: true,
        id: "root",
        smoothChildTiming: true
      });
      _config.stringFilter = _colorStringFilter;
      _gsap = {
        registerPlugin: function registerPlugin() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          args.forEach(function(config3) {
            return _createPlugin(config3);
          });
        },
        timeline: function timeline(vars) {
          return new Timeline(vars);
        },
        getTweensOf: function getTweensOf(targets, onlyActive) {
          return _globalTimeline.getTweensOf(targets, onlyActive);
        },
        getProperty: function getProperty(target, property, unit, uncache) {
          _isString(target) && (target = toArray(target)[0]);
          var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
          unit === "native" && (unit = "");
          return !target ? target : !property ? function(property2, unit2, uncache2) {
            return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
          } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
        },
        quickSetter: function quickSetter(target, property, unit) {
          target = toArray(target);
          if (target.length > 1) {
            var setters = target.map(function(t) {
              return gsap.quickSetter(t, property, unit);
            }), l = setters.length;
            return function(value) {
              var i2 = l;
              while (i2--) {
                setters[i2](value);
              }
            };
          }
          target = target[0] || {};
          var Plugin = _plugins[property], cache = _getCache(target), p2 = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
            var p3 = new Plugin();
            _quickTween._pt = 0;
            p3.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
            p3.render(1, p3);
            _quickTween._pt && _renderPropTweens(1, _quickTween);
          } : cache.set(target, p2);
          return Plugin ? setter : function(value) {
            return setter(target, p2, unit ? value + unit : value, cache, 1);
          };
        },
        isTweening: function isTweening(targets) {
          return _globalTimeline.getTweensOf(targets, true).length > 0;
        },
        defaults: function defaults(value) {
          value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
          return _mergeDeep(_defaults, value || {});
        },
        config: function config2(value) {
          return _mergeDeep(_config, value || {});
        },
        registerEffect: function registerEffect(_ref3) {
          var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
          (plugins || "").split(",").forEach(function(pluginName) {
            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
          });
          _effects[name] = function(targets, vars, tl) {
            return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
          };
          if (extendTimeline) {
            Timeline.prototype[name] = function(targets, vars, position) {
              return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
            };
          }
        },
        registerEase: function registerEase(name, ease) {
          _easeMap[name] = _parseEase(ease);
        },
        parseEase: function parseEase(ease, defaultEase) {
          return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
        },
        getById: function getById(id) {
          return _globalTimeline.getById(id);
        },
        exportRoot: function exportRoot(vars, includeDelayedCalls) {
          if (vars === void 0) {
            vars = {};
          }
          var tl = new Timeline(vars), child, next;
          tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
          _globalTimeline.remove(tl);
          tl._dp = 0;
          tl._time = tl._tTime = _globalTimeline._time;
          child = _globalTimeline._first;
          while (child) {
            next = child._next;
            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
              _addToTimeline(tl, child, child._start - child._delay);
            }
            child = next;
          }
          _addToTimeline(_globalTimeline, tl, 0);
          return tl;
        },
        utils: {
          wrap,
          wrapYoyo,
          distribute,
          random,
          snap,
          normalize,
          getUnit,
          clamp: clamp2,
          splitColor,
          toArray,
          selector,
          mapRange,
          pipe,
          unitize,
          interpolate,
          shuffle
        },
        install: _install,
        effects: _effects,
        ticker: _ticker,
        updateRoot: Timeline.updateRoot,
        plugins: _plugins,
        globalTimeline: _globalTimeline,
        core: {
          PropTween,
          globals: _addGlobal,
          Tween,
          Timeline,
          Animation,
          getCache: _getCache,
          _removeLinkedListItem,
          suppressOverwrites: function suppressOverwrites(value) {
            return _suppressOverwrites = value;
          }
        }
      };
      _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
        return _gsap[name] = Tween[name];
      });
      _ticker.add(Timeline.updateRoot);
      _quickTween = _gsap.to({}, {
        duration: 0
      });
      _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
        var pt = plugin._pt;
        while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
          pt = pt._next;
        }
        return pt;
      };
      _addModifiers = function _addModifiers2(tween, modifiers) {
        var targets = tween._targets, p2, i2, pt;
        for (p2 in modifiers) {
          i2 = targets.length;
          while (i2--) {
            pt = tween._ptLookup[i2][p2];
            if (pt && (pt = pt.d)) {
              if (pt._pt) {
                pt = _getPluginPropTween(pt, p2);
              }
              pt && pt.modifier && pt.modifier(modifiers[p2], tween, targets[i2], p2);
            }
          }
        }
      };
      _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
        return {
          name,
          rawVars: 1,
          init: function init10(target, vars, tween) {
            tween._onInit = function(tween2) {
              var temp, p2;
              if (_isString(vars)) {
                temp = {};
                _forEachName(vars, function(name2) {
                  return temp[name2] = 1;
                });
                vars = temp;
              }
              if (modifier) {
                temp = {};
                for (p2 in vars) {
                  temp[p2] = modifier(vars[p2]);
                }
                vars = temp;
              }
              _addModifiers(tween2, vars);
            };
          }
        };
      };
      gsap = _gsap.registerPlugin({
        name: "attr",
        init: function init(target, vars, tween, index, targets) {
          var p2, pt;
          for (p2 in vars) {
            pt = this.add(target, "setAttribute", (target.getAttribute(p2) || 0) + "", vars[p2], index, targets, 0, 0, p2);
            pt && (pt.op = p2);
            this._props.push(p2);
          }
        }
      }, {
        name: "endArray",
        init: function init2(target, value) {
          var i2 = value.length;
          while (i2--) {
            this.add(target, i2, target[i2] || 0, value[i2]);
          }
        }
      }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
      Tween.version = Timeline.version = gsap.version = "3.9.1";
      _coreReady = 1;
      _windowExists() && _wake();
      Power0 = _easeMap.Power0;
      Power1 = _easeMap.Power1;
      Power2 = _easeMap.Power2;
      Power3 = _easeMap.Power3;
      Power4 = _easeMap.Power4;
      Linear = _easeMap.Linear;
      Quad = _easeMap.Quad;
      Cubic = _easeMap.Cubic;
      Quart = _easeMap.Quart;
      Quint = _easeMap.Quint;
      Strong = _easeMap.Strong;
      Elastic = _easeMap.Elastic;
      Back = _easeMap.Back;
      SteppedEase = _easeMap.SteppedEase;
      Bounce = _easeMap.Bounce;
      Sine = _easeMap.Sine;
      Expo = _easeMap.Expo;
      Circ = _easeMap.Circ;
    }
  });

  // node_modules/gsap/CSSPlugin.js
  var _win2, _doc2, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _windowExists3, _transformProps, _RAD2DEG, _DEG2RAD, _atan2, _bigNum2, _capsExp, _horizontalExp, _complexExp, _propertyAliases, _renderCSSProp, _renderPropWithEnd, _renderCSSPropWithBeginning, _renderRoundedCSSProp, _renderNonTweeningValue, _renderNonTweeningValueOnlyAtEnd, _setterCSSStyle, _setterCSSProp, _setterTransform, _setterScale, _setterScaleWithRender, _setterTransformWithRender, _transformProp, _transformOriginProp, _supports3D, _createElement, _getComputedProperty, _prefixes, _checkPropPrefix, _initCore, _getBBoxHack, _getAttributeFallbacks, _getBBox, _isSVG, _removeProperty, _addNonTweeningPT, _nonConvertibleUnits, _convertToUnit, _get, _tweenComplexCSSString, _keywordToPercent, _convertKeywordsToPercentages, _renderClearProps, _specialProps, _identity2DMatrix, _rotationalProperties, _isNullTransform, _getComputedTransformMatrixAsArray, _getMatrix, _applySVGOrigin, _parseTransform, _firstTwoOnly, _addPxTranslate, _renderNon3DTransforms, _zeroDeg, _zeroPx, _endParenthesis, _renderCSSTransforms, _renderSVGTransforms, _addRotationalPropTween, _assign, _addRawTransformPTs, CSSPlugin;
  var init_CSSPlugin = __esm({
    "node_modules/gsap/CSSPlugin.js"() {
      init_gsap_core();
      _windowExists3 = function _windowExists4() {
        return typeof window !== "undefined";
      };
      _transformProps = {};
      _RAD2DEG = 180 / Math.PI;
      _DEG2RAD = Math.PI / 180;
      _atan2 = Math.atan2;
      _bigNum2 = 1e8;
      _capsExp = /([A-Z])/g;
      _horizontalExp = /(?:left|right|width|margin|padding|x)/i;
      _complexExp = /[\s,\(]\S/;
      _propertyAliases = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
      };
      _renderCSSProp = function _renderCSSProp2(ratio, data) {
        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
      };
      _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
      };
      _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
        return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
      };
      _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
        var value = data.s + data.c * ratio;
        data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
      };
      _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
        return data.set(data.t, data.p, ratio ? data.e : data.b, data);
      };
      _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
        return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
      };
      _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
        return target.style[property] = value;
      };
      _setterCSSProp = function _setterCSSProp2(target, property, value) {
        return target.style.setProperty(property, value);
      };
      _setterTransform = function _setterTransform2(target, property, value) {
        return target._gsap[property] = value;
      };
      _setterScale = function _setterScale2(target, property, value) {
        return target._gsap.scaleX = target._gsap.scaleY = value;
      };
      _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
        var cache = target._gsap;
        cache.scaleX = cache.scaleY = value;
        cache.renderTransform(ratio, cache);
      };
      _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
        var cache = target._gsap;
        cache[property] = value;
        cache.renderTransform(ratio, cache);
      };
      _transformProp = "transform";
      _transformOriginProp = _transformProp + "Origin";
      _createElement = function _createElement2(type, ns) {
        var e = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
        return e.style ? e : _doc2.createElement(type);
      };
      _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
        var cs = getComputedStyle(target);
        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
      };
      _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
      _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
        var e = element || _tempDiv, s = e.style, i2 = 5;
        if (property in s && !preferPrefix) {
          return property;
        }
        property = property.charAt(0).toUpperCase() + property.substr(1);
        while (i2-- && !(_prefixes[i2] + property in s)) {
        }
        return i2 < 0 ? null : (i2 === 3 ? "ms" : i2 >= 0 ? _prefixes[i2] : "") + property;
      };
      _initCore = function _initCore2() {
        if (_windowExists3() && window.document) {
          _win2 = window;
          _doc2 = _win2.document;
          _docElement = _doc2.documentElement;
          _tempDiv = _createElement("div") || {
            style: {}
          };
          _tempDivStyler = _createElement("div");
          _transformProp = _checkPropPrefix(_transformProp);
          _transformOriginProp = _transformProp + "Origin";
          _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
          _supports3D = !!_checkPropPrefix("perspective");
          _pluginInitted = 1;
        }
      };
      _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
        var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
        _docElement.appendChild(svg);
        svg.appendChild(this);
        this.style.display = "block";
        if (swapIfPossible) {
          try {
            bbox = this.getBBox();
            this._gsapBBox = this.getBBox;
            this.getBBox = _getBBoxHack2;
          } catch (e) {
          }
        } else if (this._gsapBBox) {
          bbox = this._gsapBBox();
        }
        if (oldParent) {
          if (oldSibling) {
            oldParent.insertBefore(this, oldSibling);
          } else {
            oldParent.appendChild(this);
          }
        }
        _docElement.removeChild(svg);
        this.style.cssText = oldCSS;
        return bbox;
      };
      _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
        var i2 = attributesArray.length;
        while (i2--) {
          if (target.hasAttribute(attributesArray[i2])) {
            return target.getAttribute(attributesArray[i2]);
          }
        }
      };
      _getBBox = function _getBBox2(target) {
        var bounds;
        try {
          bounds = target.getBBox();
        } catch (error) {
          bounds = _getBBoxHack.call(target, true);
        }
        bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
        return bounds && !bounds.width && !bounds.x && !bounds.y ? {
          x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
          y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
          width: 0,
          height: 0
        } : bounds;
      };
      _isSVG = function _isSVG2(e) {
        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
      };
      _removeProperty = function _removeProperty2(target, property) {
        if (property) {
          var style = target.style;
          if (property in _transformProps && property !== _transformOriginProp) {
            property = _transformProp;
          }
          if (style.removeProperty) {
            if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
              property = "-" + property;
            }
            style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
          } else {
            style.removeAttribute(property);
          }
        }
      };
      _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
        var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
        plugin._pt = pt;
        pt.b = beginning;
        pt.e = end;
        plugin._props.push(property);
        return pt;
      };
      _nonConvertibleUnits = {
        deg: 1,
        rad: 1,
        turn: 1
      };
      _convertToUnit = function _convertToUnit2(target, property, value, unit) {
        var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px2, parent, cache, isSVG;
        if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
          return curValue;
        }
        curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
        isSVG = target.getCTM && _isSVG(target);
        if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
          px2 = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
          return _round(toPercent ? curValue / px2 * amount : curValue / 100 * px2);
        }
        style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
        parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
        if (isSVG) {
          parent = (target.ownerSVGElement || {}).parentNode;
        }
        if (!parent || parent === _doc2 || !parent.appendChild) {
          parent = _doc2.body;
        }
        cache = parent._gsap;
        if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {
          return _round(curValue / cache.width * amount);
        } else {
          (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
          parent === target && (style.position = "static");
          parent.appendChild(_tempDiv);
          px2 = _tempDiv[measureProperty];
          parent.removeChild(_tempDiv);
          style.position = "absolute";
          if (horizontal && toPercent) {
            cache = _getCache(parent);
            cache.time = _ticker.time;
            cache.width = parent[measureProperty];
          }
        }
        return _round(toPixels ? px2 * curValue / amount : px2 && curValue ? amount / px2 * curValue : 0);
      };
      _get = function _get2(target, property, unit, uncache) {
        var value;
        _pluginInitted || _initCore();
        if (property in _propertyAliases && property !== "transform") {
          property = _propertyAliases[property];
          if (~property.indexOf(",")) {
            property = property.split(",")[0];
          }
        }
        if (_transformProps[property] && property !== "transform") {
          value = _parseTransform(target, uncache);
          value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
        } else {
          value = target.style[property];
          if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
            value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
          }
        }
        return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
      };
      _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
        if (!start || start === "none") {
          var p2 = _checkPropPrefix(prop, target, 1), s = p2 && _getComputedProperty(target, p2, 1);
          if (s && s !== start) {
            prop = p2;
            start = s;
          } else if (prop === "borderColor") {
            start = _getComputedProperty(target, "borderTopColor");
          }
        }
        var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, relative, endValues;
        pt.b = start;
        pt.e = end;
        start += "";
        end += "";
        if (end === "auto") {
          target.style[prop] = end;
          end = _getComputedProperty(target, prop) || end;
          target.style[prop] = start;
        }
        a = [start, end];
        _colorStringFilter(a);
        start = a[0];
        end = a[1];
        startValues = start.match(_numWithUnitExp) || [];
        endValues = end.match(_numWithUnitExp) || [];
        if (endValues.length) {
          while (result = _numWithUnitExp.exec(end)) {
            endValue = result[0];
            chunk = end.substring(index, result.index);
            if (color) {
              color = (color + 1) % 5;
            } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
              color = 1;
            }
            if (endValue !== (startValue = startValues[matchIndex++] || "")) {
              startNum = parseFloat(startValue) || 0;
              startUnit = startValue.substr((startNum + "").length);
              relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
              if (relative) {
                endValue = endValue.substr(2);
              }
              endNum = parseFloat(endValue);
              endUnit = endValue.substr((endNum + "").length);
              index = _numWithUnitExp.lastIndex - endUnit.length;
              if (!endUnit) {
                endUnit = endUnit || _config.units[prop] || startUnit;
                if (index === end.length) {
                  end += endUnit;
                  pt.e += endUnit;
                }
              }
              if (startUnit !== endUnit) {
                startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
              }
              pt._pt = {
                _next: pt._pt,
                p: chunk || matchIndex === 1 ? chunk : ",",
                s: startNum,
                c: relative ? relative * endNum : endNum - startNum,
                m: color && color < 4 || prop === "zIndex" ? Math.round : 0
              };
            }
          }
          pt.c = index < end.length ? end.substring(index, end.length) : "";
        } else {
          pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
        }
        _relExp.test(end) && (pt.e = 0);
        this._pt = pt;
        return pt;
      };
      _keywordToPercent = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
      };
      _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
        var split = value.split(" "), x = split[0], y = split[1] || "50%";
        if (x === "top" || x === "bottom" || y === "left" || y === "right") {
          value = x;
          x = y;
          y = value;
        }
        split[0] = _keywordToPercent[x] || x;
        split[1] = _keywordToPercent[y] || y;
        return split.join(" ");
      };
      _renderClearProps = function _renderClearProps2(ratio, data) {
        if (data.tween && data.tween._time === data.tween._dur) {
          var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i2;
          if (props === "all" || props === true) {
            style.cssText = "";
            clearTransforms = 1;
          } else {
            props = props.split(",");
            i2 = props.length;
            while (--i2 > -1) {
              prop = props[i2];
              if (_transformProps[prop]) {
                clearTransforms = 1;
                prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
              }
              _removeProperty(target, prop);
            }
          }
          if (clearTransforms) {
            _removeProperty(target, _transformProp);
            if (cache) {
              cache.svg && target.removeAttribute("transform");
              _parseTransform(target, 1);
              cache.uncache = 1;
            }
          }
        }
      };
      _specialProps = {
        clearProps: function clearProps(plugin, target, property, endValue, tween) {
          if (tween.data !== "isFromStart") {
            var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
            pt.u = endValue;
            pt.pr = -10;
            pt.tween = tween;
            plugin._props.push(property);
            return 1;
          }
        }
      };
      _identity2DMatrix = [1, 0, 0, 1, 0, 0];
      _rotationalProperties = {};
      _isNullTransform = function _isNullTransform2(value) {
        return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
      };
      _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
        var matrixString = _getComputedProperty(target, _transformProp);
        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
      };
      _getMatrix = function _getMatrix2(target, force2D) {
        var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
        if (cache.svg && target.getAttribute("transform")) {
          temp = target.transform.baseVal.consolidate().matrix;
          matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
          return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
        } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
          temp = style.display;
          style.display = "block";
          parent = target.parentNode;
          if (!parent || !target.offsetParent) {
            addedToDOM = 1;
            nextSibling = target.nextSibling;
            _docElement.appendChild(target);
          }
          matrix = _getComputedTransformMatrixAsArray(target);
          temp ? style.display = temp : _removeProperty(target, "display");
          if (addedToDOM) {
            nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
          }
        }
        return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
      };
      _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
        var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
        if (!originIsAbsolute) {
          bounds = _getBBox(target);
          xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
          yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
        } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
          x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
          y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
          xOrigin = x;
          yOrigin = y;
        }
        if (smooth || smooth !== false && cache.smooth) {
          tx = xOrigin - xOriginOld;
          ty = yOrigin - yOriginOld;
          cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
          cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
        } else {
          cache.xOffset = cache.yOffset = 0;
        }
        cache.xOrigin = xOrigin;
        cache.yOrigin = yOrigin;
        cache.smooth = !!smooth;
        cache.origin = origin;
        cache.originIsAbsolute = !!originIsAbsolute;
        target.style[_transformOriginProp] = "0px 0px";
        if (pluginToAddPropTweensTo) {
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
          _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
        }
        target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
      };
      _parseTransform = function _parseTransform2(target, uncache) {
        var cache = target._gsap || new GSCache(target);
        if ("x" in cache && !uncache && !cache.uncache) {
          return cache;
        }
        var style = target.style, invertedScaleX = cache.scaleX < 0, px2 = "px", deg = "deg", origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
        x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
        scaleX = scaleY = 1;
        cache.svg = !!(target.getCTM && _isSVG(target));
        matrix = _getMatrix(target, cache.svg);
        if (cache.svg) {
          t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin");
          _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
        }
        xOrigin = cache.xOrigin || 0;
        yOrigin = cache.yOrigin || 0;
        if (matrix !== _identity2DMatrix) {
          a = matrix[0];
          b = matrix[1];
          c = matrix[2];
          d = matrix[3];
          x = a12 = matrix[4];
          y = a22 = matrix[5];
          if (matrix.length === 6) {
            scaleX = Math.sqrt(a * a + b * b);
            scaleY = Math.sqrt(d * d + c * c);
            rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
            skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
            skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
            if (cache.svg) {
              x -= xOrigin - (xOrigin * a + yOrigin * c);
              y -= yOrigin - (xOrigin * b + yOrigin * d);
            }
          } else {
            a32 = matrix[6];
            a42 = matrix[7];
            a13 = matrix[8];
            a23 = matrix[9];
            a33 = matrix[10];
            a43 = matrix[11];
            x = matrix[12];
            y = matrix[13];
            z = matrix[14];
            angle = _atan2(a32, a33);
            rotationX = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a12 * cos + a13 * sin;
              t2 = a22 * cos + a23 * sin;
              t3 = a32 * cos + a33 * sin;
              a13 = a12 * -sin + a13 * cos;
              a23 = a22 * -sin + a23 * cos;
              a33 = a32 * -sin + a33 * cos;
              a43 = a42 * -sin + a43 * cos;
              a12 = t1;
              a22 = t2;
              a32 = t3;
            }
            angle = _atan2(-c, a33);
            rotationY = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a * cos - a13 * sin;
              t2 = b * cos - a23 * sin;
              t3 = c * cos - a33 * sin;
              a43 = d * sin + a43 * cos;
              a = t1;
              b = t2;
              c = t3;
            }
            angle = _atan2(b, a);
            rotation = angle * _RAD2DEG;
            if (angle) {
              cos = Math.cos(angle);
              sin = Math.sin(angle);
              t1 = a * cos + b * sin;
              t2 = a12 * cos + a22 * sin;
              b = b * cos - a * sin;
              a22 = a22 * cos - a12 * sin;
              a = t1;
              a12 = t2;
            }
            if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
              rotationX = rotation = 0;
              rotationY = 180 - rotationY;
            }
            scaleX = _round(Math.sqrt(a * a + b * b + c * c));
            scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
            angle = _atan2(a12, a22);
            skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
            perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
          }
          if (cache.svg) {
            t1 = target.getAttribute("transform");
            cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
            t1 && target.setAttribute("transform", t1);
          }
        }
        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
          if (invertedScaleX) {
            scaleX *= -1;
            skewX += rotation <= 0 ? 180 : -180;
            rotation += rotation <= 0 ? 180 : -180;
          } else {
            scaleY *= -1;
            skewX += skewX <= 0 ? 180 : -180;
          }
        }
        cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px2;
        cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px2;
        cache.z = z + px2;
        cache.scaleX = _round(scaleX);
        cache.scaleY = _round(scaleY);
        cache.rotation = _round(rotation) + deg;
        cache.rotationX = _round(rotationX) + deg;
        cache.rotationY = _round(rotationY) + deg;
        cache.skewX = skewX + deg;
        cache.skewY = skewY + deg;
        cache.transformPerspective = perspective + px2;
        if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
          style[_transformOriginProp] = _firstTwoOnly(origin);
        }
        cache.xOffset = cache.yOffset = 0;
        cache.force3D = _config.force3D;
        cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
        cache.uncache = 0;
        return cache;
      };
      _firstTwoOnly = function _firstTwoOnly2(value) {
        return (value = value.split(" "))[0] + " " + value[1];
      };
      _addPxTranslate = function _addPxTranslate2(target, start, value) {
        var unit = getUnit(start);
        return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
      };
      _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
        cache.z = "0px";
        cache.rotationY = cache.rotationX = "0deg";
        cache.force3D = 0;
        _renderCSSTransforms(ratio, cache);
      };
      _zeroDeg = "0deg";
      _zeroPx = "0px";
      _endParenthesis = ") ";
      _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
        var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
        if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
          var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
          angle = parseFloat(rotationX) * _DEG2RAD;
          cos = Math.cos(angle);
          x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
          y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
          z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
        }
        if (transformPerspective !== _zeroPx) {
          transforms += "perspective(" + transformPerspective + _endParenthesis;
        }
        if (xPercent || yPercent) {
          transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
        }
        if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
          transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
        }
        if (rotation !== _zeroDeg) {
          transforms += "rotate(" + rotation + _endParenthesis;
        }
        if (rotationY !== _zeroDeg) {
          transforms += "rotateY(" + rotationY + _endParenthesis;
        }
        if (rotationX !== _zeroDeg) {
          transforms += "rotateX(" + rotationX + _endParenthesis;
        }
        if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
          transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
        }
        if (scaleX !== 1 || scaleY !== 1) {
          transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
        }
        target.style[_transformProp] = transforms || "translate(0, 0)";
      };
      _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
        var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
        rotation = parseFloat(rotation);
        skewX = parseFloat(skewX);
        skewY = parseFloat(skewY);
        if (skewY) {
          skewY = parseFloat(skewY);
          skewX += skewY;
          rotation += skewY;
        }
        if (rotation || skewX) {
          rotation *= _DEG2RAD;
          skewX *= _DEG2RAD;
          a11 = Math.cos(rotation) * scaleX;
          a21 = Math.sin(rotation) * scaleX;
          a12 = Math.sin(rotation - skewX) * -scaleY;
          a22 = Math.cos(rotation - skewX) * scaleY;
          if (skewX) {
            skewY *= _DEG2RAD;
            temp = Math.tan(skewX - skewY);
            temp = Math.sqrt(1 + temp * temp);
            a12 *= temp;
            a22 *= temp;
            if (skewY) {
              temp = Math.tan(skewY);
              temp = Math.sqrt(1 + temp * temp);
              a11 *= temp;
              a21 *= temp;
            }
          }
          a11 = _round(a11);
          a21 = _round(a21);
          a12 = _round(a12);
          a22 = _round(a22);
        } else {
          a11 = scaleX;
          a22 = scaleY;
          a21 = a12 = 0;
        }
        if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
          tx = _convertToUnit(target, "x", x, "px");
          ty = _convertToUnit(target, "y", y, "px");
        }
        if (xOrigin || yOrigin || xOffset || yOffset) {
          tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
          ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
        }
        if (xPercent || yPercent) {
          temp = target.getBBox();
          tx = _round(tx + xPercent / 100 * temp.width);
          ty = _round(ty + yPercent / 100 * temp.height);
        }
        temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
        target.setAttribute("transform", temp);
        forceCSS && (target.style[_transformProp] = temp);
      };
      _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue, relative) {
        var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = relative ? endNum * relative : endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
        if (isString) {
          direction = endValue.split("_")[1];
          if (direction === "short") {
            change %= cap;
            if (change !== change % (cap / 2)) {
              change += change < 0 ? cap : -cap;
            }
          }
          if (direction === "cw" && change < 0) {
            change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
          } else if (direction === "ccw" && change > 0) {
            change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
          }
        }
        plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
        pt.e = finalValue;
        pt.u = "deg";
        plugin._props.push(property);
        return pt;
      };
      _assign = function _assign2(target, source) {
        for (var p2 in source) {
          target[p2] = source[p2];
        }
        return target;
      };
      _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
        var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p2, startValue, endValue, startNum, endNum, startUnit, endUnit;
        if (startCache.svg) {
          startValue = target.getAttribute("transform");
          target.setAttribute("transform", "");
          style[_transformProp] = transforms;
          endCache = _parseTransform(target, 1);
          _removeProperty(target, _transformProp);
          target.setAttribute("transform", startValue);
        } else {
          startValue = getComputedStyle(target)[_transformProp];
          style[_transformProp] = transforms;
          endCache = _parseTransform(target, 1);
          style[_transformProp] = startValue;
        }
        for (p2 in _transformProps) {
          startValue = startCache[p2];
          endValue = endCache[p2];
          if (startValue !== endValue && exclude.indexOf(p2) < 0) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
            startNum = startUnit !== endUnit ? _convertToUnit(target, p2, startValue, endUnit) : parseFloat(startValue);
            endNum = parseFloat(endValue);
            plugin._pt = new PropTween(plugin._pt, endCache, p2, startNum, endNum - startNum, _renderCSSProp);
            plugin._pt.u = endUnit || 0;
            plugin._props.push(p2);
          }
        }
        _assign(endCache, startCache);
      };
      _forEachName("padding,margin,Width,Radius", function(name, index) {
        var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
          return index < 2 ? name + side : "border" + side + name;
        });
        _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
          var a, vars;
          if (arguments.length < 4) {
            a = props.map(function(prop) {
              return _get(plugin, prop, property);
            });
            vars = a.join(" ");
            return vars.split(a[0]).length === 5 ? a[0] : vars;
          }
          a = (endValue + "").split(" ");
          vars = {};
          props.forEach(function(prop, i2) {
            return vars[prop] = a[i2] = a[i2] || a[(i2 - 1) / 2 | 0];
          });
          plugin.init(target, vars, tween);
        };
      });
      CSSPlugin = {
        name: "css",
        register: _initCore,
        targetTest: function targetTest(target) {
          return target.style && target.nodeType;
        },
        init: function init3(target, vars, tween, index, targets) {
          var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p2, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority;
          _pluginInitted || _initCore();
          for (p2 in vars) {
            if (p2 === "autoRound") {
              continue;
            }
            endValue = vars[p2];
            if (_plugins[p2] && _checkPlugin(p2, vars, tween, index, target, targets)) {
              continue;
            }
            type = typeof endValue;
            specialProp = _specialProps[p2];
            if (type === "function") {
              endValue = endValue.call(tween, index, target, targets);
              type = typeof endValue;
            }
            if (type === "string" && ~endValue.indexOf("random(")) {
              endValue = _replaceRandom(endValue);
            }
            if (specialProp) {
              specialProp(this, target, p2, endValue, tween) && (hasPriority = 1);
            } else if (p2.substr(0, 2) === "--") {
              startValue = (getComputedStyle(target).getPropertyValue(p2) + "").trim();
              endValue += "";
              _colorExp.lastIndex = 0;
              if (!_colorExp.test(startValue)) {
                startUnit = getUnit(startValue);
                endUnit = getUnit(endValue);
              }
              endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p2, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
              this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p2);
              props.push(p2);
            } else if (type !== "undefined") {
              if (startAt && p2 in startAt) {
                startValue = typeof startAt[p2] === "function" ? startAt[p2].call(tween, index, target, targets) : startAt[p2];
                _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
                getUnit(startValue + "") || (startValue += _config.units[p2] || getUnit(_get(target, p2)) || "");
                (startValue + "").charAt(1) === "=" && (startValue = _get(target, p2));
              } else {
                startValue = _get(target, p2);
              }
              startNum = parseFloat(startValue);
              relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
              relative && (endValue = endValue.substr(2));
              endNum = parseFloat(endValue);
              if (p2 in _propertyAliases) {
                if (p2 === "autoAlpha") {
                  if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                    startNum = 0;
                  }
                  _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
                }
                if (p2 !== "scale" && p2 !== "transform") {
                  p2 = _propertyAliases[p2];
                  ~p2.indexOf(",") && (p2 = p2.split(",")[0]);
                }
              }
              isTransformRelated = p2 in _transformProps;
              if (isTransformRelated) {
                if (!transformPropTween) {
                  cache = target._gsap;
                  cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                  smooth = vars.smoothOrigin !== false && cache.smooth;
                  transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                  transformPropTween.dep = 1;
                }
                if (p2 === "scale") {
                  this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
                  props.push("scaleY", p2);
                  p2 += "X";
                } else if (p2 === "transformOrigin") {
                  endValue = _convertKeywordsToPercentages(endValue);
                  if (cache.svg) {
                    _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                  } else {
                    endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                    endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                    _addNonTweeningPT(this, style, p2, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                  }
                  continue;
                } else if (p2 === "svgOrigin") {
                  _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                  continue;
                } else if (p2 in _rotationalProperties) {
                  _addRotationalPropTween(this, cache, p2, startNum, endValue, relative);
                  continue;
                } else if (p2 === "smoothOrigin") {
                  _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                  continue;
                } else if (p2 === "force3D") {
                  cache[p2] = endValue;
                  continue;
                } else if (p2 === "transform") {
                  _addRawTransformPTs(this, endValue, target);
                  continue;
                }
              } else if (!(p2 in style)) {
                p2 = _checkPropPrefix(p2) || p2;
              }
              if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p2 in style) {
                startUnit = (startValue + "").substr((startNum + "").length);
                endNum || (endNum = 0);
                endUnit = getUnit(endValue) || (p2 in _config.units ? _config.units[p2] : startUnit);
                startUnit !== endUnit && (startNum = _convertToUnit(target, p2, startValue, endUnit));
                this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p2, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p2 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                this._pt.u = endUnit || 0;
                if (startUnit !== endUnit && endUnit !== "%") {
                  this._pt.b = startValue;
                  this._pt.r = _renderCSSPropWithBeginning;
                }
              } else if (!(p2 in style)) {
                if (p2 in target) {
                  this.add(target, p2, startValue || target[p2], endValue, index, targets);
                } else {
                  _missingPlugin(p2, endValue);
                  continue;
                }
              } else {
                _tweenComplexCSSString.call(this, target, p2, startValue, endValue);
              }
              props.push(p2);
            }
          }
          hasPriority && _sortPropTweensByPriority(this);
        },
        get: _get,
        aliases: _propertyAliases,
        getSetter: function getSetter(target, property, plugin) {
          var p2 = _propertyAliases[property];
          p2 && p2.indexOf(",") < 0 && (property = p2);
          return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
        },
        core: {
          _removeProperty,
          _getMatrix
        }
      };
      gsap.utils.checkPrefix = _checkPropPrefix;
      (function(positionAndScale, rotation, others, aliases) {
        var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
          _transformProps[name] = 1;
        });
        _forEachName(rotation, function(name) {
          _config.units[name] = "deg";
          _rotationalProperties[name] = 1;
        });
        _propertyAliases[all[13]] = positionAndScale + "," + rotation;
        _forEachName(aliases, function(name) {
          var split = name.split(":");
          _propertyAliases[split[1]] = all[split[0]];
        });
      })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
      _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
        _config.units[name] = "px";
      });
      gsap.registerPlugin(CSSPlugin);
    }
  });

  // node_modules/gsap/utils/paths.js
  function getRawPath(value) {
    value = _isString3(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
    var e = value.getAttribute ? value : 0, rawPath;
    if (e && (value = value.getAttribute("d"))) {
      if (!e._gsPath) {
        e._gsPath = {};
      }
      rawPath = e._gsPath[value];
      return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
    }
    return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString3(value) ? stringToRawPath(value) : _isNumber3(value[0]) ? [value] : value;
  }
  function copyRawPath(rawPath) {
    var a = [], i2 = 0;
    for (; i2 < rawPath.length; i2++) {
      a[i2] = _copyMetaData(rawPath[i2], rawPath[i2].slice(0));
    }
    return _copyMetaData(rawPath, a);
  }
  function reverseSegment(segment) {
    var i2 = 0, y;
    segment.reverse();
    for (; i2 < segment.length; i2 += 2) {
      y = segment[i2];
      segment[i2] = segment[i2 + 1];
      segment[i2 + 1] = y;
    }
    segment.reversed = !segment.reversed;
  }
  function convertToPath(element, swap) {
    var type = element.tagName.toLowerCase(), circ = 0.552284749831, data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;
    if (type === "path" || !element.getBBox) {
      return element;
    }
    path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
    attr = _attrToObj(element, _typeAttrs[type]);
    if (type === "rect") {
      r = attr.rx;
      ry = attr.ry || r;
      x = attr.x;
      y = attr.y;
      w = attr.width - r * 2;
      h = attr.height - ry * 2;
      if (r || ry) {
        x2 = x + r * (1 - circ);
        x3 = x + r;
        x4 = x3 + w;
        x5 = x4 + r * circ;
        x6 = x4 + r;
        y2 = y + ry * (1 - circ);
        y3 = y + ry;
        y4 = y3 + h;
        y5 = y4 + ry * circ;
        y6 = y4 + ry;
        data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
      } else {
        data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
      }
    } else if (type === "circle" || type === "ellipse") {
      if (type === "circle") {
        r = ry = attr.r;
        rycirc = r * circ;
      } else {
        r = attr.rx;
        ry = attr.ry;
        rycirc = ry * circ;
      }
      x = attr.cx;
      y = attr.cy;
      rcirc = r * circ;
      data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
    } else if (type === "line") {
      data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2;
    } else if (type === "polyline" || type === "polygon") {
      points = (element.getAttribute("points") + "").match(_numbersExp) || [];
      x = points.shift();
      y = points.shift();
      data = "M" + x + "," + y + " L" + points.join(",");
      if (type === "polygon") {
        data += "," + x + "," + y + "z";
      }
    }
    path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));
    if (swap && element.parentNode) {
      element.parentNode.insertBefore(path, element);
      element.parentNode.removeChild(element);
    }
    return path;
  }
  function getRotationAtBezierT(segment, i2, t) {
    var a = segment[i2], b = segment[i2 + 2], c = segment[i2 + 4], x;
    a += (b - a) * t;
    b += (c - b) * t;
    a += (b - a) * t;
    x = b + (c + (segment[i2 + 6] - c) * t - b) * t - a;
    a = segment[i2 + 1];
    b = segment[i2 + 3];
    c = segment[i2 + 5];
    a += (b - a) * t;
    b += (c - b) * t;
    a += (b - a) * t;
    return _round3(_atan22(b + (c + (segment[i2 + 7] - c) * t - b) * t - a, x) * _RAD2DEG2);
  }
  function sliceRawPath(rawPath, start, end) {
    end = _isUndefined3(end) ? 1 : _roundPrecise3(end) || 0;
    start = _roundPrecise3(start) || 0;
    var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)), path = copyRawPath(rawPath);
    if (start > end) {
      start = 1 - start;
      end = 1 - end;
      _reverseRawPath(path);
      path.totalLength = 0;
    }
    if (start < 0 || end < 0) {
      var offset = Math.abs(~~Math.min(start, end)) + 1;
      start += offset;
      end += offset;
    }
    path.totalLength || cacheRawPathMeasurements(path);
    var wrap3 = end > 1, s = getProgressData(path, start, _temp, true), e = getProgressData(path, end, _temp2), eSeg = e.segment, sSeg = s.segment, eSegIndex = e.segIndex, sSegIndex = s.segIndex, ei = e.i, si = s.i, sameSegment = sSegIndex === eSegIndex, sameBezier = ei === si && sameSegment, wrapsBehind, sShift, eShift, i2, copy, totalSegments, l, j;
    if (wrap3 || loops) {
      wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;
      if (_splitSegment(path, sSegIndex, si, s.t)) {
        sSegIndex++;
        if (!wrapsBehind) {
          eSegIndex++;
          if (sameBezier) {
            e.t = (e.t - s.t) / (1 - s.t);
            ei = 0;
          } else if (sameSegment) {
            ei -= si;
          }
        }
      }
      if (Math.abs(1 - (end - start)) < 1e-5) {
        eSegIndex = sSegIndex - 1;
      } else if (!e.t && eSegIndex) {
        eSegIndex--;
      } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {
        sSegIndex++;
      }
      if (s.t === 1) {
        sSegIndex = (sSegIndex + 1) % path.length;
      }
      copy = [];
      totalSegments = path.length;
      l = 1 + totalSegments * loops;
      j = sSegIndex;
      l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;
      for (i2 = 0; i2 < l; i2++) {
        _appendOrMerge(copy, path[j++ % totalSegments]);
      }
      path = copy;
    } else {
      eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);
      if (start !== end) {
        sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);
        sameSegment && (eShift += sShift);
        eSeg.splice(ei + eShift + 2);
        (sShift || si) && sSeg.splice(0, si + sShift);
        i2 = path.length;
        while (i2--) {
          (i2 < sSegIndex || i2 > eSegIndex) && path.splice(i2, 1);
        }
      } else {
        eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0);
        ei += eShift;
        s = eSeg[ei];
        e = eSeg[ei + 1];
        eSeg.length = eSeg.totalLength = 0;
        eSeg.totalPoints = path.totalPoints = 8;
        eSeg.push(s, e, s, e, s, e, s, e);
      }
    }
    path.totalLength = 0;
    return path;
  }
  function measureSegment(segment, startIndex, bezierQty) {
    startIndex = startIndex || 0;
    if (!segment.samples) {
      segment.samples = [];
      segment.lookup = [];
    }
    var resolution = ~~segment.resolution || 12, inc = 1 / resolution, endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length, x1 = segment[startIndex], y1 = segment[startIndex + 1], samplesIndex = startIndex ? startIndex / 6 * resolution : 0, samples = segment.samples, lookup = segment.lookup, min = (startIndex ? segment.minLength : _largeNum) || _largeNum, prevLength = samples[samplesIndex + bezierQty * resolution - 1], length = startIndex ? samples[samplesIndex - 1] : 0, i2, j, x4, x3, x2, xd, xd1, y4, y3, y2, yd, yd1, inv, t, lengthIndex, l, segLength;
    samples.length = lookup.length = 0;
    for (j = startIndex + 2; j < endIndex; j += 6) {
      x4 = segment[j + 4] - x1;
      x3 = segment[j + 2] - x1;
      x2 = segment[j] - x1;
      y4 = segment[j + 5] - y1;
      y3 = segment[j + 3] - y1;
      y2 = segment[j + 1] - y1;
      xd = xd1 = yd = yd1 = 0;
      if (_abs(x4) < 0.01 && _abs(y4) < 0.01 && _abs(x2) + _abs(y2) < 0.01) {
        if (segment.length > 8) {
          segment.splice(j, 6);
          j -= 6;
          endIndex -= 6;
        }
      } else {
        for (i2 = 1; i2 <= resolution; i2++) {
          t = inc * i2;
          inv = 1 - t;
          xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);
          yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);
          l = _sqrt2(yd * yd + xd * xd);
          if (l < min) {
            min = l;
          }
          length += l;
          samples[samplesIndex++] = length;
        }
      }
      x1 += x4;
      y1 += y4;
    }
    if (prevLength) {
      prevLength -= length;
      for (; samplesIndex < samples.length; samplesIndex++) {
        samples[samplesIndex] += prevLength;
      }
    }
    if (samples.length && min) {
      segment.totalLength = segLength = samples[samples.length - 1] || 0;
      segment.minLength = min;
      if (segLength / min < 9999) {
        l = lengthIndex = 0;
        for (i2 = 0; i2 < segLength; i2 += min) {
          lookup[l++] = samples[lengthIndex] < i2 ? ++lengthIndex : lengthIndex;
        }
      }
    } else {
      segment.totalLength = samples[0] = 0;
    }
    return startIndex ? length - samples[startIndex / 2 - 1] : length;
  }
  function cacheRawPathMeasurements(rawPath, resolution) {
    var pathLength, points, i2;
    for (i2 = pathLength = points = 0; i2 < rawPath.length; i2++) {
      rawPath[i2].resolution = ~~resolution || 12;
      points += rawPath[i2].length;
      pathLength += measureSegment(rawPath[i2]);
    }
    rawPath.totalPoints = points;
    rawPath.totalLength = pathLength;
    return rawPath;
  }
  function subdivideSegment(segment, i2, t) {
    if (t <= 0 || t >= 1) {
      return 0;
    }
    var ax = segment[i2], ay = segment[i2 + 1], cp1x = segment[i2 + 2], cp1y = segment[i2 + 3], cp2x = segment[i2 + 4], cp2y = segment[i2 + 5], bx = segment[i2 + 6], by = segment[i2 + 7], x1a = ax + (cp1x - ax) * t, x2 = cp1x + (cp2x - cp1x) * t, y1a = ay + (cp1y - ay) * t, y2 = cp1y + (cp2y - cp1y) * t, x1 = x1a + (x2 - x1a) * t, y1 = y1a + (y2 - y1a) * t, x2a = cp2x + (bx - cp2x) * t, y2a = cp2y + (by - cp2y) * t;
    x2 += (x2a - x2) * t;
    y2 += (y2a - y2) * t;
    segment.splice(i2 + 2, 4, _round3(x1a), _round3(y1a), _round3(x1), _round3(y1), _round3(x1 + (x2 - x1) * t), _round3(y1 + (y2 - y1) * t), _round3(x2), _round3(y2), _round3(x2a), _round3(y2a));
    segment.samples && segment.samples.splice(i2 / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);
    return 6;
  }
  function getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {
    decoratee = decoratee || {};
    rawPath.totalLength || cacheRawPathMeasurements(rawPath);
    if (progress < 0 || progress > 1) {
      progress = _wrapProgress(progress);
    }
    var segIndex = 0, segment = rawPath[0], samples, resolution, length, min, max, i2, t;
    if (!progress) {
      t = i2 = segIndex = 0;
      segment = rawPath[0];
    } else if (progress === 1) {
      t = 1;
      segIndex = rawPath.length - 1;
      segment = rawPath[segIndex];
      i2 = segment.length - 8;
    } else {
      if (rawPath.length > 1) {
        length = rawPath.totalLength * progress;
        max = i2 = 0;
        while ((max += rawPath[i2++].totalLength) < length) {
          segIndex = i2;
        }
        segment = rawPath[segIndex];
        min = max - segment.totalLength;
        progress = (length - min) / (max - min) || 0;
      }
      samples = segment.samples;
      resolution = segment.resolution;
      length = segment.totalLength * progress;
      i2 = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);
      min = i2 ? samples[i2 - 1] : 0;
      max = samples[i2];
      if (max < length) {
        min = max;
        max = samples[++i2];
      }
      t = 1 / resolution * ((length - min) / (max - min) + i2 % resolution);
      i2 = ~~(i2 / resolution) * 6;
      if (pushToNextIfAtEnd && t === 1) {
        if (i2 + 6 < segment.length) {
          i2 += 6;
          t = 0;
        } else if (segIndex + 1 < rawPath.length) {
          i2 = t = 0;
          segment = rawPath[++segIndex];
        }
      }
    }
    decoratee.t = t;
    decoratee.i = i2;
    decoratee.path = rawPath;
    decoratee.segment = segment;
    decoratee.segIndex = segIndex;
    return decoratee;
  }
  function getPositionOnPath(rawPath, progress, includeAngle, point) {
    var segment = rawPath[0], result = point || {}, samples, resolution, length, min, max, i2, t, a, inv;
    if (progress < 0 || progress > 1) {
      progress = _wrapProgress(progress);
    }
    if (rawPath.length > 1) {
      length = rawPath.totalLength * progress;
      max = i2 = 0;
      while ((max += rawPath[i2++].totalLength) < length) {
        segment = rawPath[i2];
      }
      min = max - segment.totalLength;
      progress = (length - min) / (max - min) || 0;
    }
    samples = segment.samples;
    resolution = segment.resolution;
    length = segment.totalLength * progress;
    i2 = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);
    min = i2 ? samples[i2 - 1] : 0;
    max = samples[i2];
    if (max < length) {
      min = max;
      max = samples[++i2];
    }
    t = 1 / resolution * ((length - min) / (max - min) + i2 % resolution) || 0;
    inv = 1 - t;
    i2 = ~~(i2 / resolution) * 6;
    a = segment[i2];
    result.x = _round3((t * t * (segment[i2 + 6] - a) + 3 * inv * (t * (segment[i2 + 4] - a) + inv * (segment[i2 + 2] - a))) * t + a);
    result.y = _round3((t * t * (segment[i2 + 7] - (a = segment[i2 + 1])) + 3 * inv * (t * (segment[i2 + 5] - a) + inv * (segment[i2 + 3] - a))) * t + a);
    if (includeAngle) {
      result.angle = segment.totalLength ? getRotationAtBezierT(segment, i2, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;
    }
    return result;
  }
  function transformRawPath(rawPath, a, b, c, d, tx, ty) {
    var j = rawPath.length, segment, l, i2, x, y;
    while (--j > -1) {
      segment = rawPath[j];
      l = segment.length;
      for (i2 = 0; i2 < l; i2 += 2) {
        x = segment[i2];
        y = segment[i2 + 1];
        segment[i2] = x * a + y * c + tx;
        segment[i2 + 1] = x * b + y * d + ty;
      }
    }
    rawPath._dirty = 1;
    return rawPath;
  }
  function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
    if (lastX === x && lastY === y) {
      return;
    }
    rx = _abs(rx);
    ry = _abs(ry);
    var angleRad = angle % 360 * _DEG2RAD2, cosAngle = _cos2(angleRad), sinAngle = _sin2(angleRad), PI = Math.PI, TWOPI = PI * 2, dx2 = (lastX - x) / 2, dy2 = (lastY - y) / 2, x1 = cosAngle * dx2 + sinAngle * dy2, y1 = -sinAngle * dx2 + cosAngle * dy2, x1_sq = x1 * x1, y1_sq = y1 * y1, radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);
    if (radiiCheck > 1) {
      rx = _sqrt2(radiiCheck) * rx;
      ry = _sqrt2(radiiCheck) * ry;
    }
    var rx_sq = rx * rx, ry_sq = ry * ry, sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);
    if (sq < 0) {
      sq = 0;
    }
    var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt2(sq), cx1 = coef * (rx * y1 / ry), cy1 = coef * -(ry * x1 / rx), sx2 = (lastX + x) / 2, sy2 = (lastY + y) / 2, cx = sx2 + (cosAngle * cx1 - sinAngle * cy1), cy = sy2 + (sinAngle * cx1 + cosAngle * cy1), ux = (x1 - cx1) / rx, uy = (y1 - cy1) / ry, vx = (-x1 - cx1) / rx, vy = (-y1 - cy1) / ry, temp = ux * ux + uy * uy, angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt2(temp)), angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt2(temp * (vx * vx + vy * vy)));
    isNaN(angleExtent) && (angleExtent = PI);
    if (!sweepFlag && angleExtent > 0) {
      angleExtent -= TWOPI;
    } else if (sweepFlag && angleExtent < 0) {
      angleExtent += TWOPI;
    }
    angleStart %= TWOPI;
    angleExtent %= TWOPI;
    var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)), rawPath = [], angleIncrement = angleExtent / segments, controlLength = 4 / 3 * _sin2(angleIncrement / 2) / (1 + _cos2(angleIncrement / 2)), ma = cosAngle * rx, mb = sinAngle * rx, mc = sinAngle * -ry, md = cosAngle * ry, i2;
    for (i2 = 0; i2 < segments; i2++) {
      angle = angleStart + i2 * angleIncrement;
      x1 = _cos2(angle);
      y1 = _sin2(angle);
      ux = _cos2(angle += angleIncrement);
      uy = _sin2(angle);
      rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
    }
    for (i2 = 0; i2 < rawPath.length; i2 += 2) {
      x1 = rawPath[i2];
      y1 = rawPath[i2 + 1];
      rawPath[i2] = x1 * ma + y1 * mc + cx;
      rawPath[i2 + 1] = x1 * mb + y1 * md + cy;
    }
    rawPath[i2 - 2] = x;
    rawPath[i2 - 1] = y;
    return rawPath;
  }
  function stringToRawPath(d) {
    var a = (d + "").replace(_scientific, function(m) {
      var n = +m;
      return n < 1e-4 && n > -1e-4 ? 0 : n;
    }).match(_svgPathExp) || [], path = [], relativeX = 0, relativeY = 0, twoThirds = 2 / 3, elements = a.length, points = 0, errorMessage = "ERROR: malformed path: " + d, i2, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand, flag1, flag2, line = function line2(sx, sy, ex, ey) {
      difX = (ex - sx) / 3;
      difY = (ey - sy) / 3;
      segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
    };
    if (!d || !isNaN(a[0]) || isNaN(a[1])) {
      console.log(errorMessage);
      return path;
    }
    for (i2 = 0; i2 < elements; i2++) {
      prevCommand = command;
      if (isNaN(a[i2])) {
        command = a[i2].toUpperCase();
        isRelative = command !== a[i2];
      } else {
        i2--;
      }
      x = +a[i2 + 1];
      y = +a[i2 + 2];
      if (isRelative) {
        x += relativeX;
        y += relativeY;
      }
      if (!i2) {
        startX = x;
        startY = y;
      }
      if (command === "M") {
        if (segment) {
          if (segment.length < 8) {
            path.length -= 1;
          } else {
            points += segment.length;
          }
        }
        relativeX = startX = x;
        relativeY = startY = y;
        segment = [x, y];
        path.push(segment);
        i2 += 2;
        command = "L";
      } else if (command === "C") {
        if (!segment) {
          segment = [0, 0];
        }
        if (!isRelative) {
          relativeX = relativeY = 0;
        }
        segment.push(x, y, relativeX + a[i2 + 3] * 1, relativeY + a[i2 + 4] * 1, relativeX += a[i2 + 5] * 1, relativeY += a[i2 + 6] * 1);
        i2 += 6;
      } else if (command === "S") {
        difX = relativeX;
        difY = relativeY;
        if (prevCommand === "C" || prevCommand === "S") {
          difX += relativeX - segment[segment.length - 4];
          difY += relativeY - segment[segment.length - 3];
        }
        if (!isRelative) {
          relativeX = relativeY = 0;
        }
        segment.push(difX, difY, x, y, relativeX += a[i2 + 3] * 1, relativeY += a[i2 + 4] * 1);
        i2 += 4;
      } else if (command === "Q") {
        difX = relativeX + (x - relativeX) * twoThirds;
        difY = relativeY + (y - relativeY) * twoThirds;
        if (!isRelative) {
          relativeX = relativeY = 0;
        }
        relativeX += a[i2 + 3] * 1;
        relativeY += a[i2 + 4] * 1;
        segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
        i2 += 4;
      } else if (command === "T") {
        difX = relativeX - segment[segment.length - 4];
        difY = relativeY - segment[segment.length - 3];
        segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
        i2 += 2;
      } else if (command === "H") {
        line(relativeX, relativeY, relativeX = x, relativeY);
        i2 += 1;
      } else if (command === "V") {
        line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
        i2 += 1;
      } else if (command === "L" || command === "Z") {
        if (command === "Z") {
          x = startX;
          y = startY;
          segment.closed = true;
        }
        if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
          line(relativeX, relativeY, x, y);
          if (command === "L") {
            i2 += 2;
          }
        }
        relativeX = x;
        relativeY = y;
      } else if (command === "A") {
        flag1 = a[i2 + 4];
        flag2 = a[i2 + 5];
        difX = a[i2 + 6];
        difY = a[i2 + 7];
        j = 7;
        if (flag1.length > 1) {
          if (flag1.length < 3) {
            difY = difX;
            difX = flag2;
            j--;
          } else {
            difY = flag2;
            difX = flag1.substr(2);
            j -= 2;
          }
          flag2 = flag1.charAt(1);
          flag1 = flag1.charAt(0);
        }
        beziers = arcToSegment(relativeX, relativeY, +a[i2 + 1], +a[i2 + 2], +a[i2 + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
        i2 += j;
        if (beziers) {
          for (j = 0; j < beziers.length; j++) {
            segment.push(beziers[j]);
          }
        }
        relativeX = segment[segment.length - 2];
        relativeY = segment[segment.length - 1];
      } else {
        console.log(errorMessage);
      }
    }
    i2 = segment.length;
    if (i2 < 6) {
      path.pop();
      i2 = 0;
    } else if (segment[0] === segment[i2 - 2] && segment[1] === segment[i2 - 1]) {
      segment.closed = true;
    }
    path.totalPoints = points + i2;
    return path;
  }
  function flatPointsToSegment(points, curviness) {
    if (curviness === void 0) {
      curviness = 1;
    }
    var x = points[0], y = 0, segment = [x, y], i2 = 2;
    for (; i2 < points.length; i2 += 2) {
      segment.push(x, y, points[i2], y = (points[i2] - x) * curviness / 2, x = points[i2], -y);
    }
    return segment;
  }
  function pointsToSegment(points, curviness, cornerThreshold) {
    _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2));
    var l = points.length - 2, x = +points[0], y = +points[1], nextX = +points[2], nextY = +points[3], segment = [x, y, x, y], dx2 = nextX - x, dy2 = nextY - y, closed = Math.abs(points[l] - x) < 1e-3 && Math.abs(points[l + 1] - y) < 1e-3, prevX, prevY, angle, slope, i2, dx1, dx3, dy1, dy3, d1, d2, a, b, c;
    if (isNaN(cornerThreshold)) {
      cornerThreshold = Math.PI / 10;
    }
    if (closed) {
      points.push(nextX, nextY);
      nextX = x;
      nextY = y;
      x = points[l - 2];
      y = points[l - 1];
      points.unshift(x, y);
      l += 4;
    }
    curviness = curviness || curviness === 0 ? +curviness : 1;
    for (i2 = 2; i2 < l; i2 += 2) {
      prevX = x;
      prevY = y;
      x = nextX;
      y = nextY;
      nextX = +points[i2 + 2];
      nextY = +points[i2 + 3];
      if (x === nextX && y === nextY) {
        continue;
      }
      dx1 = dx2;
      dy1 = dy2;
      dx2 = nextX - x;
      dy2 = nextY - y;
      dx3 = nextX - prevX;
      dy3 = nextY - prevY;
      a = dx1 * dx1 + dy1 * dy1;
      b = dx2 * dx2 + dy2 * dy2;
      c = dx3 * dx3 + dy3 * dy3;
      angle = Math.acos((a + b - c) / _sqrt2(4 * a * b));
      d2 = angle / Math.PI * curviness;
      d1 = _sqrt2(a) * d2;
      d2 *= _sqrt2(b);
      if (x !== prevX || y !== prevY) {
        if (angle > cornerThreshold) {
          slope = _atan22(dy3, dx3);
          segment.push(_round3(x - _cos2(slope) * d1), _round3(y - _sin2(slope) * d1), _round3(x), _round3(y), _round3(x + _cos2(slope) * d2), _round3(y + _sin2(slope) * d2));
        } else {
          slope = _atan22(dy1, dx1);
          segment.push(_round3(x - _cos2(slope) * d1), _round3(y - _sin2(slope) * d1));
          slope = _atan22(dy2, dx2);
          segment.push(_round3(x), _round3(y), _round3(x + _cos2(slope) * d2), _round3(y + _sin2(slope) * d2));
        }
      }
    }
    x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round3(nextX), _round3(nextY), _round3(nextX), _round3(nextY)) : segment.length -= 2;
    if (closed) {
      segment.splice(0, 6);
      segment.length = segment.length - 6;
    }
    return segment;
  }
  function rawPathToString(rawPath) {
    if (_isNumber3(rawPath[0])) {
      rawPath = [rawPath];
    }
    var result = "", l = rawPath.length, sl, s, i2, segment;
    for (s = 0; s < l; s++) {
      segment = rawPath[s];
      result += "M" + _round3(segment[0]) + "," + _round3(segment[1]) + " C";
      sl = segment.length;
      for (i2 = 2; i2 < sl; i2++) {
        result += _round3(segment[i2++]) + "," + _round3(segment[i2++]) + " " + _round3(segment[i2++]) + "," + _round3(segment[i2++]) + " " + _round3(segment[i2++]) + "," + _round3(segment[i2]) + " ";
      }
      if (segment.closed) {
        result += "z";
      }
    }
    return result;
  }
  var _svgPathExp, _numbersExp, _scientific, _selectorExp, _DEG2RAD2, _RAD2DEG2, _sin2, _cos2, _abs, _sqrt2, _atan22, _largeNum, _isString3, _isNumber3, _isUndefined3, _temp, _temp2, _roundingNum, _wrapProgress, _round3, _roundPrecise3, _splitSegment, _getSampleIndex, _reverseRawPath, _copyMetaData, _appendOrMerge, _createPath, _typeAttrs, _attrToObj;
  var init_paths = __esm({
    "node_modules/gsap/utils/paths.js"() {
      _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig;
      _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig;
      _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig;
      _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i;
      _DEG2RAD2 = Math.PI / 180;
      _RAD2DEG2 = 180 / Math.PI;
      _sin2 = Math.sin;
      _cos2 = Math.cos;
      _abs = Math.abs;
      _sqrt2 = Math.sqrt;
      _atan22 = Math.atan2;
      _largeNum = 1e8;
      _isString3 = function _isString4(value) {
        return typeof value === "string";
      };
      _isNumber3 = function _isNumber4(value) {
        return typeof value === "number";
      };
      _isUndefined3 = function _isUndefined4(value) {
        return typeof value === "undefined";
      };
      _temp = {};
      _temp2 = {};
      _roundingNum = 1e5;
      _wrapProgress = function _wrapProgress2(progress) {
        return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);
      };
      _round3 = function _round4(value) {
        return Math.round(value * _roundingNum) / _roundingNum || 0;
      };
      _roundPrecise3 = function _roundPrecise4(value) {
        return Math.round(value * 1e10) / 1e10 || 0;
      };
      _splitSegment = function _splitSegment2(rawPath, segIndex, i2, t) {
        var segment = rawPath[segIndex], shift = t === 1 ? 6 : subdivideSegment(segment, i2, t);
        if (shift && shift + i2 + 2 < segment.length) {
          rawPath.splice(segIndex, 0, segment.slice(0, i2 + shift + 2));
          segment.splice(0, i2 + shift);
          return 1;
        }
      };
      _getSampleIndex = function _getSampleIndex2(samples, length, progress) {
        var l = samples.length, i2 = ~~(progress * l);
        if (samples[i2] > length) {
          while (--i2 && samples[i2] > length) {
          }
        } else {
          while (samples[++i2] < length && i2 < l) {
          }
        }
        return i2 < l ? i2 : l - 1;
      };
      _reverseRawPath = function _reverseRawPath2(rawPath, skipOuter) {
        var i2 = rawPath.length;
        skipOuter || rawPath.reverse();
        while (i2--) {
          rawPath[i2].reversed || reverseSegment(rawPath[i2]);
        }
      };
      _copyMetaData = function _copyMetaData2(source, copy) {
        copy.totalLength = source.totalLength;
        if (source.samples) {
          copy.samples = source.samples.slice(0);
          copy.lookup = source.lookup.slice(0);
          copy.minLength = source.minLength;
          copy.resolution = source.resolution;
        } else if (source.totalPoints) {
          copy.totalPoints = source.totalPoints;
        }
        return copy;
      };
      _appendOrMerge = function _appendOrMerge2(rawPath, segment) {
        var index = rawPath.length, prevSeg = rawPath[index - 1] || [], l = prevSeg.length;
        if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {
          segment = prevSeg.concat(segment.slice(2));
          index--;
        }
        rawPath[index] = segment;
      };
      _createPath = function _createPath2(e, ignore) {
        var path = document.createElementNS("http://www.w3.org/2000/svg", "path"), attr = [].slice.call(e.attributes), i2 = attr.length, name;
        ignore = "," + ignore + ",";
        while (--i2 > -1) {
          name = attr[i2].nodeName.toLowerCase();
          if (ignore.indexOf("," + name + ",") < 0) {
            path.setAttributeNS(null, name, attr[i2].nodeValue);
          }
        }
        return path;
      };
      _typeAttrs = {
        rect: "rx,ry,x,y,width,height",
        circle: "r,cx,cy",
        ellipse: "rx,ry,cx,cy",
        line: "x1,x2,y1,y2"
      };
      _attrToObj = function _attrToObj2(e, attrs) {
        var props = attrs ? attrs.split(",") : [], obj = {}, i2 = props.length;
        while (--i2 > -1) {
          obj[props[i2]] = +e.getAttribute(props[i2]) || 0;
        }
        return obj;
      };
    }
  });

  // node_modules/gsap/CustomEase.js
  var gsap2, _coreInitted2, _getGSAP, _initCore3, _bigNum3, _round5, _bonusValidated, _numExp2, _needsParsingExp, _findMinimum, _normalize, _bezierToPoints, CustomEase;
  var init_CustomEase = __esm({
    "node_modules/gsap/CustomEase.js"() {
      init_paths();
      _getGSAP = function _getGSAP2() {
        return gsap2 || typeof window !== "undefined" && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
      };
      _initCore3 = function _initCore4() {
        gsap2 = _getGSAP();
        if (gsap2) {
          gsap2.registerEase("_CE", CustomEase.create);
          _coreInitted2 = 1;
        } else {
          console.warn("Please gsap.registerPlugin(CustomEase)");
        }
      };
      _bigNum3 = 1e20;
      _round5 = function _round6(value) {
        return ~~(value * 1e3 + (value < 0 ? -0.5 : 0.5)) / 1e3;
      };
      _bonusValidated = 1;
      _numExp2 = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi;
      _needsParsingExp = /[cLlsSaAhHvVtTqQ]/g;
      _findMinimum = function _findMinimum2(values) {
        var l = values.length, min = _bigNum3, i2;
        for (i2 = 1; i2 < l; i2 += 6) {
          +values[i2] < min && (min = +values[i2]);
        }
        return min;
      };
      _normalize = function _normalize2(values, height, originY) {
        if (!originY && originY !== 0) {
          originY = Math.max(+values[values.length - 1], +values[1]);
        }
        var tx = +values[0] * -1, ty = -originY, l = values.length, sx = 1 / (+values[l - 2] + tx), sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty), i2;
        if (sy) {
          sy = 1 / sy;
        } else {
          sy = -sx;
        }
        for (i2 = 0; i2 < l; i2 += 2) {
          values[i2] = (+values[i2] + tx) * sx;
          values[i2 + 1] = (+values[i2 + 1] + ty) * sy;
        }
      };
      _bezierToPoints = function _bezierToPoints2(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
        var x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x34 = (x3 + x4) / 2, y34 = (y3 + y4) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, x234 = (x23 + x34) / 2, y234 = (y23 + y34) / 2, x1234 = (x123 + x234) / 2, y1234 = (y123 + y234) / 2, dx = x4 - x1, dy = y4 - y1, d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx), d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx), length;
        if (!points) {
          points = [{
            x: x1,
            y: y1
          }, {
            x: x4,
            y: y4
          }];
          index = 1;
        }
        points.splice(index || points.length - 1, 0, {
          x: x1234,
          y: y1234
        });
        if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
          length = points.length;
          _bezierToPoints2(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
          _bezierToPoints2(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));
        }
        return points;
      };
      CustomEase = /* @__PURE__ */ function() {
        function CustomEase2(id, data, config3) {
          _coreInitted2 || _initCore3();
          this.id = id;
          _bonusValidated && this.setData(data, config3);
        }
        var _proto = CustomEase2.prototype;
        _proto.setData = function setData(data, config3) {
          config3 = config3 || {};
          data = data || "0,0,1,1";
          var values = data.match(_numExp2), closest = 1, points = [], lookup = [], precision = config3.precision || 1, fast = precision <= 1, l, a1, a2, i2, inc, j, point, prevPoint, p2;
          this.data = data;
          if (_needsParsingExp.test(data) || ~data.indexOf("M") && data.indexOf("C") < 0) {
            values = stringToRawPath(data)[0];
          }
          l = values.length;
          if (l === 4) {
            values.unshift(0, 0);
            values.push(1, 1);
            l = 8;
          } else if ((l - 2) % 6) {
            throw "Invalid CustomEase";
          }
          if (+values[0] !== 0 || +values[l - 2] !== 1) {
            _normalize(values, config3.height, config3.originY);
          }
          this.segment = values;
          for (i2 = 2; i2 < l; i2 += 6) {
            a1 = {
              x: +values[i2 - 2],
              y: +values[i2 - 1]
            };
            a2 = {
              x: +values[i2 + 4],
              y: +values[i2 + 5]
            };
            points.push(a1, a2);
            _bezierToPoints(a1.x, a1.y, +values[i2], +values[i2 + 1], +values[i2 + 2], +values[i2 + 3], a2.x, a2.y, 1 / (precision * 2e5), points, points.length - 1);
          }
          l = points.length;
          for (i2 = 0; i2 < l; i2++) {
            point = points[i2];
            prevPoint = points[i2 - 1] || point;
            if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {
              prevPoint.cx = point.x - prevPoint.x;
              prevPoint.cy = point.y - prevPoint.y;
              prevPoint.n = point;
              prevPoint.nx = point.x;
              if (fast && i2 > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i2 - 2].cy / points[i2 - 2].cx) > 2) {
                fast = 0;
              }
              if (prevPoint.cx < closest) {
                if (!prevPoint.cx) {
                  prevPoint.cx = 1e-3;
                  if (i2 === l - 1) {
                    prevPoint.x -= 1e-3;
                    closest = Math.min(closest, 1e-3);
                    fast = 0;
                  }
                } else {
                  closest = prevPoint.cx;
                }
              }
            } else {
              points.splice(i2--, 1);
              l--;
            }
          }
          l = 1 / closest + 1 | 0;
          inc = 1 / l;
          j = 0;
          point = points[0];
          if (fast) {
            for (i2 = 0; i2 < l; i2++) {
              p2 = i2 * inc;
              if (point.nx < p2) {
                point = points[++j];
              }
              a1 = point.y + (p2 - point.x) / point.cx * point.cy;
              lookup[i2] = {
                x: p2,
                cx: inc,
                y: a1,
                cy: 0,
                nx: 9
              };
              if (i2) {
                lookup[i2 - 1].cy = a1 - lookup[i2 - 1].y;
              }
            }
            lookup[l - 1].cy = points[points.length - 1].y - a1;
          } else {
            for (i2 = 0; i2 < l; i2++) {
              if (point.nx < i2 * inc) {
                point = points[++j];
              }
              lookup[i2] = point;
            }
            if (j < points.length - 1) {
              lookup[i2 - 1] = points[points.length - 2];
            }
          }
          this.ease = function(p3) {
            var point2 = lookup[p3 * l | 0] || lookup[l - 1];
            if (point2.nx < p3) {
              point2 = point2.n;
            }
            return point2.y + (p3 - point2.x) / point2.cx * point2.cy;
          };
          this.ease.custom = this;
          this.id && gsap2 && gsap2.registerEase(this.id, this.ease);
          return this;
        };
        _proto.getSVGData = function getSVGData(config3) {
          return CustomEase2.getSVGData(this, config3);
        };
        CustomEase2.create = function create(id, data, config3) {
          return new CustomEase2(id, data, config3).ease;
        };
        CustomEase2.register = function register4(core) {
          gsap2 = core;
          _initCore3();
        };
        CustomEase2.get = function get(id) {
          return gsap2.parseEase(id);
        };
        CustomEase2.getSVGData = function getSVGData(ease, config3) {
          config3 = config3 || {};
          var width = config3.width || 100, height = config3.height || 100, x = config3.x || 0, y = (config3.y || 0) + height, e = gsap2.utils.toArray(config3.path)[0], a, slope, i2, inc, tx, ty, precision, threshold, prevX, prevY;
          if (config3.invert) {
            height = -height;
            y = 0;
          }
          if (typeof ease === "string") {
            ease = gsap2.parseEase(ease);
          }
          if (ease.custom) {
            ease = ease.custom;
          }
          if (ease instanceof CustomEase2) {
            a = rawPathToString(transformRawPath([ease.segment], width, 0, 0, -height, x, y));
          } else {
            a = [x, y];
            precision = Math.max(5, (config3.precision || 1) * 200);
            inc = 1 / precision;
            precision += 2;
            threshold = 5 / precision;
            prevX = _round5(x + inc * width);
            prevY = _round5(y + ease(inc) * -height);
            slope = (prevY - y) / (prevX - x);
            for (i2 = 2; i2 < precision; i2++) {
              tx = _round5(x + i2 * inc * width);
              ty = _round5(y + ease(i2 * inc) * -height);
              if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i2 === precision - 1) {
                a.push(prevX, prevY);
                slope = (ty - prevY) / (tx - prevX);
              }
              prevX = tx;
              prevY = ty;
            }
            a = "M" + a.join(",");
          }
          e && e.setAttribute("d", a);
          return a;
        };
        return CustomEase2;
      }();
      _getGSAP() && gsap2.registerPlugin(CustomEase);
      CustomEase.version = "3.9.1";
    }
  });

  // node_modules/gsap/CSSRulePlugin.js
  var gsap3, _coreInitted3, _win3, _doc3, CSSPlugin2, _windowExists5, _getGSAP3, _checkRegister, _initCore5, CSSRulePlugin;
  var init_CSSRulePlugin = __esm({
    "node_modules/gsap/CSSRulePlugin.js"() {
      _windowExists5 = function _windowExists6() {
        return typeof window !== "undefined";
      };
      _getGSAP3 = function _getGSAP4() {
        return gsap3 || _windowExists5() && (gsap3 = window.gsap) && gsap3.registerPlugin && gsap3;
      };
      _checkRegister = function _checkRegister2() {
        if (!_coreInitted3) {
          _initCore5();
          if (!CSSPlugin2) {
            console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)");
          }
        }
        return _coreInitted3;
      };
      _initCore5 = function _initCore6(core) {
        gsap3 = core || _getGSAP3();
        if (_windowExists5()) {
          _win3 = window;
          _doc3 = document;
        }
        if (gsap3) {
          CSSPlugin2 = gsap3.plugins.css;
          if (CSSPlugin2) {
            _coreInitted3 = 1;
          }
        }
      };
      CSSRulePlugin = {
        version: "3.9.1",
        name: "cssRule",
        init: function init4(target, value, tween, index, targets) {
          if (!_checkRegister() || typeof target.cssText === "undefined") {
            return false;
          }
          var div = target._gsProxy = target._gsProxy || _doc3.createElement("div");
          this.ss = target;
          this.style = div.style;
          div.style.cssText = target.cssText;
          CSSPlugin2.prototype.init.call(this, div, value, tween, index, targets);
        },
        render: function render(ratio, data) {
          var pt = data._pt, style = data.style, ss = data.ss, i2;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          i2 = style.length;
          while (--i2 > -1) {
            ss[style[i2]] = style[style[i2]];
          }
        },
        getRule: function getRule(selector3) {
          _checkRegister();
          var ruleProp = _doc3.all ? "rules" : "cssRules", styleSheets = _doc3.styleSheets, i2 = styleSheets.length, pseudo = selector3.charAt(0) === ":", j, curSS, cs, a;
          selector3 = (pseudo ? "" : ",") + selector3.split("::").join(":").toLowerCase() + ",";
          if (pseudo) {
            a = [];
          }
          while (i2--) {
            try {
              curSS = styleSheets[i2][ruleProp];
              if (!curSS) {
                continue;
              }
              j = curSS.length;
            } catch (e) {
              console.warn(e);
              continue;
            }
            while (--j > -1) {
              cs = curSS[j];
              if (cs.selectorText && ("," + cs.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(selector3) !== -1) {
                if (pseudo) {
                  a.push(cs.style);
                } else {
                  return cs.style;
                }
              }
            }
          }
          return a;
        },
        register: _initCore5
      };
      _getGSAP3() && gsap3.registerPlugin(CSSRulePlugin);
    }
  });

  // node_modules/gsap/utils/matrix.js
  function getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {
    if (!element || !element.parentNode || (_doc4 || _setDoc(element)).documentElement === element) {
      return new Matrix2D();
    }
    var zeroScales = _forceNonZeroScale(element), svg = _svgOwner(element), temps = svg ? _svgTemps : _divTemps, container = _placeSiblings(element, adjustGOffset), b1 = temps[0].getBoundingClientRect(), b2 = temps[1].getBoundingClientRect(), b3 = temps[2].getBoundingClientRect(), parent = container.parentNode, isFixed = !includeScrollInFixed && _isFixed(element), m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));
    parent.removeChild(container);
    if (zeroScales) {
      b1 = zeroScales.length;
      while (b1--) {
        b2 = zeroScales[b1];
        b2.scaleX = b2.scaleY = 0;
        b2.renderTransform(1, b2);
      }
    }
    return inverse ? m.inverse() : m;
  }
  var _doc4, _win4, _docElement2, _body, _divContainer, _svgContainer, _identityMatrix2, _gEl, _transformProp2, _transformOriginProp2, _hasOffsetBug, _setDoc, _forceNonZeroScale, _svgTemps, _divTemps, _getDocScrollTop, _getDocScrollLeft, _svgOwner, _isFixed, _createSibling, _consolidate, _getCTM, _placeSiblings, _setMatrix, Matrix2D;
  var init_matrix = __esm({
    "node_modules/gsap/utils/matrix.js"() {
      _transformProp2 = "transform";
      _transformOriginProp2 = _transformProp2 + "Origin";
      _setDoc = function _setDoc2(element) {
        var doc = element.ownerDocument || element;
        if (!(_transformProp2 in element.style) && "msTransform" in element.style) {
          _transformProp2 = "msTransform";
          _transformOriginProp2 = _transformProp2 + "Origin";
        }
        while (doc.parentNode && (doc = doc.parentNode)) {
        }
        _win4 = window;
        _identityMatrix2 = new Matrix2D();
        if (doc) {
          _doc4 = doc;
          _docElement2 = doc.documentElement;
          _body = doc.body;
          _gEl = _doc4.createElementNS("http://www.w3.org/2000/svg", "g");
          _gEl.style.transform = "none";
          var d1 = doc.createElement("div"), d2 = doc.createElement("div");
          _body.appendChild(d1);
          d1.appendChild(d2);
          d1.style.position = "static";
          d1.style[_transformProp2] = "translate3d(0,0,1px)";
          _hasOffsetBug = d2.offsetParent !== d1;
          _body.removeChild(d1);
        }
        return doc;
      };
      _forceNonZeroScale = function _forceNonZeroScale2(e) {
        var a, cache;
        while (e && e !== _body) {
          cache = e._gsap;
          cache && cache.uncache && cache.get(e, "x");
          if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
            cache.scaleX = cache.scaleY = 1e-4;
            cache.renderTransform(1, cache);
            a ? a.push(cache) : a = [cache];
          }
          e = e.parentNode;
        }
        return a;
      };
      _svgTemps = [];
      _divTemps = [];
      _getDocScrollTop = function _getDocScrollTop2() {
        return _win4.pageYOffset || _doc4.scrollTop || _docElement2.scrollTop || _body.scrollTop || 0;
      };
      _getDocScrollLeft = function _getDocScrollLeft2() {
        return _win4.pageXOffset || _doc4.scrollLeft || _docElement2.scrollLeft || _body.scrollLeft || 0;
      };
      _svgOwner = function _svgOwner2(element) {
        return element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null);
      };
      _isFixed = function _isFixed2(element) {
        if (_win4.getComputedStyle(element).position === "fixed") {
          return true;
        }
        element = element.parentNode;
        if (element && element.nodeType === 1) {
          return _isFixed2(element);
        }
      };
      _createSibling = function _createSibling2(element, i2) {
        if (element.parentNode && (_doc4 || _setDoc(element))) {
          var svg = _svgOwner(element), ns = svg ? svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", type = svg ? i2 ? "rect" : "g" : "div", x = i2 !== 2 ? 0 : 100, y = i2 === 3 ? 100 : 0, css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;", e = _doc4.createElementNS ? _doc4.createElementNS(ns.replace(/^https/, "http"), type) : _doc4.createElement(type);
          if (i2) {
            if (!svg) {
              if (!_divContainer) {
                _divContainer = _createSibling2(element);
                _divContainer.style.cssText = css;
              }
              e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";
              _divContainer.appendChild(e);
            } else {
              _svgContainer || (_svgContainer = _createSibling2(element));
              e.setAttribute("width", 0.01);
              e.setAttribute("height", 0.01);
              e.setAttribute("transform", "translate(" + x + "," + y + ")");
              _svgContainer.appendChild(e);
            }
          }
          return e;
        }
        throw "Need document and parent.";
      };
      _consolidate = function _consolidate2(m) {
        var c = new Matrix2D(), i2 = 0;
        for (; i2 < m.numberOfItems; i2++) {
          c.multiply(m.getItem(i2).matrix);
        }
        return c;
      };
      _getCTM = function _getCTM2(svg) {
        var m = svg.getCTM(), transform;
        if (!m) {
          transform = svg.style[_transformProp2];
          svg.style[_transformProp2] = "none";
          svg.appendChild(_gEl);
          m = _gEl.getCTM();
          svg.removeChild(_gEl);
          transform ? svg.style[_transformProp2] = transform : svg.style.removeProperty(_transformProp2.replace(/([A-Z])/g, "-$1").toLowerCase());
        }
        return m || _identityMatrix2.clone();
      };
      _placeSiblings = function _placeSiblings2(element, adjustGOffset) {
        var svg = _svgOwner(element), isRootSVG = element === svg, siblings = svg ? _svgTemps : _divTemps, parent = element.parentNode, container, m, b, x, y, cs;
        if (element === _win4) {
          return element;
        }
        siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
        container = svg ? _svgContainer : _divContainer;
        if (svg) {
          if (isRootSVG) {
            b = _getCTM(element);
            x = -b.e / b.a;
            y = -b.f / b.d;
            m = _identityMatrix2;
          } else {
            b = element.getBBox();
            m = element.transform ? element.transform.baseVal : {};
            m = !m.numberOfItems ? _identityMatrix2 : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix;
            x = m.a * b.x + m.c * b.y;
            y = m.b * b.x + m.d * b.y;
          }
          if (adjustGOffset && element.tagName.toLowerCase() === "g") {
            x = y = 0;
          }
          (isRootSVG ? svg : parent).appendChild(container);
          container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
        } else {
          x = y = 0;
          if (_hasOffsetBug) {
            m = element.offsetParent;
            b = element;
            while (b && (b = b.parentNode) && b !== m && b.parentNode) {
              if ((_win4.getComputedStyle(b)[_transformProp2] + "").length > 4) {
                x = b.offsetLeft;
                y = b.offsetTop;
                b = 0;
              }
            }
          }
          cs = _win4.getComputedStyle(element);
          if (cs.position !== "absolute" && cs.position !== "fixed") {
            m = element.offsetParent;
            while (parent && parent !== m) {
              x += parent.scrollLeft || 0;
              y += parent.scrollTop || 0;
              parent = parent.parentNode;
            }
          }
          b = container.style;
          b.top = element.offsetTop - y + "px";
          b.left = element.offsetLeft - x + "px";
          b[_transformProp2] = cs[_transformProp2];
          b[_transformOriginProp2] = cs[_transformOriginProp2];
          b.position = cs.position === "fixed" ? "fixed" : "absolute";
          element.parentNode.appendChild(container);
        }
        return container;
      };
      _setMatrix = function _setMatrix2(m, a, b, c, d, e, f) {
        m.a = a;
        m.b = b;
        m.c = c;
        m.d = d;
        m.e = e;
        m.f = f;
        return m;
      };
      Matrix2D = /* @__PURE__ */ function() {
        function Matrix2D2(a, b, c, d, e, f) {
          if (a === void 0) {
            a = 1;
          }
          if (b === void 0) {
            b = 0;
          }
          if (c === void 0) {
            c = 0;
          }
          if (d === void 0) {
            d = 1;
          }
          if (e === void 0) {
            e = 0;
          }
          if (f === void 0) {
            f = 0;
          }
          _setMatrix(this, a, b, c, d, e, f);
        }
        var _proto = Matrix2D2.prototype;
        _proto.inverse = function inverse() {
          var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, determinant = a * d - b * c || 1e-10;
          return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);
        };
        _proto.multiply = function multiply(matrix) {
          var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f, a2 = matrix.a, b2 = matrix.c, c2 = matrix.b, d2 = matrix.d, e2 = matrix.e, f2 = matrix.f;
          return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);
        };
        _proto.clone = function clone() {
          return new Matrix2D2(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        _proto.equals = function equals2(matrix) {
          var a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;
          return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;
        };
        _proto.apply = function apply(point, decoratee) {
          if (decoratee === void 0) {
            decoratee = {};
          }
          var x = point.x, y = point.y, a = this.a, b = this.b, c = this.c, d = this.d, e = this.e, f = this.f;
          decoratee.x = x * a + y * c + e || 0;
          decoratee.y = x * b + y * d + f || 0;
          return decoratee;
        };
        return Matrix2D2;
      }();
    }
  });

  // node_modules/gsap/Draggable.js
  function _assertThisInitialized2(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var gsap4, _win5, _doc5, _docElement3, _body2, _tempDiv2, _placeholderDiv, _coreInitted4, _checkPrefix, _toArray, _supportsPassive, _isTouchDevice, _touchEventLookup, _dragCount, _isMultiTouching, _isAndroid, InertiaPlugin, _defaultCursor, _supportsPointer, _windowExists7, _getGSAP5, _isFunction3, _isObject3, _isUndefined5, _emptyFunc3, _transformProp3, _transformOriginProp3, _round7, _isArray2, _createElement3, _RAD2DEG3, _bigNum4, _identityMatrix3, _getTime, _renderQueue, _lookup, _lookupCount, _clickableTagExp, _lastDragTime, _temp1, _windowProxy, _copy, _extend, _setTouchActionForAllDescendants, _renderQueueTick, _addToRenderQueue, _renderQueueTimeout, _removeFromRenderQueue, _setDefaults3, _addListener, _removeListener, _preventDefault, _hasTouchID, _onMultiTouchDocumentEnd, _onMultiTouchDocument, _getDocScrollTop3, _getDocScrollLeft3, _addScrollListener, _removeScrollListener, _isRoot, _getMaxScroll, _recordMaxScrolls, _setStyle, _getComputedStyle, _tempRect, _parseRect, _dispatchEvent, _getBounds, _point1, _getElementBounds, _parseInertia, _isClickable, _setSelectable, _isFixed3, _supports3D2, _addPaddingBR, ScrollProxy, _initCore7, EventDispatcher2, Draggable;
  var init_Draggable = __esm({
    "node_modules/gsap/Draggable.js"() {
      init_matrix();
      _windowExists7 = function _windowExists8() {
        return typeof window !== "undefined";
      };
      _getGSAP5 = function _getGSAP6() {
        return gsap4 || _windowExists7() && (gsap4 = window.gsap) && gsap4.registerPlugin && gsap4;
      };
      _isFunction3 = function _isFunction4(value) {
        return typeof value === "function";
      };
      _isObject3 = function _isObject4(value) {
        return typeof value === "object";
      };
      _isUndefined5 = function _isUndefined6(value) {
        return typeof value === "undefined";
      };
      _emptyFunc3 = function _emptyFunc4() {
        return false;
      };
      _transformProp3 = "transform";
      _transformOriginProp3 = "transformOrigin";
      _round7 = function _round8(value) {
        return Math.round(value * 1e4) / 1e4;
      };
      _isArray2 = Array.isArray;
      _createElement3 = function _createElement4(type, ns) {
        var e = _doc5.createElementNS ? _doc5.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc5.createElement(type);
        return e.style ? e : _doc5.createElement(type);
      };
      _RAD2DEG3 = 180 / Math.PI;
      _bigNum4 = 1e20;
      _identityMatrix3 = new Matrix2D();
      _getTime = Date.now || function() {
        return new Date().getTime();
      };
      _renderQueue = [];
      _lookup = {};
      _lookupCount = 0;
      _clickableTagExp = /^(?:a|input|textarea|button|select)$/i;
      _lastDragTime = 0;
      _temp1 = {};
      _windowProxy = {};
      _copy = function _copy2(obj, factor) {
        var copy = {}, p2;
        for (p2 in obj) {
          copy[p2] = factor ? obj[p2] * factor : obj[p2];
        }
        return copy;
      };
      _extend = function _extend2(obj, defaults2) {
        for (var p2 in defaults2) {
          if (!(p2 in obj)) {
            obj[p2] = defaults2[p2];
          }
        }
        return obj;
      };
      _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants2(elements, value) {
        var i2 = elements.length, children;
        while (i2--) {
          value ? elements[i2].style.touchAction = value : elements[i2].style.removeProperty("touch-action");
          children = elements[i2].children;
          children && children.length && _setTouchActionForAllDescendants2(children, value);
        }
      };
      _renderQueueTick = function _renderQueueTick2() {
        return _renderQueue.forEach(function(func) {
          return func();
        });
      };
      _addToRenderQueue = function _addToRenderQueue2(func) {
        _renderQueue.push(func);
        if (_renderQueue.length === 1) {
          gsap4.ticker.add(_renderQueueTick);
        }
      };
      _renderQueueTimeout = function _renderQueueTimeout2() {
        return !_renderQueue.length && gsap4.ticker.remove(_renderQueueTick);
      };
      _removeFromRenderQueue = function _removeFromRenderQueue2(func) {
        var i2 = _renderQueue.length;
        while (i2--) {
          if (_renderQueue[i2] === func) {
            _renderQueue.splice(i2, 1);
          }
        }
        gsap4.to(_renderQueueTimeout, {
          overwrite: true,
          delay: 15,
          duration: 0,
          onComplete: _renderQueueTimeout,
          data: "_draggable"
        });
      };
      _setDefaults3 = function _setDefaults4(obj, defaults2) {
        for (var p2 in defaults2) {
          if (!(p2 in obj)) {
            obj[p2] = defaults2[p2];
          }
        }
        return obj;
      };
      _addListener = function _addListener2(element, type, func, capture) {
        if (element.addEventListener) {
          var touchType = _touchEventLookup[type];
          capture = capture || (_supportsPassive ? {
            passive: false
          } : null);
          element.addEventListener(touchType || type, func, capture);
          touchType && type !== touchType && element.addEventListener(type, func, capture);
        }
      };
      _removeListener = function _removeListener2(element, type, func) {
        if (element.removeEventListener) {
          var touchType = _touchEventLookup[type];
          element.removeEventListener(touchType || type, func);
          touchType && type !== touchType && element.removeEventListener(type, func);
        }
      };
      _preventDefault = function _preventDefault2(event) {
        event.preventDefault && event.preventDefault();
        event.preventManipulation && event.preventManipulation();
      };
      _hasTouchID = function _hasTouchID2(list, ID) {
        var i2 = list.length;
        while (i2--) {
          if (list[i2].identifier === ID) {
            return true;
          }
        }
      };
      _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd2(event) {
        _isMultiTouching = event.touches && _dragCount < event.touches.length;
        _removeListener(event.target, "touchend", _onMultiTouchDocumentEnd2);
      };
      _onMultiTouchDocument = function _onMultiTouchDocument2(event) {
        _isMultiTouching = event.touches && _dragCount < event.touches.length;
        _addListener(event.target, "touchend", _onMultiTouchDocumentEnd);
      };
      _getDocScrollTop3 = function _getDocScrollTop4(doc) {
        return _win5.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;
      };
      _getDocScrollLeft3 = function _getDocScrollLeft4(doc) {
        return _win5.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;
      };
      _addScrollListener = function _addScrollListener2(e, callback) {
        _addListener(e, "scroll", callback);
        if (!_isRoot(e.parentNode)) {
          _addScrollListener2(e.parentNode, callback);
        }
      };
      _removeScrollListener = function _removeScrollListener2(e, callback) {
        _removeListener(e, "scroll", callback);
        if (!_isRoot(e.parentNode)) {
          _removeScrollListener2(e.parentNode, callback);
        }
      };
      _isRoot = function _isRoot2(e) {
        return !!(!e || e === _docElement3 || e.nodeType === 9 || e === _doc5.body || e === _win5 || !e.nodeType || !e.parentNode);
      };
      _getMaxScroll = function _getMaxScroll2(element, axis) {
        var dim = axis === "x" ? "Width" : "Height", scroll = "scroll" + dim, client = "client" + dim;
        return Math.max(0, _isRoot(element) ? Math.max(_docElement3[scroll], _body2[scroll]) - (_win5["inner" + dim] || _docElement3[client] || _body2[client]) : element[scroll] - element[client]);
      };
      _recordMaxScrolls = function _recordMaxScrolls2(e, skipCurrent) {
        var x = _getMaxScroll(e, "x"), y = _getMaxScroll(e, "y");
        if (_isRoot(e)) {
          e = _windowProxy;
        } else {
          _recordMaxScrolls2(e.parentNode, skipCurrent);
        }
        e._gsMaxScrollX = x;
        e._gsMaxScrollY = y;
        if (!skipCurrent) {
          e._gsScrollX = e.scrollLeft || 0;
          e._gsScrollY = e.scrollTop || 0;
        }
      };
      _setStyle = function _setStyle2(element, property, value) {
        var style = element.style;
        if (!style) {
          return;
        }
        if (_isUndefined5(style[property])) {
          property = _checkPrefix(property, element) || property;
        }
        if (value == null) {
          style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());
        } else {
          style[property] = value;
        }
      };
      _getComputedStyle = function _getComputedStyle2(element) {
        return _win5.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);
      };
      _tempRect = {};
      _parseRect = function _parseRect2(e) {
        if (e === _win5) {
          _tempRect.left = _tempRect.top = 0;
          _tempRect.width = _tempRect.right = _docElement3.clientWidth || e.innerWidth || _body2.clientWidth || 0;
          _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement3.clientHeight ? _docElement3.clientHeight : e.innerHeight || _body2.clientHeight || 0;
          return _tempRect;
        }
        var doc = e.ownerDocument || _doc5, r = !_isUndefined5(e.pageX) ? {
          left: e.pageX - _getDocScrollLeft3(doc),
          top: e.pageY - _getDocScrollTop3(doc),
          right: e.pageX - _getDocScrollLeft3(doc) + 1,
          bottom: e.pageY - _getDocScrollTop3(doc) + 1
        } : !e.nodeType && !_isUndefined5(e.left) && !_isUndefined5(e.top) ? e : _toArray(e)[0].getBoundingClientRect();
        if (_isUndefined5(r.right) && !_isUndefined5(r.width)) {
          r.right = r.left + r.width;
          r.bottom = r.top + r.height;
        } else if (_isUndefined5(r.width)) {
          r = {
            width: r.right - r.left,
            height: r.bottom - r.top,
            right: r.right,
            left: r.left,
            bottom: r.bottom,
            top: r.top
          };
        }
        return r;
      };
      _dispatchEvent = function _dispatchEvent2(target, type, callbackName) {
        var vars = target.vars, callback = vars[callbackName], listeners = target._listeners[type], result;
        if (_isFunction3(callback)) {
          result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);
        }
        if (listeners && target.dispatchEvent(type) === false) {
          result = false;
        }
        return result;
      };
      _getBounds = function _getBounds2(target, context) {
        var e = _toArray(target)[0], top, left, offset;
        if (!e.nodeType && e !== _win5) {
          if (!_isUndefined5(target.left)) {
            offset = {
              x: 0,
              y: 0
            };
            return {
              left: target.left - offset.x,
              top: target.top - offset.y,
              width: target.width,
              height: target.height
            };
          }
          left = target.min || target.minX || target.minRotation || 0;
          top = target.min || target.minY || 0;
          return {
            left,
            top,
            width: (target.max || target.maxX || target.maxRotation || 0) - left,
            height: (target.max || target.maxY || 0) - top
          };
        }
        return _getElementBounds(e, context);
      };
      _point1 = {};
      _getElementBounds = function _getElementBounds2(element, context) {
        context = _toArray(context)[0];
        var isSVG = element.getBBox && element.ownerSVGElement, doc = element.ownerDocument || _doc5, left, right, top, bottom, matrix, p1, p2, p3, p4, bbox, width, height, cs, contextParent;
        if (element === _win5) {
          top = _getDocScrollTop3(doc);
          left = _getDocScrollLeft3(doc);
          right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);
          bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0);
        } else if (context === _win5 || _isUndefined5(context)) {
          return element.getBoundingClientRect();
        } else {
          left = top = 0;
          if (isSVG) {
            bbox = element.getBBox();
            width = bbox.width;
            height = bbox.height;
          } else {
            if (element.viewBox && (bbox = element.viewBox.baseVal)) {
              left = bbox.x || 0;
              top = bbox.y || 0;
              width = bbox.width;
              height = bbox.height;
            }
            if (!width) {
              cs = _getComputedStyle(element);
              bbox = cs.boxSizing === "border-box";
              width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));
              height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));
            }
          }
          right = width;
          bottom = height;
        }
        if (element === context) {
          return {
            left,
            top,
            width: right - left,
            height: bottom - top
          };
        }
        matrix = getGlobalMatrix(context, true).multiply(getGlobalMatrix(element));
        p1 = matrix.apply({
          x: left,
          y: top
        });
        p2 = matrix.apply({
          x: right,
          y: top
        });
        p3 = matrix.apply({
          x: right,
          y: bottom
        });
        p4 = matrix.apply({
          x: left,
          y: bottom
        });
        left = Math.min(p1.x, p2.x, p3.x, p4.x);
        top = Math.min(p1.y, p2.y, p3.y, p4.y);
        contextParent = context.parentNode || {};
        return {
          left: left + (contextParent.scrollLeft || 0),
          top: top + (contextParent.scrollTop || 0),
          width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,
          height: Math.max(p1.y, p2.y, p3.y, p4.y) - top
        };
      };
      _parseInertia = function _parseInertia2(draggable, snap3, max, min, factor, forceZeroVelocity) {
        var vars = {}, a, i2, l;
        if (snap3) {
          if (factor !== 1 && snap3 instanceof Array) {
            vars.end = a = [];
            l = snap3.length;
            if (_isObject3(snap3[0])) {
              for (i2 = 0; i2 < l; i2++) {
                a[i2] = _copy(snap3[i2], factor);
              }
            } else {
              for (i2 = 0; i2 < l; i2++) {
                a[i2] = snap3[i2] * factor;
              }
            }
            max += 1.1;
            min -= 1.1;
          } else if (_isFunction3(snap3)) {
            vars.end = function(value) {
              var result = snap3.call(draggable, value), copy, p2;
              if (factor !== 1) {
                if (_isObject3(result)) {
                  copy = {};
                  for (p2 in result) {
                    copy[p2] = result[p2] * factor;
                  }
                  result = copy;
                } else {
                  result *= factor;
                }
              }
              return result;
            };
          } else {
            vars.end = snap3;
          }
        }
        if (max || max === 0) {
          vars.max = max;
        }
        if (min || min === 0) {
          vars.min = min;
        }
        if (forceZeroVelocity) {
          vars.velocity = 0;
        }
        return vars;
      };
      _isClickable = function _isClickable2(element) {
        var data;
        return !element || !element.getAttribute || element === _body2 ? false : (data = element.getAttribute("data-clickable")) === "true" || data !== "false" && (element.onclick || _clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true") ? true : _isClickable2(element.parentNode);
      };
      _setSelectable = function _setSelectable2(elements, selectable) {
        var i2 = elements.length, e;
        while (i2--) {
          e = elements[i2];
          e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc3;
          gsap4.set(e, {
            lazy: true,
            userSelect: selectable ? "text" : "none"
          });
        }
      };
      _isFixed3 = function _isFixed4(element) {
        if (_getComputedStyle(element).position === "fixed") {
          return true;
        }
        element = element.parentNode;
        if (element && element.nodeType === 1) {
          return _isFixed4(element);
        }
      };
      ScrollProxy = function ScrollProxy2(element, vars) {
        element = gsap4.utils.toArray(element)[0];
        vars = vars || {};
        var content = document.createElement("div"), style = content.style, node = element.firstChild, offsetTop = 0, offsetLeft = 0, prevTop = element.scrollTop, prevLeft = element.scrollLeft, scrollWidth = element.scrollWidth, scrollHeight = element.scrollHeight, extraPadRight = 0, maxLeft = 0, maxTop = 0, elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;
        if (_supports3D2 && vars.force3D !== false) {
          transformStart = "translate3d(";
          transformEnd = "px,0px)";
        } else if (_transformProp3) {
          transformStart = "translate(";
          transformEnd = "px)";
        }
        this.scrollTop = function(value, force) {
          if (!arguments.length) {
            return -this.top();
          }
          this.top(-value, force);
        };
        this.scrollLeft = function(value, force) {
          if (!arguments.length) {
            return -this.left();
          }
          this.left(-value, force);
        };
        this.left = function(value, force) {
          if (!arguments.length) {
            return -(element.scrollLeft + offsetLeft);
          }
          var dif = element.scrollLeft - prevLeft, oldOffset = offsetLeft;
          if ((dif > 2 || dif < -2) && !force) {
            prevLeft = element.scrollLeft;
            gsap4.killTweensOf(this, {
              left: 1,
              scrollLeft: 1
            });
            this.left(-prevLeft);
            if (vars.onKill) {
              vars.onKill();
            }
            return;
          }
          value = -value;
          if (value < 0) {
            offsetLeft = value - 0.5 | 0;
            value = 0;
          } else if (value > maxLeft) {
            offsetLeft = value - maxLeft | 0;
            value = maxLeft;
          } else {
            offsetLeft = 0;
          }
          if (offsetLeft || oldOffset) {
            if (!this._skip) {
              style[_transformProp3] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
            }
            if (offsetLeft + extraPadRight >= 0) {
              style.paddingRight = offsetLeft + extraPadRight + "px";
            }
          }
          element.scrollLeft = value | 0;
          prevLeft = element.scrollLeft;
        };
        this.top = function(value, force) {
          if (!arguments.length) {
            return -(element.scrollTop + offsetTop);
          }
          var dif = element.scrollTop - prevTop, oldOffset = offsetTop;
          if ((dif > 2 || dif < -2) && !force) {
            prevTop = element.scrollTop;
            gsap4.killTweensOf(this, {
              top: 1,
              scrollTop: 1
            });
            this.top(-prevTop);
            if (vars.onKill) {
              vars.onKill();
            }
            return;
          }
          value = -value;
          if (value < 0) {
            offsetTop = value - 0.5 | 0;
            value = 0;
          } else if (value > maxTop) {
            offsetTop = value - maxTop | 0;
            value = maxTop;
          } else {
            offsetTop = 0;
          }
          if (offsetTop || oldOffset) {
            if (!this._skip) {
              style[_transformProp3] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
            }
          }
          element.scrollTop = value | 0;
          prevTop = element.scrollTop;
        };
        this.maxScrollTop = function() {
          return maxTop;
        };
        this.maxScrollLeft = function() {
          return maxLeft;
        };
        this.disable = function() {
          node = content.firstChild;
          while (node) {
            nextNode = node.nextSibling;
            element.appendChild(node);
            node = nextNode;
          }
          if (element === content.parentNode) {
            element.removeChild(content);
          }
        };
        this.enable = function() {
          node = element.firstChild;
          if (node === content) {
            return;
          }
          while (node) {
            nextNode = node.nextSibling;
            content.appendChild(node);
            node = nextNode;
          }
          element.appendChild(content);
          this.calibrate();
        };
        this.calibrate = function(force) {
          var widthMatches = element.clientWidth === elementWidth, cs, x, y;
          prevTop = element.scrollTop;
          prevLeft = element.scrollLeft;
          if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
            return;
          }
          if (offsetTop || offsetLeft) {
            x = this.left();
            y = this.top();
            this.left(-element.scrollLeft);
            this.top(-element.scrollTop);
          }
          cs = _getComputedStyle(element);
          if (!widthMatches || force) {
            style.display = "block";
            style.width = "auto";
            style.paddingRight = "0px";
            extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
            if (extraPadRight) {
              extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);
            }
          }
          style.display = "inline-block";
          style.position = "relative";
          style.overflow = "visible";
          style.verticalAlign = "top";
          style.boxSizing = "content-box";
          style.width = "100%";
          style.paddingRight = extraPadRight + "px";
          if (_addPaddingBR) {
            style.paddingBottom = cs.paddingBottom;
          }
          elementWidth = element.clientWidth;
          elementHeight = element.clientHeight;
          scrollWidth = element.scrollWidth;
          scrollHeight = element.scrollHeight;
          maxLeft = element.scrollWidth - elementWidth;
          maxTop = element.scrollHeight - elementHeight;
          contentHeight = content.offsetHeight;
          style.display = "block";
          if (x || y) {
            this.left(x);
            this.top(y);
          }
        };
        this.content = content;
        this.element = element;
        this._skip = false;
        this.enable();
      };
      _initCore7 = function _initCore8(required) {
        if (_windowExists7() && document.body) {
          var nav = window && window.navigator;
          _win5 = window;
          _doc5 = document;
          _docElement3 = _doc5.documentElement;
          _body2 = _doc5.body;
          _tempDiv2 = _createElement3("div");
          _supportsPointer = !!window.PointerEvent;
          _placeholderDiv = _createElement3("div");
          _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";
          _defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";
          _isAndroid = nav && nav.userAgent.toLowerCase().indexOf("android") !== -1;
          _isTouchDevice = "ontouchstart" in _docElement3 && "orientation" in _win5 || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);
          _addPaddingBR = function() {
            var div = _createElement3("div"), child = _createElement3("div"), childStyle = child.style, parent = _body2, val;
            childStyle.display = "inline-block";
            childStyle.position = "relative";
            div.style.cssText = child.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";
            div.appendChild(child);
            parent.appendChild(div);
            val = child.offsetHeight + 18 > div.scrollHeight;
            parent.removeChild(div);
            return val;
          }();
          _touchEventLookup = function(types) {
            var standard = types.split(","), converted = ("onpointerdown" in _tempDiv2 ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in _tempDiv2 ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","), obj = {}, i2 = 4;
            while (--i2 > -1) {
              obj[standard[i2]] = converted[i2];
              obj[converted[i2]] = standard[i2];
            }
            try {
              _docElement3.addEventListener("test", null, Object.defineProperty({}, "passive", {
                get: function get() {
                  _supportsPassive = 1;
                }
              }));
            } catch (e) {
            }
            return obj;
          }("touchstart,touchmove,touchend,touchcancel");
          _addListener(_doc5, "touchcancel", _emptyFunc3);
          _addListener(_win5, "touchmove", _emptyFunc3);
          _body2 && _body2.addEventListener("touchstart", _emptyFunc3);
          _addListener(_doc5, "contextmenu", function() {
            for (var p2 in _lookup) {
              if (_lookup[p2].isPressed) {
                _lookup[p2].endDrag();
              }
            }
          });
          gsap4 = _coreInitted4 = _getGSAP5();
        }
        if (gsap4) {
          InertiaPlugin = gsap4.plugins.inertia;
          _checkPrefix = gsap4.utils.checkPrefix;
          _transformProp3 = _checkPrefix(_transformProp3);
          _transformOriginProp3 = _checkPrefix(_transformOriginProp3);
          _toArray = gsap4.utils.toArray;
          _supports3D2 = !!_checkPrefix("perspective");
        } else if (required) {
          console.warn("Please gsap.registerPlugin(Draggable)");
        }
      };
      EventDispatcher2 = /* @__PURE__ */ function() {
        function EventDispatcher3(target) {
          this._listeners = {};
          this.target = target || this;
        }
        var _proto = EventDispatcher3.prototype;
        _proto.addEventListener = function addEventListener(type, callback) {
          var list = this._listeners[type] || (this._listeners[type] = []);
          if (!~list.indexOf(callback)) {
            list.push(callback);
          }
        };
        _proto.removeEventListener = function removeEventListener(type, callback) {
          var list = this._listeners[type], i2 = list && list.indexOf(callback) || -1;
          i2 > -1 && list.splice(i2, 1);
        };
        _proto.dispatchEvent = function dispatchEvent(type) {
          var _this = this;
          var result;
          (this._listeners[type] || []).forEach(function(callback) {
            return callback.call(_this, {
              type,
              target: _this.target
            }) === false && (result = false);
          });
          return result;
        };
        return EventDispatcher3;
      }();
      Draggable = /* @__PURE__ */ function(_EventDispatcher) {
        _inheritsLoose2(Draggable2, _EventDispatcher);
        function Draggable2(target, vars) {
          var _this2;
          _this2 = _EventDispatcher.call(this) || this;
          _coreInitted4 || _initCore7(1);
          target = _toArray(target)[0];
          if (!InertiaPlugin) {
            InertiaPlugin = gsap4.plugins.inertia;
          }
          _this2.vars = vars = _copy(vars || {});
          _this2.target = target;
          _this2.x = _this2.y = _this2.rotation = 0;
          _this2.dragResistance = parseFloat(vars.dragResistance) || 0;
          _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
          _this2.lockAxis = vars.lockAxis;
          _this2.autoScroll = vars.autoScroll || 0;
          _this2.lockedAxis = null;
          _this2.allowEventDefault = !!vars.allowEventDefault;
          gsap4.getProperty(target, "x");
          var type = (vars.type || "x,y").toLowerCase(), xyMode = ~type.indexOf("x") || ~type.indexOf("y"), rotationMode = type.indexOf("rotation") !== -1, xProp = rotationMode ? "rotation" : xyMode ? "x" : "left", yProp = xyMode ? "y" : "top", allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"), allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"), minimumMovement = vars.minimumMovement || 2, self2 = _assertThisInitialized2(_this2), triggers = _toArray(vars.trigger || vars.handle || target), killProps = {}, dragEndTime = 0, checkAutoScrollBounds = false, autoScrollMarginTop = vars.autoScrollMarginTop || 40, autoScrollMarginRight = vars.autoScrollMarginRight || 40, autoScrollMarginBottom = vars.autoScrollMarginBottom || 40, autoScrollMarginLeft = vars.autoScrollMarginLeft || 40, isClickable = vars.clickableTest || _isClickable, clickTime = 0, gsCache = target._gsap || gsap4.core.getCache(target), isFixed = _isFixed3(target), getPropAsNum = function getPropAsNum2(property, unit) {
            return parseFloat(gsCache.get(target, property, unit));
          }, ownerDoc = target.ownerDocument || _doc5, enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, hasMoveCallback, maxX, minX, maxY, minY, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, snapXY, isClicking, touchEventTarget, matrix, interrupted, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch, isPreventingDefault, innerMatrix, onContextMenu = function onContextMenu2(e) {
            _preventDefault(e);
            e.stopImmediatePropagation && e.stopImmediatePropagation();
            return false;
          }, render6 = function render7(suppressEvents) {
            if (self2.autoScroll && self2.isDragging && (checkAutoScrollBounds || dirty)) {
              var e = target, autoScrollFactor = self2.autoScroll * 15, parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;
              checkAutoScrollBounds = false;
              _windowProxy.scrollTop = _win5.pageYOffset != null ? _win5.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
              _windowProxy.scrollLeft = _win5.pageXOffset != null ? _win5.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
              pointerX = self2.pointerX - _windowProxy.scrollLeft;
              pointerY = self2.pointerY - _windowProxy.scrollTop;
              while (e && !isRoot) {
                isRoot = _isRoot(e.parentNode);
                parent = isRoot ? _windowProxy : e.parentNode;
                rect = isRoot ? {
                  bottom: Math.max(_docElement3.clientHeight, _win5.innerHeight || 0),
                  right: Math.max(_docElement3.clientWidth, _win5.innerWidth || 0),
                  left: 0,
                  top: 0
                } : parent.getBoundingClientRect();
                changeX = changeY = 0;
                if (allowY) {
                  gap = parent._gsMaxScrollY - parent.scrollTop;
                  if (gap < 0) {
                    changeY = gap;
                  } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
                    checkAutoScrollBounds = true;
                    changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);
                  } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
                    checkAutoScrollBounds = true;
                    changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);
                  }
                  if (changeY) {
                    parent.scrollTop += changeY;
                  }
                }
                if (allowX) {
                  gap = parent._gsMaxScrollX - parent.scrollLeft;
                  if (gap < 0) {
                    changeX = gap;
                  } else if (pointerX > rect.right - autoScrollMarginRight && gap) {
                    checkAutoScrollBounds = true;
                    changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);
                  } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
                    checkAutoScrollBounds = true;
                    changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);
                  }
                  if (changeX) {
                    parent.scrollLeft += changeX;
                  }
                }
                if (isRoot && (changeX || changeY)) {
                  _win5.scrollTo(parent.scrollLeft, parent.scrollTop);
                  setPointerPosition(self2.pointerX + changeX, self2.pointerY + changeY);
                }
                e = parent;
              }
            }
            if (dirty) {
              var x = self2.x, y = self2.y;
              if (rotationMode) {
                self2.deltaX = x - parseFloat(gsCache.rotation);
                self2.rotation = x;
                gsCache.rotation = x + "deg";
                gsCache.renderTransform(1, gsCache);
              } else {
                if (scrollProxy) {
                  if (allowY) {
                    self2.deltaY = y - scrollProxy.top();
                    scrollProxy.top(y);
                  }
                  if (allowX) {
                    self2.deltaX = x - scrollProxy.left();
                    scrollProxy.left(x);
                  }
                } else if (xyMode) {
                  if (allowY) {
                    self2.deltaY = y - parseFloat(gsCache.y);
                    gsCache.y = y + "px";
                  }
                  if (allowX) {
                    self2.deltaX = x - parseFloat(gsCache.x);
                    gsCache.x = x + "px";
                  }
                  gsCache.renderTransform(1, gsCache);
                } else {
                  if (allowY) {
                    self2.deltaY = y - parseFloat(target.style.top || 0);
                    target.style.top = y + "px";
                  }
                  if (allowX) {
                    self2.deltaX = x - parseFloat(target.style.left || 0);
                    target.style.left = x + "px";
                  }
                }
              }
              if (hasDragCallback && !suppressEvents && !isDispatching) {
                isDispatching = true;
                if (_dispatchEvent(self2, "drag", "onDrag") === false) {
                  if (allowX) {
                    self2.x -= self2.deltaX;
                  }
                  if (allowY) {
                    self2.y -= self2.deltaY;
                  }
                  render7(true);
                }
                isDispatching = false;
              }
            }
            dirty = false;
          }, syncXY = function syncXY2(skipOnUpdate, skipSnap) {
            var x = self2.x, y = self2.y, snappedValue, cs;
            if (!target._gsap) {
              gsCache = gsap4.core.getCache(target);
            }
            gsCache.uncache && gsap4.getProperty(target, "x");
            if (xyMode) {
              self2.x = parseFloat(gsCache.x);
              self2.y = parseFloat(gsCache.y);
            } else if (rotationMode) {
              self2.x = self2.rotation = parseFloat(gsCache.rotation);
            } else if (scrollProxy) {
              self2.y = scrollProxy.top();
              self2.x = scrollProxy.left();
            } else {
              self2.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;
              self2.x = parseFloat(target.style.left || (cs || {}).left) || 0;
            }
            if ((snapX || snapY || snapXY) && !skipSnap && (self2.isDragging || self2.isThrowing)) {
              if (snapXY) {
                _temp1.x = self2.x;
                _temp1.y = self2.y;
                snappedValue = snapXY(_temp1);
                if (snappedValue.x !== self2.x) {
                  self2.x = snappedValue.x;
                  dirty = true;
                }
                if (snappedValue.y !== self2.y) {
                  self2.y = snappedValue.y;
                  dirty = true;
                }
              }
              if (snapX) {
                snappedValue = snapX(self2.x);
                if (snappedValue !== self2.x) {
                  self2.x = snappedValue;
                  if (rotationMode) {
                    self2.rotation = snappedValue;
                  }
                  dirty = true;
                }
              }
              if (snapY) {
                snappedValue = snapY(self2.y);
                if (snappedValue !== self2.y) {
                  self2.y = snappedValue;
                }
                dirty = true;
              }
            }
            dirty && render6(true);
            if (!skipOnUpdate) {
              self2.deltaX = self2.x - x;
              self2.deltaY = self2.y - y;
              _dispatchEvent(self2, "throwupdate", "onThrowUpdate");
            }
          }, buildSnapFunc = function buildSnapFunc2(snap3, min, max, factor) {
            if (min == null) {
              min = -_bigNum4;
            }
            if (max == null) {
              max = _bigNum4;
            }
            if (_isFunction3(snap3)) {
              return function(n) {
                var edgeTolerance = !self2.isPressed ? 1 : 1 - self2.edgeResistance;
                return snap3.call(self2, n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor;
              };
            }
            if (_isArray2(snap3)) {
              return function(n) {
                var i2 = snap3.length, closest = 0, absDif = _bigNum4, val, dif;
                while (--i2 > -1) {
                  val = snap3[i2];
                  dif = val - n;
                  if (dif < 0) {
                    dif = -dif;
                  }
                  if (dif < absDif && val >= min && val <= max) {
                    closest = i2;
                    absDif = dif;
                  }
                }
                return snap3[closest];
              };
            }
            return isNaN(snap3) ? function(n) {
              return n;
            } : function() {
              return snap3 * factor;
            };
          }, buildPointSnapFunc = function buildPointSnapFunc2(snap3, minX2, maxX2, minY2, maxY2, radius, factor) {
            radius = radius && radius < _bigNum4 ? radius * radius : _bigNum4;
            if (_isFunction3(snap3)) {
              return function(point) {
                var edgeTolerance = !self2.isPressed ? 1 : 1 - self2.edgeResistance, x = point.x, y = point.y, result, dx, dy;
                point.x = x = x > maxX2 ? maxX2 + (x - maxX2) * edgeTolerance : x < minX2 ? minX2 + (x - minX2) * edgeTolerance : x;
                point.y = y = y > maxY2 ? maxY2 + (y - maxY2) * edgeTolerance : y < minY2 ? minY2 + (y - minY2) * edgeTolerance : y;
                result = snap3.call(self2, point);
                if (result !== point) {
                  point.x = result.x;
                  point.y = result.y;
                }
                if (factor !== 1) {
                  point.x *= factor;
                  point.y *= factor;
                }
                if (radius < _bigNum4) {
                  dx = point.x - x;
                  dy = point.y - y;
                  if (dx * dx + dy * dy > radius) {
                    point.x = x;
                    point.y = y;
                  }
                }
                return point;
              };
            }
            if (_isArray2(snap3)) {
              return function(p2) {
                var i2 = snap3.length, closest = 0, minDist = _bigNum4, x, y, point, dist;
                while (--i2 > -1) {
                  point = snap3[i2];
                  x = point.x - p2.x;
                  y = point.y - p2.y;
                  dist = x * x + y * y;
                  if (dist < minDist) {
                    closest = i2;
                    minDist = dist;
                  }
                }
                return minDist <= radius ? snap3[closest] : p2;
              };
            }
            return function(n) {
              return n;
            };
          }, calculateBounds = function calculateBounds2() {
            var bounds, targetBounds, snap3, snapIsRaw;
            hasBounds = false;
            if (scrollProxy) {
              scrollProxy.calibrate();
              self2.minX = minX = -scrollProxy.maxScrollLeft();
              self2.minY = minY = -scrollProxy.maxScrollTop();
              self2.maxX = maxX = self2.maxY = maxY = 0;
              hasBounds = true;
            } else if (!!vars.bounds) {
              bounds = _getBounds(vars.bounds, target.parentNode);
              if (rotationMode) {
                self2.minX = minX = bounds.left;
                self2.maxX = maxX = bounds.left + bounds.width;
                self2.minY = minY = self2.maxY = maxY = 0;
              } else if (!_isUndefined5(vars.bounds.maxX) || !_isUndefined5(vars.bounds.maxY)) {
                bounds = vars.bounds;
                self2.minX = minX = bounds.minX;
                self2.minY = minY = bounds.minY;
                self2.maxX = maxX = bounds.maxX;
                self2.maxY = maxY = bounds.maxY;
              } else {
                targetBounds = _getBounds(target, target.parentNode);
                self2.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left);
                self2.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top);
                self2.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));
                self2.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));
              }
              if (minX > maxX) {
                self2.minX = maxX;
                self2.maxX = maxX = minX;
                minX = self2.minX;
              }
              if (minY > maxY) {
                self2.minY = maxY;
                self2.maxY = maxY = minY;
                minY = self2.minY;
              }
              if (rotationMode) {
                self2.minRotation = minX;
                self2.maxRotation = maxX;
              }
              hasBounds = true;
            }
            if (vars.liveSnap) {
              snap3 = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;
              snapIsRaw = _isArray2(snap3) || _isFunction3(snap3);
              if (rotationMode) {
                snapX = buildSnapFunc(snapIsRaw ? snap3 : snap3.rotation, minX, maxX, 1);
                snapY = null;
              } else {
                if (snap3.points) {
                  snapXY = buildPointSnapFunc(snapIsRaw ? snap3 : snap3.points, minX, maxX, minY, maxY, snap3.radius, scrollProxy ? -1 : 1);
                } else {
                  if (allowX) {
                    snapX = buildSnapFunc(snapIsRaw ? snap3 : snap3.x || snap3.left || snap3.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);
                  }
                  if (allowY) {
                    snapY = buildSnapFunc(snapIsRaw ? snap3 : snap3.y || snap3.top || snap3.scrollTop, minY, maxY, scrollProxy ? -1 : 1);
                  }
                }
              }
            }
          }, onThrowComplete = function onThrowComplete2() {
            self2.isThrowing = false;
            _dispatchEvent(self2, "throwcomplete", "onThrowComplete");
          }, onThrowInterrupt = function onThrowInterrupt2() {
            self2.isThrowing = false;
          }, animate = function animate2(inertia, forceZeroVelocity) {
            var snap3, snapIsRaw, tween, overshootTolerance;
            if (inertia && InertiaPlugin) {
              if (inertia === true) {
                snap3 = vars.snap || vars.liveSnap || {};
                snapIsRaw = _isArray2(snap3) || _isFunction3(snap3);
                inertia = {
                  resistance: (vars.throwResistance || vars.resistance || 1e3) / (rotationMode ? 10 : 1)
                };
                if (rotationMode) {
                  inertia.rotation = _parseInertia(self2, snapIsRaw ? snap3 : snap3.rotation, maxX, minX, 1, forceZeroVelocity);
                } else {
                  if (allowX) {
                    inertia[xProp] = _parseInertia(self2, snapIsRaw ? snap3 : snap3.points || snap3.x || snap3.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self2.lockedAxis === "x");
                  }
                  if (allowY) {
                    inertia[yProp] = _parseInertia(self2, snapIsRaw ? snap3 : snap3.points || snap3.y || snap3.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self2.lockedAxis === "y");
                  }
                  if (snap3.points || _isArray2(snap3) && _isObject3(snap3[0])) {
                    inertia.linkedProps = xProp + "," + yProp;
                    inertia.radius = snap3.radius;
                  }
                }
              }
              self2.isThrowing = true;
              overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self2.edgeResistance + 0.2;
              if (!inertia.duration) {
                inertia.duration = {
                  max: Math.max(vars.minDuration || 0, "maxDuration" in vars ? vars.maxDuration : 2),
                  min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject3(inertia) && inertia.resistance > 1e3 ? 0 : 0.5,
                  overshoot: overshootTolerance
                };
              }
              self2.tween = tween = gsap4.to(scrollProxy || target, {
                inertia,
                data: "_draggable",
                onComplete: onThrowComplete,
                onInterrupt: onThrowInterrupt,
                onUpdate: vars.fastMode ? _dispatchEvent : syncXY,
                onUpdateParams: vars.fastMode ? [self2, "onthrowupdate", "onThrowUpdate"] : snap3 && snap3.radius ? [false, true] : []
              });
              if (!vars.fastMode) {
                if (scrollProxy) {
                  scrollProxy._skip = true;
                }
                tween.render(1e9, true, true);
                syncXY(true, true);
                self2.endX = self2.x;
                self2.endY = self2.y;
                if (rotationMode) {
                  self2.endRotation = self2.x;
                }
                tween.play(0);
                syncXY(true, true);
                if (scrollProxy) {
                  scrollProxy._skip = false;
                }
              }
            } else if (hasBounds) {
              self2.applyBounds();
            }
          }, updateMatrix = function updateMatrix2(shiftStart) {
            var start = matrix, p2;
            matrix = getGlobalMatrix(target.parentNode, true);
            if (shiftStart && self2.isPressed && !matrix.equals(start || new Matrix2D())) {
              p2 = start.inverse().apply({
                x: startPointerX,
                y: startPointerY
              });
              matrix.apply(p2, p2);
              startPointerX = p2.x;
              startPointerY = p2.y;
            }
            if (matrix.equals(_identityMatrix3)) {
              matrix = null;
            }
          }, recordStartPositions = function recordStartPositions2() {
            var edgeTolerance = 1 - self2.edgeResistance, offsetX = isFixed ? _getDocScrollLeft3(ownerDoc) : 0, offsetY = isFixed ? _getDocScrollTop3(ownerDoc) : 0, parsedOrigin, x, y;
            updateMatrix(false);
            _point1.x = self2.pointerX - offsetX;
            _point1.y = self2.pointerY - offsetY;
            matrix && matrix.apply(_point1, _point1);
            startPointerX = _point1.x;
            startPointerY = _point1.y;
            if (dirty) {
              setPointerPosition(self2.pointerX, self2.pointerY);
              render6(true);
            }
            innerMatrix = getGlobalMatrix(target);
            if (scrollProxy) {
              calculateBounds();
              startElementY = scrollProxy.top();
              startElementX = scrollProxy.left();
            } else {
              if (isTweening2()) {
                syncXY(true, true);
                calculateBounds();
              } else {
                self2.applyBounds();
              }
              if (rotationMode) {
                parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp3] || "0 0").split(" ");
                rotationOrigin = self2.rotationOrigin = getGlobalMatrix(target).apply({
                  x: parseFloat(parsedOrigin[0]) || 0,
                  y: parseFloat(parsedOrigin[1]) || 0
                });
                syncXY(true, true);
                x = self2.pointerX - rotationOrigin.x - offsetX;
                y = rotationOrigin.y - self2.pointerY + offsetY;
                startElementX = self2.x;
                startElementY = self2.y = Math.atan2(y, x) * _RAD2DEG3;
              } else {
                startElementY = getPropAsNum(yProp, "px");
                startElementX = getPropAsNum(xProp, "px");
              }
            }
            if (hasBounds && edgeTolerance) {
              if (startElementX > maxX) {
                startElementX = maxX + (startElementX - maxX) / edgeTolerance;
              } else if (startElementX < minX) {
                startElementX = minX - (minX - startElementX) / edgeTolerance;
              }
              if (!rotationMode) {
                if (startElementY > maxY) {
                  startElementY = maxY + (startElementY - maxY) / edgeTolerance;
                } else if (startElementY < minY) {
                  startElementY = minY - (minY - startElementY) / edgeTolerance;
                }
              }
            }
            self2.startX = startElementX = _round7(startElementX);
            self2.startY = startElementY = _round7(startElementY);
          }, isTweening2 = function isTweening3() {
            return self2.tween && self2.tween.isActive();
          }, removePlaceholder = function removePlaceholder2() {
            if (_placeholderDiv.parentNode && !isTweening2() && !self2.isDragging) {
              _placeholderDiv.parentNode.removeChild(_placeholderDiv);
            }
          }, onPress = function onPress2(e, force) {
            var i2;
            if (!enabled || self2.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self2.pointerEvent.type]) {
              isPreventingDefault && e && enabled && _preventDefault(e);
              return;
            }
            interrupted = isTweening2();
            self2.pointerEvent = e;
            if (_touchEventLookup[e.type]) {
              touchEventTarget = ~e.type.indexOf("touch") ? e.currentTarget || e.target : ownerDoc;
              _addListener(touchEventTarget, "touchend", onRelease);
              _addListener(touchEventTarget, "touchmove", onMove);
              _addListener(touchEventTarget, "touchcancel", onRelease);
              _addListener(ownerDoc, "touchstart", _onMultiTouchDocument);
            } else {
              touchEventTarget = null;
              _addListener(ownerDoc, "mousemove", onMove);
            }
            touchDragAxis = null;
            if (!_supportsPointer || !touchEventTarget) {
              _addListener(ownerDoc, "mouseup", onRelease);
              e && e.target && _addListener(e.target, "mouseup", onRelease);
            }
            isClicking = isClickable.call(self2, e.target) && vars.dragClickables === false && !force;
            if (isClicking) {
              _addListener(e.target, "change", onRelease);
              _dispatchEvent(self2, "pressInit", "onPressInit");
              _dispatchEvent(self2, "press", "onPress");
              _setSelectable(triggers, true);
              isPreventingDefault = false;
              return;
            }
            allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self2.vars.allowNativeTouchScrolling === false || self2.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x";
            isPreventingDefault = !allowNativeTouchScrolling && !self2.allowEventDefault;
            if (isPreventingDefault) {
              _preventDefault(e);
              _addListener(_win5, "touchforcechange", _preventDefault);
            }
            if (e.changedTouches) {
              e = touch = e.changedTouches[0];
              touchID = e.identifier;
            } else if (e.pointerId) {
              touchID = e.pointerId;
            } else {
              touch = touchID = null;
            }
            _dragCount++;
            _addToRenderQueue(render6);
            startPointerY = self2.pointerY = e.pageY;
            startPointerX = self2.pointerX = e.pageX;
            _dispatchEvent(self2, "pressInit", "onPressInit");
            if (allowNativeTouchScrolling || self2.autoScroll) {
              _recordMaxScrolls(target.parentNode);
            }
            if (target.parentNode && self2.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {
              _placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
              target.parentNode.appendChild(_placeholderDiv);
            }
            recordStartPositions();
            self2.tween && self2.tween.kill();
            self2.isThrowing = false;
            gsap4.killTweensOf(scrollProxy || target, killProps, true);
            scrollProxy && gsap4.killTweensOf(target, {
              scrollTo: 1
            }, true);
            self2.tween = self2.lockedAxis = null;
            if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {
              target.style.zIndex = Draggable2.zIndex++;
            }
            self2.isPressed = true;
            hasDragCallback = !!(vars.onDrag || self2._listeners.drag);
            hasMoveCallback = !!(vars.onMove || self2._listeners.move);
            if (vars.cursor !== false || vars.activeCursor) {
              i2 = triggers.length;
              while (--i2 > -1) {
                gsap4.set(triggers[i2], {
                  cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)
                });
              }
            }
            _dispatchEvent(self2, "press", "onPress");
          }, onMove = function onMove2(e) {
            var originalEvent = e, touches, pointerX, pointerY, i2, dx, dy;
            if (!enabled || _isMultiTouching || !self2.isPressed || !e) {
              isPreventingDefault && e && enabled && _preventDefault(e);
              return;
            }
            self2.pointerEvent = e;
            touches = e.changedTouches;
            if (touches) {
              e = touches[0];
              if (e !== touch && e.identifier !== touchID) {
                i2 = touches.length;
                while (--i2 > -1 && (e = touches[i2]).identifier !== touchID && e.target !== target) {
                }
                if (i2 < 0) {
                  return;
                }
              }
            } else if (e.pointerId && touchID && e.pointerId !== touchID) {
              return;
            }
            if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {
              _point1.x = e.pageX - (isFixed ? _getDocScrollLeft3(ownerDoc) : 0);
              _point1.y = e.pageY - (isFixed ? _getDocScrollTop3(ownerDoc) : 0);
              matrix && matrix.apply(_point1, _point1);
              pointerX = _point1.x;
              pointerY = _point1.y;
              dx = Math.abs(pointerX - startPointerX);
              dy = Math.abs(pointerY - startPointerY);
              if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {
                touchDragAxis = dx > dy && allowX ? "x" : "y";
                if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {
                  _addListener(_win5, "touchforcechange", _preventDefault);
                }
                if (self2.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {
                  self2.lockedAxis = touchDragAxis === "x" ? "y" : "x";
                  _isFunction3(self2.vars.onLockAxis) && self2.vars.onLockAxis.call(self2, originalEvent);
                }
                if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
                  onRelease(originalEvent);
                  return;
                }
              }
            }
            if (!self2.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {
              _preventDefault(originalEvent);
              isPreventingDefault = true;
            } else if (isPreventingDefault) {
              isPreventingDefault = false;
            }
            if (self2.autoScroll) {
              checkAutoScrollBounds = true;
            }
            setPointerPosition(e.pageX, e.pageY, hasMoveCallback);
          }, setPointerPosition = function setPointerPosition2(pointerX, pointerY, invokeOnMove) {
            var dragTolerance = 1 - self2.dragResistance, edgeTolerance = 1 - self2.edgeResistance, prevPointerX = self2.pointerX, prevPointerY = self2.pointerY, prevStartElementY = startElementY, prevX = self2.x, prevY = self2.y, prevEndX = self2.endX, prevEndY = self2.endY, prevEndRotation = self2.endRotation, prevDirty = dirty, xChange, yChange, x, y, dif, temp;
            self2.pointerX = pointerX;
            self2.pointerY = pointerY;
            if (isFixed) {
              pointerX -= _getDocScrollLeft3(ownerDoc);
              pointerY -= _getDocScrollTop3(ownerDoc);
            }
            if (rotationMode) {
              y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG3;
              dif = self2.y - y;
              if (dif > 180) {
                startElementY -= 360;
                self2.y = y;
              } else if (dif < -180) {
                startElementY += 360;
                self2.y = y;
              }
              if (self2.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
                self2.y = y;
                x = startElementX + (startElementY - y) * dragTolerance;
              } else {
                x = startElementX;
              }
            } else {
              if (matrix) {
                temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;
                pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;
                pointerX = temp;
              }
              yChange = pointerY - startPointerY;
              xChange = pointerX - startPointerX;
              if (yChange < minimumMovement && yChange > -minimumMovement) {
                yChange = 0;
              }
              if (xChange < minimumMovement && xChange > -minimumMovement) {
                xChange = 0;
              }
              if ((self2.lockAxis || self2.lockedAxis) && (xChange || yChange)) {
                temp = self2.lockedAxis;
                if (!temp) {
                  self2.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;
                  if (temp && _isFunction3(self2.vars.onLockAxis)) {
                    self2.vars.onLockAxis.call(self2, self2.pointerEvent);
                  }
                }
                if (temp === "y") {
                  yChange = 0;
                } else if (temp === "x") {
                  xChange = 0;
                }
              }
              x = _round7(startElementX + xChange * dragTolerance);
              y = _round7(startElementY + yChange * dragTolerance);
            }
            if ((snapX || snapY || snapXY) && (self2.x !== x || self2.y !== y && !rotationMode)) {
              if (snapXY) {
                _temp1.x = x;
                _temp1.y = y;
                temp = snapXY(_temp1);
                x = _round7(temp.x);
                y = _round7(temp.y);
              }
              if (snapX) {
                x = _round7(snapX(x));
              }
              if (snapY) {
                y = _round7(snapY(y));
              }
            }
            if (hasBounds) {
              if (x > maxX) {
                x = maxX + Math.round((x - maxX) * edgeTolerance);
              } else if (x < minX) {
                x = minX + Math.round((x - minX) * edgeTolerance);
              }
              if (!rotationMode) {
                if (y > maxY) {
                  y = Math.round(maxY + (y - maxY) * edgeTolerance);
                } else if (y < minY) {
                  y = Math.round(minY + (y - minY) * edgeTolerance);
                }
              }
            }
            if (self2.x !== x || self2.y !== y && !rotationMode) {
              if (rotationMode) {
                self2.endRotation = self2.x = self2.endX = x;
                dirty = true;
              } else {
                if (allowY) {
                  self2.y = self2.endY = y;
                  dirty = true;
                }
                if (allowX) {
                  self2.x = self2.endX = x;
                  dirty = true;
                }
              }
              if (!invokeOnMove || _dispatchEvent(self2, "move", "onMove") !== false) {
                if (!self2.isDragging && self2.isPressed) {
                  self2.isDragging = true;
                  _dispatchEvent(self2, "dragstart", "onDragStart");
                }
              } else {
                self2.pointerX = prevPointerX;
                self2.pointerY = prevPointerY;
                startElementY = prevStartElementY;
                self2.x = prevX;
                self2.y = prevY;
                self2.endX = prevEndX;
                self2.endY = prevEndY;
                self2.endRotation = prevEndRotation;
                dirty = prevDirty;
              }
            }
          }, onRelease = function onRelease2(e, force) {
            if (!enabled || !self2.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {
              isPreventingDefault && e && enabled && _preventDefault(e);
              return;
            }
            self2.isPressed = false;
            var originalEvent = e, wasDragging = self2.isDragging, isContextMenuRelease = self2.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2), placeholderDelayedCall = gsap4.delayedCall(1e-3, removePlaceholder), touches, i2, syntheticEvent, eventTarget, syntheticClick;
            if (touchEventTarget) {
              _removeListener(touchEventTarget, "touchend", onRelease2);
              _removeListener(touchEventTarget, "touchmove", onMove);
              _removeListener(touchEventTarget, "touchcancel", onRelease2);
              _removeListener(ownerDoc, "touchstart", _onMultiTouchDocument);
            } else {
              _removeListener(ownerDoc, "mousemove", onMove);
            }
            _removeListener(_win5, "touchforcechange", _preventDefault);
            if (!_supportsPointer || !touchEventTarget) {
              _removeListener(ownerDoc, "mouseup", onRelease2);
              e && e.target && _removeListener(e.target, "mouseup", onRelease2);
            }
            dirty = false;
            if (wasDragging) {
              dragEndTime = _lastDragTime = _getTime();
              self2.isDragging = false;
            }
            if (isClicking && !isContextMenuRelease) {
              if (e) {
                _removeListener(e.target, "change", onRelease2);
                self2.pointerEvent = originalEvent;
              }
              _setSelectable(triggers, false);
              _dispatchEvent(self2, "release", "onRelease");
              _dispatchEvent(self2, "click", "onClick");
              isClicking = false;
              return;
            }
            _removeFromRenderQueue(render6);
            i2 = triggers.length;
            while (--i2 > -1) {
              _setStyle(triggers[i2], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));
            }
            _dragCount--;
            if (e) {
              touches = e.changedTouches;
              if (touches) {
                e = touches[0];
                if (e !== touch && e.identifier !== touchID) {
                  i2 = touches.length;
                  while (--i2 > -1 && (e = touches[i2]).identifier !== touchID && e.target !== target) {
                  }
                  if (i2 < 0) {
                    return;
                  }
                }
              }
              self2.pointerEvent = originalEvent;
              self2.pointerX = e.pageX;
              self2.pointerY = e.pageY;
            }
            if (isContextMenuRelease && originalEvent) {
              _preventDefault(originalEvent);
              isPreventingDefault = true;
              _dispatchEvent(self2, "release", "onRelease");
            } else if (originalEvent && !wasDragging) {
              isPreventingDefault = false;
              if (interrupted && (vars.snap || vars.bounds)) {
                animate(vars.inertia || vars.throwProps);
              }
              _dispatchEvent(self2, "release", "onRelease");
              if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {
                _dispatchEvent(self2, "click", "onClick");
                if (_getTime() - clickTime < 300) {
                  _dispatchEvent(self2, "doubleclick", "onDoubleClick");
                }
                eventTarget = originalEvent.target || target;
                clickTime = _getTime();
                syntheticClick = function syntheticClick2() {
                  if (clickTime !== clickDispatch && self2.enabled() && !self2.isPressed && !originalEvent.defaultPrevented) {
                    if (eventTarget.click) {
                      eventTarget.click();
                    } else if (ownerDoc.createEvent) {
                      syntheticEvent = ownerDoc.createEvent("MouseEvents");
                      syntheticEvent.initMouseEvent("click", true, true, _win5, 1, self2.pointerEvent.screenX, self2.pointerEvent.screenY, self2.pointerX, self2.pointerY, false, false, false, false, 0, null);
                      eventTarget.dispatchEvent(syntheticEvent);
                    }
                  }
                };
                if (!_isAndroid && !originalEvent.defaultPrevented) {
                  gsap4.delayedCall(0.05, syntheticClick);
                }
              }
            } else {
              animate(vars.inertia || vars.throwProps);
              if (!self2.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self2, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {
                isPreventingDefault = true;
                _preventDefault(originalEvent);
              } else {
                isPreventingDefault = false;
              }
              _dispatchEvent(self2, "release", "onRelease");
            }
            isTweening2() && placeholderDelayedCall.duration(self2.tween.duration());
            wasDragging && _dispatchEvent(self2, "dragend", "onDragEnd");
            return true;
          }, updateScroll = function updateScroll2(e) {
            if (e && self2.isDragging && !scrollProxy) {
              var parent = e.target || target.parentNode, deltaX = parent.scrollLeft - parent._gsScrollX, deltaY = parent.scrollTop - parent._gsScrollY;
              if (deltaX || deltaY) {
                if (matrix) {
                  startPointerX -= deltaX * matrix.a + deltaY * matrix.c;
                  startPointerY -= deltaY * matrix.d + deltaX * matrix.b;
                } else {
                  startPointerX -= deltaX;
                  startPointerY -= deltaY;
                }
                parent._gsScrollX += deltaX;
                parent._gsScrollY += deltaY;
                setPointerPosition(self2.pointerX, self2.pointerY);
              }
            }
          }, onClick = function onClick2(e) {
            var time = _getTime(), recentlyClicked = time - clickTime < 100, recentlyDragged = time - dragEndTime < 50, alreadyDispatched = recentlyClicked && clickDispatch === clickTime, defaultPrevented = self2.pointerEvent && self2.pointerEvent.defaultPrevented, alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime, trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched;
            if ((alreadyDispatched || recentlyDragged && self2.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {
              e.stopImmediatePropagation();
            }
            if (recentlyClicked && !(self2.pointerEvent && self2.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {
              if (trusted && alreadyDispatched) {
                trustedClickDispatch = clickTime;
              }
              clickDispatch = clickTime;
              return;
            }
            if (self2.isPressed || recentlyDragged || recentlyClicked) {
              if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
                _preventDefault(e);
              }
            }
            if (!recentlyClicked && !recentlyDragged) {
              e && e.target && (self2.pointerEvent = e);
              _dispatchEvent(self2, "click", "onClick");
            }
          }, localizePoint = function localizePoint2(p2) {
            return matrix ? {
              x: p2.x * matrix.a + p2.y * matrix.c + matrix.e,
              y: p2.x * matrix.b + p2.y * matrix.d + matrix.f
            } : {
              x: p2.x,
              y: p2.y
            };
          };
          old = Draggable2.get(target);
          old && old.kill();
          _this2.startDrag = function(event, align) {
            var r1, r2, p1, p2;
            onPress(event || self2.pointerEvent, true);
            if (align && !self2.hitTest(event || self2.pointerEvent)) {
              r1 = _parseRect(event || self2.pointerEvent);
              r2 = _parseRect(target);
              p1 = localizePoint({
                x: r1.left + r1.width / 2,
                y: r1.top + r1.height / 2
              });
              p2 = localizePoint({
                x: r2.left + r2.width / 2,
                y: r2.top + r2.height / 2
              });
              startPointerX -= p1.x - p2.x;
              startPointerY -= p1.y - p2.y;
            }
            if (!self2.isDragging) {
              self2.isDragging = true;
              _dispatchEvent(self2, "dragstart", "onDragStart");
            }
          };
          _this2.drag = onMove;
          _this2.endDrag = function(e) {
            return onRelease(e || self2.pointerEvent, true);
          };
          _this2.timeSinceDrag = function() {
            return self2.isDragging ? 0 : (_getTime() - dragEndTime) / 1e3;
          };
          _this2.timeSinceClick = function() {
            return (_getTime() - clickTime) / 1e3;
          };
          _this2.hitTest = function(target2, threshold) {
            return Draggable2.hitTest(self2.target, target2, threshold);
          };
          _this2.getDirection = function(from, diagonalThreshold) {
            var mode = from === "velocity" && InertiaPlugin ? from : _isObject3(from) && !rotationMode ? "element" : "start", xChange, yChange, ratio, direction, r1, r2;
            if (mode === "element") {
              r1 = _parseRect(self2.target);
              r2 = _parseRect(from);
            }
            xChange = mode === "start" ? self2.x - startElementX : mode === "velocity" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);
            if (rotationMode) {
              return xChange < 0 ? "counter-clockwise" : "clockwise";
            } else {
              diagonalThreshold = diagonalThreshold || 2;
              yChange = mode === "start" ? self2.y - startElementY : mode === "velocity" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);
              ratio = Math.abs(xChange / yChange);
              direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";
              if (ratio < diagonalThreshold) {
                if (direction !== "") {
                  direction += "-";
                }
                direction += yChange < 0 ? "up" : "down";
              }
            }
            return direction;
          };
          _this2.applyBounds = function(newBounds, sticky) {
            var x, y, forceZeroVelocity, e, parent, isRoot;
            if (newBounds && vars.bounds !== newBounds) {
              vars.bounds = newBounds;
              return self2.update(true, sticky);
            }
            syncXY(true);
            calculateBounds();
            if (hasBounds && !isTweening2()) {
              x = self2.x;
              y = self2.y;
              if (x > maxX) {
                x = maxX;
              } else if (x < minX) {
                x = minX;
              }
              if (y > maxY) {
                y = maxY;
              } else if (y < minY) {
                y = minY;
              }
              if (self2.x !== x || self2.y !== y) {
                forceZeroVelocity = true;
                self2.x = self2.endX = x;
                if (rotationMode) {
                  self2.endRotation = x;
                } else {
                  self2.y = self2.endY = y;
                }
                dirty = true;
                render6(true);
                if (self2.autoScroll && !self2.isDragging) {
                  _recordMaxScrolls(target.parentNode);
                  e = target;
                  _windowProxy.scrollTop = _win5.pageYOffset != null ? _win5.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
                  _windowProxy.scrollLeft = _win5.pageXOffset != null ? _win5.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
                  while (e && !isRoot) {
                    isRoot = _isRoot(e.parentNode);
                    parent = isRoot ? _windowProxy : e.parentNode;
                    if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
                      parent.scrollTop = parent._gsMaxScrollY;
                    }
                    if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
                      parent.scrollLeft = parent._gsMaxScrollX;
                    }
                    e = parent;
                  }
                }
              }
              if (self2.isThrowing && (forceZeroVelocity || self2.endX > maxX || self2.endX < minX || self2.endY > maxY || self2.endY < minY)) {
                animate(vars.inertia || vars.throwProps, forceZeroVelocity);
              }
            }
            return self2;
          };
          _this2.update = function(applyBounds, sticky, ignoreExternalChanges) {
            if (sticky && self2.isPressed) {
              var m = getGlobalMatrix(target), p2 = innerMatrix.apply({
                x: self2.x - startElementX,
                y: self2.y - startElementY
              }), m2 = getGlobalMatrix(target.parentNode, true);
              m2.apply({
                x: m.e - p2.x,
                y: m.f - p2.y
              }, p2);
              self2.x -= p2.x - m2.e;
              self2.y -= p2.y - m2.f;
              render6(true);
              recordStartPositions();
            }
            var x = self2.x, y = self2.y;
            updateMatrix(!sticky);
            if (applyBounds) {
              self2.applyBounds();
            } else {
              dirty && ignoreExternalChanges && render6(true);
              syncXY(true);
            }
            if (sticky) {
              setPointerPosition(self2.pointerX, self2.pointerY);
              dirty && render6(true);
            }
            if (self2.isPressed && !sticky && (allowX && Math.abs(x - self2.x) > 0.01 || allowY && Math.abs(y - self2.y) > 0.01 && !rotationMode)) {
              recordStartPositions();
            }
            if (self2.autoScroll) {
              _recordMaxScrolls(target.parentNode, self2.isDragging);
              checkAutoScrollBounds = self2.isDragging;
              render6(true);
              _removeScrollListener(target, updateScroll);
              _addScrollListener(target, updateScroll);
            }
            return self2;
          };
          _this2.enable = function(type2) {
            var setVars = {
              lazy: true
            }, id, i2, trigger;
            if (vars.cursor !== false) {
              setVars.cursor = vars.cursor || _defaultCursor;
            }
            if (gsap4.utils.checkPrefix("touchCallout")) {
              setVars.touchCallout = "none";
            }
            if (type2 !== "soft") {
              _setTouchActionForAllDescendants(triggers, allowX === allowY ? "none" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x");
              i2 = triggers.length;
              while (--i2 > -1) {
                trigger = triggers[i2];
                _supportsPointer || _addListener(trigger, "mousedown", onPress);
                _addListener(trigger, "touchstart", onPress);
                _addListener(trigger, "click", onClick, true);
                gsap4.set(trigger, setVars);
                if (trigger.getBBox && trigger.ownerSVGElement) {
                  gsap4.set(trigger.ownerSVGElement, {
                    touchAction: allowX === allowY ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"
                  });
                }
                vars.allowContextMenu || _addListener(trigger, "contextmenu", onContextMenu);
              }
              _setSelectable(triggers, false);
            }
            _addScrollListener(target, updateScroll);
            enabled = true;
            if (InertiaPlugin && type2 !== "soft") {
              InertiaPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
            }
            target._gsDragID = id = "d" + _lookupCount++;
            _lookup[id] = self2;
            if (scrollProxy) {
              scrollProxy.enable();
              scrollProxy.element._gsDragID = id;
            }
            (vars.bounds || rotationMode) && recordStartPositions();
            vars.bounds && self2.applyBounds();
            return self2;
          };
          _this2.disable = function(type2) {
            var dragging = self2.isDragging, i2 = triggers.length, trigger;
            while (--i2 > -1) {
              _setStyle(triggers[i2], "cursor", null);
            }
            if (type2 !== "soft") {
              _setTouchActionForAllDescendants(triggers, null);
              i2 = triggers.length;
              while (--i2 > -1) {
                trigger = triggers[i2];
                _setStyle(trigger, "touchCallout", null);
                _removeListener(trigger, "mousedown", onPress);
                _removeListener(trigger, "touchstart", onPress);
                _removeListener(trigger, "click", onClick);
                _removeListener(trigger, "contextmenu", onContextMenu);
              }
              _setSelectable(triggers, true);
              if (touchEventTarget) {
                _removeListener(touchEventTarget, "touchcancel", onRelease);
                _removeListener(touchEventTarget, "touchend", onRelease);
                _removeListener(touchEventTarget, "touchmove", onMove);
              }
              _removeListener(ownerDoc, "mouseup", onRelease);
              _removeListener(ownerDoc, "mousemove", onMove);
            }
            _removeScrollListener(target, updateScroll);
            enabled = false;
            InertiaPlugin && type2 !== "soft" && InertiaPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
            scrollProxy && scrollProxy.disable();
            _removeFromRenderQueue(render6);
            self2.isDragging = self2.isPressed = isClicking = false;
            dragging && _dispatchEvent(self2, "dragend", "onDragEnd");
            return self2;
          };
          _this2.enabled = function(value, type2) {
            return arguments.length ? value ? self2.enable(type2) : self2.disable(type2) : enabled;
          };
          _this2.kill = function() {
            self2.isThrowing = false;
            self2.tween && self2.tween.kill();
            self2.disable();
            gsap4.set(triggers, {
              clearProps: "userSelect"
            });
            delete _lookup[target._gsDragID];
            return self2;
          };
          if (~type.indexOf("scroll")) {
            scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({
              onKill: function onKill() {
                self2.isPressed && onRelease(null);
              }
            }, vars));
            target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";
            target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";
            target = scrollProxy.content;
          }
          if (rotationMode) {
            killProps.rotation = 1;
          } else {
            if (allowX) {
              killProps[xProp] = 1;
            }
            if (allowY) {
              killProps[yProp] = 1;
            }
          }
          gsCache.force3D = "force3D" in vars ? vars.force3D : true;
          _this2.enable();
          return _this2;
        }
        Draggable2.register = function register4(core) {
          gsap4 = core;
          _initCore7();
        };
        Draggable2.create = function create(targets, vars) {
          _coreInitted4 || _initCore7(true);
          return _toArray(targets).map(function(target) {
            return new Draggable2(target, vars);
          });
        };
        Draggable2.get = function get(target) {
          return _lookup[(_toArray(target)[0] || {})._gsDragID];
        };
        Draggable2.timeSinceDrag = function timeSinceDrag() {
          return (_getTime() - _lastDragTime) / 1e3;
        };
        Draggable2.hitTest = function hitTest(obj1, obj2, threshold) {
          if (obj1 === obj2) {
            return false;
          }
          var r1 = _parseRect(obj1), r2 = _parseRect(obj2), top = r1.top, left = r1.left, right = r1.right, bottom = r1.bottom, width = r1.width, height = r1.height, isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top, overlap, area2, isRatio;
          if (isOutside || !threshold) {
            return !isOutside;
          }
          isRatio = (threshold + "").indexOf("%") !== -1;
          threshold = parseFloat(threshold) || 0;
          overlap = {
            left: Math.max(left, r2.left),
            top: Math.max(top, r2.top)
          };
          overlap.width = Math.min(right, r2.right) - overlap.left;
          overlap.height = Math.min(bottom, r2.bottom) - overlap.top;
          if (overlap.width < 0 || overlap.height < 0) {
            return false;
          }
          if (isRatio) {
            threshold *= 0.01;
            area2 = overlap.width * overlap.height;
            return area2 >= width * height * threshold || area2 >= r2.width * r2.height * threshold;
          }
          return overlap.width > threshold && overlap.height > threshold;
        };
        return Draggable2;
      }(EventDispatcher2);
      _setDefaults3(Draggable.prototype, {
        pointerX: 0,
        pointerY: 0,
        startX: 0,
        startY: 0,
        deltaX: 0,
        deltaY: 0,
        isDragging: false,
        isPressed: false
      });
      Draggable.zIndex = 1e3;
      Draggable.version = "3.9.1";
      _getGSAP5() && gsap4.registerPlugin(Draggable);
    }
  });

  // node_modules/gsap/EaselPlugin.js
  var gsap5, _coreInitted5, _win6, _createJS, _ColorFilter, _ColorMatrixFilter, _colorProps, _windowExists9, _getGSAP7, _getCreateJS, _warn3, _cache, _parseColorFilter, _idMatrix, _lumR, _lumG, _lumB, _applyMatrix, _setSaturation, _colorize, _setHue, _setContrast, _parseColorMatrixFilter, _initCore9, EaselPlugin;
  var init_EaselPlugin = __esm({
    "node_modules/gsap/EaselPlugin.js"() {
      _colorProps = "redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset".split(",");
      _windowExists9 = function _windowExists10() {
        return typeof window !== "undefined";
      };
      _getGSAP7 = function _getGSAP8() {
        return gsap5 || _windowExists9() && (gsap5 = window.gsap) && gsap5.registerPlugin && gsap5;
      };
      _getCreateJS = function _getCreateJS2() {
        return _createJS || _win6 && _win6.createjs || _win6 || {};
      };
      _warn3 = function _warn4(message) {
        return console.warn(message);
      };
      _cache = function _cache2(target) {
        var b = target.getBounds && target.getBounds();
        if (!b) {
          b = target.nominalBounds || {
            x: 0,
            y: 0,
            width: 100,
            height: 100
          };
          target.setBounds && target.setBounds(b.x, b.y, b.width, b.height);
        }
        target.cache && target.cache(b.x, b.y, b.width, b.height);
        _warn3("EaselPlugin: for filters to display in EaselJS, you must call the object's cache() method first. GSAP attempted to use the target's getBounds() for the cache but that may not be completely accurate. " + target);
      };
      _parseColorFilter = function _parseColorFilter2(target, v, plugin) {
        if (!_ColorFilter) {
          _ColorFilter = _getCreateJS().ColorFilter;
          if (!_ColorFilter) {
            _warn3("EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded.");
          }
        }
        var filters = target.filters || [], i2 = filters.length, c, s, e, a, p2, pt;
        while (i2--) {
          if (filters[i2] instanceof _ColorFilter) {
            s = filters[i2];
            break;
          }
        }
        if (!s) {
          s = new _ColorFilter();
          filters.push(s);
          target.filters = filters;
        }
        e = s.clone();
        if (v.tint != null) {
          c = gsap5.utils.splitColor(v.tint);
          a = v.tintAmount != null ? +v.tintAmount : 1;
          e.redOffset = +c[0] * a;
          e.greenOffset = +c[1] * a;
          e.blueOffset = +c[2] * a;
          e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;
        } else {
          for (p2 in v) {
            if (p2 !== "exposure") {
              if (p2 !== "brightness") {
                e[p2] = +v[p2];
              }
            }
          }
        }
        if (v.exposure != null) {
          e.redOffset = e.greenOffset = e.blueOffset = 255 * (+v.exposure - 1);
          e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;
        } else if (v.brightness != null) {
          a = +v.brightness - 1;
          e.redOffset = e.greenOffset = e.blueOffset = a > 0 ? a * 255 : 0;
          e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);
        }
        i2 = 8;
        while (i2--) {
          p2 = _colorProps[i2];
          if (s[p2] !== e[p2]) {
            pt = plugin.add(s, p2, s[p2], e[p2]);
            if (pt) {
              pt.op = "easel_colorFilter";
            }
          }
        }
        plugin._props.push("easel_colorFilter");
        if (!target.cacheID) {
          _cache(target);
        }
      };
      _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
      _lumR = 0.212671;
      _lumG = 0.71516;
      _lumB = 0.072169;
      _applyMatrix = function _applyMatrix2(m, m2) {
        if (!(m instanceof Array) || !(m2 instanceof Array)) {
          return m2;
        }
        var temp = [], i2 = 0, z = 0, y, x;
        for (y = 0; y < 4; y++) {
          for (x = 0; x < 5; x++) {
            z = x === 4 ? m[i2 + 4] : 0;
            temp[i2 + x] = m[i2] * m2[x] + m[i2 + 1] * m2[x + 5] + m[i2 + 2] * m2[x + 10] + m[i2 + 3] * m2[x + 15] + z;
          }
          i2 += 5;
        }
        return temp;
      };
      _setSaturation = function _setSaturation2(m, n) {
        if (isNaN(n)) {
          return m;
        }
        var inv = 1 - n, r = inv * _lumR, g = inv * _lumG, b = inv * _lumB;
        return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
      };
      _colorize = function _colorize2(m, color, amount) {
        if (isNaN(amount)) {
          amount = 1;
        }
        var c = gsap5.utils.splitColor(color), r = c[0] / 255, g = c[1] / 255, b = c[2] / 255, inv = 1 - amount;
        return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
      };
      _setHue = function _setHue2(m, n) {
        if (isNaN(n)) {
          return m;
        }
        n *= Math.PI / 180;
        var c = Math.cos(n), s = Math.sin(n);
        return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
      };
      _setContrast = function _setContrast2(m, n) {
        if (isNaN(n)) {
          return m;
        }
        n += 0.01;
        return _applyMatrix([n, 0, 0, 0, 128 * (1 - n), 0, n, 0, 0, 128 * (1 - n), 0, 0, n, 0, 128 * (1 - n), 0, 0, 0, 1, 0], m);
      };
      _parseColorMatrixFilter = function _parseColorMatrixFilter2(target, v, plugin) {
        if (!_ColorMatrixFilter) {
          _ColorMatrixFilter = _getCreateJS().ColorMatrixFilter;
          if (!_ColorMatrixFilter) {
            _warn3("EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded.");
          }
        }
        var filters = target.filters || [], i2 = filters.length, matrix, startMatrix, s, pg;
        while (--i2 > -1) {
          if (filters[i2] instanceof _ColorMatrixFilter) {
            s = filters[i2];
            break;
          }
        }
        if (!s) {
          s = new _ColorMatrixFilter(_idMatrix.slice());
          filters.push(s);
          target.filters = filters;
        }
        startMatrix = s.matrix;
        matrix = _idMatrix.slice();
        if (v.colorize != null) {
          matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));
        }
        if (v.contrast != null) {
          matrix = _setContrast(matrix, Number(v.contrast));
        }
        if (v.hue != null) {
          matrix = _setHue(matrix, Number(v.hue));
        }
        if (v.saturation != null) {
          matrix = _setSaturation(matrix, Number(v.saturation));
        }
        i2 = matrix.length;
        while (--i2 > -1) {
          if (matrix[i2] !== startMatrix[i2]) {
            pg = plugin.add(startMatrix, i2, startMatrix[i2], matrix[i2]);
            if (pg) {
              pg.op = "easel_colorMatrixFilter";
            }
          }
        }
        plugin._props.push("easel_colorMatrixFilter");
        if (!target.cacheID) {
          _cache();
        }
        plugin._matrix = startMatrix;
      };
      _initCore9 = function _initCore10(core) {
        gsap5 = core || _getGSAP7();
        if (_windowExists9()) {
          _win6 = window;
        }
        if (gsap5) {
          _coreInitted5 = 1;
        }
      };
      EaselPlugin = {
        version: "3.9.1",
        name: "easel",
        init: function init5(target, value, tween, index, targets) {
          if (!_coreInitted5) {
            _initCore9();
            if (!gsap5) {
              _warn3("Please gsap.registerPlugin(EaselPlugin)");
            }
          }
          this.target = target;
          var p2, pt, tint, colorMatrix, end, labels, i2;
          for (p2 in value) {
            end = value[p2];
            if (p2 === "colorFilter" || p2 === "tint" || p2 === "tintAmount" || p2 === "exposure" || p2 === "brightness") {
              if (!tint) {
                _parseColorFilter(target, value.colorFilter || value, this);
                tint = true;
              }
            } else if (p2 === "saturation" || p2 === "contrast" || p2 === "hue" || p2 === "colorize" || p2 === "colorizeAmount") {
              if (!colorMatrix) {
                _parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);
                colorMatrix = true;
              }
            } else if (p2 === "frame") {
              if (typeof end === "string" && end.charAt(1) !== "=" && (labels = target.labels)) {
                for (i2 = 0; i2 < labels.length; i2++) {
                  if (labels[i2].label === end) {
                    end = labels[i2].position;
                  }
                }
              }
              pt = this.add(target, "gotoAndStop", target.currentFrame, end, index, targets, Math.round);
              if (pt) {
                pt.op = p2;
              }
            } else if (target[p2] != null) {
              this.add(target, p2, "get", end);
            }
          }
        },
        render: function render2(ratio, data) {
          var pt = data._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          if (data.target.cacheID) {
            data.target.updateCache();
          }
        },
        register: _initCore9
      };
      EaselPlugin.registerCreateJS = function(createjs) {
        _createJS = createjs;
      };
      _getGSAP7() && gsap5.registerPlugin(EaselPlugin);
    }
  });

  // node_modules/gsap/EasePack.js
  var gsap6, _coreInitted6, _registerEase, _getGSAP9, _boolean, _initCore11, _createSlowMo, _createExpoScale, EasePoint, _createRoughEase, SlowMo, ExpoScaleEase, RoughEase, EasePack, p2;
  var init_EasePack = __esm({
    "node_modules/gsap/EasePack.js"() {
      _getGSAP9 = function _getGSAP10() {
        return gsap6 || typeof window !== "undefined" && (gsap6 = window.gsap) && gsap6.registerPlugin && gsap6;
      };
      _boolean = function _boolean2(value, defaultValue) {
        return !!(typeof value === "undefined" ? defaultValue : value && !~(value + "").indexOf("false"));
      };
      _initCore11 = function _initCore12(core) {
        gsap6 = core || _getGSAP9();
        if (gsap6) {
          _registerEase = gsap6.registerEase;
          var eases = gsap6.parseEase(), createConfig = function createConfig2(ease) {
            return function(ratio) {
              var y = 0.5 + ratio / 2;
              ease.config = function(p3) {
                return ease(2 * (1 - p3) * p3 * y + p3 * p3);
              };
            };
          }, p2;
          for (p2 in eases) {
            if (!eases[p2].config) {
              createConfig(eases[p2]);
            }
          }
          _registerEase("slow", SlowMo);
          _registerEase("expoScale", ExpoScaleEase);
          _registerEase("rough", RoughEase);
          for (p2 in EasePack) {
            p2 !== "version" && gsap6.core.globals(p2, EasePack[p2]);
          }
          _coreInitted6 = 1;
        }
      };
      _createSlowMo = function _createSlowMo2(linearRatio, power, yoyoMode) {
        linearRatio = Math.min(1, linearRatio || 0.7);
        var pow = linearRatio < 1 ? power || power === 0 ? power : 0.7 : 0, p1 = (1 - linearRatio) / 2, p3 = p1 + linearRatio, calcEnd = _boolean(yoyoMode);
        return function(p2) {
          var r = p2 + (0.5 - p2) * pow;
          return p2 < p1 ? calcEnd ? 1 - (p2 = 1 - p2 / p1) * p2 : r - (p2 = 1 - p2 / p1) * p2 * p2 * p2 * r : p2 > p3 ? calcEnd ? p2 === 1 ? 0 : 1 - (p2 = (p2 - p3) / p1) * p2 : r + (p2 - r) * (p2 = (p2 - p3) / p1) * p2 * p2 * p2 : calcEnd ? 1 : r;
        };
      };
      _createExpoScale = function _createExpoScale2(start, end, ease) {
        var p1 = Math.log(end / start), p2 = end - start;
        ease && (ease = gsap6.parseEase(ease));
        return function(p3) {
          return (start * Math.exp(p1 * (ease ? ease(p3) : p3)) - start) / p2;
        };
      };
      EasePoint = function EasePoint2(time, value, next) {
        this.t = time;
        this.v = value;
        if (next) {
          this.next = next;
          next.prev = this;
          this.c = next.v - value;
          this.gap = next.t - time;
        }
      };
      _createRoughEase = function _createRoughEase2(vars) {
        if (typeof vars !== "object") {
          vars = {
            points: +vars || 20
          };
        }
        var taper = vars.taper || "none", a = [], cnt = 0, points = (+vars.points || 20) | 0, i2 = points, randomize = _boolean(vars.randomize, true), clamp4 = _boolean(vars.clamp), template = gsap6 ? gsap6.parseEase(vars.template) : 0, strength = (+vars.strength || 1) * 0.4, x, y, bump, invX, obj, pnt, recent;
        while (--i2 > -1) {
          x = randomize ? Math.random() : 1 / points * i2;
          y = template ? template(x) : x;
          if (taper === "none") {
            bump = strength;
          } else if (taper === "out") {
            invX = 1 - x;
            bump = invX * invX * strength;
          } else if (taper === "in") {
            bump = x * x * strength;
          } else if (x < 0.5) {
            invX = x * 2;
            bump = invX * invX * 0.5 * strength;
          } else {
            invX = (1 - x) * 2;
            bump = invX * invX * 0.5 * strength;
          }
          if (randomize) {
            y += Math.random() * bump - bump * 0.5;
          } else if (i2 % 2) {
            y += bump * 0.5;
          } else {
            y -= bump * 0.5;
          }
          if (clamp4) {
            if (y > 1) {
              y = 1;
            } else if (y < 0) {
              y = 0;
            }
          }
          a[cnt++] = {
            x,
            y
          };
        }
        a.sort(function(a2, b) {
          return a2.x - b.x;
        });
        pnt = new EasePoint(1, 1, null);
        i2 = points;
        while (i2--) {
          obj = a[i2];
          pnt = new EasePoint(obj.x, obj.y, pnt);
        }
        recent = new EasePoint(0, 0, pnt.t ? pnt : pnt.next);
        return function(p2) {
          var pnt2 = recent;
          if (p2 > pnt2.t) {
            while (pnt2.next && p2 >= pnt2.t) {
              pnt2 = pnt2.next;
            }
            pnt2 = pnt2.prev;
          } else {
            while (pnt2.prev && p2 <= pnt2.t) {
              pnt2 = pnt2.prev;
            }
          }
          recent = pnt2;
          return pnt2.v + (p2 - pnt2.t) / pnt2.gap * pnt2.c;
        };
      };
      SlowMo = _createSlowMo(0.7);
      SlowMo.ease = SlowMo;
      SlowMo.config = _createSlowMo;
      ExpoScaleEase = _createExpoScale(1, 2);
      ExpoScaleEase.config = _createExpoScale;
      RoughEase = _createRoughEase();
      RoughEase.ease = RoughEase;
      RoughEase.config = _createRoughEase;
      EasePack = {
        SlowMo,
        RoughEase,
        ExpoScaleEase
      };
      for (p2 in EasePack) {
        EasePack[p2].register = _initCore11;
        EasePack[p2].version = "3.9.1";
      }
      _getGSAP9() && gsap6.registerPlugin(SlowMo);
    }
  });

  // node_modules/gsap/Flip.js
  var _id2, _toArray2, gsap7, _batch, _batchAction, _body3, _closestTenth, _forEachBatch, _batchLookup, _RAD2DEG4, _DEG2RAD3, _emptyObj, _dashedNameLookup, _memoizedRemoveProps, _listToArray, _callbacks, _removeProps, _getEl, _round9, _toggleClass, _reserved, _fitReserved, _camelToDashed, _copy3, _memoizedProps, _memoizeProps, _getInverseGlobalMatrix, _getDOMDepth, _orderByDOMDepth, _recordInlineStyles, _applyInlineStyles, _setFinalStates, _absoluteProps, _makeAbsolute, _filterComps, _makeCompsAbsolute, _findElStateInState, _parseElementState, _recordProps, _applyProps, _getID, _elementsFromElementStates, _handleCallback, _fit, _parseState, _getChangingElState, _bodyMetrics, _bodyProps, _bodyLocked, _lockBodyScroll, _fromTo, _interrupt3, _killFlip, _createLookup, FlipState, ElementState, FlipAction, FlipBatch, Flip;
  var init_Flip = __esm({
    "node_modules/gsap/Flip.js"() {
      init_matrix();
      _id2 = 1;
      _forEachBatch = function _forEachBatch2(batch, name) {
        return batch.actions.forEach(function(a) {
          return a.vars[name] && a.vars[name](a);
        });
      };
      _batchLookup = {};
      _RAD2DEG4 = 180 / Math.PI;
      _DEG2RAD3 = Math.PI / 180;
      _emptyObj = {};
      _dashedNameLookup = {};
      _memoizedRemoveProps = {};
      _listToArray = function _listToArray2(list) {
        return typeof list === "string" ? list.split(" ").join("").split(",") : list;
      };
      _callbacks = _listToArray("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt");
      _removeProps = _listToArray("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight");
      _getEl = function _getEl2(target) {
        return _toArray2(target)[0] || console.warn("Element not found:", target);
      };
      _round9 = function _round10(value) {
        return Math.round(value * 1e4) / 1e4 || 0;
      };
      _toggleClass = function _toggleClass2(targets, className, action) {
        return targets.forEach(function(el) {
          return el.classList[action](className);
        });
      };
      _reserved = {
        zIndex: 1,
        kill: 1,
        simple: 1,
        spin: 1,
        clearProps: 1,
        targets: 1,
        toggleClass: 1,
        onComplete: 1,
        onUpdate: 1,
        onInterrupt: 1,
        onStart: 1,
        delay: 1,
        repeat: 1,
        repeatDelay: 1,
        yoyo: 1,
        scale: 1,
        fade: 1,
        absolute: 1,
        props: 1,
        onEnter: 1,
        onLeave: 1,
        custom: 1,
        paused: 1,
        nested: 1,
        prune: 1,
        absoluteOnLeave: 1
      };
      _fitReserved = {
        zIndex: 1,
        simple: 1,
        clearProps: 1,
        scale: 1,
        absolute: 1,
        fitChild: 1,
        getVars: 1,
        props: 1
      };
      _camelToDashed = function _camelToDashed2(p2) {
        return p2.replace(/([A-Z])/g, "-$1").toLowerCase();
      };
      _copy3 = function _copy4(obj, exclude) {
        var result = {}, p2;
        for (p2 in obj) {
          exclude[p2] || (result[p2] = obj[p2]);
        }
        return result;
      };
      _memoizedProps = {};
      _memoizeProps = function _memoizeProps2(props) {
        var p2 = _memoizedProps[props] = _listToArray(props);
        _memoizedRemoveProps[props] = p2.concat(_removeProps);
        return p2;
      };
      _getInverseGlobalMatrix = function _getInverseGlobalMatrix2(el) {
        var cache = el._gsap || gsap7.core.getCache(el);
        if (cache.gmCache === gsap7.ticker.frame) {
          return cache.gMatrix;
        }
        cache.gmCache = gsap7.ticker.frame;
        return cache.gMatrix = getGlobalMatrix(el, true, false, true);
      };
      _getDOMDepth = function _getDOMDepth2(el, invert, level) {
        if (level === void 0) {
          level = 0;
        }
        var parent = el.parentNode, inc = 1e3 * Math.pow(10, level) * (invert ? -1 : 1), l = invert ? -inc * 900 : 0;
        while (el) {
          l += inc;
          el = el.previousSibling;
        }
        return parent ? l + _getDOMDepth2(parent, invert, level + 1) : l;
      };
      _orderByDOMDepth = function _orderByDOMDepth2(comps, invert, isElStates) {
        comps.forEach(function(comp) {
          return comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert);
        });
        comps.sort(function(c1, c2) {
          return c1.d - c2.d;
        });
        return comps;
      };
      _recordInlineStyles = function _recordInlineStyles2(elState, props) {
        var style = elState.element.style, a = elState.css = elState.css || [], i2 = props.length, p2, v;
        while (i2--) {
          p2 = props[i2];
          v = style[p2] || style.getPropertyValue(p2);
          a.push(v ? p2 : _dashedNameLookup[p2] || (_dashedNameLookup[p2] = _camelToDashed(p2)), v);
        }
        return style;
      };
      _applyInlineStyles = function _applyInlineStyles2(state) {
        var css = state.css, style = state.element.style, i2 = 0;
        state.cache.uncache = 1;
        for (; i2 < css.length; i2 += 2) {
          css[i2 + 1] ? style[css[i2]] = css[i2 + 1] : style.removeProperty(css[i2]);
        }
      };
      _setFinalStates = function _setFinalStates2(comps, onlyTransforms) {
        comps.forEach(function(c) {
          return c.a.cache.uncache = 1;
        });
        onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);
      };
      _absoluteProps = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(",");
      _makeAbsolute = function _makeAbsolute2(elState, fallbackNode, ignoreBatch) {
        var element = elState.element, width = elState.width, height = elState.height, uncache = elState.uncache, getProp = elState.getProp, style = element.style, i2 = 4, result, displayIsNone, cs;
        typeof fallbackNode !== "object" && (fallbackNode = elState);
        if (_batch && ignoreBatch !== 1) {
          _batch._abs.push({
            t: element,
            b: elState,
            a: elState,
            sd: 0
          });
          _batch._final.push(function() {
            return (elState.cache.uncache = 1) && _applyInlineStyles(elState);
          });
          return element;
        }
        displayIsNone = getProp("display") === "none";
        if (!elState.isVisible || displayIsNone) {
          displayIsNone && (_recordInlineStyles(elState, ["display"]).display = fallbackNode.display);
          elState.matrix = fallbackNode.matrix;
          elState.width = width = elState.width || fallbackNode.width;
          elState.height = height = elState.height || fallbackNode.height;
        }
        _recordInlineStyles(elState, _absoluteProps);
        cs = window.getComputedStyle(element);
        while (i2--) {
          style[_absoluteProps[i2]] = cs[_absoluteProps[i2]];
        }
        style.gridArea = "1 / 1 / 1 / 1";
        style.transition = "none";
        style.position = "absolute";
        style.width = width + "px";
        style.height = height + "px";
        style.top || (style.top = "0px");
        style.left || (style.left = "0px");
        if (uncache) {
          result = new ElementState(element);
        } else {
          result = _copy3(elState, _emptyObj);
          result.position = "absolute";
          if (elState.simple) {
            var bounds = element.getBoundingClientRect();
            result.matrix = new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop());
          } else {
            result.matrix = getGlobalMatrix(element, false, false, true);
          }
        }
        result = _fit(result, elState, true);
        elState.x = _closestTenth(result.x, 0.01);
        elState.y = _closestTenth(result.y, 0.01);
        return element;
      };
      _filterComps = function _filterComps2(comps, targets) {
        if (targets !== true) {
          targets = _toArray2(targets);
          comps = comps.filter(function(c) {
            if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {
              return true;
            } else {
              c.t._gsap.renderTransform(1);
              c.t.style.width = c.b.width + "px";
              c.t.style.height = c.b.height + "px";
            }
          });
        }
        return comps;
      };
      _makeCompsAbsolute = function _makeCompsAbsolute2(comps) {
        return _orderByDOMDepth(comps, true).forEach(function(c) {
          return (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1);
        });
      };
      _findElStateInState = function _findElStateInState2(state, other) {
        return other && state.idLookup[_parseElementState(other).id] || state.elementStates[0];
      };
      _parseElementState = function _parseElementState2(elOrNode, props, simple, other) {
        return elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === "string" ? _getEl(elOrNode) || console.warn(elOrNode + " not found") : elOrNode, props, simple);
      };
      _recordProps = function _recordProps2(elState, props) {
        var getProp = gsap7.getProperty(elState.element, null, "native"), obj = elState.props = {}, i2 = props.length;
        while (i2--) {
          obj[props[i2]] = (getProp(props[i2]) + "").trim();
        }
        obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);
        return elState;
      };
      _applyProps = function _applyProps2(element, props) {
        var style = element.style || element, p2;
        for (p2 in props) {
          style[p2] = props[p2];
        }
      };
      _getID = function _getID2(el) {
        var id = el.getAttribute("data-flip-id");
        id || el.setAttribute("data-flip-id", id = "auto-" + _id2++);
        return id;
      };
      _elementsFromElementStates = function _elementsFromElementStates2(elStates) {
        return elStates.map(function(elState) {
          return elState.element;
        });
      };
      _handleCallback = function _handleCallback2(callback, elStates, tl) {
        return callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0);
      };
      _fit = function _fit2(fromState, toState, scale, applyProps, fitChild, vars) {
        var element = fromState.element, cache = fromState.cache, parent = fromState.parent, x = fromState.x, y = fromState.y, width = toState.width, height = toState.height, scaleX = toState.scaleX, scaleY = toState.scaleY, rotation = toState.rotation, bounds = toState.bounds, cssText = vars && element.style.cssText, transform = vars && element.getBBox && element.getAttribute("transform"), dimensionState = fromState, _toState$matrix = toState.matrix, e = _toState$matrix.e, f = _toState$matrix.f, deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation, simple = !deep && fromState.simple && toState.simple && !fitChild, skewX, fromPoint, toPoint, getProp, parentMatrix, matrix, bbox;
        if (simple) {
          scaleX = scaleY = 1;
          rotation = skewX = 0;
        } else {
          parentMatrix = _getInverseGlobalMatrix(parent);
          matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix);
          rotation = _round9(Math.atan2(matrix.b, matrix.a) * _RAD2DEG4);
          skewX = _round9(Math.atan2(matrix.c, matrix.d) * _RAD2DEG4 + rotation) % 360;
          scaleX = Math.sqrt(Math.pow(matrix.a, 2) + Math.pow(matrix.b, 2));
          scaleY = Math.sqrt(Math.pow(matrix.c, 2) + Math.pow(matrix.d, 2)) * Math.cos(skewX * _DEG2RAD3);
          if (fitChild) {
            fitChild = _toArray2(fitChild)[0];
            getProp = gsap7.getProperty(fitChild);
            bbox = fitChild.getBBox && typeof fitChild.getBBox === "function" && fitChild.getBBox();
            dimensionState = {
              scaleX: getProp("scaleX"),
              scaleY: getProp("scaleY"),
              width: bbox ? bbox.width : Math.ceil(parseFloat(getProp("width", "px"))),
              height: bbox ? bbox.height : parseFloat(getProp("height", "px"))
            };
          }
          cache.rotation = rotation + "deg";
          cache.skewX = skewX + "deg";
        }
        if (scale) {
          scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width;
          scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;
          cache.scaleX = scaleX;
          cache.scaleY = scaleY;
        } else {
          width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);
          height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);
          element.style.width = width + "px";
          element.style.height = height + "px";
        }
        applyProps && _applyProps(element, toState.props);
        if (simple) {
          x += e - fromState.matrix.e;
          y += f - fromState.matrix.f;
        } else if (deep || parent !== toState.parent) {
          cache.renderTransform(1, cache);
          matrix = getGlobalMatrix(fitChild || element, false, false, true);
          fromPoint = parentMatrix.apply({
            x: matrix.e,
            y: matrix.f
          });
          toPoint = parentMatrix.apply({
            x: e,
            y: f
          });
          x += toPoint.x - fromPoint.x;
          y += toPoint.y - fromPoint.y;
        } else {
          parentMatrix.e = parentMatrix.f = 0;
          toPoint = parentMatrix.apply({
            x: e - fromState.matrix.e,
            y: f - fromState.matrix.f
          });
          x += toPoint.x;
          y += toPoint.y;
        }
        x = _closestTenth(x, 0.02);
        y = _closestTenth(y, 0.02);
        if (vars && !(vars instanceof ElementState)) {
          element.style.cssText = cssText;
          element.getBBox && element.setAttribute("transform", transform || "");
          cache.uncache = 1;
        } else {
          cache.x = x + "px";
          cache.y = y + "px";
          cache.renderTransform(1, cache);
        }
        if (vars) {
          vars.x = x;
          vars.y = y;
          vars.rotation = rotation;
          vars.skewX = skewX;
          if (scale) {
            vars.scaleX = scaleX;
            vars.scaleY = scaleY;
          } else {
            vars.width = width;
            vars.height = height;
          }
        }
        return vars || cache;
      };
      _parseState = function _parseState2(targetsOrState, vars) {
        return targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars);
      };
      _getChangingElState = function _getChangingElState2(toState, fromState, id) {
        var to1 = toState.idLookup[id], to2 = toState.alt[id];
        return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;
      };
      _bodyMetrics = [];
      _bodyProps = "width,height,overflowX,overflowY".split(",");
      _lockBodyScroll = function _lockBodyScroll2(lock) {
        if (lock !== _bodyLocked) {
          var s = _body3.style, w = _body3.clientWidth === window.outerWidth, h = _body3.clientHeight === window.outerHeight, i2 = 4;
          if (lock && (w || h)) {
            while (i2--) {
              _bodyMetrics[i2] = s[_bodyProps[i2]];
            }
            if (w) {
              s.width = _body3.clientWidth + "px";
              s.overflowY = "hidden";
            }
            if (h) {
              s.height = _body3.clientHeight + "px";
              s.overflowX = "hidden";
            }
            _bodyLocked = lock;
          } else if (_bodyLocked) {
            while (i2--) {
              _bodyMetrics[i2] ? s[_bodyProps[i2]] = _bodyMetrics[i2] : s.removeProperty(_camelToDashed(_bodyProps[i2]));
            }
            _bodyLocked = lock;
          }
        }
      };
      _fromTo = function _fromTo2(fromState, toState, vars, relative) {
        fromState instanceof FlipState && toState instanceof FlipState || console.warn("Not a valid state object.");
        vars = vars || {};
        var _vars = vars, clearProps2 = _vars.clearProps, onEnter = _vars.onEnter, onLeave = _vars.onLeave, absolute = _vars.absolute, absoluteOnLeave = _vars.absoluteOnLeave, custom = _vars.custom, delay = _vars.delay, paused = _vars.paused, repeat = _vars.repeat, repeatDelay = _vars.repeatDelay, yoyo = _vars.yoyo, toggleClass = _vars.toggleClass, nested = _vars.nested, _zIndex = _vars.zIndex, scale = _vars.scale, fade = _vars.fade, stagger = _vars.stagger, spin = _vars.spin, prune = _vars.prune, props = ("props" in vars ? vars : fromState).props, tweenVars = _copy3(vars, _reserved), animation = gsap7.timeline({
          delay,
          paused,
          repeat,
          repeatDelay,
          yoyo
        }), remainingProps = tweenVars, entering = [], leaving = [], comps = [], swapOutTargets = [], spinNum = spin === true ? 1 : spin || 0, spinFunc = typeof spin === "function" ? spin : function() {
          return spinNum;
        }, interrupted = fromState.interrupted || toState.interrupted, addFunc = animation[relative !== 1 ? "to" : "from"], v, p2, endTime, i2, el, comp, state, targets, finalStates, fromNode, toNode, run, a, b;
        for (p2 in toState.idLookup) {
          toNode = !toState.alt[p2] ? toState.idLookup[p2] : _getChangingElState(toState, fromState, p2);
          el = toNode.element;
          fromNode = fromState.idLookup[p2];
          fromState.alt[p2] && el === fromNode.element && (fromState.alt[p2].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p2]);
          if (fromNode) {
            comp = {
              t: el,
              b: fromNode,
              a: toNode,
              sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1
            };
            comps.push(comp);
            if (comp.sd) {
              if (comp.sd < 0) {
                comp.b = toNode;
                comp.a = fromNode;
              }
              interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);
              fade && comps.push(comp.swap = {
                t: fromNode.element,
                b: comp.b,
                a: comp.a,
                sd: -comp.sd,
                swap: comp
              });
            }
            el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;
          } else if (toNode.isVisible) {
            comps.push({
              t: el,
              b: _copy3(toNode, {
                isVisible: 1
              }),
              a: toNode,
              sd: 0
            });
            el._flip = _batch ? _batch.timeline : animation;
          }
        }
        props && (_memoizedProps[props] || _memoizeProps(props)).forEach(function(p3) {
          return tweenVars[p3] = function(i3) {
            return comps[i3].a.props[p3];
          };
        });
        comps.finalStates = finalStates = [];
        run = function run2() {
          _orderByDOMDepth(comps);
          _lockBodyScroll(true);
          for (i2 = 0; i2 < comps.length; i2++) {
            comp = comps[i2];
            a = comp.a;
            b = comp.b;
            if (prune && !a.isDifferent(b)) {
              comps.splice(i2--, 1);
            } else {
              el = comp.t;
              nested && !(comp.sd < 0) && i2 && (a.matrix = getGlobalMatrix(el, false, false, true));
              if (comp.sd || b.isVisible && a.isVisible) {
                if (comp.sd < 0) {
                  state = new ElementState(el, props, fromState.simple);
                  _fit(state, a, scale, 0, 0, state);
                  state.matrix = getGlobalMatrix(el, false, false, true);
                  state.css = comp.b.css;
                  comp.a = a = state;
                  fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);
                  stagger && swapOutTargets.push(el);
                } else if (comp.sd > 0 && fade) {
                  el.style.opacity = interrupted ? a.opacity - b.opacity : "0";
                }
                _fit(a, b, scale, props);
              } else if (b.isVisible !== a.isVisible) {
                if (!b.isVisible) {
                  a.isVisible && entering.push(a);
                  comps.splice(i2--, 1);
                } else if (!a.isVisible) {
                  b.css = a.css;
                  leaving.push(b);
                  comps.splice(i2--, 1);
                  absolute && nested && _fit(a, b, scale, props);
                }
              }
              if (!scale) {
                el.style.maxWidth = Math.max(a.width, b.width) + "px";
                el.style.maxHeight = Math.max(a.height, b.height) + "px";
                el.style.minWidth = Math.min(a.width, b.width) + "px";
                el.style.minHeight = Math.min(a.height, b.height) + "px";
              }
              nested && toggleClass && el.classList.add(toggleClass);
            }
            finalStates.push(a);
          }
          var classTargets;
          if (toggleClass) {
            classTargets = finalStates.map(function(s) {
              return s.element;
            });
            nested && classTargets.forEach(function(e) {
              return e.classList.remove(toggleClass);
            });
          }
          _lockBodyScroll(false);
          if (scale) {
            tweenVars.scaleX = function(i3) {
              return comps[i3].a.scaleX;
            };
            tweenVars.scaleY = function(i3) {
              return comps[i3].a.scaleY;
            };
          } else {
            tweenVars.width = function(i3) {
              return comps[i3].a.width + "px";
            };
            tweenVars.height = function(i3) {
              return comps[i3].a.height + "px";
            };
            tweenVars.autoRound = vars.autoRound || false;
          }
          tweenVars.x = function(i3) {
            return comps[i3].a.x + "px";
          };
          tweenVars.y = function(i3) {
            return comps[i3].a.y + "px";
          };
          tweenVars.rotation = function(i3) {
            return comps[i3].a.rotation + (spin ? spinFunc(i3, targets[i3], targets) * 360 : 0);
          };
          tweenVars.skewX = function(i3) {
            return comps[i3].a.skewX;
          };
          targets = comps.map(function(c) {
            return c.t;
          });
          if (_zIndex || _zIndex === 0) {
            tweenVars.modifiers = {
              zIndex: function zIndex() {
                return _zIndex;
              }
            };
            tweenVars.zIndex = _zIndex;
            tweenVars.immediateRender = vars.immediateRender !== false;
          }
          fade && (tweenVars.opacity = function(i3) {
            return comps[i3].sd < 0 ? 0 : comps[i3].sd > 0 ? comps[i3].a.opacity : "+=0";
          });
          if (swapOutTargets.length) {
            stagger = gsap7.utils.distribute(stagger);
            var dummyArray = targets.slice(swapOutTargets.length);
            tweenVars.stagger = function(i3, el2) {
              return stagger(~swapOutTargets.indexOf(el2) ? targets.indexOf(comps[i3].swap.t) : i3, el2, dummyArray);
            };
          }
          _callbacks.forEach(function(name) {
            return vars[name] && animation.eventCallback(name, vars[name], vars[name + "Params"]);
          });
          if (custom && targets.length) {
            remainingProps = _copy3(tweenVars, _reserved);
            if ("scale" in custom) {
              custom.scaleX = custom.scaleY = custom.scale;
              delete custom.scale;
            }
            for (p2 in custom) {
              v = _copy3(custom[p2], _fitReserved);
              v[p2] = tweenVars[p2];
              !("duration" in v) && "duration" in tweenVars && (v.duration = tweenVars.duration);
              v.stagger = tweenVars.stagger;
              addFunc.call(animation, targets, v, 0);
              delete remainingProps[p2];
            }
          }
          if (targets.length || leaving.length || entering.length) {
            toggleClass && animation.add(function() {
              return _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? "remove" : "add");
            }, 0) && !paused && _toggleClass(classTargets, toggleClass, "add");
            targets.length && addFunc.call(animation, targets, remainingProps, 0);
          }
          _handleCallback(onEnter, entering, animation);
          _handleCallback(onLeave, leaving, animation);
          var batchTl = _batch && _batch.timeline;
          if (batchTl) {
            batchTl.add(animation, 0);
            _batch._final.push(function() {
              return _setFinalStates(comps, !clearProps2);
            });
          }
          endTime = animation.duration();
          animation.call(function() {
            var forward = animation.time() >= endTime;
            forward && !batchTl && _setFinalStates(comps, !clearProps2);
            toggleClass && _toggleClass(classTargets, toggleClass, forward ? "remove" : "add");
          });
        };
        absoluteOnLeave && (absolute = comps.filter(function(comp2) {
          return !comp2.sd && !comp2.a.isVisible && comp2.b.isVisible;
        }).map(function(comp2) {
          return comp2.a.element;
        }));
        if (_batch) {
          var _batch$_abs;
          absolute && (_batch$_abs = _batch._abs).push.apply(_batch$_abs, _filterComps(comps, absolute));
          _batch._run.push(run);
        } else {
          absolute && _makeCompsAbsolute(_filterComps(comps, absolute));
          run();
        }
        return _batch ? _batch.timeline : animation;
      };
      _interrupt3 = function _interrupt4(tl) {
        tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);
        tl.getChildren(true, false, true).forEach(_interrupt4);
      };
      _killFlip = function _killFlip2(tl, action) {
        if (tl && tl.progress() < 1 && !tl.paused()) {
          if (action) {
            _interrupt3(tl);
            action < 2 && tl.progress(1);
            tl.kill();
          }
          return true;
        }
      };
      _createLookup = function _createLookup2(state) {
        var lookup = state.idLookup = {}, alt = state.alt = {}, elStates = state.elementStates, i2 = elStates.length, elState;
        while (i2--) {
          elState = elStates[i2];
          lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;
        }
      };
      FlipState = /* @__PURE__ */ function() {
        function FlipState2(targets, vars, targetsAreElementStates) {
          this.props = vars && vars.props;
          this.simple = !!(vars && vars.simple);
          if (targetsAreElementStates) {
            this.targets = _elementsFromElementStates(targets);
            this.elementStates = targets;
            _createLookup(this);
          } else {
            this.targets = _toArray2(targets);
            var soft = vars && (vars.kill === false || vars.batch && !vars.kill);
            _batch && !soft && _batch._kill.push(this);
            this.update(soft || !!_batch);
          }
        }
        var _proto = FlipState2.prototype;
        _proto.update = function update(soft) {
          var _this = this;
          this.elementStates = this.targets.map(function(el) {
            return new ElementState(el, _this.props, _this.simple);
          });
          _createLookup(this);
          this.interrupt(soft);
          this.recordInlineStyles();
          return this;
        };
        _proto.clear = function clear() {
          this.targets.length = this.elementStates.length = 0;
          _createLookup(this);
          return this;
        };
        _proto.fit = function fit(state, scale, nested) {
          var elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true), toElStates = (state || this).idLookup, i2 = 0, fromNode, toNode;
          for (; i2 < elStatesInOrder.length; i2++) {
            fromNode = elStatesInOrder[i2];
            nested && (fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true));
            toNode = toElStates[fromNode.id];
            toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);
            fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true);
          }
          return this;
        };
        _proto.getProperty = function getProperty2(element, property) {
          var es = this.getElementState(element) || _emptyObj;
          return (property in es ? es : es.props || _emptyObj)[property];
        };
        _proto.add = function add(state) {
          var i2 = state.targets.length, lookup = this.idLookup, alt = this.alt, index, es, es2;
          while (i2--) {
            es = state.elementStates[i2];
            es2 = lookup[es.id];
            if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {
              index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);
              this.targets.splice(index, 1, state.targets[i2]);
              this.elementStates.splice(index, 1, es);
            } else {
              this.targets.push(state.targets[i2]);
              this.elementStates.push(es);
            }
          }
          state.interrupted && (this.interrupted = true);
          state.simple || (this.simple = false);
          _createLookup(this);
          return this;
        };
        _proto.compare = function compare(state) {
          var l1 = state.idLookup, l2 = this.idLookup, unchanged = [], changed = [], enter = [], leave = [], targets = [], a1 = state.alt, a2 = this.alt, place = function place2(s12, s22, el2) {
            return (s12.isVisible !== s22.isVisible ? s12.isVisible ? enter : leave : s12.isVisible ? changed : unchanged).push(el2) && targets.push(el2);
          }, placeIfDoesNotExist = function placeIfDoesNotExist2(s12, s22, el2) {
            return targets.indexOf(el2) < 0 && place(s12, s22, el2);
          }, s1, s2, p2, el, s1Alt, s2Alt, c1, c2;
          for (p2 in l1) {
            s1Alt = a1[p2];
            s2Alt = a2[p2];
            s1 = !s1Alt ? l1[p2] : _getChangingElState(state, this, p2);
            el = s1.element;
            s2 = l2[p2];
            if (s2Alt) {
              c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;
              c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1;
              if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {
                (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);
                targets.push(c1.element, c2.element);
              } else {
                place(c1, c2, c1.element);
              }
              s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p2]);
              placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);
              placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);
              s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);
            } else {
              !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);
              s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);
            }
          }
          for (p2 in l2) {
            if (!l1[p2]) {
              leave.push(l2[p2].element);
              a2[p2] && leave.push(a2[p2].element);
            }
          }
          return {
            changed,
            unchanged,
            enter,
            leave
          };
        };
        _proto.recordInlineStyles = function recordInlineStyles() {
          var props = _memoizedRemoveProps[this.props] || _removeProps, i2 = this.elementStates.length;
          while (i2--) {
            _recordInlineStyles(this.elementStates[i2], props);
          }
        };
        _proto.interrupt = function interrupt(soft) {
          var _this2 = this;
          var timelines = [];
          this.targets.forEach(function(t) {
            var tl = t._flip, foundInProgress = _killFlip(tl, soft ? 0 : 1);
            soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(function() {
              return _this2.updateVisibility();
            });
            foundInProgress && timelines.push(tl);
          });
          !soft && timelines.length && this.updateVisibility();
          this.interrupted || (this.interrupted = !!timelines.length);
        };
        _proto.updateVisibility = function updateVisibility() {
          this.elementStates.forEach(function(es) {
            var b = es.element.getBoundingClientRect();
            es.isVisible = !!(b.width || b.height || b.top || b.left);
            es.uncache = 1;
          });
        };
        _proto.getElementState = function getElementState(element) {
          return this.elementStates[this.targets.indexOf(_getEl(element))];
        };
        _proto.makeAbsolute = function makeAbsolute() {
          return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);
        };
        return FlipState2;
      }();
      ElementState = /* @__PURE__ */ function() {
        function ElementState2(element, props, simple) {
          this.element = element;
          this.update(props, simple);
        }
        var _proto2 = ElementState2.prototype;
        _proto2.isDifferent = function isDifferent(state) {
          var b1 = this.bounds, b2 = state.bounds;
          return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);
        };
        _proto2.update = function update(props, simple) {
          var self2 = this, element = self2.element, getProp = gsap7.getProperty(element), cache = gsap7.core.getCache(element), bounds = element.getBoundingClientRect(), bbox = element.getBBox && typeof element.getBBox === "function" && element.nodeName.toLowerCase() !== "svg" && element.getBBox(), m = simple ? new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop()) : getGlobalMatrix(element, false, false, true);
          self2.getProp = getProp;
          self2.element = element;
          self2.id = _getID(element);
          self2.matrix = m;
          self2.cache = cache;
          self2.bounds = bounds;
          self2.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);
          self2.display = getProp("display");
          self2.position = getProp("position");
          self2.parent = element.parentNode;
          self2.x = getProp("x");
          self2.y = getProp("y");
          self2.scaleX = cache.scaleX;
          self2.scaleY = cache.scaleY;
          self2.rotation = getProp("rotation");
          self2.skewX = getProp("skewX");
          self2.opacity = getProp("opacity");
          self2.width = bbox ? bbox.width : _closestTenth(getProp("width", "px"), 0.04);
          self2.height = bbox ? bbox.height : _closestTenth(getProp("height", "px"), 0.04);
          props && _recordProps(self2, _memoizedProps[props] || _memoizeProps(props));
          self2.ctm = element.getCTM && element.nodeName.toLowerCase() === "svg" && _getCTM(element).inverse();
          self2.simple = simple || _round9(m.a) === 1 && !_round9(m.b) && !_round9(m.c) && _round9(m.d) === 1;
          self2.uncache = 0;
        };
        return ElementState2;
      }();
      FlipAction = /* @__PURE__ */ function() {
        function FlipAction2(vars, batch) {
          this.vars = vars;
          this.batch = batch;
          this.states = [];
          this.timeline = batch.timeline;
        }
        var _proto3 = FlipAction2.prototype;
        _proto3.getStateById = function getStateById(id) {
          var i2 = this.states.length;
          while (i2--) {
            if (this.states[i2].idLookup[id]) {
              return this.states[i2];
            }
          }
        };
        _proto3.kill = function kill2() {
          this.batch.remove(this);
        };
        return FlipAction2;
      }();
      FlipBatch = /* @__PURE__ */ function() {
        function FlipBatch2(id) {
          this.id = id;
          this.actions = [];
          this._kill = [];
          this._final = [];
          this._abs = [];
          this._run = [];
          this.data = {};
          this.state = new FlipState();
          this.timeline = gsap7.timeline();
        }
        var _proto4 = FlipBatch2.prototype;
        _proto4.add = function add(config3) {
          var result = this.actions.filter(function(action) {
            return action.vars === config3;
          });
          if (result.length) {
            return result[0];
          }
          result = new FlipAction(typeof config3 === "function" ? {
            animate: config3
          } : config3, this);
          this.actions.push(result);
          return result;
        };
        _proto4.remove = function remove(action) {
          var i2 = this.actions.indexOf(action);
          i2 >= 0 && this.actions.splice(i2, 1);
          return this;
        };
        _proto4.getState = function getState(merge) {
          var _this3 = this;
          var prevBatch = _batch, prevAction = _batchAction;
          _batch = this;
          this.state.clear();
          this._kill.length = 0;
          this.actions.forEach(function(action) {
            if (action.vars.getState) {
              action.states.length = 0;
              _batchAction = action;
              action.state = action.vars.getState(action);
            }
            merge && action.states.forEach(function(s) {
              return _this3.state.add(s);
            });
          });
          _batchAction = prevAction;
          _batch = prevBatch;
          this.killConflicts();
          return this;
        };
        _proto4.animate = function animate() {
          var _this4 = this;
          var prevBatch = _batch, tl = this.timeline, i2 = this.actions.length, finalStates, endTime;
          _batch = this;
          tl.clear();
          this._abs.length = this._final.length = this._run.length = 0;
          this.actions.forEach(function(a) {
            a.vars.animate && a.vars.animate(a);
            var onEnter = a.vars.onEnter, onLeave = a.vars.onLeave, targets = a.targets, s, result;
            if (targets && targets.length && (onEnter || onLeave)) {
              s = new FlipState();
              a.states.forEach(function(state) {
                return s.add(state);
              });
              result = s.compare(Flip.getState(targets));
              result.enter.length && onEnter && onEnter(result.enter);
              result.leave.length && onLeave && onLeave(result.leave);
            }
          });
          _makeCompsAbsolute(this._abs);
          this._run.forEach(function(f) {
            return f();
          });
          endTime = tl.duration();
          finalStates = this._final.slice(0);
          tl.add(function() {
            if (endTime <= tl.time()) {
              finalStates.forEach(function(f) {
                return f();
              });
              _forEachBatch(_this4, "onComplete");
            }
          });
          _batch = prevBatch;
          while (i2--) {
            this.actions[i2].vars.once && this.actions[i2].kill();
          }
          _forEachBatch(this, "onStart");
          tl.restart();
          return this;
        };
        _proto4.loadState = function loadState(done) {
          done || (done = function done2() {
            return 0;
          });
          var queue = [];
          this.actions.forEach(function(c) {
            if (c.vars.loadState) {
              var i2, f = function f2(targets) {
                targets && (c.targets = targets);
                i2 = queue.indexOf(f2);
                if (~i2) {
                  queue.splice(i2, 1);
                  queue.length || done();
                }
              };
              queue.push(f);
              c.vars.loadState(f);
            }
          });
          queue.length || done();
          return this;
        };
        _proto4.setState = function setState() {
          this.actions.forEach(function(c) {
            return c.targets = c.vars.setState && c.vars.setState(c);
          });
          return this;
        };
        _proto4.killConflicts = function killConflicts(soft) {
          this.state.interrupt(soft);
          this._kill.forEach(function(state) {
            return state.interrupt(soft);
          });
          return this;
        };
        _proto4.run = function run(skipGetState, merge) {
          var _this5 = this;
          if (this !== _batch) {
            skipGetState || this.getState(merge);
            this.loadState(function() {
              if (!_this5._killed) {
                _this5.setState();
                _this5.animate();
              }
            });
          }
          return this;
        };
        _proto4.clear = function clear(stateOnly) {
          this.state.clear();
          stateOnly || (this.actions.length = 0);
        };
        _proto4.getStateById = function getStateById(id) {
          var i2 = this.actions.length, s;
          while (i2--) {
            s = this.actions[i2].getStateById(id);
            if (s) {
              return s;
            }
          }
          return this.state.idLookup[id] && this.state;
        };
        _proto4.kill = function kill2() {
          this._killed = 1;
          this.clear();
          delete _batchLookup[this.id];
        };
        return FlipBatch2;
      }();
      Flip = /* @__PURE__ */ function() {
        function Flip2() {
        }
        Flip2.getState = function getState(targets, vars) {
          var state = _parseState(targets, vars);
          _batchAction && _batchAction.states.push(state);
          vars && vars.batch && Flip2.batch(vars.batch).state.add(state);
          return state;
        };
        Flip2.from = function from(state, vars) {
          vars = vars || {};
          "clearProps" in vars || (vars.clearProps = true);
          return _fromTo(state, _parseState(vars.targets || state.targets, {
            props: vars.props || state.props,
            simple: vars.simple,
            kill: !!vars.kill
          }), vars, -1);
        };
        Flip2.to = function to(state, vars) {
          return _fromTo(state, _parseState(vars.targets || state.targets, {
            props: vars.props || state.props,
            simple: vars.simple,
            kill: !!vars.kill
          }), vars, 1);
        };
        Flip2.fromTo = function fromTo(fromState, toState, vars) {
          return _fromTo(fromState, toState, vars);
        };
        Flip2.fit = function fit(fromEl, toEl, vars) {
          var v = vars ? _copy3(vars, _fitReserved) : {}, _ref = vars || v, absolute = _ref.absolute, scale = _ref.scale, getVars = _ref.getVars, props = _ref.props, runBackwards = _ref.runBackwards, onComplete = _ref.onComplete, simple = _ref.simple, fitChild = vars && vars.fitChild && _getEl(vars.fitChild), before = _parseElementState(toEl, props, simple, fromEl), after = _parseElementState(fromEl, 0, simple, before), inlineProps = props ? _memoizedRemoveProps[props] : _removeProps;
          props && _applyProps(v, before.props);
          if (runBackwards) {
            _recordInlineStyles(after, inlineProps);
            "immediateRender" in v || (v.immediateRender = true);
            v.onComplete = function() {
              _applyInlineStyles(after);
              onComplete && onComplete.apply(this, arguments);
            };
          }
          absolute && _makeAbsolute(after, before);
          v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);
          return getVars ? v : v.duration ? gsap7.to(after.element, v) : null;
        };
        Flip2.makeAbsolute = function makeAbsolute(targetsOrStates, vars) {
          return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();
        };
        Flip2.batch = function batch(id) {
          id || (id = "default");
          return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));
        };
        Flip2.killFlipsOf = function killFlipsOf(targets, complete) {
          (targets instanceof FlipState ? targets.targets : _toArray2(targets)).forEach(function(t) {
            return t && _killFlip(t._flip, complete !== false ? 1 : 2);
          });
        };
        Flip2.isFlipping = function isFlipping(target) {
          var f = Flip2.getByTarget(target);
          return !!f && f.isActive();
        };
        Flip2.getByTarget = function getByTarget(target) {
          return (_getEl(target) || _emptyObj)._flip;
        };
        Flip2.getElementState = function getElementState(target, props) {
          return new ElementState(_getEl(target), props);
        };
        Flip2.convertCoordinates = function convertCoordinates2(fromElement, toElement, point) {
          var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));
          return point ? m.apply(point) : m;
        };
        Flip2.register = function register4(core) {
          _body3 = typeof document !== "undefined" && document.body;
          if (_body3) {
            gsap7 = core;
            _setDoc(_body3);
            _toArray2 = gsap7.utils.toArray;
            var snap3 = gsap7.utils.snap(0.1);
            _closestTenth = function _closestTenth2(value, add) {
              return snap3(parseFloat(value) + add);
            };
          }
        };
        return Flip2;
      }();
      Flip.version = "3.9.1";
      typeof window !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);
    }
  });

  // node_modules/gsap/MotionPathPlugin.js
  var _xProps, _yProps, _DEG2RAD4, gsap8, PropTween2, _getUnit, _toArray3, _getGSAP11, _populateSegmentFromArray, _getPropNum, _relativize, _segmentToRawPath, _emptyFunc5, _numExp3, _originToPoint, _getAlignMatrix, _align, _addDimensionalPropTween, _sliceModifier, MotionPathPlugin;
  var init_MotionPathPlugin = __esm({
    "node_modules/gsap/MotionPathPlugin.js"() {
      init_paths();
      init_matrix();
      _xProps = "x,translateX,left,marginLeft,xPercent".split(",");
      _yProps = "y,translateY,top,marginTop,yPercent".split(",");
      _DEG2RAD4 = Math.PI / 180;
      _getGSAP11 = function _getGSAP12() {
        return gsap8 || typeof window !== "undefined" && (gsap8 = window.gsap) && gsap8.registerPlugin && gsap8;
      };
      _populateSegmentFromArray = function _populateSegmentFromArray2(segment, values, property, mode) {
        var l = values.length, si = mode === 2 ? 0 : mode, i2 = 0, v;
        for (; i2 < l; i2++) {
          segment[si] = v = parseFloat(values[i2][property]);
          mode === 2 && (segment[si + 1] = 0);
          si += 2;
        }
        return segment;
      };
      _getPropNum = function _getPropNum2(target, prop, unit) {
        return parseFloat(target._gsap.get(target, prop, unit || "px")) || 0;
      };
      _relativize = function _relativize2(segment) {
        var x = segment[0], y = segment[1], i2;
        for (i2 = 2; i2 < segment.length; i2 += 2) {
          x = segment[i2] += x;
          y = segment[i2 + 1] += y;
        }
      };
      _segmentToRawPath = function _segmentToRawPath2(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {
        if (vars.type === "cubic") {
          segment = [segment];
        } else {
          vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);
          vars.relative && _relativize(segment);
          var pointFunc = y ? pointsToSegment : flatPointsToSegment;
          segment = [pointFunc(segment, vars.curviness)];
        }
        segment = slicer(_align(segment, target, vars));
        _addDimensionalPropTween(plugin, target, x, segment, "x", unitX);
        y && _addDimensionalPropTween(plugin, target, y, segment, "y", unitY);
        return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12));
      };
      _emptyFunc5 = function _emptyFunc6(v) {
        return v;
      };
      _numExp3 = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g;
      _originToPoint = function _originToPoint2(element, origin, parentMatrix) {
        var m = getGlobalMatrix(element), x = 0, y = 0, svg;
        if ((element.tagName + "").toLowerCase() === "svg") {
          svg = element.viewBox.baseVal;
          svg.width || (svg = {
            width: +element.getAttribute("width"),
            height: +element.getAttribute("height")
          });
        } else {
          svg = origin && element.getBBox && element.getBBox();
        }
        if (origin && origin !== "auto") {
          x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;
          y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;
        }
        return parentMatrix.apply(x || y ? m.apply({
          x,
          y
        }) : {
          x: m.e,
          y: m.f
        });
      };
      _getAlignMatrix = function _getAlignMatrix2(fromElement, toElement, fromOrigin, toOrigin) {
        var parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true), m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)), fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix), _originToPoint22 = _originToPoint(toElement, toOrigin, parentMatrix), x = _originToPoint22.x, y = _originToPoint22.y, p2;
        m.e = m.f = 0;
        if (toOrigin === "auto" && toElement.getTotalLength && toElement.tagName.toLowerCase() === "path") {
          p2 = toElement.getAttribute("d").match(_numExp3) || [];
          p2 = m.apply({
            x: +p2[0],
            y: +p2[1]
          });
          x += p2.x;
          y += p2.y;
        }
        if (p2 || toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement) {
          p2 = m.apply(toElement.getBBox());
          x -= p2.x;
          y -= p2.y;
        }
        m.e = x - fromPoint.x;
        m.f = y - fromPoint.y;
        return m;
      };
      _align = function _align2(rawPath, target, _ref) {
        var align = _ref.align, matrix = _ref.matrix, offsetX = _ref.offsetX, offsetY = _ref.offsetY, alignOrigin = _ref.alignOrigin;
        var x = rawPath[0][0], y = rawPath[0][1], curX = _getPropNum(target, "x"), curY = _getPropNum(target, "y"), alignTarget, m, p2;
        if (!rawPath || !rawPath.length) {
          return getRawPath("M0,0L0,0");
        }
        if (align) {
          if (align === "self" || (alignTarget = _toArray3(align)[0] || target) === target) {
            transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);
          } else {
            if (alignOrigin && alignOrigin[2] !== false) {
              gsap8.set(target, {
                transformOrigin: alignOrigin[0] * 100 + "% " + alignOrigin[1] * 100 + "%"
              });
            } else {
              alignOrigin = [_getPropNum(target, "xPercent") / -100, _getPropNum(target, "yPercent") / -100];
            }
            m = _getAlignMatrix(target, alignTarget, alignOrigin, "auto");
            p2 = m.apply({
              x,
              y
            });
            transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p2.x - m.e), curY + m.f - (p2.y - m.f));
          }
        }
        if (matrix) {
          transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        } else if (offsetX || offsetY) {
          transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);
        }
        return rawPath;
      };
      _addDimensionalPropTween = function _addDimensionalPropTween2(plugin, target, property, rawPath, pathProperty, forceUnit) {
        var cache = target._gsap, harness = cache.harness, alias = harness && harness.aliases && harness.aliases[property], prop = alias && alias.indexOf(",") < 0 ? alias : property, pt = plugin._pt = new PropTween2(plugin._pt, target, prop, 0, 0, _emptyFunc5, 0, cache.set(target, prop, plugin));
        pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;
        pt.path = rawPath;
        pt.pp = pathProperty;
        plugin._props.push(prop);
      };
      _sliceModifier = function _sliceModifier2(start, end) {
        return function(rawPath) {
          return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;
        };
      };
      MotionPathPlugin = {
        version: "3.9.1",
        name: "motionPath",
        register: function register(core, Plugin, propTween) {
          gsap8 = core;
          _getUnit = gsap8.utils.getUnit;
          _toArray3 = gsap8.utils.toArray;
          PropTween2 = propTween;
        },
        init: function init6(target, vars) {
          if (!gsap8) {
            console.warn("Please gsap.registerPlugin(MotionPathPlugin)");
            return false;
          }
          if (!(typeof vars === "object" && !vars.style) || !vars.path) {
            vars = {
              path: vars
            };
          }
          var rawPaths = [], _vars = vars, path = _vars.path, autoRotate = _vars.autoRotate, unitX = _vars.unitX, unitY = _vars.unitY, x = _vars.x, y = _vars.y, firstObj = path[0], slicer = _sliceModifier(vars.start, "end" in vars ? vars.end : 1), rawPath, p2;
          this.rawPaths = rawPaths;
          this.target = target;
          if (this.rotate = autoRotate || autoRotate === 0) {
            this.rOffset = parseFloat(autoRotate) || 0;
            this.radians = !!vars.useRadians;
            this.rProp = vars.rotation || "rotation";
            this.rSet = target._gsap.set(target, this.rProp, this);
            this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0;
          }
          if (Array.isArray(path) && !("closed" in path) && typeof firstObj !== "number") {
            for (p2 in firstObj) {
              if (!x && ~_xProps.indexOf(p2)) {
                x = p2;
              } else if (!y && ~_yProps.indexOf(p2)) {
                y = p2;
              }
            }
            if (x && y) {
              rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));
            } else {
              x = y = 0;
            }
            for (p2 in firstObj) {
              p2 !== x && p2 !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p2, 2), target, p2, 0, slicer, vars, _getUnit(path[0][p2])));
            }
          } else {
            rawPath = slicer(_align(getRawPath(vars.path), target, vars));
            cacheRawPathMeasurements(rawPath, vars.resolution);
            rawPaths.push(rawPath);
            _addDimensionalPropTween(this, target, vars.x || "x", rawPath, "x", vars.unitX || "px");
            _addDimensionalPropTween(this, target, vars.y || "y", rawPath, "y", vars.unitY || "px");
          }
        },
        render: function render3(ratio, data) {
          var rawPaths = data.rawPaths, i2 = rawPaths.length, pt = data._pt;
          if (ratio > 1) {
            ratio = 1;
          } else if (ratio < 0) {
            ratio = 0;
          }
          while (i2--) {
            getPositionOnPath(rawPaths[i2], ratio, !i2 && data.rotate, rawPaths[i2]);
          }
          while (pt) {
            pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);
            pt = pt._next;
          }
          data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD4 : 1) + data.rOffset + data.ru, data, ratio);
        },
        getLength: function getLength(path) {
          return cacheRawPathMeasurements(getRawPath(path)).totalLength;
        },
        sliceRawPath,
        getRawPath,
        pointsToSegment,
        stringToRawPath,
        rawPathToString,
        transformRawPath,
        getGlobalMatrix,
        getPositionOnPath,
        cacheRawPathMeasurements,
        convertToPath: function convertToPath2(targets, swap) {
          return _toArray3(targets).map(function(target) {
            return convertToPath(target, swap !== false);
          });
        },
        convertCoordinates: function convertCoordinates(fromElement, toElement, point) {
          var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));
          return point ? m.apply(point) : m;
        },
        getAlignMatrix: _getAlignMatrix,
        getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {
          var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);
          return {
            x: m.e,
            y: m.f
          };
        },
        arrayToRawPath: function arrayToRawPath(value, vars) {
          vars = vars || {};
          var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || "x", 0), value, vars.y || "y", 1);
          vars.relative && _relativize(segment);
          return [vars.type === "cubic" ? segment : pointsToSegment(segment, vars.curviness)];
        }
      };
      _getGSAP11() && gsap8.registerPlugin(MotionPathPlugin);
    }
  });

  // node_modules/gsap/PixiPlugin.js
  var gsap9, _win7, _splitColor, _coreInitted7, _PIXI, PropTween3, _getSetter3, _isV4, _windowExists11, _getGSAP13, _isFunction5, _warn5, _idMatrix2, _lumR2, _lumG2, _lumB2, _applyMatrix3, _setSaturation3, _colorize3, _setHue3, _setContrast3, _getFilter, _addColorMatrixFilterCacheTween, _applyBrightnessToMatrix, _copy5, _CMFdefaults, _parseColorMatrixFilter3, _renderColor, _renderDirtyCache, _renderAutoAlpha, _addColorTween, _colorProps2, _xyContexts, _contexts, _colorMatrixFilterProps, _DEG2RAD5, _isString5, _degreesToRadians, _renderPropWithEnd3, _addRotationalPropTween3, _initCore13, i, p, PixiPlugin;
  var init_PixiPlugin = __esm({
    "node_modules/gsap/PixiPlugin.js"() {
      _windowExists11 = function _windowExists12() {
        return typeof window !== "undefined";
      };
      _getGSAP13 = function _getGSAP14() {
        return gsap9 || _windowExists11() && (gsap9 = window.gsap) && gsap9.registerPlugin && gsap9;
      };
      _isFunction5 = function _isFunction6(value) {
        return typeof value === "function";
      };
      _warn5 = function _warn6(message) {
        return console.warn(message);
      };
      _idMatrix2 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
      _lumR2 = 0.212671;
      _lumG2 = 0.71516;
      _lumB2 = 0.072169;
      _applyMatrix3 = function _applyMatrix4(m, m2) {
        var temp = [], i2 = 0, z = 0, y, x;
        for (y = 0; y < 4; y++) {
          for (x = 0; x < 5; x++) {
            z = x === 4 ? m[i2 + 4] : 0;
            temp[i2 + x] = m[i2] * m2[x] + m[i2 + 1] * m2[x + 5] + m[i2 + 2] * m2[x + 10] + m[i2 + 3] * m2[x + 15] + z;
          }
          i2 += 5;
        }
        return temp;
      };
      _setSaturation3 = function _setSaturation4(m, n) {
        var inv = 1 - n, r = inv * _lumR2, g = inv * _lumG2, b = inv * _lumB2;
        return _applyMatrix3([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
      };
      _colorize3 = function _colorize4(m, color, amount) {
        var c = _splitColor(color), r = c[0] / 255, g = c[1] / 255, b = c[2] / 255, inv = 1 - amount;
        return _applyMatrix3([inv + amount * r * _lumR2, amount * r * _lumG2, amount * r * _lumB2, 0, 0, amount * g * _lumR2, inv + amount * g * _lumG2, amount * g * _lumB2, 0, 0, amount * b * _lumR2, amount * b * _lumG2, inv + amount * b * _lumB2, 0, 0, 0, 0, 0, 1, 0], m);
      };
      _setHue3 = function _setHue4(m, n) {
        n *= Math.PI / 180;
        var c = Math.cos(n), s = Math.sin(n);
        return _applyMatrix3([_lumR2 + c * (1 - _lumR2) + s * -_lumR2, _lumG2 + c * -_lumG2 + s * -_lumG2, _lumB2 + c * -_lumB2 + s * (1 - _lumB2), 0, 0, _lumR2 + c * -_lumR2 + s * 0.143, _lumG2 + c * (1 - _lumG2) + s * 0.14, _lumB2 + c * -_lumB2 + s * -0.283, 0, 0, _lumR2 + c * -_lumR2 + s * -(1 - _lumR2), _lumG2 + c * -_lumG2 + s * _lumG2, _lumB2 + c * (1 - _lumB2) + s * _lumB2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
      };
      _setContrast3 = function _setContrast4(m, n) {
        return _applyMatrix3([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m);
      };
      _getFilter = function _getFilter2(target, type) {
        var filterClass = _PIXI.filters[type], filters = target.filters || [], i2 = filters.length, filter;
        filterClass || _warn5(type + " not found. PixiPlugin.registerPIXI(PIXI)");
        while (--i2 > -1) {
          if (filters[i2] instanceof filterClass) {
            return filters[i2];
          }
        }
        filter = new filterClass();
        if (type === "BlurFilter") {
          filter.blur = 0;
        }
        filters.push(filter);
        target.filters = filters;
        return filter;
      };
      _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween2(p2, plugin, cache, vars) {
        plugin.add(cache, p2, cache[p2], vars[p2]);
        plugin._props.push(p2);
      };
      _applyBrightnessToMatrix = function _applyBrightnessToMatrix2(brightness, matrix) {
        var temp = new _PIXI.filters.ColorMatrixFilter();
        temp.matrix = matrix;
        temp.brightness(brightness, true);
        return temp.matrix;
      };
      _copy5 = function _copy6(obj) {
        var copy = {}, p2;
        for (p2 in obj) {
          copy[p2] = obj[p2];
        }
        return copy;
      };
      _CMFdefaults = {
        contrast: 1,
        saturation: 1,
        colorizeAmount: 0,
        colorize: "rgb(255,255,255)",
        hue: 0,
        brightness: 1
      };
      _parseColorMatrixFilter3 = function _parseColorMatrixFilter4(target, v, pg) {
        var filter = _getFilter(target, "ColorMatrixFilter"), cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy5(_CMFdefaults), combine = v.combineCMF && !("colorMatrixFilter" in v && !v.colorMatrixFilter), i2, matrix, startMatrix;
        startMatrix = filter.matrix;
        if (v.resolution) {
          filter.resolution = v.resolution;
        }
        if (v.matrix && v.matrix.length === startMatrix.length) {
          matrix = v.matrix;
          if (cache.contrast !== 1) {
            _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
          }
          if (cache.hue) {
            _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
          }
          if (cache.brightness !== 1) {
            _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
          }
          if (cache.colorizeAmount) {
            _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
            _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
          }
          if (cache.saturation !== 1) {
            _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
          }
        } else {
          matrix = _idMatrix2.slice();
          if (v.contrast != null) {
            matrix = _setContrast3(matrix, +v.contrast);
            _addColorMatrixFilterCacheTween("contrast", pg, cache, v);
          } else if (cache.contrast !== 1) {
            if (combine) {
              matrix = _setContrast3(matrix, cache.contrast);
            } else {
              _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
            }
          }
          if (v.hue != null) {
            matrix = _setHue3(matrix, +v.hue);
            _addColorMatrixFilterCacheTween("hue", pg, cache, v);
          } else if (cache.hue) {
            if (combine) {
              matrix = _setHue3(matrix, cache.hue);
            } else {
              _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
            }
          }
          if (v.brightness != null) {
            matrix = _applyBrightnessToMatrix(+v.brightness, matrix);
            _addColorMatrixFilterCacheTween("brightness", pg, cache, v);
          } else if (cache.brightness !== 1) {
            if (combine) {
              matrix = _applyBrightnessToMatrix(cache.brightness, matrix);
            } else {
              _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
            }
          }
          if (v.colorize != null) {
            v.colorizeAmount = "colorizeAmount" in v ? +v.colorizeAmount : 1;
            matrix = _colorize3(matrix, v.colorize, v.colorizeAmount);
            _addColorMatrixFilterCacheTween("colorize", pg, cache, v);
            _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v);
          } else if (cache.colorizeAmount) {
            if (combine) {
              matrix = _colorize3(matrix, cache.colorize, cache.colorizeAmount);
            } else {
              _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
              _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
            }
          }
          if (v.saturation != null) {
            matrix = _setSaturation3(matrix, +v.saturation);
            _addColorMatrixFilterCacheTween("saturation", pg, cache, v);
          } else if (cache.saturation !== 1) {
            if (combine) {
              matrix = _setSaturation3(matrix, cache.saturation);
            } else {
              _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
            }
          }
        }
        i2 = matrix.length;
        while (--i2 > -1) {
          if (matrix[i2] !== startMatrix[i2]) {
            pg.add(startMatrix, i2, startMatrix[i2], matrix[i2], "colorMatrixFilter");
          }
        }
        pg._props.push("colorMatrixFilter");
      };
      _renderColor = function _renderColor2(ratio, _ref) {
        var t = _ref.t, p2 = _ref.p, color = _ref.color, set = _ref.set;
        set(t, p2, color[0] << 16 | color[1] << 8 | color[2]);
      };
      _renderDirtyCache = function _renderDirtyCache2(ratio, _ref2) {
        var g = _ref2.g;
        if (g) {
          g.dirty++;
          g.clearDirty++;
        }
      };
      _renderAutoAlpha = function _renderAutoAlpha2(ratio, data) {
        data.t.visible = !!data.t.alpha;
      };
      _addColorTween = function _addColorTween2(target, p2, value, plugin) {
        var currentValue = target[p2], startColor = _splitColor(_isFunction5(currentValue) ? target[p2.indexOf("set") || !_isFunction5(target["get" + p2.substr(3)]) ? p2 : "get" + p2.substr(3)]() : currentValue), endColor = _splitColor(value);
        plugin._pt = new PropTween3(plugin._pt, target, p2, 0, 0, _renderColor, {
          t: target,
          p: p2,
          color: startColor,
          set: _getSetter3(target, p2)
        });
        plugin.add(startColor, 0, startColor[0], endColor[0]);
        plugin.add(startColor, 1, startColor[1], endColor[1]);
        plugin.add(startColor, 2, startColor[2], endColor[2]);
      };
      _colorProps2 = {
        tint: 1,
        lineColor: 1,
        fillColor: 1
      };
      _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(",");
      _contexts = {
        x: "position",
        y: "position",
        tileX: "tilePosition",
        tileY: "tilePosition"
      };
      _colorMatrixFilterProps = {
        colorMatrixFilter: 1,
        saturation: 1,
        contrast: 1,
        hue: 1,
        colorize: 1,
        colorizeAmount: 1,
        brightness: 1,
        combineCMF: 1
      };
      _DEG2RAD5 = Math.PI / 180;
      _isString5 = function _isString6(value) {
        return typeof value === "string";
      };
      _degreesToRadians = function _degreesToRadians2(value) {
        return _isString5(value) && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD5 : value * _DEG2RAD5;
      };
      _renderPropWithEnd3 = function _renderPropWithEnd4(ratio, data) {
        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e5) / 1e5, data);
      };
      _addRotationalPropTween3 = function _addRotationalPropTween4(plugin, target, property, startNum, endValue, radians) {
        var cap = 360 * (radians ? _DEG2RAD5 : 1), isString = _isString5(endValue), relative = isString && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0, endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD5 : 1), change = relative ? endNum * relative : endNum - startNum, finalValue = startNum + change, direction, pt;
        if (isString) {
          direction = endValue.split("_")[1];
          if (direction === "short") {
            change %= cap;
            if (change !== change % (cap / 2)) {
              change += change < 0 ? cap : -cap;
            }
          }
          if (direction === "cw" && change < 0) {
            change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;
          } else if (direction === "ccw" && change > 0) {
            change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;
          }
        }
        plugin._pt = pt = new PropTween3(plugin._pt, target, property, startNum, change, _renderPropWithEnd3);
        pt.e = finalValue;
        return pt;
      };
      _initCore13 = function _initCore14() {
        if (_windowExists11()) {
          _win7 = window;
          gsap9 = _getGSAP13();
          _PIXI = _coreInitted7 = _PIXI || _win7.PIXI;
          _isV4 = _PIXI && _PIXI.VERSION && _PIXI.VERSION.charAt(0) === "4";
          _splitColor = function _splitColor2(color) {
            return gsap9.utils.splitColor((color + "").substr(0, 2) === "0x" ? "#" + color.substr(2) : color);
          };
        }
      };
      for (i = 0; i < _xyContexts.length; i++) {
        p = _xyContexts[i];
        _contexts[p + "X"] = p;
        _contexts[p + "Y"] = p;
      }
      PixiPlugin = {
        version: "3.9.1",
        name: "pixi",
        register: function register2(core, Plugin, propTween) {
          gsap9 = core;
          PropTween3 = propTween;
          _getSetter3 = Plugin.getSetter;
          _initCore13();
        },
        registerPIXI: function registerPIXI(pixi) {
          _PIXI = pixi;
        },
        init: function init7(target, values, tween, index, targets) {
          _PIXI || _initCore13();
          if (!_PIXI || !(target instanceof _PIXI.DisplayObject)) {
            console.warn(target, "is not a DisplayObject or PIXI was not found. PixiPlugin.registerPIXI(PIXI);");
            return false;
          }
          var context, axis, value, colorMatrix, filter, p2, padding, i2, data;
          for (p2 in values) {
            context = _contexts[p2];
            value = values[p2];
            if (context) {
              axis = ~p2.charAt(p2.length - 1).toLowerCase().indexOf("x") ? "x" : "y";
              this.add(target[context], axis, target[context][axis], context === "skew" ? _degreesToRadians(value) : value);
            } else if (p2 === "scale" || p2 === "anchor" || p2 === "pivot" || p2 === "tileScale") {
              this.add(target[p2], "x", target[p2].x, value);
              this.add(target[p2], "y", target[p2].y, value);
            } else if (p2 === "rotation" || p2 === "angle") {
              _addRotationalPropTween3(this, target, p2, target[p2], value, p2 === "rotation");
            } else if (_colorMatrixFilterProps[p2]) {
              if (!colorMatrix) {
                _parseColorMatrixFilter3(target, values.colorMatrixFilter || values, this);
                colorMatrix = true;
              }
            } else if (p2 === "blur" || p2 === "blurX" || p2 === "blurY" || p2 === "blurPadding") {
              filter = _getFilter(target, "BlurFilter");
              this.add(filter, p2, filter[p2], value);
              if (values.blurPadding !== 0) {
                padding = values.blurPadding || Math.max(filter[p2], value) * 2;
                i2 = target.filters.length;
                while (--i2 > -1) {
                  target.filters[i2].padding = Math.max(target.filters[i2].padding, padding);
                }
              }
            } else if (_colorProps2[p2]) {
              if ((p2 === "lineColor" || p2 === "fillColor") && target instanceof _PIXI.Graphics) {
                data = (target.geometry || target).graphicsData;
                this._pt = new PropTween3(this._pt, target, p2, 0, 0, _renderDirtyCache, {
                  g: target.geometry || target
                });
                i2 = data.length;
                while (--i2 > -1) {
                  _addColorTween(_isV4 ? data[i2] : data[i2][p2.substr(0, 4) + "Style"], _isV4 ? p2 : "color", value, this);
                }
              } else {
                _addColorTween(target, p2, value, this);
              }
            } else if (p2 === "autoAlpha") {
              this._pt = new PropTween3(this._pt, target, "visible", 0, 0, _renderAutoAlpha);
              this.add(target, "alpha", target.alpha, value);
              this._props.push("alpha", "visible");
            } else if (p2 !== "resolution") {
              this.add(target, p2, "get", value);
            }
            this._props.push(p2);
          }
        }
      };
      _getGSAP13() && gsap9.registerPlugin(PixiPlugin);
    }
  });

  // node_modules/gsap/ScrollToPlugin.js
  var gsap10, _coreInitted8, _window, _docEl, _body4, _toArray4, _config2, _windowExists13, _getGSAP15, _isString7, _isFunction7, _max, _buildGetter, _clean, _getOffset, _parseVal, _initCore15, ScrollToPlugin;
  var init_ScrollToPlugin = __esm({
    "node_modules/gsap/ScrollToPlugin.js"() {
      _windowExists13 = function _windowExists14() {
        return typeof window !== "undefined";
      };
      _getGSAP15 = function _getGSAP16() {
        return gsap10 || _windowExists13() && (gsap10 = window.gsap) && gsap10.registerPlugin && gsap10;
      };
      _isString7 = function _isString8(value) {
        return typeof value === "string";
      };
      _isFunction7 = function _isFunction8(value) {
        return typeof value === "function";
      };
      _max = function _max2(element, axis) {
        var dim = axis === "x" ? "Width" : "Height", scroll = "scroll" + dim, client = "client" + dim;
        return element === _window || element === _docEl || element === _body4 ? Math.max(_docEl[scroll], _body4[scroll]) - (_window["inner" + dim] || _docEl[client] || _body4[client]) : element[scroll] - element["offset" + dim];
      };
      _buildGetter = function _buildGetter2(e, axis) {
        var p2 = "scroll" + (axis === "x" ? "Left" : "Top");
        if (e === _window) {
          if (e.pageXOffset != null) {
            p2 = "page" + axis.toUpperCase() + "Offset";
          } else {
            e = _docEl[p2] != null ? _docEl : _body4;
          }
        }
        return function() {
          return e[p2];
        };
      };
      _clean = function _clean2(value, index, target, targets) {
        _isFunction7(value) && (value = value(index, target, targets));
        if (typeof value !== "object") {
          return _isString7(value) && value !== "max" && value.charAt(1) !== "=" ? {
            x: value,
            y: value
          } : {
            y: value
          };
        } else if (value.nodeType) {
          return {
            y: value,
            x: value
          };
        } else {
          var result = {}, p2;
          for (p2 in value) {
            result[p2] = p2 !== "onAutoKill" && _isFunction7(value[p2]) ? value[p2](index, target, targets) : value[p2];
          }
          return result;
        }
      };
      _getOffset = function _getOffset2(element, container) {
        element = _toArray4(element)[0];
        if (!element || !element.getBoundingClientRect) {
          return console.warn("scrollTo target doesn't exist. Using 0") || {
            x: 0,
            y: 0
          };
        }
        var rect = element.getBoundingClientRect(), isRoot = !container || container === _window || container === _body4, cRect = isRoot ? {
          top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body4.scrollTop || 0),
          left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body4.scrollLeft || 0)
        } : container.getBoundingClientRect(), offsets = {
          x: rect.left - cRect.left,
          y: rect.top - cRect.top
        };
        if (!isRoot && container) {
          offsets.x += _buildGetter(container, "x")();
          offsets.y += _buildGetter(container, "y")();
        }
        return offsets;
      };
      _parseVal = function _parseVal2(value, target, axis, currentVal, offset) {
        return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString7(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
      };
      _initCore15 = function _initCore16() {
        gsap10 = _getGSAP15();
        if (_windowExists13() && gsap10 && document.body) {
          _window = window;
          _body4 = document.body;
          _docEl = document.documentElement;
          _toArray4 = gsap10.utils.toArray;
          gsap10.config({
            autoKillThreshold: 7
          });
          _config2 = gsap10.config();
          _coreInitted8 = 1;
        }
      };
      ScrollToPlugin = {
        version: "3.9.1",
        name: "scrollTo",
        rawVars: 1,
        register: function register3(core) {
          gsap10 = core;
          _initCore15();
        },
        init: function init8(target, value, tween, index, targets) {
          _coreInitted8 || _initCore15();
          var data = this, snapType = gsap10.getProperty(target, "scrollSnapType");
          data.isWin = target === _window;
          data.target = target;
          data.tween = tween;
          value = _clean(value, index, target, targets);
          data.vars = value;
          data.autoKill = !!value.autoKill;
          data.getX = _buildGetter(target, "x");
          data.getY = _buildGetter(target, "y");
          data.x = data.xPrev = data.getX();
          data.y = data.yPrev = data.getY();
          if (snapType && snapType !== "none") {
            data.snap = 1;
            data.snapInline = target.style.scrollSnapType;
            target.style.scrollSnapType = "none";
          }
          if (value.x != null) {
            data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);
            data._props.push("scrollTo_x");
          } else {
            data.skipX = 1;
          }
          if (value.y != null) {
            data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);
            data._props.push("scrollTo_y");
          } else {
            data.skipY = 1;
          }
        },
        render: function render4(ratio, data) {
          var pt = data._pt, target = data.target, tween = data.tween, autoKill = data.autoKill, xPrev = data.xPrev, yPrev = data.yPrev, isWin = data.isWin, snap3 = data.snap, snapInline = data.snapInline, x, y, yDif, xDif, threshold;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          x = isWin || !data.skipX ? data.getX() : xPrev;
          y = isWin || !data.skipY ? data.getY() : yPrev;
          yDif = y - yPrev;
          xDif = x - xPrev;
          threshold = _config2.autoKillThreshold;
          if (data.x < 0) {
            data.x = 0;
          }
          if (data.y < 0) {
            data.y = 0;
          }
          if (autoKill) {
            if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
              data.skipX = 1;
            }
            if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
              data.skipY = 1;
            }
            if (data.skipX && data.skipY) {
              tween.kill();
              data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
            }
          }
          if (isWin) {
            _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
          } else {
            data.skipY || (target.scrollTop = data.y);
            data.skipX || (target.scrollLeft = data.x);
          }
          if (snap3 && (ratio === 1 || ratio === 0)) {
            y = target.scrollTop;
            x = target.scrollLeft;
            snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
            target.scrollTop = y + 1;
            target.scrollLeft = x + 1;
            target.scrollTop = y;
            target.scrollLeft = x;
          }
          data.xPrev = data.x;
          data.yPrev = data.y;
        },
        kill: function kill(property) {
          var both = property === "scrollTo";
          if (both || property === "scrollTo_x") {
            this.skipX = 1;
          }
          if (both || property === "scrollTo_y") {
            this.skipY = 1;
          }
        }
      };
      ScrollToPlugin.max = _max;
      ScrollToPlugin.getOffset = _getOffset;
      ScrollToPlugin.buildGetter = _buildGetter;
      _getGSAP15() && gsap10.registerPlugin(ScrollToPlugin);
    }
  });

  // node_modules/gsap/ScrollTrigger.js
  var gsap11, _coreInitted9, _win8, _doc6, _docEl2, _body5, _root, _resizeDelay, _toArray5, _clamp3, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp4, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites2, _ignoreResize, _limitCallbacks, _startup, _proxies, _scrollers, _getTime2, _time1, _lastScrollTime, _enabled, _passThrough3, _getTarget, _round11, _windowExists15, _getGSAP17, _isViewport, _getProxyProp, _getScrollFunc, _getBoundsFunc, _getSizeFunc, _getOffsetsFunc, _maxScroll, _iterateAutoRefresh, _isString9, _isFunction9, _isNumber5, _isObject5, _callIfFunc, _combineFunc, _endAnimation, _callback3, _abs2, _scrollLeft, _scrollTop, _left, _top, _right, _bottom, _width, _height, _Right, _Left, _Top, _Bottom, _padding, _margin, _Width, _Height, _px, _horizontal, _vertical, _getComputedStyle3, _makePositionable, _setDefaults5, _getBounds3, _getSize, _getLabelRatioArray, _getClosestLabel, _snapDirectional, _getLabelAtDirection, _multiListener, _addListener3, _removeListener3, _markerDefaults, _defaults2, _keywords, _offsetToPx, _createMarker, _positionMarker, _triggers, _ids, _sync, _onScroll, _onResize, _listeners, _emptyArray, _media, _creatingMedia, _lastMediaTick, _onMediaChange, _softRefresh, _dispatch, _savedStyles, _revertRecorded, _revertAll, _clearScrollMemory, _refreshingAll, _refreshAll, _lastScroll, _direction, _updateAll, _propNamesToCopy, _stateProps, _swapPinOut, _swapPinIn, _capsExp2, _setState, _getState, _copyState, _winOffsets, _parsePosition3, _prefixExp, _reparent, _getTweenCreator, ScrollTrigger;
  var init_ScrollTrigger = __esm({
    "node_modules/gsap/ScrollTrigger.js"() {
      _startup = 1;
      _proxies = [];
      _scrollers = [];
      _getTime2 = Date.now;
      _time1 = _getTime2();
      _lastScrollTime = 0;
      _enabled = 1;
      _passThrough3 = function _passThrough4(v) {
        return v;
      };
      _getTarget = function _getTarget2(t) {
        return _toArray5(t)[0] || (_isString9(t) && gsap11.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
      };
      _round11 = function _round12(value) {
        return Math.round(value * 1e5) / 1e5 || 0;
      };
      _windowExists15 = function _windowExists16() {
        return typeof window !== "undefined";
      };
      _getGSAP17 = function _getGSAP18() {
        return gsap11 || _windowExists15() && (gsap11 = window.gsap) && gsap11.registerPlugin && gsap11;
      };
      _isViewport = function _isViewport2(e) {
        return !!~_root.indexOf(e);
      };
      _getProxyProp = function _getProxyProp2(element, property) {
        return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
      };
      _getScrollFunc = function _getScrollFunc2(element, _ref) {
        var s = _ref.s, sc3 = _ref.sc;
        var i2 = _scrollers.indexOf(element), offset = sc3 === _vertical.sc ? 1 : 2;
        !~i2 && (i2 = _scrollers.push(element) - 1);
        return _scrollers[i2 + offset] || (_scrollers[i2 + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc3 : function(value) {
          return arguments.length ? element[s] = value : element[s];
        }));
      };
      _getBoundsFunc = function _getBoundsFunc2(element) {
        return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function() {
          _winOffsets.width = _win8.innerWidth;
          _winOffsets.height = _win8.innerHeight;
          return _winOffsets;
        } : function() {
          return _getBounds3(element);
        });
      };
      _getSizeFunc = function _getSizeFunc2(scroller, isViewport, _ref2) {
        var d = _ref2.d, d2 = _ref2.d2, a = _ref2.a;
        return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
          return a()[d];
        } : function() {
          return (isViewport ? _win8["inner" + d2] : scroller["client" + d2]) || 0;
        };
      };
      _getOffsetsFunc = function _getOffsetsFunc2(element, isViewport) {
        return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
          return _winOffsets;
        };
      };
      _maxScroll = function _maxScroll2(element, _ref3) {
        var s = _ref3.s, d2 = _ref3.d2, d = _ref3.d, a = _ref3.a;
        return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_body5[s] || _docEl2[s]) - (_win8["inner" + d2] || _docEl2["client" + d2] || _body5["client" + d2]) : element[s] - element["offset" + d2];
      };
      _iterateAutoRefresh = function _iterateAutoRefresh2(func, events) {
        for (var i2 = 0; i2 < _autoRefresh.length; i2 += 3) {
          (!events || ~events.indexOf(_autoRefresh[i2 + 1])) && func(_autoRefresh[i2], _autoRefresh[i2 + 1], _autoRefresh[i2 + 2]);
        }
      };
      _isString9 = function _isString10(value) {
        return typeof value === "string";
      };
      _isFunction9 = function _isFunction10(value) {
        return typeof value === "function";
      };
      _isNumber5 = function _isNumber6(value) {
        return typeof value === "number";
      };
      _isObject5 = function _isObject6(value) {
        return typeof value === "object";
      };
      _callIfFunc = function _callIfFunc2(value) {
        return _isFunction9(value) && value();
      };
      _combineFunc = function _combineFunc2(f1, f2) {
        return function() {
          var result1 = _callIfFunc(f1), result2 = _callIfFunc(f2);
          return function() {
            _callIfFunc(result1);
            _callIfFunc(result2);
          };
        };
      };
      _endAnimation = function _endAnimation2(animation, reversed, pause) {
        return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
      };
      _callback3 = function _callback4(self2, func) {
        if (self2.enabled) {
          var result = func(self2);
          result && result.totalTime && (self2.callbackAnimation = result);
        }
      };
      _abs2 = Math.abs;
      _scrollLeft = "scrollLeft";
      _scrollTop = "scrollTop";
      _left = "left";
      _top = "top";
      _right = "right";
      _bottom = "bottom";
      _width = "width";
      _height = "height";
      _Right = "Right";
      _Left = "Left";
      _Top = "Top";
      _Bottom = "Bottom";
      _padding = "padding";
      _margin = "margin";
      _Width = "Width";
      _Height = "Height";
      _px = "px";
      _horizontal = {
        s: _scrollLeft,
        p: _left,
        p2: _Left,
        os: _right,
        os2: _Right,
        d: _width,
        d2: _Width,
        a: "x",
        sc: function sc(value) {
          return arguments.length ? _win8.scrollTo(value, _vertical.sc()) : _win8.pageXOffset || _doc6[_scrollLeft] || _docEl2[_scrollLeft] || _body5[_scrollLeft] || 0;
        }
      };
      _vertical = {
        s: _scrollTop,
        p: _top,
        p2: _Top,
        os: _bottom,
        os2: _Bottom,
        d: _height,
        d2: _Height,
        a: "y",
        op: _horizontal,
        sc: function sc2(value) {
          return arguments.length ? _win8.scrollTo(_horizontal.sc(), value) : _win8.pageYOffset || _doc6[_scrollTop] || _docEl2[_scrollTop] || _body5[_scrollTop] || 0;
        }
      };
      _getComputedStyle3 = function _getComputedStyle4(element) {
        return _win8.getComputedStyle(element);
      };
      _makePositionable = function _makePositionable2(element) {
        var position = _getComputedStyle3(element).position;
        element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
      };
      _setDefaults5 = function _setDefaults6(obj, defaults2) {
        for (var p2 in defaults2) {
          p2 in obj || (obj[p2] = defaults2[p2]);
        }
        return obj;
      };
      _getBounds3 = function _getBounds4(element, withoutTransforms) {
        var tween = withoutTransforms && _getComputedStyle3(element)[_transformProp4] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap11.to(element, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0
        }).progress(1), bounds = element.getBoundingClientRect();
        tween && tween.progress(0).kill();
        return bounds;
      };
      _getSize = function _getSize2(element, _ref4) {
        var d2 = _ref4.d2;
        return element["offset" + d2] || element["client" + d2] || 0;
      };
      _getLabelRatioArray = function _getLabelRatioArray2(timeline2) {
        var a = [], labels = timeline2.labels, duration = timeline2.duration(), p2;
        for (p2 in labels) {
          a.push(labels[p2] / duration);
        }
        return a;
      };
      _getClosestLabel = function _getClosestLabel2(animation) {
        return function(value) {
          return gsap11.utils.snap(_getLabelRatioArray(animation), value);
        };
      };
      _snapDirectional = function _snapDirectional2(snapIncrementOrArray) {
        var snap3 = gsap11.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a2, b) {
          return a2 - b;
        });
        return a ? function(value, direction, threshold) {
          if (threshold === void 0) {
            threshold = 1e-3;
          }
          var i2;
          if (!direction) {
            return snap3(value);
          }
          if (direction > 0) {
            value -= threshold;
            for (i2 = 0; i2 < a.length; i2++) {
              if (a[i2] >= value) {
                return a[i2];
              }
            }
            return a[i2 - 1];
          } else {
            i2 = a.length;
            value += threshold;
            while (i2--) {
              if (a[i2] <= value) {
                return a[i2];
              }
            }
          }
          return a[0];
        } : function(value, direction, threshold) {
          if (threshold === void 0) {
            threshold = 1e-3;
          }
          var snapped = snap3(value);
          return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap3(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
        };
      };
      _getLabelAtDirection = function _getLabelAtDirection2(timeline2) {
        return function(value, st) {
          return _snapDirectional(_getLabelRatioArray(timeline2))(value, st.direction);
        };
      };
      _multiListener = function _multiListener2(func, element, types, callback) {
        return types.split(",").forEach(function(type) {
          return func(element, type, callback);
        });
      };
      _addListener3 = function _addListener4(element, type, func) {
        return element.addEventListener(type, func, {
          passive: true
        });
      };
      _removeListener3 = function _removeListener4(element, type, func) {
        return element.removeEventListener(type, func);
      };
      _markerDefaults = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal"
      };
      _defaults2 = {
        toggleActions: "play",
        anticipatePin: 0
      };
      _keywords = {
        top: 0,
        left: 0,
        center: 0.5,
        bottom: 1,
        right: 1
      };
      _offsetToPx = function _offsetToPx2(value, size) {
        if (_isString9(value)) {
          var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
          if (~eqIndex) {
            value.indexOf("%") > eqIndex && (relative *= size / 100);
            value = value.substr(0, eqIndex - 1);
          }
          value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
        }
        return value;
      };
      _createMarker = function _createMarker2(type, name, container, direction, _ref5, offset, matchWidthEl, containerAnimation) {
        var startColor = _ref5.startColor, endColor = _ref5.endColor, fontSize = _ref5.fontSize, indent = _ref5.indent, fontWeight = _ref5.fontWeight;
        var e = _doc6.createElement("div"), useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent = useFixedPosition ? _body5 : container, isStart = type.indexOf("start") !== -1, color = isStart ? startColor : endColor, css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
        (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
        matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
        e._isStart = isStart;
        e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
        e.style.cssText = css;
        e.innerText = name || name === 0 ? type + "-" + name : type;
        parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
        e._offset = e["offset" + direction.op.d2];
        _positionMarker(e, 0, direction, isStart);
        return e;
      };
      _positionMarker = function _positionMarker2(marker, start, direction, flipped) {
        var vars = {
          display: "block"
        }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
        marker._isFlipped = flipped;
        vars[direction.a + "Percent"] = flipped ? -100 : 0;
        vars[direction.a] = flipped ? "1px" : 0;
        vars["border" + side + _Width] = 1;
        vars["border" + oppositeSide + _Width] = 0;
        vars[direction.p] = start + "px";
        gsap11.set(marker, vars);
      };
      _triggers = [];
      _ids = {};
      _sync = function _sync2() {
        return _getTime2() - _lastScrollTime > 34 && _updateAll();
      };
      _onScroll = function _onScroll2() {
        _updateAll();
        _lastScrollTime || _dispatch("scrollStart");
        _lastScrollTime = _getTime2();
      };
      _onResize = function _onResize2() {
        return !_refreshing && !_ignoreResize && !_doc6.fullscreenElement && _resizeDelay.restart(true);
      };
      _listeners = {};
      _emptyArray = [];
      _media = [];
      _onMediaChange = function _onMediaChange2(e) {
        var tick = gsap11.ticker.frame, matches = [], i2 = 0, index;
        if (_lastMediaTick !== tick || _startup) {
          _revertAll();
          for (; i2 < _media.length; i2 += 4) {
            index = _win8.matchMedia(_media[i2]).matches;
            if (index !== _media[i2 + 3]) {
              _media[i2 + 3] = index;
              index ? matches.push(i2) : _revertAll(1, _media[i2]) || _isFunction9(_media[i2 + 2]) && _media[i2 + 2]();
            }
          }
          _revertRecorded();
          for (i2 = 0; i2 < matches.length; i2++) {
            index = matches[i2];
            _creatingMedia = _media[index];
            _media[index + 2] = _media[index + 1](e);
          }
          _creatingMedia = 0;
          _coreInitted9 && _refreshAll(0, 1);
          _lastMediaTick = tick;
          _dispatch("matchMedia");
        }
      };
      _softRefresh = function _softRefresh2() {
        return _removeListener3(ScrollTrigger, "scrollEnd", _softRefresh2) || _refreshAll(true);
      };
      _dispatch = function _dispatch2(type) {
        return _listeners[type] && _listeners[type].map(function(f) {
          return f();
        }) || _emptyArray;
      };
      _savedStyles = [];
      _revertRecorded = function _revertRecorded2(media) {
        for (var i2 = 0; i2 < _savedStyles.length; i2 += 5) {
          if (!media || _savedStyles[i2 + 4] === media) {
            _savedStyles[i2].style.cssText = _savedStyles[i2 + 1];
            _savedStyles[i2].getBBox && _savedStyles[i2].setAttribute("transform", _savedStyles[i2 + 2] || "");
            _savedStyles[i2 + 3].uncache = 1;
          }
        }
      };
      _revertAll = function _revertAll2(kill2, media) {
        var trigger;
        for (_i = 0; _i < _triggers.length; _i++) {
          trigger = _triggers[_i];
          if (!media || trigger.media === media) {
            if (kill2) {
              trigger.kill(1);
            } else {
              trigger.revert();
            }
          }
        }
        media && _revertRecorded(media);
        media || _dispatch("revert");
      };
      _clearScrollMemory = function _clearScrollMemory2() {
        return _scrollers.forEach(function(obj) {
          return typeof obj === "function" && (obj.rec = 0);
        });
      };
      _refreshAll = function _refreshAll2(force, skipRevert) {
        if (_lastScrollTime && !force) {
          _addListener3(ScrollTrigger, "scrollEnd", _softRefresh);
          return;
        }
        _refreshingAll = true;
        var refreshInits = _dispatch("refreshInit");
        _sort && ScrollTrigger.sort();
        skipRevert || _revertAll();
        _triggers.forEach(function(t) {
          return t.refresh();
        });
        _triggers.forEach(function(t) {
          return t.vars.end === "max" && t.setPositions(t.start, _maxScroll(t.scroller, t._dir));
        });
        refreshInits.forEach(function(result) {
          return result && result.render && result.render(-1);
        });
        _clearScrollMemory();
        _resizeDelay.pause();
        _refreshingAll = false;
        _dispatch("refresh");
      };
      _lastScroll = 0;
      _direction = 1;
      _updateAll = function _updateAll2() {
        if (!_refreshingAll) {
          var l = _triggers.length, time = _getTime2(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();
          _direction = _lastScroll > scroll ? -1 : 1;
          _lastScroll = scroll;
          if (recordVelocity) {
            if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
              _lastScrollTime = 0;
              _dispatch("scrollEnd");
            }
            _time2 = _time1;
            _time1 = time;
          }
          if (_direction < 0) {
            _i = l;
            while (_i-- > 0) {
              _triggers[_i] && _triggers[_i].update(0, recordVelocity);
            }
            _direction = 1;
          } else {
            for (_i = 0; _i < l; _i++) {
              _triggers[_i] && _triggers[_i].update(0, recordVelocity);
            }
          }
        }
      };
      _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"];
      _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]);
      _swapPinOut = function _swapPinOut2(pin, spacer, state) {
        _setState(state);
        var cache = pin._gsap;
        if (cache.spacerIsNative) {
          _setState(cache.spacerState);
        } else if (pin.parentNode === spacer) {
          var parent = spacer.parentNode;
          if (parent) {
            parent.insertBefore(pin, spacer);
            parent.removeChild(spacer);
          }
        }
      };
      _swapPinIn = function _swapPinIn2(pin, spacer, cs, spacerState) {
        if (pin.parentNode !== spacer) {
          var i2 = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p2;
          while (i2--) {
            p2 = _propNamesToCopy[i2];
            spacerStyle[p2] = cs[p2];
          }
          spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
          cs.display === "inline" && (spacerStyle.display = "inline-block");
          pinStyle[_bottom] = pinStyle[_right] = spacerStyle.flexBasis = "auto";
          spacerStyle.overflow = "visible";
          spacerStyle.boxSizing = "border-box";
          spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
          spacerStyle[_height] = _getSize(pin, _vertical) + _px;
          spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
          _setState(spacerState);
          pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
          pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
          pinStyle[_padding] = cs[_padding];
          pin.parentNode.insertBefore(spacer, pin);
          spacer.appendChild(pin);
        }
      };
      _capsExp2 = /([A-Z])/g;
      _setState = function _setState2(state) {
        if (state) {
          var style = state.t.style, l = state.length, i2 = 0, p2, value;
          (state.t._gsap || gsap11.core.getCache(state.t)).uncache = 1;
          for (; i2 < l; i2 += 2) {
            value = state[i2 + 1];
            p2 = state[i2];
            if (value) {
              style[p2] = value;
            } else if (style[p2]) {
              style.removeProperty(p2.replace(_capsExp2, "-$1").toLowerCase());
            }
          }
        }
      };
      _getState = function _getState2(element) {
        var l = _stateProps.length, style = element.style, state = [], i2 = 0;
        for (; i2 < l; i2++) {
          state.push(_stateProps[i2], style[_stateProps[i2]]);
        }
        state.t = element;
        return state;
      };
      _copyState = function _copyState2(state, override, omitOffsets) {
        var result = [], l = state.length, i2 = omitOffsets ? 8 : 0, p2;
        for (; i2 < l; i2 += 2) {
          p2 = state[i2];
          result.push(p2, p2 in override ? override[p2] : state[i2 + 1]);
        }
        result.t = state.t;
        return result;
      };
      _winOffsets = {
        left: 0,
        top: 0
      };
      _parsePosition3 = function _parsePosition4(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self2, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
        _isFunction9(value) && (value = value(self2));
        if (_isString9(value) && value.substr(0, 3) === "max") {
          value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
        }
        var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;
        containerAnimation && containerAnimation.seek(0);
        if (!_isNumber5(value)) {
          _isFunction9(trigger) && (trigger = trigger(self2));
          var offsets = value.split(" "), bounds, localOffset, globalOffset, display;
          element = _getTarget(trigger) || _body5;
          bounds = _getBounds3(element) || {};
          if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle3(element).display === "none") {
            display = element.style.display;
            element.style.display = "block";
            bounds = _getBounds3(element);
            display ? element.style.display = display : element.style.removeProperty("display");
          }
          localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
          globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
          value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
          markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
          scrollerSize -= scrollerSize - globalOffset;
        } else if (markerScroller) {
          _positionMarker(markerScroller, scrollerSize, direction, true);
        }
        if (marker) {
          var position = value + scrollerSize, isStart = marker._isStart;
          p1 = "scroll" + direction.d2;
          _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body5[p1], _docEl2[p1]) : marker.parentNode[p1]) <= position + 1);
          if (useFixedPosition) {
            scrollerBounds = _getBounds3(markerScroller);
            useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
          }
        }
        if (containerAnimation && element) {
          p1 = _getBounds3(element);
          containerAnimation.seek(scrollerMax);
          p2 = _getBounds3(element);
          containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
          value = value / containerAnimation._caScrollDist * scrollerMax;
        }
        containerAnimation && containerAnimation.seek(time);
        return containerAnimation ? value : Math.round(value);
      };
      _prefixExp = /(?:webkit|moz|length|cssText|inset)/i;
      _reparent = function _reparent2(element, parent, top, left) {
        if (element.parentNode !== parent) {
          var style = element.style, p2, cs;
          if (parent === _body5) {
            element._stOrig = style.cssText;
            cs = _getComputedStyle3(element);
            for (p2 in cs) {
              if (!+p2 && !_prefixExp.test(p2) && cs[p2] && typeof style[p2] === "string" && p2 !== "0") {
                style[p2] = cs[p2];
              }
            }
            style.top = top;
            style.left = left;
          } else {
            style.cssText = element._stOrig;
          }
          gsap11.core.getCache(element).uncache = 1;
          parent.appendChild(element);
        }
      };
      _getTweenCreator = function _getTweenCreator2(scroller, direction) {
        var getScroll = _getScrollFunc(scroller, direction), prop = "_scroll" + direction.p2, lastScroll1, lastScroll2, getTween = function getTween2(scrollTo, vars, initialValue, change1, change2) {
          var tween = getTween2.tween, onComplete = vars.onComplete, modifiers = {};
          tween && tween.kill();
          lastScroll1 = Math.round(initialValue);
          vars[prop] = scrollTo;
          vars.modifiers = modifiers;
          modifiers[prop] = function(value) {
            value = _round11(getScroll());
            if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2 && Math.abs(value - lastScroll2) > 2) {
              tween.kill();
              getTween2.tween = 0;
            } else {
              value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
            }
            lastScroll2 = lastScroll1;
            return lastScroll1 = _round11(value);
          };
          vars.onComplete = function() {
            getTween2.tween = 0;
            onComplete && onComplete.call(tween);
          };
          tween = getTween2.tween = gsap11.to(scroller, vars);
          return tween;
        };
        scroller[prop] = getScroll;
        _addListener3(scroller, "wheel", function() {
          return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
        });
        return getTween;
      };
      _horizontal.op = _vertical;
      ScrollTrigger = /* @__PURE__ */ function() {
        function ScrollTrigger2(vars, animation) {
          _coreInitted9 || ScrollTrigger2.register(gsap11) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
          this.init(vars, animation);
        }
        var _proto = ScrollTrigger2.prototype;
        _proto.init = function init10(vars, animation) {
          this.progress = this.start = 0;
          this.vars && this.kill(1);
          if (!_enabled) {
            this.update = this.refresh = this.kill = _passThrough3;
            return;
          }
          vars = _setDefaults5(_isString9(vars) || _isNumber5(vars) || vars.nodeType ? {
            trigger: vars
          } : vars, _defaults2);
          var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap3 = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || _win8), scrollerCache = gsap11.core.getCache(scroller), isViewport = _isViewport(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : _defaults2.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle3(scroller)["border" + direction.p2 + _Width]) || 0, self2 = this, onRefreshInit = vars.onRefreshInit && function() {
            return vars.onRefreshInit(self2);
          }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, scrollFunc = _getScrollFunc(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, markerEndSetter, cs, snap1, snap22, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevProgress, prevScroll, prevAnimProgress, caMarkerSetter;
          self2.media = _creatingMedia;
          self2._dir = direction;
          anticipatePin *= 45;
          self2.scroller = scroller;
          self2.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
          scroll1 = scrollFunc();
          self2.vars = vars;
          animation = animation || vars.animation;
          "refreshPriority" in vars && (_sort = 1);
          scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
            top: _getTweenCreator(scroller, _vertical),
            left: _getTweenCreator(scroller, _horizontal)
          };
          self2.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
          if (animation) {
            animation.vars.lazy = false;
            animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
            self2.animation = animation.pause();
            animation.scrollTrigger = self2;
            scrubSmooth = _isNumber5(scrub) && scrub;
            scrubSmooth && (scrubTween = gsap11.to(animation, {
              ease: "power3",
              duration: scrubSmooth,
              onComplete: function onComplete() {
                return onScrubComplete && onScrubComplete(self2);
              }
            }));
            snap1 = 0;
            id || (id = animation.vars.id);
          }
          _triggers.push(self2);
          if (snap3) {
            if (!_isObject5(snap3) || snap3.push) {
              snap3 = {
                snapTo: snap3
              };
            }
            "scrollBehavior" in _body5.style && gsap11.set(isViewport ? [_body5, _docEl2] : scroller, {
              scrollBehavior: "auto"
            });
            snapFunc = _isFunction9(snap3.snapTo) ? snap3.snapTo : snap3.snapTo === "labels" ? _getClosestLabel(animation) : snap3.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap3.directional !== false ? function(value, st) {
              return _snapDirectional(snap3.snapTo)(value, st.direction);
            } : gsap11.utils.snap(snap3.snapTo);
            snapDurClamp = snap3.duration || {
              min: 0.1,
              max: 2
            };
            snapDurClamp = _isObject5(snapDurClamp) ? _clamp3(snapDurClamp.min, snapDurClamp.max) : _clamp3(snapDurClamp, snapDurClamp);
            snapDelayedCall = gsap11.delayedCall(snap3.delay || scrubSmooth / 2 || 0.1, function() {
              if (Math.abs(self2.getVelocity()) < 10 && !_pointerIsDown && lastSnap !== scrollFunc()) {
                var totalProgress = animation && !isToggle ? animation.totalProgress() : self2.progress, velocity = (totalProgress - snap22) / (_getTime2() - _time2) * 1e3 || 0, change1 = gsap11.utils.clamp(-self2.progress, 1 - self2.progress, _abs2(velocity / 2) * velocity / 0.185), naturalEnd = self2.progress + (snap3.inertia === false ? 0 : change1), endValue = _clamp3(0, 1, snapFunc(naturalEnd, self2)), scroll = scrollFunc(), endScroll = Math.round(start + endValue * change), _snap = snap3, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete, tween = tweenTo.tween;
                if (scroll <= end && scroll >= start && endScroll !== scroll) {
                  if (tween && !tween._initted && tween.data <= _abs2(endScroll - scroll)) {
                    return;
                  }
                  if (snap3.inertia === false) {
                    change1 = endValue - self2.progress;
                  }
                  tweenTo(endScroll, {
                    duration: snapDurClamp(_abs2(Math.max(_abs2(naturalEnd - totalProgress), _abs2(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                    ease: snap3.ease || "power3",
                    data: _abs2(endScroll - scroll),
                    onInterrupt: function onInterrupt() {
                      return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self2);
                    },
                    onComplete: function onComplete() {
                      self2.update();
                      lastSnap = scrollFunc();
                      snap1 = snap22 = animation && !isToggle ? animation.totalProgress() : self2.progress;
                      onSnapComplete && onSnapComplete(self2);
                      _onComplete && _onComplete(self2);
                    }
                  }, scroll, change1 * change, endScroll - scroll - change1 * change);
                  onStart && onStart(self2, tweenTo.tween);
                }
              } else if (self2.isActive) {
                snapDelayedCall.restart(true);
              }
            }).pause();
          }
          id && (_ids[id] = self2);
          trigger = self2.trigger = _getTarget(trigger || pin);
          pin = pin === true ? trigger : _getTarget(pin);
          _isString9(toggleClass) && (toggleClass = {
            targets: trigger,
            className: toggleClass
          });
          if (pin) {
            pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle3(pin.parentNode).display === "flex" ? false : _padding);
            self2.pin = pin;
            vars.force3D !== false && gsap11.set(pin, {
              force3D: true
            });
            pinCache = gsap11.core.getCache(pin);
            if (!pinCache.spacer) {
              if (pinSpacer) {
                pinSpacer = _getTarget(pinSpacer);
                pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
                pinCache.spacerIsNative = !!pinSpacer;
                pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
              }
              pinCache.spacer = spacer = pinSpacer || _doc6.createElement("div");
              spacer.classList.add("pin-spacer");
              id && spacer.classList.add("pin-spacer-" + id);
              pinCache.pinState = pinOriginalState = _getState(pin);
            } else {
              pinOriginalState = pinCache.pinState;
            }
            self2.spacer = spacer = pinCache.spacer;
            cs = _getComputedStyle3(pin);
            spacingStart = cs[pinSpacing + direction.os2];
            pinGetter = gsap11.getProperty(pin);
            pinSetter = gsap11.quickSetter(pin, direction.a, _px);
            _swapPinIn(pin, spacer, cs);
            pinState = _getState(pin);
          }
          if (markers) {
            markerVars = _isObject5(markers) ? _setDefaults5(markers, _markerDefaults) : _markerDefaults;
            markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
            markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
            offset = markerStartTrigger["offset" + direction.op.d2];
            markerStart = _createMarker("start", id, scroller, direction, markerVars, offset, 0, containerAnimation);
            markerEnd = _createMarker("end", id, scroller, direction, markerVars, offset, 0, containerAnimation);
            containerAnimation && (caMarkerSetter = gsap11.quickSetter([markerStart, markerEnd], direction.a, _px));
            if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
              _makePositionable(isViewport ? _body5 : scroller);
              gsap11.set([markerStartTrigger, markerEndTrigger], {
                force3D: true
              });
              markerStartSetter = gsap11.quickSetter(markerStartTrigger, direction.a, _px);
              markerEndSetter = gsap11.quickSetter(markerEndTrigger, direction.a, _px);
            }
          }
          if (containerAnimation) {
            var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
            containerAnimation.eventCallback("onUpdate", function() {
              self2.update(0, 0, 1);
              oldOnUpdate && oldOnUpdate.apply(oldParams || []);
            });
          }
          self2.previous = function() {
            return _triggers[_triggers.indexOf(self2) - 1];
          };
          self2.next = function() {
            return _triggers[_triggers.indexOf(self2) + 1];
          };
          self2.revert = function(revert) {
            var r = revert !== false || !self2.enabled, prevRefreshing = _refreshing;
            if (r !== self2.isReverted) {
              if (r) {
                self2.scroll.rec || (self2.scroll.rec = scrollFunc());
                prevScroll = Math.max(scrollFunc(), self2.scroll.rec || 0);
                prevProgress = self2.progress;
                prevAnimProgress = animation && animation.progress();
              }
              markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
                return m.style.display = r ? "none" : "block";
              });
              r && (_refreshing = 1);
              self2.update(r);
              _refreshing = prevRefreshing;
              pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self2.isActive) && _swapPinIn(pin, spacer, _getComputedStyle3(pin), spacerState));
              self2.isReverted = r;
            }
          };
          self2.refresh = function(soft, force) {
            if ((_refreshing || !self2.enabled) && !force) {
              return;
            }
            if (pin && soft && _lastScrollTime) {
              _addListener3(ScrollTrigger2, "scrollEnd", _softRefresh);
              return;
            }
            _refreshing = 1;
            scrubTween && scrubTween.pause();
            invalidateOnRefresh && animation && animation.time(-0.01, true).invalidate();
            self2.isReverted || self2.revert();
            var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), offset2 = 0, otherPinOffset = 0, parsedEnd = vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self2)) || 0, i2 = triggerIndex, cs2, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins;
            while (i2--) {
              curTrigger = _triggers[i2];
              curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1);
              curPin = curTrigger.pin;
              if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
                revertedPins || (revertedPins = []);
                revertedPins.unshift(curTrigger);
                curTrigger.revert();
              }
            }
            _isFunction9(parsedStart) && (parsedStart = parsedStart(self2));
            start = _parsePosition3(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -1e-3 : 0);
            _isFunction9(parsedEnd) && (parsedEnd = parsedEnd(self2));
            if (_isString9(parsedEnd) && !parsedEnd.indexOf("+=")) {
              if (~parsedEnd.indexOf(" ")) {
                parsedEnd = (_isString9(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
              } else {
                offset2 = _offsetToPx(parsedEnd.substr(2), size);
                parsedEnd = _isString9(parsedStart) ? parsedStart : start + offset2;
                parsedEndTrigger = trigger;
              }
            }
            end = Math.max(start, _parsePosition3(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset2, markerEnd, markerEndTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -1e-3;
            change = end - start || (start -= 0.01) && 1e-3;
            offset2 = 0;
            i2 = triggerIndex;
            while (i2--) {
              curTrigger = _triggers[i2];
              curPin = curTrigger.pin;
              if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation) {
                cs2 = curTrigger.end - curTrigger.start;
                if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber5(parsedStart)) {
                  offset2 += cs2 * (1 - curTrigger.progress);
                }
                curPin === pin && (otherPinOffset += cs2);
              }
            }
            start += offset2;
            end += offset2;
            self2._pinPush = otherPinOffset;
            if (markerStart && offset2) {
              cs2 = {};
              cs2[direction.a] = "+=" + offset2;
              pinnedContainer && (cs2[direction.p] = "-=" + scrollFunc());
              gsap11.set([markerStart, markerEnd], cs2);
            }
            if (pin) {
              cs2 = _getComputedStyle3(pin);
              isVertical = direction === _vertical;
              scroll = scrollFunc();
              pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
              !max && end > 1 && ((isViewport ? _body5 : scroller).style["overflow-" + direction.a] = "scroll");
              _swapPinIn(pin, spacer, cs2);
              pinState = _getState(pin);
              bounds = _getBounds3(pin, true);
              oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
              if (pinSpacing) {
                spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
                spacerState.t = spacer;
                i2 = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
                i2 && spacerState.push(direction.d, i2 + _px);
                _setState(spacerState);
                useFixedPosition && scrollFunc(prevScroll);
              }
              if (useFixedPosition) {
                override = {
                  top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                  left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                  boxSizing: "border-box",
                  position: "fixed"
                };
                override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
                override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
                override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
                override[_padding] = cs2[_padding];
                override[_padding + _Top] = cs2[_padding + _Top];
                override[_padding + _Right] = cs2[_padding + _Right];
                override[_padding + _Bottom] = cs2[_padding + _Bottom];
                override[_padding + _Left] = cs2[_padding + _Left];
                pinActiveState = _copyState(pinOriginalState, override, pinReparent);
              }
              if (animation) {
                initted = animation._initted;
                _suppressOverwrites2(1);
                animation.render(animation.duration(), true, true);
                pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
                change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2);
                animation.render(0, true, true);
                initted || animation.invalidate();
                _suppressOverwrites2(0);
              } else {
                pinChange = change;
              }
            } else if (trigger && scrollFunc() && !containerAnimation) {
              bounds = trigger.parentNode;
              while (bounds && bounds !== _body5) {
                if (bounds._pinOffset) {
                  start -= bounds._pinOffset;
                  end -= bounds._pinOffset;
                }
                bounds = bounds.parentNode;
              }
            }
            revertedPins && revertedPins.forEach(function(t) {
              return t.revert(false);
            });
            self2.start = start;
            self2.end = end;
            scroll1 = scroll2 = scrollFunc();
            if (!containerAnimation) {
              scroll1 < prevScroll && scrollFunc(prevScroll);
              self2.scroll.rec = 0;
            }
            self2.revert(false);
            _refreshing = 0;
            animation && isToggle && animation._initted && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true);
            if (prevProgress !== self2.progress || containerAnimation) {
              animation && !isToggle && animation.totalProgress(prevProgress, true);
              self2.progress = prevProgress;
              self2.update(0, 0, 1);
            }
            pin && pinSpacing && (spacer._pinOffset = Math.round(self2.progress * pinChange));
            onRefresh && onRefresh(self2);
          };
          self2.getVelocity = function() {
            return (scrollFunc() - scroll2) / (_getTime2() - _time2) * 1e3 || 0;
          };
          self2.endAnimation = function() {
            _endAnimation(self2.callbackAnimation);
            if (animation) {
              scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self2.direction < 0, 1);
            }
          };
          self2.labelToScroll = function(label) {
            return animation && animation.labels && (start || self2.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
          };
          self2.getTrailing = function(name) {
            var i2 = _triggers.indexOf(self2), a = self2.direction > 0 ? _triggers.slice(0, i2).reverse() : _triggers.slice(i2 + 1);
            return _isString9(name) ? a.filter(function(t) {
              return t.vars.preventOverlaps === name;
            }) : a;
          };
          self2.update = function(reset, recordVelocity, forceFake) {
            if (containerAnimation && !forceFake && !reset) {
              return;
            }
            var scroll = self2.scroll(), p2 = reset ? 0 : (scroll - start) / change, clipped = p2 < 0 ? 0 : p2 > 1 ? 1 : p2 || 0, prevProgress2 = self2.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;
            if (recordVelocity) {
              scroll2 = scroll1;
              scroll1 = containerAnimation ? scrollFunc() : scroll;
              if (snap3) {
                snap22 = snap1;
                snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
              }
            }
            anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime2() - _time2) * anticipatePin && (clipped = 1e-4);
            if (clipped !== prevProgress2 && self2.enabled) {
              isActive = self2.isActive = !!clipped && clipped < 1;
              wasActive = !!prevProgress2 && prevProgress2 < 1;
              toggled = isActive !== wasActive;
              stateChanged = toggled || !!clipped !== !!prevProgress2;
              self2.direction = clipped > prevProgress2 ? 1 : -1;
              self2.progress = clipped;
              if (stateChanged && !_refreshing) {
                toggleState = clipped && !prevProgress2 ? 0 : clipped === 1 ? 1 : prevProgress2 === 1 ? 2 : 3;
                if (isToggle) {
                  action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
                  isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
                }
              }
              preventOverlaps && toggled && (isTakingAction || scrub || !animation) && (_isFunction9(preventOverlaps) ? preventOverlaps(self2) : self2.getTrailing(preventOverlaps).forEach(function(t) {
                return t.endAnimation();
              }));
              if (!isToggle) {
                if (scrubTween && !_refreshing && !_startup) {
                  scrubTween.vars.totalProgress = clipped;
                  scrubTween.invalidate().restart();
                } else if (animation) {
                  animation.totalProgress(clipped, !!_refreshing);
                }
              }
              if (pin) {
                reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
                if (!useFixedPosition) {
                  pinSetter(pinStart + pinChange * clipped);
                } else if (stateChanged) {
                  isAtMax = !reset && clipped > prevProgress2 && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
                  if (pinReparent) {
                    if (!reset && (isActive || isAtMax)) {
                      var bounds = _getBounds3(pin, true), _offset2 = scroll - start;
                      _reparent(pin, _body5, bounds.top + (direction === _vertical ? _offset2 : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset2) + _px);
                    } else {
                      _reparent(pin, spacer);
                    }
                  }
                  _setState(isActive || isAtMax ? pinActiveState : pinState);
                  pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
                }
              }
              snap3 && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
              toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray5(toggleClass.targets).forEach(function(el) {
                return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
              });
              onUpdate && !isToggle && !reset && onUpdate(self2);
              if (stateChanged && !_refreshing) {
                if (isToggle) {
                  if (isTakingAction) {
                    if (action === "complete") {
                      animation.pause().totalProgress(1);
                    } else if (action === "reset") {
                      animation.restart(true).pause();
                    } else if (action === "restart") {
                      animation.restart(true);
                    } else {
                      animation[action]();
                    }
                  }
                  onUpdate && onUpdate(self2);
                }
                if (toggled || !_limitCallbacks) {
                  onToggle && toggled && _callback3(self2, onToggle);
                  callbacks[toggleState] && _callback3(self2, callbacks[toggleState]);
                  once && (clipped === 1 ? self2.kill(false, 1) : callbacks[toggleState] = 0);
                  if (!toggled) {
                    toggleState = clipped === 1 ? 1 : 3;
                    callbacks[toggleState] && _callback3(self2, callbacks[toggleState]);
                  }
                }
                if (fastScrollEnd && !isActive && Math.abs(self2.getVelocity()) > (_isNumber5(fastScrollEnd) ? fastScrollEnd : 2500)) {
                  _endAnimation(self2.callbackAnimation);
                  scrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);
                }
              } else if (isToggle && onUpdate && !_refreshing) {
                onUpdate(self2);
              }
            }
            if (markerEndSetter) {
              var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
              markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
              markerEndSetter(n);
            }
            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
          };
          self2.enable = function(reset, refresh) {
            if (!self2.enabled) {
              self2.enabled = true;
              _addListener3(scroller, "resize", _onResize);
              _addListener3(scroller, "scroll", _onScroll);
              onRefreshInit && _addListener3(ScrollTrigger2, "refreshInit", onRefreshInit);
              if (reset !== false) {
                self2.progress = prevProgress = 0;
                scroll1 = scroll2 = lastSnap = scrollFunc();
              }
              refresh !== false && self2.refresh();
            }
          };
          self2.getTween = function(snap4) {
            return snap4 && tweenTo ? tweenTo.tween : scrubTween;
          };
          self2.setPositions = function(newStart, newEnd) {
            if (pin) {
              pinStart += newStart - start;
              pinChange += newEnd - newStart - change;
            }
            self2.start = start = newStart;
            self2.end = end = newEnd;
            change = newEnd - newStart;
            self2.update();
          };
          self2.disable = function(reset, allowAnimation) {
            if (self2.enabled) {
              reset !== false && self2.revert();
              self2.enabled = self2.isActive = false;
              allowAnimation || scrubTween && scrubTween.pause();
              prevScroll = 0;
              pinCache && (pinCache.uncache = 1);
              onRefreshInit && _removeListener3(ScrollTrigger2, "refreshInit", onRefreshInit);
              if (snapDelayedCall) {
                snapDelayedCall.pause();
                tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
              }
              if (!isViewport) {
                var i2 = _triggers.length;
                while (i2--) {
                  if (_triggers[i2].scroller === scroller && _triggers[i2] !== self2) {
                    return;
                  }
                }
                _removeListener3(scroller, "resize", _onResize);
                _removeListener3(scroller, "scroll", _onScroll);
              }
            }
          };
          self2.kill = function(revert, allowAnimation) {
            self2.disable(revert, allowAnimation);
            scrubTween && scrubTween.kill();
            id && delete _ids[id];
            var i2 = _triggers.indexOf(self2);
            i2 >= 0 && _triggers.splice(i2, 1);
            i2 === _i && _direction > 0 && _i--;
            i2 = 0;
            _triggers.forEach(function(t) {
              return t.scroller === self2.scroller && (i2 = 1);
            });
            i2 || (self2.scroll.rec = 0);
            if (animation) {
              animation.scrollTrigger = null;
              revert && animation.render(-1);
              allowAnimation || animation.kill();
            }
            markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
              return m.parentNode && m.parentNode.removeChild(m);
            });
            if (pin) {
              pinCache && (pinCache.uncache = 1);
              i2 = 0;
              _triggers.forEach(function(t) {
                return t.pin === pin && i2++;
              });
              i2 || (pinCache.spacer = 0);
            }
          };
          self2.enable(false, false);
          !animation || !animation.add || change ? self2.refresh() : gsap11.delayedCall(0.01, function() {
            return start || end || self2.refresh();
          }) && (change = 0.01) && (start = end = 0);
        };
        ScrollTrigger2.register = function register4(core) {
          if (!_coreInitted9) {
            gsap11 = core || _getGSAP17();
            if (_windowExists15() && window.document) {
              _win8 = window;
              _doc6 = document;
              _docEl2 = _doc6.documentElement;
              _body5 = _doc6.body;
            }
            if (gsap11) {
              _toArray5 = gsap11.utils.toArray;
              _clamp3 = gsap11.utils.clamp;
              _suppressOverwrites2 = gsap11.core.suppressOverwrites || _passThrough3;
              gsap11.core.globals("ScrollTrigger", ScrollTrigger2);
              if (_body5) {
                _addListener3(_win8, "wheel", _onScroll);
                _root = [_win8, _doc6, _docEl2, _body5];
                _addListener3(_doc6, "scroll", _onScroll);
                var bodyStyle = _body5.style, border = bodyStyle.borderTopStyle, bounds;
                bodyStyle.borderTopStyle = "solid";
                bounds = _getBounds3(_body5);
                _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
                _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
                border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
                _syncInterval = setInterval(_sync, 200);
                gsap11.delayedCall(0.5, function() {
                  return _startup = 0;
                });
                _addListener3(_doc6, "touchcancel", _passThrough3);
                _addListener3(_body5, "touchstart", _passThrough3);
                _multiListener(_addListener3, _doc6, "pointerdown,touchstart,mousedown", function() {
                  return _pointerIsDown = 1;
                });
                _multiListener(_addListener3, _doc6, "pointerup,touchend,mouseup", function() {
                  return _pointerIsDown = 0;
                });
                _transformProp4 = gsap11.utils.checkPrefix("transform");
                _stateProps.push(_transformProp4);
                _coreInitted9 = _getTime2();
                _resizeDelay = gsap11.delayedCall(0.2, _refreshAll).pause();
                _autoRefresh = [_doc6, "visibilitychange", function() {
                  var w = _win8.innerWidth, h = _win8.innerHeight;
                  if (_doc6.hidden) {
                    _prevWidth = w;
                    _prevHeight = h;
                  } else if (_prevWidth !== w || _prevHeight !== h) {
                    _onResize();
                  }
                }, _doc6, "DOMContentLoaded", _refreshAll, _win8, "load", function() {
                  return _lastScrollTime || _refreshAll();
                }, _win8, "resize", _onResize];
                _iterateAutoRefresh(_addListener3);
              }
            }
          }
          return _coreInitted9;
        };
        ScrollTrigger2.defaults = function defaults2(config3) {
          if (config3) {
            for (var p2 in config3) {
              _defaults2[p2] = config3[p2];
            }
          }
          return _defaults2;
        };
        ScrollTrigger2.kill = function kill2() {
          _enabled = 0;
          _triggers.slice(0).forEach(function(trigger) {
            return trigger.kill(1);
          });
        };
        ScrollTrigger2.config = function config3(vars) {
          "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
          var ms = vars.syncInterval;
          ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
          if ("autoRefreshEvents" in vars) {
            _iterateAutoRefresh(_removeListener3) || _iterateAutoRefresh(_addListener3, vars.autoRefreshEvents || "none");
            _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
          }
        };
        ScrollTrigger2.scrollerProxy = function scrollerProxy(target, vars) {
          var t = _getTarget(target), i2 = _scrollers.indexOf(t), isViewport = _isViewport(t);
          if (~i2) {
            _scrollers.splice(i2, isViewport ? 6 : 2);
          }
          if (vars) {
            isViewport ? _proxies.unshift(_win8, vars, _body5, vars, _docEl2, vars) : _proxies.unshift(t, vars);
          }
        };
        ScrollTrigger2.matchMedia = function matchMedia(vars) {
          var mq, p2, i2, func, result;
          for (p2 in vars) {
            i2 = _media.indexOf(p2);
            func = vars[p2];
            _creatingMedia = p2;
            if (p2 === "all") {
              func();
            } else {
              mq = _win8.matchMedia(p2);
              if (mq) {
                mq.matches && (result = func());
                if (~i2) {
                  _media[i2 + 1] = _combineFunc(_media[i2 + 1], func);
                  _media[i2 + 2] = _combineFunc(_media[i2 + 2], result);
                } else {
                  i2 = _media.length;
                  _media.push(p2, func, result);
                  mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
                }
                _media[i2 + 3] = mq.matches;
              }
            }
            _creatingMedia = 0;
          }
          return _media;
        };
        ScrollTrigger2.clearMatchMedia = function clearMatchMedia(query) {
          query || (_media.length = 0);
          query = _media.indexOf(query);
          query >= 0 && _media.splice(query, 4);
        };
        ScrollTrigger2.isInViewport = function isInViewport(element, ratio, horizontal) {
          var bounds = (_isString9(element) ? _getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;
          return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win8.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win8.innerHeight;
        };
        ScrollTrigger2.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
          _isString9(element) && (element = _getTarget(element));
          var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
          return horizontal ? (bounds.left + offset) / _win8.innerWidth : (bounds.top + offset) / _win8.innerHeight;
        };
        return ScrollTrigger2;
      }();
      ScrollTrigger.version = "3.9.1";
      ScrollTrigger.saveStyles = function(targets) {
        return targets ? _toArray5(targets).forEach(function(target) {
          if (target && target.style) {
            var i2 = _savedStyles.indexOf(target);
            i2 >= 0 && _savedStyles.splice(i2, 5);
            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap11.core.getCache(target), _creatingMedia);
          }
        }) : _savedStyles;
      };
      ScrollTrigger.revert = function(soft, media) {
        return _revertAll(!soft, media);
      };
      ScrollTrigger.create = function(vars, animation) {
        return new ScrollTrigger(vars, animation);
      };
      ScrollTrigger.refresh = function(safe) {
        return safe ? _onResize() : (_coreInitted9 || ScrollTrigger.register()) && _refreshAll(true);
      };
      ScrollTrigger.update = _updateAll;
      ScrollTrigger.clearScrollMemory = _clearScrollMemory;
      ScrollTrigger.maxScroll = function(element, horizontal) {
        return _maxScroll(element, horizontal ? _horizontal : _vertical);
      };
      ScrollTrigger.getScrollFunc = function(element, horizontal) {
        return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
      };
      ScrollTrigger.getById = function(id) {
        return _ids[id];
      };
      ScrollTrigger.getAll = function() {
        return _triggers.slice(0);
      };
      ScrollTrigger.isScrolling = function() {
        return !!_lastScrollTime;
      };
      ScrollTrigger.snapDirectional = _snapDirectional;
      ScrollTrigger.addEventListener = function(type, callback) {
        var a = _listeners[type] || (_listeners[type] = []);
        ~a.indexOf(callback) || a.push(callback);
      };
      ScrollTrigger.removeEventListener = function(type, callback) {
        var a = _listeners[type], i2 = a && a.indexOf(callback);
        i2 >= 0 && a.splice(i2, 1);
      };
      ScrollTrigger.batch = function(targets, vars) {
        var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback2(type, callback) {
          var elements = [], triggers = [], delay = gsap11.delayedCall(interval, function() {
            callback(elements, triggers);
            elements = [];
            triggers = [];
          }).pause();
          return function(self2) {
            elements.length || delay.restart(true);
            elements.push(self2.trigger);
            triggers.push(self2);
            batchMax <= elements.length && delay.progress(1);
          };
        }, p2;
        for (p2 in vars) {
          varsCopy[p2] = p2.substr(0, 2) === "on" && _isFunction9(vars[p2]) && p2 !== "onRefreshInit" ? proxyCallback(p2, vars[p2]) : vars[p2];
        }
        if (_isFunction9(batchMax)) {
          batchMax = batchMax();
          _addListener3(ScrollTrigger, "refresh", function() {
            return batchMax = vars.batchMax();
          });
        }
        _toArray5(targets).forEach(function(target) {
          var config3 = {};
          for (p2 in varsCopy) {
            config3[p2] = varsCopy[p2];
          }
          config3.trigger = target;
          result.push(ScrollTrigger.create(config3));
        });
        return result;
      };
      ScrollTrigger.sort = function(func) {
        return _triggers.sort(func || function(a, b) {
          return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
        });
      };
      _getGSAP17() && gsap11.registerPlugin(ScrollTrigger);
    }
  });

  // node_modules/gsap/utils/strings.js
  function getText(e) {
    var type = e.nodeType, result = "";
    if (type === 1 || type === 9 || type === 11) {
      if (typeof e.textContent === "string") {
        return e.textContent;
      } else {
        for (e = e.firstChild; e; e = e.nextSibling) {
          result += getText(e);
        }
      }
    } else if (type === 3 || type === 4) {
      return e.nodeValue;
    }
    return result;
  }
  function splitInnerHTML(element, delimiter, trim, preserveSpaces) {
    var node = element.firstChild, result = [], s;
    while (node) {
      if (node.nodeType === 3) {
        s = (node.nodeValue + "").replace(/^\n+/g, "");
        if (!preserveSpaces) {
          s = s.replace(/\s+/g, " ");
        }
        result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces));
      } else if ((node.nodeName + "").toLowerCase() === "br") {
        result[result.length - 1] += "<br>";
      } else {
        result.push(node.outerHTML);
      }
      node = node.nextSibling;
    }
    s = result.length;
    while (s--) {
      result[s] === "&" && result.splice(s, 1, "&amp;");
    }
    return result;
  }
  function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {
    text += "";
    if (trim) {
      text = text.replace(_trimExp, "");
    }
    if (delimiter && delimiter !== "") {
      return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);
    }
    var result = [], l = text.length, i2 = 0, j, character;
    for (; i2 < l; i2++) {
      character = text.charAt(i2);
      if (character.charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text.charCodeAt(i2 + 1) >= 65024 && text.charCodeAt(i2 + 1) <= 65039) {
        j = ((text.substr(i2, 12).split(emojiExp) || [])[1] || "").length || 2;
        character = text.substr(i2, j);
        result.emoji = 1;
        i2 += j - 1;
      }
      result.push(character === ">" ? "&gt;" : character === "<" ? "&lt;" : preserveSpaces && character === " " && (text.charAt(i2 - 1) === " " || text.charAt(i2 + 1) === " ") ? "&nbsp;" : character);
    }
    return result;
  }
  var _trimExp, emojiExp;
  var init_strings = __esm({
    "node_modules/gsap/utils/strings.js"() {
      _trimExp = /(^\s+|\s+$)/g;
      emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
    }
  });

  // node_modules/gsap/TextPlugin.js
  var gsap12, _tempDiv3, _getGSAP19, TextPlugin;
  var init_TextPlugin = __esm({
    "node_modules/gsap/TextPlugin.js"() {
      init_strings();
      _getGSAP19 = function _getGSAP20() {
        return gsap12 || typeof window !== "undefined" && (gsap12 = window.gsap) && gsap12.registerPlugin && gsap12;
      };
      TextPlugin = {
        version: "3.9.1",
        name: "text",
        init: function init9(target, value, tween) {
          var i2 = target.nodeName.toUpperCase(), data = this, _short, text, original, j, condensedText, condensedOriginal, aggregate, s;
          data.svg = target.getBBox && (i2 === "TEXT" || i2 === "TSPAN");
          if (!("innerHTML" in target) && !data.svg) {
            return false;
          }
          data.target = target;
          if (typeof value !== "object") {
            value = {
              value
            };
          }
          if (!("value" in value)) {
            data.text = data.original = [""];
            return;
          }
          data.delimiter = value.delimiter || "";
          original = splitInnerHTML(target, data.delimiter, false, value.preserveSpaces);
          if (!_tempDiv3) {
            _tempDiv3 = document.createElement("div");
          }
          _tempDiv3.innerHTML = value.value;
          text = splitInnerHTML(_tempDiv3, data.delimiter);
          data.from = tween._from;
          if (data.from) {
            i2 = original;
            original = text;
            text = i2;
          }
          data.hasClass = !!(value.newClass || value.oldClass);
          data.newClass = value.newClass;
          data.oldClass = value.oldClass;
          i2 = original.length - text.length;
          _short = i2 < 0 ? original : text;
          data.fillChar = value.fillChar || (value.padSpace ? "&nbsp;" : "");
          if (i2 < 0) {
            i2 = -i2;
          }
          while (--i2 > -1) {
            _short.push(data.fillChar);
          }
          if (value.type === "diff") {
            j = 0;
            condensedText = [];
            condensedOriginal = [];
            aggregate = "";
            for (i2 = 0; i2 < text.length; i2++) {
              s = text[i2];
              if (s === original[i2]) {
                aggregate += s;
              } else {
                condensedText[j] = aggregate + s;
                condensedOriginal[j++] = aggregate + original[i2];
                aggregate = "";
              }
            }
            text = condensedText;
            original = condensedOriginal;
            if (aggregate) {
              text.push(aggregate);
              original.push(aggregate);
            }
          }
          if (value.speed) {
            tween.duration(Math.min(0.05 / value.speed * _short.length, value.maxDuration || 9999));
          }
          this.original = original;
          this.text = text;
          this._props.push("text");
        },
        render: function render5(ratio, data) {
          if (ratio > 1) {
            ratio = 1;
          } else if (ratio < 0) {
            ratio = 0;
          }
          if (data.from) {
            ratio = 1 - ratio;
          }
          var text = data.text, hasClass = data.hasClass, newClass = data.newClass, oldClass = data.oldClass, delimiter = data.delimiter, target = data.target, fillChar = data.fillChar, original = data.original, l = text.length, i2 = ratio * l + 0.5 | 0, applyNew, applyOld, str;
          if (hasClass && ratio) {
            applyNew = newClass && i2;
            applyOld = oldClass && i2 !== l;
            str = (applyNew ? "<span class='" + newClass + "'>" : "") + text.slice(0, i2).join(delimiter) + (applyNew ? "</span>" : "") + (applyOld ? "<span class='" + oldClass + "'>" : "") + delimiter + original.slice(i2).join(delimiter) + (applyOld ? "</span>" : "");
          } else {
            str = text.slice(0, i2).join(delimiter) + delimiter + original.slice(i2).join(delimiter);
          }
          if (data.svg) {
            target.textContent = str;
          } else {
            target.innerHTML = fillChar === "&nbsp;" && ~str.indexOf("  ") ? str.split("  ").join("&nbsp;&nbsp;") : str;
          }
        }
      };
      TextPlugin.splitInnerHTML = splitInnerHTML;
      TextPlugin.emojiSafeSplit = emojiSafeSplit;
      TextPlugin.getText = getText;
      _getGSAP19() && gsap12.registerPlugin(TextPlugin);
    }
  });

  // node_modules/gsap/all.js
  var gsapWithCSS, TweenMaxWithCSS;
  var init_all = __esm({
    "node_modules/gsap/all.js"() {
      init_gsap_core();
      init_CSSPlugin();
      init_CustomEase();
      init_CSSRulePlugin();
      init_Draggable();
      init_EaselPlugin();
      init_EasePack();
      init_Flip();
      init_MotionPathPlugin();
      init_PixiPlugin();
      init_ScrollToPlugin();
      init_ScrollTrigger();
      init_TextPlugin();
      gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
      TweenMaxWithCSS = gsapWithCSS.core.Tween;
    }
  });

  // node_modules/three/examples/jsm/curves/NURBSUtils.js
  function findSpan(p2, u, U) {
    const n = U.length - p2 - 1;
    if (u >= U[n]) {
      return n - 1;
    }
    if (u <= U[p2]) {
      return p2;
    }
    let low = p2;
    let high = n;
    let mid = Math.floor((low + high) / 2);
    while (u < U[mid] || u >= U[mid + 1]) {
      if (u < U[mid]) {
        high = mid;
      } else {
        low = mid;
      }
      mid = Math.floor((low + high) / 2);
    }
    return mid;
  }
  function calcBasisFunctions(span, u, p2, U) {
    const N = [];
    const left = [];
    const right = [];
    N[0] = 1;
    for (let j = 1; j <= p2; ++j) {
      left[j] = u - U[span + 1 - j];
      right[j] = U[span + j] - u;
      let saved = 0;
      for (let r = 0; r < j; ++r) {
        const rv = right[r + 1];
        const lv = left[j - r];
        const temp = N[r] / (rv + lv);
        N[r] = saved + rv * temp;
        saved = lv * temp;
      }
      N[j] = saved;
    }
    return N;
  }
  function calcBSplinePoint(p2, U, P, u) {
    const span = findSpan(p2, u, U);
    const N = calcBasisFunctions(span, u, p2, U);
    const C = new Vector4(0, 0, 0, 0);
    for (let j = 0; j <= p2; ++j) {
      const point = P[span - p2 + j];
      const Nj = N[j];
      const wNj = point.w * Nj;
      C.x += point.x * wNj;
      C.y += point.y * wNj;
      C.z += point.z * wNj;
      C.w += point.w * Nj;
    }
    return C;
  }
  function calcBasisFunctionDerivatives(span, u, p2, n, U) {
    const zeroArr = [];
    for (let i2 = 0; i2 <= p2; ++i2)
      zeroArr[i2] = 0;
    const ders = [];
    for (let i2 = 0; i2 <= n; ++i2)
      ders[i2] = zeroArr.slice(0);
    const ndu = [];
    for (let i2 = 0; i2 <= p2; ++i2)
      ndu[i2] = zeroArr.slice(0);
    ndu[0][0] = 1;
    const left = zeroArr.slice(0);
    const right = zeroArr.slice(0);
    for (let j = 1; j <= p2; ++j) {
      left[j] = u - U[span + 1 - j];
      right[j] = U[span + j] - u;
      let saved = 0;
      for (let r2 = 0; r2 < j; ++r2) {
        const rv = right[r2 + 1];
        const lv = left[j - r2];
        ndu[j][r2] = rv + lv;
        const temp = ndu[r2][j - 1] / ndu[j][r2];
        ndu[r2][j] = saved + rv * temp;
        saved = lv * temp;
      }
      ndu[j][j] = saved;
    }
    for (let j = 0; j <= p2; ++j) {
      ders[0][j] = ndu[j][p2];
    }
    for (let r2 = 0; r2 <= p2; ++r2) {
      let s1 = 0;
      let s2 = 1;
      const a = [];
      for (let i2 = 0; i2 <= p2; ++i2) {
        a[i2] = zeroArr.slice(0);
      }
      a[0][0] = 1;
      for (let k = 1; k <= n; ++k) {
        let d = 0;
        const rk = r2 - k;
        const pk = p2 - k;
        if (r2 >= k) {
          a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
          d = a[s2][0] * ndu[rk][pk];
        }
        const j1 = rk >= -1 ? 1 : -rk;
        const j2 = r2 - 1 <= pk ? k - 1 : p2 - r2;
        for (let j3 = j1; j3 <= j2; ++j3) {
          a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
          d += a[s2][j3] * ndu[rk + j3][pk];
        }
        if (r2 <= pk) {
          a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];
          d += a[s2][k] * ndu[r2][pk];
        }
        ders[k][r2] = d;
        const j = s1;
        s1 = s2;
        s2 = j;
      }
    }
    let r = p2;
    for (let k = 1; k <= n; ++k) {
      for (let j = 0; j <= p2; ++j) {
        ders[k][j] *= r;
      }
      r *= p2 - k;
    }
    return ders;
  }
  function calcBSplineDerivatives(p2, U, P, u, nd) {
    const du = nd < p2 ? nd : p2;
    const CK = [];
    const span = findSpan(p2, u, U);
    const nders = calcBasisFunctionDerivatives(span, u, p2, du, U);
    const Pw = [];
    for (let i2 = 0; i2 < P.length; ++i2) {
      const point = P[i2].clone();
      const w = point.w;
      point.x *= w;
      point.y *= w;
      point.z *= w;
      Pw[i2] = point;
    }
    for (let k = 0; k <= du; ++k) {
      const point = Pw[span - p2].clone().multiplyScalar(nders[k][0]);
      for (let j = 1; j <= p2; ++j) {
        point.add(Pw[span - p2 + j].clone().multiplyScalar(nders[k][j]));
      }
      CK[k] = point;
    }
    for (let k = du + 1; k <= nd + 1; ++k) {
      CK[k] = new Vector4(0, 0, 0);
    }
    return CK;
  }
  function calcKoverI(k, i2) {
    let nom = 1;
    for (let j = 2; j <= k; ++j) {
      nom *= j;
    }
    let denom = 1;
    for (let j = 2; j <= i2; ++j) {
      denom *= j;
    }
    for (let j = 2; j <= k - i2; ++j) {
      denom *= j;
    }
    return nom / denom;
  }
  function calcRationalCurveDerivatives(Pders) {
    const nd = Pders.length;
    const Aders = [];
    const wders = [];
    for (let i2 = 0; i2 < nd; ++i2) {
      const point = Pders[i2];
      Aders[i2] = new Vector3(point.x, point.y, point.z);
      wders[i2] = point.w;
    }
    const CK = [];
    for (let k = 0; k < nd; ++k) {
      const v = Aders[k].clone();
      for (let i2 = 1; i2 <= k; ++i2) {
        v.sub(CK[k - i2].clone().multiplyScalar(calcKoverI(k, i2) * wders[i2]));
      }
      CK[k] = v.divideScalar(wders[0]);
    }
    return CK;
  }
  function calcNURBSDerivatives(p2, U, P, u, nd) {
    const Pders = calcBSplineDerivatives(p2, U, P, u, nd);
    return calcRationalCurveDerivatives(Pders);
  }
  var init_NURBSUtils = __esm({
    "node_modules/three/examples/jsm/curves/NURBSUtils.js"() {
      init_three_module();
    }
  });

  // node_modules/three/examples/jsm/curves/NURBSCurve.js
  var NURBSCurve;
  var init_NURBSCurve = __esm({
    "node_modules/three/examples/jsm/curves/NURBSCurve.js"() {
      init_three_module();
      init_NURBSUtils();
      NURBSCurve = class extends Curve {
        constructor(degree, knots, controlPoints, startKnot, endKnot) {
          super();
          this.degree = degree;
          this.knots = knots;
          this.controlPoints = [];
          this.startKnot = startKnot || 0;
          this.endKnot = endKnot || this.knots.length - 1;
          for (let i2 = 0; i2 < controlPoints.length; ++i2) {
            const point = controlPoints[i2];
            this.controlPoints[i2] = new Vector4(point.x, point.y, point.z, point.w);
          }
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]);
          const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
          if (hpoint.w !== 1) {
            hpoint.divideScalar(hpoint.w);
          }
          return point.set(hpoint.x, hpoint.y, hpoint.z);
        }
        getTangent(t, optionalTarget = new Vector3()) {
          const tangent = optionalTarget;
          const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
          const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
          tangent.copy(ders[1]).normalize();
          return tangent;
        }
      };
    }
  });

  // src/js/core/Globals.ts
  var IS_DEV, SHOW_LIFECYCLE_BUTTONS, SITE_PARAMS, GL_ELEMENTS, ANIMATIONS, CURVES_DATA;
  var init_Globals = __esm({
    "src/js/core/Globals.ts"() {
      IS_DEV = false;
      SHOW_LIFECYCLE_BUTTONS = IS_DEV ? false : false;
      SITE_PARAMS = {
        wh: window.innerHeight,
        ww: window.innerWidth,
        mouse: {
          x: 0,
          y: 0
        },
        scroll: {
          speed: 0,
          y: 0
        }
      };
      GL_ELEMENTS = {
        scene: null,
        orthoScene: null
      };
      ANIMATIONS = {
        cameraTilt: {
          active: true,
          ease: 0.05,
          x: 70,
          y: 40
        },
        image: {
          active: true
        },
        window: {
          active: true,
          tilt: false,
          ease: 0.05,
          force: 0.1
        },
        scroll: {
          active: true,
          ease: 0.1,
          image: 0.98,
          window: 0.99
        }
      };
      CURVES_DATA = {
        "curves": [
          { "type": "NURBS", "points": [{ "x": -4.860988140106201, "y": -0.7323960065841675, "z": 1.20608651638031 }, { "x": -0.0789170041680336, "y": 1.4759081602096558, "z": 4.164191246032715 }, { "x": 1.46574866771698, "y": 1.0716938972473145, "z": 0.5001409649848938 }, { "x": -2.6652450561523438, "y": -1.3993984460830688, "z": -3.645242929458618 }, { "x": 3.595470428466797, "y": -1.7366470098495483, "z": -1.6189199686050415 }] }
        ]
      };
    }
  });

  // src/glsl/background.vert
  var background_default;
  var init_background = __esm({
    "src/glsl/background.vert"() {
      background_default = "uniform float time;\n\nvarying vec2 vUv;\n\nvoid main(){\n	vUv = uv; \n\n	vec4 newPosition=modelViewMatrix*vec4(position,1.);\n	gl_Position=projectionMatrix*newPosition;\n}";
    }
  });

  // src/glsl/background.frag
  var background_default2;
  var init_background2 = __esm({
    "src/glsl/background.frag"() {
      background_default2 = "precision highp float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\n\nuniform vec2 u_mouse;\nuniform float u_mouse_size;\nuniform bool u_show_lines;\n\nuniform float u_time_multiplier;\n\nvarying vec2 vUv; \n\n#define PI 3.1415926535897932384626433832795\n\nfloat plot(vec2 uv,float pct,float thickness){\n	return smoothstep(pct-thickness,pct,uv.y)-\n	smoothstep(pct,pct+thickness,uv.y);\n}\n\nfloat rand(vec2 co){\n	return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat dithering(vec2 st,float intensity){\n	return mix(-intensity / 255.,intensity / 255.,rand(st));\n}\n\nvoid main(){\n\n	// VARS\n	vec2 uv=vUv;\n	\n	vec2 mouse = u_mouse;\n\n	float t = u_time*u_time_multiplier;\n	\n	vec3 c1=u_color1;\n	vec3 c2=u_color2;\n	vec3 c3=u_color3;\n\n	float thickness=u_show_lines?.02:.7;\n\n	// MOUSE\n	float uvX = uv.x * u_resolution.x/u_resolution.y;\n	float mx = mouse.x * u_resolution.x/u_resolution.y;\n	float distanceVal = 1. - distance(vec2(uvX, uv.y), vec2(mx, mouse.y));\n	float d = u_mouse_size;\n	float dVal = smoothstep(1.- d, 1., distanceVal);\n	\n	// LINE 1\n	float y1=.5;\n	y1+=sin(.600*PI*uv.x+t*.05 + dVal)*.2;\n	y1+=sin(.744*PI*uv.x+t)*.07;\n	y1=plot(uv,y1,thickness);\n	y1=smoothstep(0.,1.,y1);\n	\n	// LINE 2\n	float y2=.5;\n	y2+=sin(.400*PI*uv.x+t*-1.)*.01;\n	y2+=sin(.484*PI*uv.x+t*.2+dVal)*.3;\n	y2=plot(uv,y2,thickness);\n	y2=smoothstep(0.,1.,y2);\n	\n\n	// DITHERING\n	y2+=dithering(uv, 10.);\n		\n	// MIX COLORS\n	vec3 color=mix(c1,c3,y1);\n	color=mix(color,c2,y2);\n\n	// SHOW LINES\n	if(u_show_lines){\n		color = vec3(y1 + y2 + dVal);\n	}\n\n	\n	gl_FragColor=vec4(color,1.);\n}";
    }
  });

  // src/glsl/particle.vert
  var particle_default;
  var init_particle = __esm({
    "src/glsl/particle.vert"() {
      particle_default = "precision highp float;\n\nattribute vec3 position;\nattribute float opacity;\nattribute float pSize;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float scale;\nuniform float size;\nuniform float globalOpacity;\n\nvarying float vOpacity;\n\nvarying float z;\n\nvoid main () {\n	vec3 p = position;\n\n	z = p.z;\n\n	vOpacity = opacity * globalOpacity;\n\n	vec4 mvPos = modelViewMatrix * vec4(p, 1.0);\n	// gl_PointSize = scale * opacity * size / (-mvPos.z);\n	gl_PointSize = pSize * scale * size / (-mvPos.z);\n	gl_Position = projectionMatrix * mvPos;\n}";
    }
  });

  // src/glsl/particle.frag
  var particle_default2;
  var init_particle2 = __esm({
    "src/glsl/particle.frag"() {
      particle_default2 = "precision highp float;\n\nuniform vec3 color;\nvarying float vOpacity;\nvarying float z;\n\nuniform sampler2D mask;\nuniform vec2 resolution;\n\nvoid main() {\n    if(vOpacity < .01) discard;\n\n	vec2 st = vec2(-1.) + 2.0 * gl_PointCoord.xy;\n	float d = 1.0 - distance(st, vec2(0.));\n\n	vec2 uv = gl_FragCoord.xy / resolution;\n	float m = texture2D(mask, uv).r;\n\n	if(z<0.0 && m < .9) discard;\n\n	/* if (glow) {\n		d = smoothstep(0., .5, d);\n	} else {\n		// sharper dot\n		d = smoothstep(0., .1, d);\n	} */\n\n    d = smoothstep(0., .8, d);\n\n	gl_FragColor = vec4(color, .5*d*vOpacity);\n}";
    }
  });

  // src/js/core/ShaderLib.ts
  var BEAM, NURBS, PARTICLES, PARTICLES_PRESETS, WINDOW_OPTIONS, H_MAT, H_MAT2, P_MAT, PARTICLES_MAT, WIN_MAT, MASK_MAT, BG_MAT, IMAGE_MAT;
  var init_ShaderLib = __esm({
    "src/js/core/ShaderLib.ts"() {
      init_three_module();
      init_background();
      init_background2();
      init_particle();
      init_particle2();
      init_three_module();
      init_three_module();
      BEAM = {
        scale: 58,
        drag: {
          min: 0.1,
          max: 0.5
        },
        scaleFactor: 0.2,
        size: 0.7,
        speed: 1,
        direction: 0,
        mirror: true
      };
      NURBS = {
        degree: 3
      };
      PARTICLES = {
        scale: 120,
        max: 512,
        rate: 1,
        interval: 1
      };
      PARTICLES_PRESETS = [
        {
          name: "Calm",
          speed: 0.15,
          drag: {
            min: 0.01,
            max: 0.1
          },
          max: PARTICLES.max,
          rate: PARTICLES.rate,
          interval: 8
        },
        {
          name: "Medium",
          speed: 0.75,
          drag: {
            min: 0.1,
            max: 0.5
          },
          max: PARTICLES.max,
          rate: PARTICLES.rate,
          interval: PARTICLES.interval
        },
        {
          name: "Fast",
          speed: 2.5,
          drag: {
            min: 0.1,
            max: 0.5
          },
          max: PARTICLES.max,
          rate: PARTICLES.rate,
          interval: PARTICLES.interval
        },
        {
          name: "Funky",
          speed: 3.5,
          drag: {
            min: 0.01,
            max: 0.1
          },
          max: PARTICLES.max,
          rate: 2,
          interval: PARTICLES.interval
        },
        {
          name: "Reset",
          speed: BEAM.speed,
          drag: BEAM.drag,
          max: PARTICLES.max,
          rate: PARTICLES.rate,
          interval: PARTICLES.interval
        }
      ];
      WINDOW_OPTIONS = {
        opacity: 0.37,
        color: 16777215
      };
      H_MAT = new LineBasicMaterial({
        color: 10066329
      });
      H_MAT2 = new LineBasicMaterial({
        color: 13369344,
        opacity: 0.25,
        transparent: true
      });
      P_MAT = new PointsMaterial({
        color: 0,
        sizeAttenuation: false,
        size: 5
      });
      PARTICLES_MAT = new RawShaderMaterial({
        vertexShader: particle_default,
        fragmentShader: particle_default2,
        uniforms: {
          color: { value: new Color(16777215) },
          size: { value: 150 },
          scale: { value: 150 },
          globalOpacity: { value: 0.5 },
          mask: { value: null },
          resolution: { value: new Vector2() }
        },
        transparent: true,
        depthWrite: false,
        depthTest: false,
        blending: AdditiveBlending
      });
      WIN_MAT = new MeshBasicMaterial({
        color: WINDOW_OPTIONS.color,
        opacity: WINDOW_OPTIONS.opacity,
        transparent: true
      });
      MASK_MAT = new MeshBasicMaterial({
        color: 16777215
      });
      BG_MAT = new ShaderMaterial({
        uniforms: {
          u_color1: { value: new Color() },
          u_color2: { value: new Color() },
          u_color3: { value: new Color() },
          u_time: { value: 0 },
          u_time_multiplier: { value: 1.3 },
          u_show_lines: { value: false },
          u_mouse: { value: new Vector2() },
          u_mouse_size: { value: 0 },
          u_resolution: { value: new Vector2() }
        },
        vertexShader: background_default,
        fragmentShader: background_default2
      });
      IMAGE_MAT = new MeshBasicMaterial({
        transparent: true
      });
    }
  });

  // src/js/phy/CustomParticle.ts
  var import_math2, import_phy, CustomParticle;
  var init_CustomParticle = __esm({
    "src/js/phy/CustomParticle.ts"() {
      import_math2 = __toESM(require_main());
      import_phy = __toESM(require_main2());
      init_ShaderLib();
      CustomParticle = class extends import_phy.Particle {
        constructor(id = 0, _path, speed = 1) {
          super(id);
          this.t = 0;
          this.opacity = 0;
          this.pSize = 1;
          this.offset = null;
          this.path = _path;
          this.drag = import_math2.Random.randf(BEAM.drag.min, BEAM.drag.max);
          this.pSize = import_math2.Random.randf(BEAM.scaleFactor, 1);
          this.pSize *= BEAM.size;
          this.offset = new import_math2.Vec(import_math2.Random.randf(-1, 1), import_math2.Random.randf(-1, 1), import_math2.Random.randf(-1, 1));
          this.offset.scale(BEAM.scale);
          this.t = BEAM.direction ? 0 : 1;
          this.dt = import_math2.Random.randf(speed * 0.5, speed) / PARTICLES.max;
          const pt = this.path.getPoint(this.t);
          pt.x += this.offset.x;
          pt.y += this.offset.y;
          pt.z += this.offset.z;
          this.setPosition(pt.x, pt.y, pt.z);
        }
        updateT(dt) {
          if (BEAM.direction === 1) {
            this.t = Math.min(1, this.t + this.dt * dt);
          } else {
            this.t = Math.max(0, this.t - this.dt * dt);
          }
          if (this.t < 0.25) {
            this.opacity = import_math2.MathUtils.smoothstep(0, 0.25, this.t);
          } else if (this.t > 0.75) {
            this.opacity = 1 - import_math2.MathUtils.smoothstep(0.75, 1, this.t);
          } else {
            this.opacity = 1;
          }
        }
      };
    }
  });

  // src/js/phy/CustomEmitter.ts
  var import_math3, import_phy2, CustomEmitter;
  var init_CustomEmitter = __esm({
    "src/js/phy/CustomEmitter.ts"() {
      import_math3 = __toESM(require_main());
      import_phy2 = __toESM(require_main2());
      init_CustomParticle();
      init_ShaderLib();
      CustomEmitter = class extends import_phy2.Emitter {
        constructor(physics, options = {}, paths, speed = 1) {
          super(physics, options);
          this.paths = [];
          this.speed = 1;
          this.speed = speed;
          this.paths = paths;
        }
        create() {
          const path = this.paths[import_math3.Random.randi(0, this.paths.length - 1)];
          return new CustomParticle(this.id++, path, BEAM.speed);
        }
      };
    }
  });

  // src/js/phy/PathSteering.ts
  var import_math4, import_phy3, targetDt, PathSteering;
  var init_PathSteering = __esm({
    "src/js/phy/PathSteering.ts"() {
      import_math4 = __toESM(require_main());
      import_phy3 = __toESM(require_main2());
      init_three_module();
      init_ShaderLib();
      targetDt = 100 / 6;
      PathSteering = class extends import_phy3.Behaviour {
        constructor() {
          super();
          this.tmp = new import_math4.Vec();
          this.target = new Vector3();
          this.time = 0;
          this.dt = 0;
          this.time = performance.now();
        }
        prepare() {
          const t = performance.now();
          this.dt = t - this.time;
          this.time = t;
          this.dt /= targetDt;
        }
        apply(particle) {
          particle.path.getPoint(particle.t, this.target);
          this.target.x += particle.offset.x;
          this.target.y += particle.offset.y;
          this.target.z += particle.offset.z;
          this.tmp.x = this.target.x - particle.position.x;
          this.tmp.y = this.target.y - particle.position.y;
          this.tmp.z = this.target.z - particle.position.z;
          particle.force.add(this.tmp.scale(0.1));
          if (particle.t === BEAM.direction) {
            particle.state = 3;
          }
          particle.updateT(this.dt);
        }
      };
    }
  });

  // src/js/components/Section.ts
  var import_math5, import_phy4, import_tweakpane, CHROME_FIX, GRADIENT_PRESETS, ANIMATION_TOGGLES, ANIMATION_PRESETS_TITLES, ANIMATION_PRESETS, Section;
  var init_Section = __esm({
    "src/js/components/Section.ts"() {
      import_math5 = __toESM(require_main());
      import_phy4 = __toESM(require_main2());
      init_all();
      init_three_module();
      init_NURBSCurve();
      import_tweakpane = __toESM(require_tweakpane());
      init_Globals();
      init_ShaderLib();
      init_CustomEmitter();
      init_PathSteering();
      CHROME_FIX = {
        easeIn: 0.9,
        easeOut: 0.2,
        maxSpeed: 50,
        speed: 0
      };
      GRADIENT_PRESETS = [
        {
          color1: "#F38181",
          color2: "#F8C18E",
          color3: "#83DDCB"
        },
        {
          color1: "#83DDCB",
          color2: "#6BB29E",
          color3: "#83CB9C"
        },
        {
          color1: "#83CB9C",
          color2: "#4DBA8C",
          color3: "#FFC27D"
        },
        {
          color1: "#FFC27D",
          color2: "#EF9655",
          color3: "#ED7C7C"
        },
        {
          color1: "#F6BB77",
          color2: "#FF9C82",
          color3: "#EB7086"
        }
      ];
      ANIMATION_TOGGLES = {
        opacityWindow: true,
        scaleWindow: true,
        translateWindow: true,
        translateRangeWindow: { x: 0, y: 0 },
        rotationWindow: true,
        rotationRangeWindow: 0,
        easeWindow: "power2.inOut",
        durationWindow: 3,
        delayWindow: 0,
        opacityImage: true,
        scaleImage: true,
        translateImage: true,
        translateRangeImage: { x: 0, y: 0 },
        rotationImage: true,
        rotationRangeImage: 0,
        easeImage: "power2.inOut",
        durationImage: 3,
        delayImage: 0
      };
      ANIMATION_PRESETS_TITLES = [
        "Default",
        "1",
        "2",
        "3",
        "Funky"
      ];
      ANIMATION_PRESETS = [
        {
          opacityWindow: true,
          scaleWindow: true,
          translateWindow: true,
          translateRangeWindow: { x: 0, y: 0 },
          rotationWindow: true,
          rotationRangeWindow: 0,
          easeWindow: "power2.inOut",
          durationWindow: 3,
          delayWindow: 0,
          opacityImage: true,
          scaleImage: true,
          translateImage: true,
          translateRangeImage: { x: 0, y: 0 },
          rotationImage: true,
          rotationRangeImage: 0,
          easeImage: "power2.inOut",
          durationImage: 3,
          delayImage: 0
        },
        {
          opacityWindow: false,
          scaleWindow: false,
          translateWindow: false,
          translateRangeWindow: { x: 0, y: 0 },
          rotationWindow: true,
          rotationRangeWindow: 180,
          easeWindow: "power2.inOut",
          durationWindow: 2,
          delayWindow: 0,
          opacityImage: true,
          scaleImage: false,
          translateImage: true,
          translateRangeImage: { x: -2, y: 0 },
          easeImage: "power2.out",
          durationImage: 1.5,
          delayImage: 1
        },
        {
          translateWindow: false,
          rotationRangeWindow: -45,
          easeWindow: "power3.inOut",
          durationWindow: 2.5,
          translateRangeImage: { x: 0, y: -10 },
          rotationRangeImage: 15,
          easeImage: "power1.inOut",
          durationImage: 2.5
        },
        {
          scaleWindow: false,
          translateRangeWindow: { x: 0, y: 10 },
          rotationWindow: false,
          easeWindow: "power2.out",
          durationWindow: 2,
          scaleImage: false,
          translateRangeImage: { x: 0, y: -2 },
          rotationImage: false,
          easeImage: "power2.out",
          durationImage: 2
        },
        {
          translateRangeWindow: { x: 0, y: -50 },
          rotationRangeWindow: -360,
          easeWindow: "power4.inOut",
          durationWindow: 2.5,
          opacityImage: false,
          translateRangeImage: { x: 0, y: -10 },
          rotationRangeImage: 15,
          easeImage: "power3.inOut",
          durationImage: 2.5
        }
      ];
      Section = class {
        constructor(dom) {
          this.active = false;
          this.transition = {
            inProgress: false,
            complete: false,
            window: {
              opacity: 0,
              rotation: 0,
              translate: 0,
              scale: 0
            },
            image: {
              opacity: 0,
              rotation: 0,
              translate: 0,
              scale: 0
            }
          };
          this.group = new Group();
          this.particlesGroup = new Group();
          this.phy = null;
          this.speed = 0;
          this.pane = null;
          this.disposeInProgress = false;
          this.animationToggles = null;
          this.dom = dom;
          this.refresh();
          this.getParameters();
          this.start();
        }
        start() {
          if (this.params.color1 && this.params.color2 && this.params.color3)
            this.createBackground();
          if (this.params.particles) {
            this.createWindow();
          }
          if (this.params.image)
            this.createImage();
          GL_ELEMENTS.scene.add(this.group);
          if (this.dom.hasAttribute("data-webgl-dev"))
            this.devPane();
          this.resetAnimation();
        }
        devPane() {
          return;
          this.pane = new import_tweakpane.Pane();
          const pane = this.pane;
          pane.containerElem_.style.zIndex = 999;
          pane.containerElem_.style.width = "350px";
          pane.containerElem_.style.position = "fixed";
          this.pane.addButton({
            title: "Export"
          }).on("click", () => {
            const exp = this.pane.exportPreset();
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exp));
            var dlAnchorElem = document.getElementById("downloadAnchorElem");
            dlAnchorElem.setAttribute("href", dataStr);
            dlAnchorElem.setAttribute("download", "settings_kids-and-us.json");
            dlAnchorElem.click();
          });
          this.pane.addSeparator();
          this.devBackground();
          this.pane.addSeparator();
          this.devCamera();
          this.pane.addSeparator();
          this.devImage();
          this.pane.addSeparator();
          this.devWindow();
          this.pane.addSeparator();
          this.devParticles();
          this.pane.addSeparator();
          this.devAnimation();
        }
        devBackground() {
          if (!this.bgMesh)
            return;
          const folder = this.pane.addFolder({
            title: "Background",
            expanded: false
          });
          const tabs = folder.addTab({
            pages: [
              { title: "Settings" },
              { title: "Presets" }
            ]
          });
          const tab0 = tabs.pages[0];
          tab0.addInput(this.params, "timeMulti", {
            label: "Speed",
            min: 0,
            max: 10
          }).on("change", (ev) => {
            this.bgMesh.material.uniforms.u_time_multiplier.value = ev.value;
          });
          tab0.addInput(this.params, "mouseSize", {
            label: "Mouse Area",
            min: 0,
            max: 1
          }).on("change", (ev) => {
            this.bgMesh.material.uniforms.u_mouse_size.value = ev.value;
          });
          tab0.addInput(this.params, "mouseEase", {
            label: "Mouse Ease",
            min: 0.05,
            max: 1
          }).on("change", (ev) => {
            this.params.mouseEase = ev.value;
          });
          tab0.addInput(this.params, "showLines", {
            label: "Show Lines"
          }).on("change", (ev) => {
            this.bgMesh.material.uniforms.u_show_lines.value = ev.value;
          });
          tab0.addInput(this.params, "color1", {
            label: "Color 1"
          }).on("change", (ev) => {
            this.bgMesh.material.uniforms.u_color1.value = new Color(ev.value);
          });
          tab0.addInput(this.params, "color2", {
            label: "Color 2"
          }).on("change", (ev) => {
            this.bgMesh.material.uniforms.u_color2.value = new Color(ev.value);
          });
          tab0.addInput(this.params, "color3", {
            label: "Color 3"
          }).on("change", (ev) => {
            this.bgMesh.material.uniforms.u_color3.value = new Color(ev.value);
          });
          const tab1 = tabs.pages[1];
          let i2 = 0;
          for (const item of GRADIENT_PRESETS) {
            i2++;
            tab1.addButton({
              title: `Preset ${i2}`
            }).on("click", () => {
              this.params.color1 = item.color1;
              this.params.color2 = item.color2;
              this.params.color3 = item.color3;
              this.bgMesh.material.uniforms.u_color1.value = new Color(item.color1);
              this.bgMesh.material.uniforms.u_color2.value = new Color(item.color2);
              this.bgMesh.material.uniforms.u_color3.value = new Color(item.color3);
              this.pane.refresh();
            });
          }
        }
        devCamera() {
          const folder = this.pane.addFolder({
            title: "Camera",
            expanded: false
          });
          folder.addInput(ANIMATIONS.cameraTilt, "active", {
            label: "Active Camera"
          });
          folder.addInput(ANIMATIONS.cameraTilt, "ease", {
            label: "Camera Ease",
            min: 0.01,
            max: 0.99
          });
          folder.addInput(ANIMATIONS.cameraTilt, "x", {
            label: "Camera X",
            min: 0,
            max: 150
          });
          folder.addInput(ANIMATIONS.cameraTilt, "y", {
            label: "Camera Y",
            min: 0,
            max: 150
          });
        }
        devImage() {
          const folder = this.pane.addFolder({
            title: "Image",
            expanded: false
          });
          folder.addInput(ANIMATIONS.image, "active", {
            label: "visible"
          });
        }
        devWindow() {
          const folder = this.pane.addFolder({
            title: "Window",
            expanded: false
          });
          folder.addInput(ANIMATIONS.window, "active", {
            label: "visible"
          });
          folder.addInput(WINDOW_OPTIONS, "opacity", {
            label: "Opacity",
            min: 0.01,
            max: 1
          }).on("change", (ev) => {
            this.windowMesh.material.opacity = WINDOW_OPTIONS.opacity;
          });
          folder.addInput(WINDOW_OPTIONS, "color", {
            label: "Color",
            view: "color",
            alpha: false
          }).on("change", (ev) => {
            const color = new Color(WINDOW_OPTIONS.color);
            this.windowMesh.material.color = color;
          });
        }
        devParticles() {
          const folder = this.pane.addFolder({
            title: "Particles",
            expanded: false
          });
          folder.addInput(PARTICLES_MAT, "visible");
          folder.addInput(BEAM, "scale", {
            label: "Beam Scale",
            min: 1,
            max: 150
          });
          folder.addInput(BEAM, "scaleFactor", {
            label: "Random scale factor",
            min: 1e-3,
            max: 1,
            step: 1e-3
          });
          folder.addInput(BEAM, "size", {
            label: "Size",
            min: 0.1,
            max: 2,
            step: 0.01
          });
          const subfolder = folder.addFolder({
            title: "Speed",
            expanded: false
          });
          for (const item of PARTICLES_PRESETS) {
            subfolder.addButton({
              title: item.name
            }).on("click", () => {
              BEAM.speed = item.speed;
              BEAM.drag = item.drag;
              PARTICLES.max = item.max;
              PARTICLES.interval = item.interval;
              PARTICLES.rate = item.rate;
              this.phy.emitter.timer = 0;
              this.phy.emitter.max = PARTICLES.max;
              this.phy.emitter.interval = PARTICLES.interval;
              this.phy.emitter.rate = PARTICLES.rate;
              this.phy.particles.splice(0, this.phy.particles.length - 1);
              this.pane.refresh();
            });
          }
          folder.addInput(BEAM, "direction", {
            label: "Direction",
            options: {
              "Enter Window": 1,
              "Exit Window": 0
            }
          });
          folder.addInput(this.params, "mirror", {
            label: "Mirror Curve"
          });
        }
        devAnimation() {
          const folder = this.pane.addFolder({
            title: "Scroll Animation",
            expanded: false
          });
          const wF = folder.addFolder({
            title: "Window",
            expanded: false
          });
          const iF = folder.addFolder({
            title: "Image",
            expanded: false
          });
          const pF = folder.addFolder({
            title: "Presets",
            expanded: false
          });
          wF.addInput(this.animationToggles, "opacityWindow", {
            label: "Opacity"
          });
          iF.addInput(this.animationToggles, "opacityImage", {
            label: "Opacity"
          });
          wF.addInput(this.animationToggles, "scaleWindow", {
            label: "Scale"
          });
          iF.addInput(this.animationToggles, "scaleImage", {
            label: "Scale"
          });
          wF.addInput(this.animationToggles, "translateWindow", {
            label: "Translate"
          });
          iF.addInput(this.animationToggles, "translateImage", {
            label: "Translate"
          });
          const translateRangeOptions = {
            x: {
              inverted: true,
              step: 1,
              max: 100,
              min: -100
            },
            y: {
              inverted: true,
              step: 1,
              max: 100,
              min: -100
            }
          };
          wF.addInput(this.animationToggles, "translateRangeWindow", __spreadValues({
            label: "Translate Percent"
          }, translateRangeOptions));
          iF.addInput(this.animationToggles, "translateRangeImage", __spreadValues({
            label: "Translate Percent"
          }, translateRangeOptions));
          wF.addInput(this.animationToggles, "rotationWindow", {
            label: "Rotation"
          });
          iF.addInput(this.animationToggles, "rotationImage", {
            label: "Rotation"
          });
          wF.addInput(this.animationToggles, "rotationRangeWindow", {
            label: "Rotation Deg",
            min: -360,
            max: 360,
            step: 1
          });
          iF.addInput(this.animationToggles, "rotationRangeImage", {
            label: "Rotation Deg",
            min: -360,
            max: 360,
            step: 1
          });
          const delayOptions = {
            min: 0,
            max: 4,
            step: 0.1
          };
          wF.addInput(this.animationToggles, "delayWindow", __spreadValues({
            label: "Delay"
          }, delayOptions));
          iF.addInput(this.animationToggles, "delayImage", __spreadValues({
            label: "Delay"
          }, delayOptions));
          const durationOptions = {
            min: 0,
            max: 6,
            step: 0.1
          };
          wF.addInput(this.animationToggles, "durationWindow", __spreadValues({
            label: "Duration"
          }, durationOptions));
          iF.addInput(this.animationToggles, "durationImage", __spreadValues({
            label: "Duration"
          }, durationOptions));
          const easeOptions = {
            Linear: "none",
            In_1: "power1.in",
            In_2: "power2.in",
            In_3: "power3.in",
            In_4: "power4.in",
            Out_1: "power1.out",
            Out_2: "power2.out",
            Out_3: "power3.out",
            Out_4: "power4.out",
            InOut_1: "power1.inOut",
            InOut_2: "power2.inOut",
            InOut_3: "power3.inOut",
            InOut_4: "power4.inOut"
          };
          wF.addInput(this.animationToggles, "easeWindow", {
            label: "Ease",
            options: easeOptions
          });
          iF.addInput(this.animationToggles, "easeImage", {
            label: "Ease",
            options: easeOptions
          });
          let i2 = 0;
          const defaultPreset = ANIMATION_PRESETS[0];
          for (const item of ANIMATION_PRESETS) {
            pF.addButton({
              title: ANIMATION_PRESETS_TITLES[i2]
            }).on("click", () => {
              for (const [k, v] of Object.entries(this.animationToggles)) {
                this.animationToggles[k] = item[k] != void 0 ? item[k] : defaultPreset[k];
              }
              this.pane.refresh();
            });
            i2++;
          }
          folder.addButton({
            title: "Replay"
          }).on("click", this.resetAnimation.bind(this));
        }
        getParameters() {
          this.params = {
            color1: null,
            color2: null,
            color3: null,
            timeMulti: 1.5,
            showLines: false,
            position: 1,
            mirror: BEAM.mirror,
            image: null,
            particles: true,
            mouseSize: 0.8,
            mouseEase: 0.3,
            animationDuration: 1.5,
            animationEase: "power3.inOut"
          };
          if (this.dom.hasAttribute("data-webgl-color-1"))
            this.params.color1 = this.dom.getAttribute("data-webgl-color-1");
          if (this.dom.hasAttribute("data-webgl-color-2"))
            this.params.color2 = this.dom.getAttribute("data-webgl-color-2");
          if (this.dom.hasAttribute("data-webgl-color-3"))
            this.params.color3 = this.dom.getAttribute("data-webgl-color-3");
          if (this.dom.hasAttribute("data-webgl-position"))
            this.params.position = this.dom.getAttribute("data-webgl-position") === "left" ? 1 : -1;
          if (this.dom.hasAttribute("data-webgl-nurbs-mirror"))
            this.params.mirror = this.dom.getAttribute("data-webgl-nurbs-mirror") === "true";
          if (this.dom.hasAttribute("data-webgl-particles"))
            this.params.particles = this.dom.getAttribute("data-webgl-particles") === "true";
          if (this.dom.hasAttribute("data-webgl-image"))
            this.params.image = this.dom.getAttribute("data-webgl-image");
          this.animationToggles = __spreadValues({}, ANIMATION_TOGGLES);
        }
        refresh() {
          this.rect = {
            top: 0,
            topNoScroll: 0,
            left: 0,
            width: 0,
            height: 0
          };
          const rect = this.dom.getBoundingClientRect();
          this.rect.top = rect.top + document.documentElement.scrollTop;
          this.rect.topNoScroll = rect.top;
          this.rect.left = rect.left;
          this.rect.width = rect.width;
          this.rect.height = rect.height;
        }
        dispose() {
          this.disposeInProgress = true;
          if (this.pane)
            this.pane.dispose();
          if (this.bgMesh) {
            this.bgMesh.geometry.dispose();
            this.bgMesh.material.dispose();
            GL_ELEMENTS.orthoScene.remove(this.bgMesh);
          }
          this.bgMesh = null;
          if (this.windowMesh) {
            this.windowMesh.geometry.dispose();
          }
          this.windowMesh = null;
          if (this.imageMesh) {
            this.imageMesh.geometry.dispose();
            this.imageMesh.material.map.dispose();
            this.imageMesh.material.dispose();
          }
          this.imageMesh = null;
          GL_ELEMENTS.scene.remove(this.group);
          this.group = null;
          this.phy.particles = [];
          this.phy = null;
          this.particles.geometry.dispose();
          this.particles = null;
        }
        resize() {
          this.refresh();
          this.resizeBackground();
        }
        createBackground() {
          const geometry = new PlaneGeometry(1, 1, 1, 1);
          this.bgMesh = new Mesh(geometry, BG_MAT.clone());
          this.bgMesh.name = "Background Mesh";
          const u = this.bgMesh.material.uniforms;
          u.u_color1.value.set(this.params.color1);
          u.u_color2.value.set(this.params.color2);
          u.u_color3.value.set(this.params.color3);
          u.u_mouse.value.set(SITE_PARAMS.mouse.x, SITE_PARAMS.mouse.y);
          u.u_mouse_size.value = this.params.mouseSize;
          u.u_resolution.value.set(this.rect.width, this.rect.height);
          this.resizeBackground();
        }
        resizeBackground() {
          this.bgMesh.scale.set(SITE_PARAMS.ww, this.rect.height, 0);
          const top = this.rect.topNoScroll - this.rect.height * 0.5 + SITE_PARAMS.scroll.y;
          this.bgMesh.position.set(0, -top, 0);
        }
        updateBackground(time) {
          if (!this.bgMesh)
            return;
          const m = SITE_PARAMS.mouse;
          const r = this.rect;
          CHROME_FIX.maxSpeed = SITE_PARAMS.scroll.speed * 0.5 > CHROME_FIX.maxSpeed ? SITE_PARAMS.scroll.speed * 0.5 : CHROME_FIX.maxSpeed;
          const speed = Math.max(1e-3, import_math5.MathUtils.map(SITE_PARAMS.scroll.speed, 0, CHROME_FIX.maxSpeed, 0, 1));
          CHROME_FIX.speed = import_math5.MathUtils.lerp(speed, CHROME_FIX.speed, speed > CHROME_FIX.speed ? CHROME_FIX.easeOut : CHROME_FIX.easeIn);
          const result = CHROME_FIX.speed * (this.rect.height * 0.2);
          this.bgMesh.scale.set(SITE_PARAMS.ww, this.rect.height + result, 0);
          const uniforms = this.bgMesh.material.uniforms;
          uniforms.u_resolution.value.x = r.width;
          uniforms.u_resolution.value.y = r.height;
          uniforms.u_time.value = time;
          const x = import_math5.MathUtils.lerp(uniforms.u_mouse.value.x, import_math5.MathUtils.map(m.x - r.left, 0, r.width, 0, 1), this.params.mouseEase);
          const y = import_math5.MathUtils.lerp(uniforms.u_mouse.value.y, import_math5.MathUtils.map(m.y - r.topNoScroll, 0, r.height, 1, 0), this.params.mouseEase);
          uniforms.u_mouse.value.x = x;
          uniforms.u_mouse.value.y = y;
        }
        createWindow() {
          const material = WIN_MAT;
          const geometry = new PlaneGeometry(1, 1, 1, 1);
          this.windowMesh = new Mesh(geometry, material);
          this.group.add(this.windowMesh);
        }
        updateWindow() {
          if (!this.windowMesh)
            return;
          this.windowMesh.visible = this.active ? ANIMATIONS.window.active : false;
          const t = this.transition.window;
          const side = this.rect.height * 0.5;
          this.windowMesh.scale.set(side, side, 0);
          this.windowMesh.scale.multiplyScalar(t.scale);
          const x = this.animationToggles.translateWindow ? this.rect.width * (this.animationToggles.translateRangeWindow.x / 100) * (1 - t.translate) : 0;
          const y = this.animationToggles.translateWindow ? this.rect.height * (this.animationToggles.translateRangeWindow.y / 100) * (1 - t.translate) : 0;
          this.windowMesh.position.set(x, y, 0);
          this.windowMesh.material.opacity = WINDOW_OPTIONS.opacity;
          const initialRotation = this.animationToggles.rotationRangeWindow * (Math.PI / 180);
          const rotationZ = import_math5.MathUtils.map(t.rotation, 0, 1, initialRotation, 0);
          this.windowMesh.rotation.set(0, 0, rotationZ);
        }
        createImage() {
          const loader4 = new TextureLoader();
          const url = this.params.image;
          loader4.load(url, (t) => {
            const geometry = new PlaneGeometry(1, 1, 1, 1);
            const material = IMAGE_MAT.clone();
            material.map = t;
            this.imageMesh = new Mesh(geometry, material);
            this.group.add(this.imageMesh);
          });
        }
        updateImage() {
          if (!this.imageMesh)
            return;
          this.imageMesh.material.visible = this.active ? ANIMATIONS.image.active : false;
          const t = this.transition.image;
          const side = this.rect.height * 0.4;
          this.imageMesh.scale.set(side, side, 0);
          this.imageMesh.scale.multiplyScalar(t.scale);
          const meshP = this.params.position * window.innerWidth * 0.1;
          const x = this.animationToggles.translateImage ? this.rect.width * (this.animationToggles.translateRangeImage.x / 100) * (1 - t.translate) : 0;
          const y = this.animationToggles.translateImage ? this.rect.height * (this.animationToggles.translateRangeImage.y / 100) * (1 - t.translate) : 0;
          this.imageMesh.position.set(x + meshP, y, 500);
          this.imageMesh.material.opacity = t.opacity;
          const initialRotation = this.animationToggles.rotationRangeImage * (Math.PI / 180);
          this.imageMesh.rotation.z = import_math5.MathUtils.map(t.rotation, 0, 1, initialRotation, 0);
        }
        createParticles(data) {
          const curves = [];
          for (const curve of data.curves) {
            const pts = [];
            for (const pt of curve.points) {
              pts.push(new Vector4(pt.x * PARTICLES.scale, pt.y * PARTICLES.scale, pt.z * PARTICLES.scale, 0.5));
            }
            const knots = [];
            for (let k = 0; k <= NURBS.degree; k++)
              knots.push(0);
            for (let i2 = 0; i2 < pts.length; i2++) {
              const knot = (i2 + 1) / (pts.length - NURBS.degree);
              knots.push(import_math5.MathUtils.clamp(knot, 0, 1));
            }
            const cc = new NURBSCurve(NURBS.degree, knots, pts, 0, knots.length - 1);
            curves.push(cc);
          }
          this.phy = new import_phy4.Physics();
          const emitter = new CustomEmitter(this.phy, {
            rate: PARTICLES.rate,
            interval: PARTICLES.interval,
            max: PARTICLES.max
          }, curves);
          this.phy.emitter = emitter;
          const steering = new PathSteering();
          this.phy.addBehaviour(steering);
          const _pos = [];
          for (let i2 = 0; i2 < PARTICLES.max; i2++) {
            _pos.push(import_math5.Random.randf(-500, 500));
            _pos.push(import_math5.Random.randf(-500, 500));
            _pos.push(import_math5.Random.randf(0, 0));
          }
          const pos = new Float32Array(_pos);
          const op = new Float32Array(PARTICLES.max);
          const pSize = new Float32Array(PARTICLES.max);
          const pageo = new BufferGeometry();
          pageo.setAttribute("position", new BufferAttribute(pos, 3));
          pageo.setAttribute("opacity", new BufferAttribute(op, 1));
          pageo.setAttribute("pSize", new BufferAttribute(pSize, 1));
          this.particles = new Points(pageo, PARTICLES_MAT);
          this.particlesGroup.add(this.particles);
          this.group.add(this.particlesGroup);
        }
        updateParticles() {
          if (!this.active)
            return;
          if (!this.phy)
            return;
          const t = this.transition;
          if (t.value === 0 && (!t.complete && !t.inProgress)) {
            return;
          }
          this.phy.update();
          this.particlesGroup.scale.x = this.params.mirror ? -1 : 1;
          const pgeo = this.particles.geometry;
          const pos = pgeo.attributes.position;
          const op = pgeo.attributes.opacity;
          const pSize = pgeo.attributes.pSize;
          for (let i2 = 0; i2 < this.phy.particles.length; i2++) {
            const p2 = this.phy.particles[i2];
            pos.array[i2 * 3] = p2.position.x;
            pos.array[i2 * 3 + 1] = p2.position.y;
            pos.array[i2 * 3 + 2] = p2.position.z;
            op.array[i2] = p2.opacity;
            pSize.array[i2] = p2.pSize;
          }
          for (let i2 = this.phy.particles.length; i2 < PARTICLES.max; i2++) {
            pos.array[i2 * 3] = 1e5;
            pos.array[i2 * 3 + 1] = 1e6;
            pos.array[i2 * 3 + 2] = 1e7;
            op.array[i2] = 0;
            pSize.array[i2] = 0;
          }
          pos.needsUpdate = true;
          op.needsUpdate = true;
          pSize.needsUpdate = true;
        }
        updateAnimation() {
          if (!this.active) {
            this.resetAnimation();
            return;
          }
          const t = this.transition;
          const r = this.rect;
          const wh = SITE_PARAMS.wh;
          const start = r.topNoScroll - wh * 0.55;
          const end = r.topNoScroll - wh * 0.45 + wh;
          if (start <= 0 && end >= 0) {
            if (SITE_PARAMS.scroll.speed > 100)
              return;
            if (t.inProgress || t.complete)
              return;
            t.inProgress = true;
            const tl = gsapWithCSS.timeline({
              paused: true,
              onComplete: () => {
                t.complete = true;
                t.inProgress = false;
              }
            });
            tl.addLabel("start").to(t.window, {
              opacity: 1,
              scale: 1,
              rotation: 1,
              translate: 1,
              duration: this.animationToggles.durationWindow,
              ease: this.animationToggles.easeWindow
            }, `start+=${this.animationToggles.delayWindow}`).to(t.image, {
              opacity: 1,
              scale: 1,
              rotation: 1,
              translate: 1,
              duration: this.animationToggles.durationImage,
              ease: this.animationToggles.easeImage
            }, `start+=${this.animationToggles.delayImage}`);
            tl.play();
          }
        }
        resetAnimation() {
          const t = this.transition;
          if (!t.complete && !t.inProgress)
            return;
          t.inProgress = false;
          t.complete = false;
          gsapWithCSS.killTweensOf(t);
          gsapWithCSS.killTweensOf(t.window);
          gsapWithCSS.killTweensOf(t.image);
          this.phy.particles.splice(0, this.phy.particles.length - 1);
          t.window.opacity = this.animationToggles.opacityWindow ? 0 : 1;
          t.window.scale = this.animationToggles.scaleWindow ? 0 : 1;
          t.window.translate = this.animationToggles.translateWindow ? 0 : 1;
          t.window.rotation = this.animationToggles.rotationWindow ? 0 : 1;
          t.image.opacity = this.animationToggles.opacityImage ? 0 : 1;
          t.image.scale = this.animationToggles.scaleImage ? 0 : 1;
          t.image.translate = this.animationToggles.translateImage ? 0 : 1;
          t.image.rotation = this.animationToggles.rotationImage ? 0 : 1;
        }
        update(time) {
          this.refresh();
          const r = this.rect;
          const ww = SITE_PARAMS.ww;
          const wh = SITE_PARAMS.wh;
          const s = document.documentElement.scrollTop;
          this.active = s + wh >= r.top && s <= r.top + r.height;
          const p2 = this.params.position * -1;
          this.group.position.x = p2 * ww * 0.25;
          const top = r.top - wh * 0.5 + r.height * 0.5;
          this.group.position.y = import_math5.MathUtils.lerp(this.group.position.y, s - top, ANIMATIONS.scroll.ease);
          this.group.visible = this.active;
          this.updateAnimation();
          this.updateBackground(time);
          this.updateWindow();
          this.updateImage();
          this.updateParticles();
        }
      };
    }
  });

  // src/js/core/App.ts
  var App_exports = {};
  __export(App_exports, {
    App: () => App
  });
  var import_math6, import_tweakpane2, RT_SCALE, App;
  var init_App = __esm({
    "src/js/core/App.ts"() {
      init_main2();
      import_math6 = __toESM(require_main());
      init_three_module();
      import_tweakpane2 = __toESM(require_tweakpane());
      init_Section();
      init_Globals();
      init_ShaderLib();
      RT_SCALE = 0.25;
      App = class extends WebGLSketch {
        constructor() {
          super(window.innerWidth, window.innerHeight, {
            alpha: true,
            antialias: true
          });
          this.sections = [];
          this.orthoGroup = new Group();
          this.rt = FboUtils.getRenderTarget(window.innerWidth * RT_SCALE, window.innerHeight * RT_SCALE, {}, false);
          this.orthoScene = new Scene();
          GL_ELEMENTS.orthoScene = this.orthoScene;
          GL_ELEMENTS.scene = this.scene;
          SITE_PARAMS.scroll.y = window.scrollY;
          this.renderer.setClearColor(16777215, 1);
          document.body.appendChild(this.domElement);
          this.domElement.style.position = "fixed";
          this.domElement.style.top = "0";
          this.domElement.style.left = "0";
          this.domElement.style.width = "100%";
          this.domElement.style.height = "100%";
          this.domElement.style.zIndex = "-1";
          const w = window.innerWidth * 0.5;
          const h = window.innerHeight * 0.5;
          this.orthoCamera = new OrthographicCamera(-w, w, h, -h, 1, 100);
          this.addEventListeners();
          PARTICLES_MAT.uniforms.mask.value = this.rt.texture;
          PARTICLES_MAT.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
          this.camerasResize();
          this.start();
          this.pause();
          this.createLifecycleButtons();
        }
        destroySections() {
          this.pause();
          for (const section of this.sections)
            section.dispose();
          this.sections = [];
          this.renderer.domElement.style.display = "none";
          this.orthoGroup = null;
        }
        buildSections() {
          this.destroySections();
          this.orthoGroup = new Group();
          this.renderer.domElement.style.display = "unset";
          const sections = document.querySelectorAll('[data-webgl="true"]');
          if (!!!sections)
            return;
          for (const section of sections) {
            const s = new Section(section);
            this.sections.push(s);
            this.orthoGroup.add(s.bgMesh);
            s.createParticles(CURVES_DATA);
          }
          this.orthoScene.add(this.orthoGroup);
          this.resume();
        }
        createLifecycleButtons() {
          return;
          const ev = new CustomEvent("webgl:build");
          window.dispatchEvent(ev);
          return;
          if (SHOW_LIFECYCLE_BUTTONS) {
            const pane = new import_tweakpane2.Pane();
            pane.containerElem_.style.zIndex = 999;
            pane.containerElem_.style.width = "150px";
            pane.containerElem_.style.position = "fixed";
            pane.containerElem_.style.right = "380px";
            pane.addButton({ title: "Build" }).on("click", () => {
              const ev2 = new CustomEvent("webgl:build");
              window.dispatchEvent(ev2);
            });
            pane.addButton({ title: "Destroy" }).on("click", () => {
              const ev2 = new CustomEvent("webgl:destroy");
              window.dispatchEvent(ev2);
            });
          } else {
            const ev2 = new CustomEvent("webgl:build");
            window.dispatchEvent(ev2);
          }
        }
        resize(w, h) {
          super.resize(w, h);
          SITE_PARAMS.ww = w;
          SITE_PARAMS.wh = h;
          this.rt.setSize(w * RT_SCALE, h * RT_SCALE);
          PARTICLES_MAT.uniforms.resolution.value.set(w, h);
          this.camerasResize();
          for (const s of this.sections)
            s.resize();
        }
        camerasResize() {
          const w = SITE_PARAMS.ww;
          const h = SITE_PARAMS.wh;
          this.orthoCamera.position.y = 0;
          this.orthoCamera.position.z = 1;
          const w2 = w * 0.5;
          const h2 = h * 0.5;
          this.orthoCamera.left = -w2;
          this.orthoCamera.right = w2;
          this.orthoCamera.top = h2;
          this.orthoCamera.bottom = -h2;
          this.orthoCamera.updateProjectionMatrix();
          this.camera.position.z = 1e3;
          this.camera.aspect = w / h;
          this.camera.fov = 2 * Math.atan(h / 2 / 1e3) * (180 / Math.PI);
          this.camera.far = 1600;
          this.camera.updateProjectionMatrix();
        }
        onWheel(ev) {
          SITE_PARAMS.scroll.speed = Math.abs(ev.deltaY);
        }
        updateScroll() {
          SITE_PARAMS.scroll.y = window.scrollY;
          this.orthoGroup.position.y = SITE_PARAMS.scroll.y - window.innerHeight * 0.5;
        }
        addEventListeners() {
          window.addEventListener("resize", (ev) => {
            this.resize(window.innerWidth, window.innerHeight);
          });
          window.addEventListener("wheel", (ev) => {
            this.onWheel(ev);
          });
          window.addEventListener("scroll", (ev) => {
            this.updateScroll();
          });
          this.updateScroll();
          window.addEventListener("mousemove", (e) => {
            SITE_PARAMS.mouse.x = e.clientX;
            SITE_PARAMS.mouse.y = e.clientY;
          });
          window.addEventListener("webgl:build", this.buildSections.bind(this));
          window.addEventListener("webgl:destroy", this.destroySections.bind(this));
        }
        update() {
          if (this.sections.length === 0)
            return;
          super.update();
          this.updateScroll();
          const time = this.clock.getElapsedTime();
          for (const section of this.sections) {
            section.update(time);
          }
          const w = window.innerWidth;
          const h = window.innerHeight;
          const x = import_math6.MathUtils.map(SITE_PARAMS.mouse.x, 0, w, -ANIMATIONS.cameraTilt.x, ANIMATIONS.cameraTilt.x);
          const y = import_math6.MathUtils.map(SITE_PARAMS.mouse.y, 0, h, ANIMATIONS.cameraTilt.y, -ANIMATIONS.cameraTilt.y);
          this.camera.position.x = import_math6.MathUtils.lerp(this.camera.position.x, x, ANIMATIONS.cameraTilt.ease);
          this.camera.position.y = import_math6.MathUtils.lerp(this.camera.position.y, y, ANIMATIONS.cameraTilt.ease);
          this.camera.lookAt(0, 0, 0);
        }
        render() {
          if (this.sections.length === 0) {
            this.renderer.setClearColor(16777215, 0);
            return;
          }
          for (const section of this.sections) {
            if (section.particles)
              section.particles.visible = false;
            if (section.imageMesh)
              section.imageMesh.visible = false;
            if (section.windowMesh)
              section.windowMesh.material = MASK_MAT;
          }
          this.renderer.autoClear = true;
          this.renderer.setRenderTarget(this.rt);
          this.renderer.setClearColor(0, 1);
          this.renderer.autoClear = true;
          this.renderer.render(this.scene, this.camera);
          this.renderer.setRenderTarget(null);
          this.renderer.autoClear = false;
          this.renderer.setClearColor(16777215, 0);
          this.renderer.render(this.orthoScene, this.orthoCamera);
          this.renderer.clearDepth();
          for (const section of this.sections) {
            if (section.particles)
              section.particles.visible = true;
            if (section.imageMesh)
              section.imageMesh.visible = true;
            if (section.windowMesh)
              section.windowMesh.material = WIN_MAT;
          }
          this.renderer.render(this.scene, this.camera);
        }
      };
    }
  });

  // src/js/main.js
  var { App: App2 } = (init_App(), __toCommonJS(App_exports));
  var _App = new App2();
})();
/*!
 * CSSPlugin 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * CSSRulePlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * CustomEase 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * Draggable 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
/*!
 * EasePack 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * EaselPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * Flip 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * GSAP 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * MotionPathPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * PixiPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * ScrollToPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * ScrollTrigger 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * TextPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * matrix 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * paths 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*!
 * strings: 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/*! Tweakpane 3.0.7 (c) 2016 cocopon, licensed under the MIT license. */
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
//# sourceMappingURL=main.js.map
